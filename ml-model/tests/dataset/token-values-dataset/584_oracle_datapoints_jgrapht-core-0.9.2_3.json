[{"id":109481260,"label":true,"oracleId":26022,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"UndirectedGraphBuilder","javadocTag":"@param baseGraph the graph object to base building on","methodJavadoc":"    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * <p>The recomended way to use this constructor is: {@code new\n     * UndirectedGraphBuilder<...>(new YourGraph<...>(...))}.\n     *\n     * <p>NOTE: {@code baseGraph} should not be an existing graph. If you want\n     * to add an existing graph to the graph being built, you should use the\n     * {@link #addVertex(Object)} method.\n     *\n     * @param baseGraph the graph object to base building on\n     */","methodSourceCode":"public UndirectedGraphBuilder(G baseGraph){\n    super(baseGraph);\n}","classJavadoc":"/**\n * A builder class for {@link Graph}. If you want to extend this class, see\n * {@link UndirectedGraphBuilderBase}.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------\n * UndirectedGraphBuilder.java\n * ---------------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\n\n\n/**\n * A builder class for {@link Graph}. If you want to extend this class, see\n * {@link UndirectedGraphBuilderBase}.\n */\npublic final class UndirectedGraphBuilder<V, E, G extends UndirectedGraph<V, E>>\n    extends UndirectedGraphBuilderBase<V, E, G, UndirectedGraphBuilder<V, E, G>>\n{\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * <p>The recomended way to use this constructor is: {@code new\n     * UndirectedGraphBuilder<...>(new YourGraph<...>(...))}.\n     *\n     * <p>NOTE: {@code baseGraph} should not be an existing graph. If you want\n     * to add an existing graph to the graph being built, you should use the\n     * {@link #addVertex(Object)} method.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public UndirectedGraphBuilder(G baseGraph)\n    {\n        super(baseGraph);\n    }\n\n    @Override protected UndirectedGraphBuilder<V, E, G> self()\n    {\n        return this;\n    }\n}\n\n// End UndirectedGraphBuilder.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109481468,"label":true,"oracleId":26023,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"UndirectedWeightedGraphBuilder","javadocTag":"@param baseGraph the graph object to base building on","methodJavadoc":"    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * <p>The recomended way to use this constructor is: {@code new\n     * UndirectedWeightedGraphBuilder<...>(new YourGraph<...>(...))}.\n     *\n     * <p>NOTE: {@code baseGraph} should not be an existing graph. If you want\n     * to add an existing graph to the graph being built, you should use the\n     * {@link #addVertex(Object)} method.\n     *\n     * @param baseGraph the graph object to base building on\n     */","methodSourceCode":"public UndirectedWeightedGraphBuilder(G baseGraph){\n    super(baseGraph);\n}","classJavadoc":"/**\n * A builder class for undirected weighted graphs. If you want to extend this\n * class, see {@link UndirectedWeightedGraphBuilderBase}.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -----------------------------------\n * UndirectedWeightedGraphBuilder.java\n * -----------------------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\n\n\n/**\n * A builder class for undirected weighted graphs. If you want to extend this\n * class, see {@link UndirectedWeightedGraphBuilderBase}.\n */\npublic final class UndirectedWeightedGraphBuilder<V,\n    E, G extends UndirectedGraph<V, E> & WeightedGraph<V, E>>\n    extends UndirectedWeightedGraphBuilderBase<V,\n        E, G, UndirectedWeightedGraphBuilder<V, E, G>>\n{\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * <p>The recomended way to use this constructor is: {@code new\n     * UndirectedWeightedGraphBuilder<...>(new YourGraph<...>(...))}.\n     *\n     * <p>NOTE: {@code baseGraph} should not be an existing graph. If you want\n     * to add an existing graph to the graph being built, you should use the\n     * {@link #addVertex(Object)} method.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public UndirectedWeightedGraphBuilder(G baseGraph)\n    {\n        super(baseGraph);\n    }\n\n    @Override protected UndirectedWeightedGraphBuilder<V, E, G> self()\n    {\n        return this;\n    }\n}\n\n// End UndirectedWeightedGraphBuilder.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109481679,"label":true,"oracleId":26024,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"UndirectedWeightedGraphBuilderBase","javadocTag":"@param source source vertex of the edge.","methodJavadoc":"    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */","methodSourceCode":"public B addEdge(V source, V target, double weight){\n    Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n    return this.self();\n}","classJavadoc":"/**\n * Base class for {@link UndirectedWeightedGraphBuilder} for extending.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------------------\n * UndirectedWeightedGraphBuilderBase.java\n * ---------------------------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\n\n\n/**\n * Base class for {@link UndirectedWeightedGraphBuilder} for extending.\n */\npublic abstract class UndirectedWeightedGraphBuilderBase<V,\n    E,\n    G extends UndirectedGraph<V, E> & WeightedGraph<V, E>,\n    B extends UndirectedWeightedGraphBuilderBase<V, E, G, B>>\n    extends UndirectedGraphBuilderBase<V, E, G, B>\n{\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public UndirectedWeightedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }\n\n    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */\n    public B addEdge(V source, V target, double weight)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n        return this.self();\n    }\n}\n\n// End UndirectedWeightedGraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109481890,"label":true,"oracleId":26025,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"UndirectedWeightedGraphBuilderBase","javadocTag":"@param target target vertex of the edge.","methodJavadoc":"    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */","methodSourceCode":"public B addEdge(V source, V target, double weight){\n    Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n    return this.self();\n}","classJavadoc":"/**\n * Base class for {@link UndirectedWeightedGraphBuilder} for extending.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------------------\n * UndirectedWeightedGraphBuilderBase.java\n * ---------------------------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\n\n\n/**\n * Base class for {@link UndirectedWeightedGraphBuilder} for extending.\n */\npublic abstract class UndirectedWeightedGraphBuilderBase<V,\n    E,\n    G extends UndirectedGraph<V, E> & WeightedGraph<V, E>,\n    B extends UndirectedWeightedGraphBuilderBase<V, E, G, B>>\n    extends UndirectedGraphBuilderBase<V, E, G, B>\n{\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public UndirectedWeightedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }\n\n    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */\n    public B addEdge(V source, V target, double weight)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n        return this.self();\n    }\n}\n\n// End UndirectedWeightedGraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109482101,"label":true,"oracleId":26026,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"UndirectedWeightedGraphBuilderBase","javadocTag":"@param weight weight of the edge.","methodJavadoc":"    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */","methodSourceCode":"public B addEdge(V source, V target, double weight){\n    Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n    return this.self();\n}","classJavadoc":"/**\n * Base class for {@link UndirectedWeightedGraphBuilder} for extending.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------------------\n * UndirectedWeightedGraphBuilderBase.java\n * ---------------------------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\n\n\n/**\n * Base class for {@link UndirectedWeightedGraphBuilder} for extending.\n */\npublic abstract class UndirectedWeightedGraphBuilderBase<V,\n    E,\n    G extends UndirectedGraph<V, E> & WeightedGraph<V, E>,\n    B extends UndirectedWeightedGraphBuilderBase<V, E, G, B>>\n    extends UndirectedGraphBuilderBase<V, E, G, B>\n{\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public UndirectedWeightedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }\n\n    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */\n    public B addEdge(V source, V target, double weight)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n        return this.self();\n    }\n}\n\n// End UndirectedWeightedGraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109482313,"label":true,"oracleId":26027,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"UndirectedWeightedGraphBuilderBase","javadocTag":"@return this builder object","methodJavadoc":"    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */","methodSourceCode":"public B addEdge(V source, V target, double weight){\n    Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n    return this.self();\n}","classJavadoc":"/**\n * Base class for {@link UndirectedWeightedGraphBuilder} for extending.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------------------\n * UndirectedWeightedGraphBuilderBase.java\n * ---------------------------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\n\n\n/**\n * Base class for {@link UndirectedWeightedGraphBuilder} for extending.\n */\npublic abstract class UndirectedWeightedGraphBuilderBase<V,\n    E,\n    G extends UndirectedGraph<V, E> & WeightedGraph<V, E>,\n    B extends UndirectedWeightedGraphBuilderBase<V, E, G, B>>\n    extends UndirectedGraphBuilderBase<V, E, G, B>\n{\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public UndirectedWeightedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }\n\n    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */\n    public B addEdge(V source, V target, double weight)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n        return this.self();\n    }\n}\n\n// End UndirectedWeightedGraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109482521,"label":true,"oracleId":26028,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"UndirectedWeightedGraphBuilderBase","javadocTag":"@param baseGraph the graph object to base building on","methodJavadoc":"    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */","methodSourceCode":"public UndirectedWeightedGraphBuilderBase(G baseGraph){\n    super(baseGraph);\n}","classJavadoc":"/**\n * Base class for {@link UndirectedWeightedGraphBuilder} for extending.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------------------\n * UndirectedWeightedGraphBuilderBase.java\n * ---------------------------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\n\n\n/**\n * Base class for {@link UndirectedWeightedGraphBuilder} for extending.\n */\npublic abstract class UndirectedWeightedGraphBuilderBase<V,\n    E,\n    G extends UndirectedGraph<V, E> & WeightedGraph<V, E>,\n    B extends UndirectedWeightedGraphBuilderBase<V, E, G, B>>\n    extends UndirectedGraphBuilderBase<V, E, G, B>\n{\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public UndirectedWeightedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }\n\n    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */\n    public B addEdge(V source, V target, double weight)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n        return this.self();\n    }\n}\n\n// End UndirectedWeightedGraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109482732,"label":true,"oracleId":26029,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"DirectedWeightedGraphBuilderBase","javadocTag":"@param source source vertex of the edge.","methodJavadoc":"    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */","methodSourceCode":"public B addEdge(V source, V target, double weight){\n    Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n    return this.self();\n}","classJavadoc":"/**\n * Base class for {@link DirectedWeightedGraphBuilder} for extending.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------------------\n * DirectedWeightedGraphBuilderBase.java\n * -------------------------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\n\n\n/**\n * Base class for {@link DirectedWeightedGraphBuilder} for extending.\n */\npublic abstract class DirectedWeightedGraphBuilderBase<V,\n    E,\n    G extends DirectedGraph<V, E> & WeightedGraph<V, E>,\n    B extends DirectedWeightedGraphBuilderBase<V, E, G, B>>\n    extends DirectedGraphBuilderBase<V, E, G, B>\n{\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public DirectedWeightedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }\n\n    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */\n    public B addEdge(V source, V target, double weight)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n        return this.self();\n    }\n}\n\n// End DirectedWeightedGraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109482943,"label":true,"oracleId":26030,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"DirectedWeightedGraphBuilderBase","javadocTag":"@param target target vertex of the edge.","methodJavadoc":"    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */","methodSourceCode":"public B addEdge(V source, V target, double weight){\n    Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n    return this.self();\n}","classJavadoc":"/**\n * Base class for {@link DirectedWeightedGraphBuilder} for extending.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------------------\n * DirectedWeightedGraphBuilderBase.java\n * -------------------------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\n\n\n/**\n * Base class for {@link DirectedWeightedGraphBuilder} for extending.\n */\npublic abstract class DirectedWeightedGraphBuilderBase<V,\n    E,\n    G extends DirectedGraph<V, E> & WeightedGraph<V, E>,\n    B extends DirectedWeightedGraphBuilderBase<V, E, G, B>>\n    extends DirectedGraphBuilderBase<V, E, G, B>\n{\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public DirectedWeightedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }\n\n    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */\n    public B addEdge(V source, V target, double weight)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n        return this.self();\n    }\n}\n\n// End DirectedWeightedGraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109483154,"label":true,"oracleId":26031,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"DirectedWeightedGraphBuilderBase","javadocTag":"@param weight weight of the edge.","methodJavadoc":"    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */","methodSourceCode":"public B addEdge(V source, V target, double weight){\n    Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n    return this.self();\n}","classJavadoc":"/**\n * Base class for {@link DirectedWeightedGraphBuilder} for extending.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------------------\n * DirectedWeightedGraphBuilderBase.java\n * -------------------------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\n\n\n/**\n * Base class for {@link DirectedWeightedGraphBuilder} for extending.\n */\npublic abstract class DirectedWeightedGraphBuilderBase<V,\n    E,\n    G extends DirectedGraph<V, E> & WeightedGraph<V, E>,\n    B extends DirectedWeightedGraphBuilderBase<V, E, G, B>>\n    extends DirectedGraphBuilderBase<V, E, G, B>\n{\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public DirectedWeightedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }\n\n    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */\n    public B addEdge(V source, V target, double weight)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n        return this.self();\n    }\n}\n\n// End DirectedWeightedGraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109483366,"label":true,"oracleId":26032,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"DirectedWeightedGraphBuilderBase","javadocTag":"@return this builder object","methodJavadoc":"    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */","methodSourceCode":"public B addEdge(V source, V target, double weight){\n    Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n    return this.self();\n}","classJavadoc":"/**\n * Base class for {@link DirectedWeightedGraphBuilder} for extending.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------------------\n * DirectedWeightedGraphBuilderBase.java\n * -------------------------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\n\n\n/**\n * Base class for {@link DirectedWeightedGraphBuilder} for extending.\n */\npublic abstract class DirectedWeightedGraphBuilderBase<V,\n    E,\n    G extends DirectedGraph<V, E> & WeightedGraph<V, E>,\n    B extends DirectedWeightedGraphBuilderBase<V, E, G, B>>\n    extends DirectedGraphBuilderBase<V, E, G, B>\n{\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public DirectedWeightedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }\n\n    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */\n    public B addEdge(V source, V target, double weight)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n        return this.self();\n    }\n}\n\n// End DirectedWeightedGraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109483574,"label":true,"oracleId":26033,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"DirectedWeightedGraphBuilderBase","javadocTag":"@param baseGraph the graph object to base building on","methodJavadoc":"    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */","methodSourceCode":"public DirectedWeightedGraphBuilderBase(G baseGraph){\n    super(baseGraph);\n}","classJavadoc":"/**\n * Base class for {@link DirectedWeightedGraphBuilder} for extending.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------------------\n * DirectedWeightedGraphBuilderBase.java\n * -------------------------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\n\n\n/**\n * Base class for {@link DirectedWeightedGraphBuilder} for extending.\n */\npublic abstract class DirectedWeightedGraphBuilderBase<V,\n    E,\n    G extends DirectedGraph<V, E> & WeightedGraph<V, E>,\n    B extends DirectedWeightedGraphBuilderBase<V, E, G, B>>\n    extends DirectedGraphBuilderBase<V, E, G, B>\n{\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public DirectedWeightedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }\n\n    /**\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     */\n    public B addEdge(V source, V target, double weight)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n        return this.self();\n    }\n}\n\n// End DirectedWeightedGraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109483783,"label":true,"oracleId":26034,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"AbstractGraphBuilder","javadocTag":"@return the {@code this} object.","methodJavadoc":"    /**\n     * @return the {@code this} object.\n     */","methodSourceCode":"protected abstract B self();","classJavadoc":"/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109483992,"label":true,"oracleId":26035,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"AbstractGraphBuilder","javadocTag":"@param vertex the vertex to add","methodJavadoc":"    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */","methodSourceCode":"public B addVertex(V vertex){\n    this.graph.addVertex(vertex);\n    return this.self();\n}","classJavadoc":"/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109484201,"label":true,"oracleId":26036,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"AbstractGraphBuilder","javadocTag":"@param vertices the vertices to add","methodJavadoc":"    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */","methodSourceCode":"public B addVertices(V... vertices){\n    for (V vertex : vertices) {\n        this.addVertex(vertex);\n    }\n    return this.self();\n}","classJavadoc":"/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109484412,"label":true,"oracleId":26037,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"AbstractGraphBuilder","javadocTag":"@param source source vertex of the edge.","methodJavadoc":"    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */","methodSourceCode":"public B addEdge(V source, V target){\n    Graphs.addEdgeWithVertices(this.graph, source, target);\n    return this.self();\n}","classJavadoc":"/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109484622,"label":true,"oracleId":26038,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"AbstractGraphBuilder","javadocTag":"@param target target vertex of the edge.","methodJavadoc":"    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */","methodSourceCode":"public B addEdge(V source, V target){\n    Graphs.addEdgeWithVertices(this.graph, source, target);\n    return this.self();\n}","classJavadoc":"/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109484831,"label":true,"oracleId":26039,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"AbstractGraphBuilder","javadocTag":"@param vertex the vertex to remove","methodJavadoc":"    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */","methodSourceCode":"public B removeVertex(V vertex){\n    this.graph.removeVertex(vertex);\n    return this.self();\n}","classJavadoc":"/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109485040,"label":true,"oracleId":26040,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"AbstractGraphBuilder","javadocTag":"@param vertices the vertices to remove","methodJavadoc":"    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */","methodSourceCode":"public B removeVertices(V... vertices){\n    for (V vertex : vertices) {\n        this.removeVertex(vertex);\n    }\n    return this.self();\n}","classJavadoc":"/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109485251,"label":true,"oracleId":26041,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"AbstractGraphBuilder","javadocTag":"@param source source vertex of the edge.","methodJavadoc":"    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */","methodSourceCode":"public B removeEdge(V source, V target){\n    this.graph.removeEdge(source, target);\n    return this.self();\n}","classJavadoc":"/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109485461,"label":true,"oracleId":26042,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"AbstractGraphBuilder","javadocTag":"@param target target vertex of the edge.","methodJavadoc":"    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */","methodSourceCode":"public B removeEdge(V source, V target){\n    this.graph.removeEdge(source, target);\n    return this.self();\n}","classJavadoc":"/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109485670,"label":true,"oracleId":26043,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"AbstractGraphBuilder","javadocTag":"@return the built graph.","methodJavadoc":"    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */","methodSourceCode":"public G build(){\n    return this.graph;\n}","classJavadoc":"/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109485879,"label":true,"oracleId":26044,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"AbstractGraphBuilder","javadocTag":"@return the built unmodifiable graph.","methodJavadoc":"    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */","methodSourceCode":"public UnmodifiableGraph<V, E> buildUnmodifiable(){\n    return new UnmodifiableGraph<V, E>(this.graph);\n}","classJavadoc":"/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109486087,"label":true,"oracleId":26045,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"AbstractGraphBuilder","javadocTag":"@param baseGraph the graph object to base building on","methodJavadoc":"    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */","methodSourceCode":"public AbstractGraphBuilder(G baseGraph){\n    this.graph = baseGraph;\n}","classJavadoc":"/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109486295,"label":true,"oracleId":26046,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"DirectedWeightedGraphBuilder","javadocTag":"@param baseGraph the graph object to base building on","methodJavadoc":"    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * <p>The recomended way to use this constructor is: {@code new\n     * DirectedWeightedGraphBuilder<...>(new YourGraph<...>(...))}.\n     *\n     * <p>NOTE: {@code baseGraph} should not be an existing graph. If you want\n     * to add an existing graph to the graph being built, you should use the\n     * {@link #addVertex(Object)} method.\n     *\n     * @param baseGraph the graph object to base building on\n     */","methodSourceCode":"public DirectedWeightedGraphBuilder(G baseGraph){\n    super(baseGraph);\n}","classJavadoc":"/**\n * A builder class for directed weighted graphs}. If you want to extend this\n * class, see {@link DirectedWeightedGraphBuilderBase}.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------------\n * DirectedWeightedGraphBuilder.java\n * ---------------------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\n\n\n/**\n * A builder class for directed weighted graphs}. If you want to extend this\n * class, see {@link DirectedWeightedGraphBuilderBase}.\n */\npublic final class DirectedWeightedGraphBuilder<V,\n    E, G extends DirectedGraph<V, E> & WeightedGraph<V, E>>\n    extends DirectedWeightedGraphBuilderBase<V,\n        E, G, DirectedWeightedGraphBuilder<V, E, G>>\n{\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * <p>The recomended way to use this constructor is: {@code new\n     * DirectedWeightedGraphBuilder<...>(new YourGraph<...>(...))}.\n     *\n     * <p>NOTE: {@code baseGraph} should not be an existing graph. If you want\n     * to add an existing graph to the graph being built, you should use the\n     * {@link #addVertex(Object)} method.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public DirectedWeightedGraphBuilder(G baseGraph)\n    {\n        super(baseGraph);\n    }\n\n    @Override protected DirectedWeightedGraphBuilder<V, E, G> self()\n    {\n        return this;\n    }\n}\n\n// End DirectedWeightedGraphBuilder.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109486503,"label":true,"oracleId":26047,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph.builder","className":"DirectedGraphBuilderBase","javadocTag":"@param baseGraph the graph object to base building on","methodJavadoc":"    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */","methodSourceCode":"public DirectedGraphBuilderBase(G baseGraph){\n    super(baseGraph);\n}","classJavadoc":"/**\n * Base class for {@link DirectedGraphBuilder} for extending.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -----------------------------\n * DirectedGraphBuilderBase.java\n * -----------------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for {@link DirectedGraphBuilder} for extending.\n */\npublic abstract class DirectedGraphBuilderBase<V,\n    E,\n    G extends DirectedGraph<V, E>,\n    B extends DirectedGraphBuilderBase<V, E, G, B>>\n    extends AbstractGraphBuilder<V, E, G, B>\n{\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public DirectedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }\n\n    @Override public UnmodifiableDirectedGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableDirectedGraph<V, E>(this.graph);\n    }\n}\n\n// End DirectedGraphBuilderBase.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109486711,"label":true,"oracleId":26048,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph","className":"ListenableDirectedGraph","javadocTag":"@param edgeClass class on which to base factory for edges","methodJavadoc":"    /**\n     * Creates a new listenable directed graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */","methodSourceCode":"public ListenableDirectedGraph(Class<? extends E> edgeClass){\n    this(new DefaultDirectedGraph<V, E>(edgeClass));\n}","classJavadoc":"/**\n * A directed graph which is also {@link org.jgrapht.ListenableGraph}.\n *\n * @see DefaultListenableGraph\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------------------\n * ListenableDirectedGraph.java\n * ----------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport org.jgrapht.*;\n\n\n/**\n * A directed graph which is also {@link org.jgrapht.ListenableGraph}.\n *\n * @see DefaultListenableGraph\n */\npublic class ListenableDirectedGraph<V, E>\n    extends DefaultListenableGraph<V, E>\n    implements DirectedGraph<V, E>\n{\n    private static final long serialVersionUID = 3257571698126368824L;\n\n    /**\n     * Creates a new listenable directed graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */\n    public ListenableDirectedGraph(Class<? extends E> edgeClass)\n    {\n        this(new DefaultDirectedGraph<V, E>(edgeClass));\n    }\n\n    /**\n     * Creates a new listenable directed graph.\n     *\n     * @param base the backing graph.\n     */\n    public ListenableDirectedGraph(DirectedGraph<V, E> base)\n    {\n        super(base);\n    }\n}\n\n// End ListenableDirectedGraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109486919,"label":true,"oracleId":26049,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph","className":"ListenableDirectedGraph","javadocTag":"@param base the backing graph.","methodJavadoc":"    /**\n     * Creates a new listenable directed graph.\n     *\n     * @param base the backing graph.\n     */","methodSourceCode":"public ListenableDirectedGraph(DirectedGraph<V, E> base){\n    super(base);\n}","classJavadoc":"/**\n * A directed graph which is also {@link org.jgrapht.ListenableGraph}.\n *\n * @see DefaultListenableGraph\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------------------\n * ListenableDirectedGraph.java\n * ----------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport org.jgrapht.*;\n\n\n/**\n * A directed graph which is also {@link org.jgrapht.ListenableGraph}.\n *\n * @see DefaultListenableGraph\n */\npublic class ListenableDirectedGraph<V, E>\n    extends DefaultListenableGraph<V, E>\n    implements DirectedGraph<V, E>\n{\n    private static final long serialVersionUID = 3257571698126368824L;\n\n    /**\n     * Creates a new listenable directed graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */\n    public ListenableDirectedGraph(Class<? extends E> edgeClass)\n    {\n        this(new DefaultDirectedGraph<V, E>(edgeClass));\n    }\n\n    /**\n     * Creates a new listenable directed graph.\n     *\n     * @param base the backing graph.\n     */\n    public ListenableDirectedGraph(DirectedGraph<V, E> base)\n    {\n        super(base);\n    }\n}\n\n// End ListenableDirectedGraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109487127,"label":true,"oracleId":26050,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph","className":"UnmodifiableDirectedGraph","javadocTag":"@param g the backing graph on which an unmodifiable graph is to be\ncreated.","methodJavadoc":"    /**\n     * Creates a new unmodifiable directed graph based on the specified backing\n     * graph.\n     *\n     * @param g the backing graph on which an unmodifiable graph is to be\n     * created.\n     */","methodSourceCode":"public UnmodifiableDirectedGraph(DirectedGraph<V, E> g){\n    super(g);\n}","classJavadoc":"/**\n * A directed graph that cannot be modified.\n *\n * @see UnmodifiableGraph\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------------------\n * UnmodifiableDirectedGraph.java\n * ------------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n *\n */\npackage org.jgrapht.graph;\n\nimport org.jgrapht.*;\n\n\n/**\n * A directed graph that cannot be modified.\n *\n * @see UnmodifiableGraph\n */\npublic class UnmodifiableDirectedGraph<V, E>\n    extends UnmodifiableGraph<V, E>\n    implements DirectedGraph<V, E>\n{\n    private static final long serialVersionUID = 3978701783725913906L;\n\n    /**\n     * Creates a new unmodifiable directed graph based on the specified backing\n     * graph.\n     *\n     * @param g the backing graph on which an unmodifiable graph is to be\n     * created.\n     */\n    public UnmodifiableDirectedGraph(DirectedGraph<V, E> g)\n    {\n        super(g);\n    }\n}\n\n// End UnmodifiableDirectedGraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109487336,"label":true,"oracleId":26051,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph","className":"SimpleGraphPath","javadocTag":"@return A list of the vertices that define the path.","methodJavadoc":"    /**\n     * @return A list of the vertices that define the path.\n     */","methodSourceCode":"public List<V> getVertexList(){\n    return this.vertices;\n}","classJavadoc":"/**\n * A vertex-based representation of a simple path. The graph must be simple for\n * the vertices to uniquely determine a path. See {@link SimpleGraph}\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------------\n * SimpleGraphPath.java\n * ------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Rodrigo López Dato\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 22-Jan-2014 : Initial revision;\n * 29-Jan-2013 : Added weight parameter. Edge list is now stored when validating\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * A vertex-based representation of a simple path. The graph must be simple for\n * the vertices to uniquely determine a path. See {@link SimpleGraph}\n */\npublic class SimpleGraphPath<V, E>\n    implements GraphPath<V, E>\n{\n    private SimpleGraph<V, E> graph;\n    private List<V> vertices;\n    private List<E> edges;\n    private double weight;\n\n    /**\n     * @param simpleGraph The simple graph where the path is.\n     * @param vertices A list of vertices that make up the path.\n     *\n     * @throws IllegalArgumentException if the vertices are not in the path or\n     * if they do not define a path in the graph.\n     */\n    public SimpleGraphPath(\n        SimpleGraph<V, E> simpleGraph,\n        List<V> vertices,\n        double weight)\n    {\n        this.graph = simpleGraph;\n        this.vertices = vertices;\n        this.edges = new ArrayList<E>();\n        this.weight = weight;\n\n        if (vertices.size() < 2) {\n            throw new IllegalArgumentException(\n                \"At least two vertices are required to form a path\");\n        }\n\n        for (int i = 0; i < (getVertexList().size() - 1); i++) {\n            E currentEdge =\n                getGraph().getEdge(\n                    getVertexList().get(i),\n                    getVertexList().get(i + 1));\n            if (currentEdge != null) {\n                edges.add(currentEdge);\n            } else {\n                throw new IllegalArgumentException(\n                    \"The specified vertices do not form a path\");\n            }\n        }\n    }\n\n    @Override public SimpleGraph<V, E> getGraph()\n    {\n        return this.graph;\n    }\n\n    @Override public V getStartVertex()\n    {\n        return this.getVertexList().get(0);\n    }\n\n    @Override public V getEndVertex()\n    {\n        return this.getVertexList().get(getVertexList().size() - 1);\n    }\n\n    @Override public List<E> getEdgeList()\n    {\n        return this.edges;\n    }\n\n    /**\n     * @return A list of the vertices that define the path.\n     */\n    public List<V> getVertexList()\n    {\n        return this.vertices;\n    }\n\n    @Override public double getWeight()\n    {\n        return weight;\n    }\n}\n\n// End SimpleGraphPath.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109487546,"label":true,"oracleId":26052,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph","className":"SimpleGraphPath","javadocTag":"@param simpleGraph The simple graph where the path is.","methodJavadoc":"    /**\n     * @param simpleGraph The simple graph where the path is.\n     * @param vertices A list of vertices that make up the path.\n     *\n     * @throws IllegalArgumentException if the vertices are not in the path or\n     * if they do not define a path in the graph.\n     */","methodSourceCode":"public SimpleGraphPath(SimpleGraph<V, E> simpleGraph, List<V> vertices, double weight){\n    this.graph = simpleGraph;\n    this.vertices = vertices;\n    this.edges = new ArrayList<E>();\n    this.weight = weight;\n    if (vertices.size() < 2) {\n        throw new IllegalArgumentException(\"At least two vertices are required to form a path\");\n    }\n    for (int i = 0; i < (getVertexList().size() - 1); i++) {\n        E currentEdge = getGraph().getEdge(getVertexList().get(i), getVertexList().get(i + 1));\n        if (currentEdge != null) {\n            edges.add(currentEdge);\n        } else {\n            throw new IllegalArgumentException(\"The specified vertices do not form a path\");\n        }\n    }\n}","classJavadoc":"/**\n * A vertex-based representation of a simple path. The graph must be simple for\n * the vertices to uniquely determine a path. See {@link SimpleGraph}\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------------\n * SimpleGraphPath.java\n * ------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Rodrigo López Dato\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 22-Jan-2014 : Initial revision;\n * 29-Jan-2013 : Added weight parameter. Edge list is now stored when validating\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * A vertex-based representation of a simple path. The graph must be simple for\n * the vertices to uniquely determine a path. See {@link SimpleGraph}\n */\npublic class SimpleGraphPath<V, E>\n    implements GraphPath<V, E>\n{\n    private SimpleGraph<V, E> graph;\n    private List<V> vertices;\n    private List<E> edges;\n    private double weight;\n\n    /**\n     * @param simpleGraph The simple graph where the path is.\n     * @param vertices A list of vertices that make up the path.\n     *\n     * @throws IllegalArgumentException if the vertices are not in the path or\n     * if they do not define a path in the graph.\n     */\n    public SimpleGraphPath(\n        SimpleGraph<V, E> simpleGraph,\n        List<V> vertices,\n        double weight)\n    {\n        this.graph = simpleGraph;\n        this.vertices = vertices;\n        this.edges = new ArrayList<E>();\n        this.weight = weight;\n\n        if (vertices.size() < 2) {\n            throw new IllegalArgumentException(\n                \"At least two vertices are required to form a path\");\n        }\n\n        for (int i = 0; i < (getVertexList().size() - 1); i++) {\n            E currentEdge =\n                getGraph().getEdge(\n                    getVertexList().get(i),\n                    getVertexList().get(i + 1));\n            if (currentEdge != null) {\n                edges.add(currentEdge);\n            } else {\n                throw new IllegalArgumentException(\n                    \"The specified vertices do not form a path\");\n            }\n        }\n    }\n\n    @Override public SimpleGraph<V, E> getGraph()\n    {\n        return this.graph;\n    }\n\n    @Override public V getStartVertex()\n    {\n        return this.getVertexList().get(0);\n    }\n\n    @Override public V getEndVertex()\n    {\n        return this.getVertexList().get(getVertexList().size() - 1);\n    }\n\n    @Override public List<E> getEdgeList()\n    {\n        return this.edges;\n    }\n\n    /**\n     * @return A list of the vertices that define the path.\n     */\n    public List<V> getVertexList()\n    {\n        return this.vertices;\n    }\n\n    @Override public double getWeight()\n    {\n        return weight;\n    }\n}\n\n// End SimpleGraphPath.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109487756,"label":true,"oracleId":26053,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph","className":"SimpleGraphPath","javadocTag":"@param vertices A list of vertices that make up the path.","methodJavadoc":"    /**\n     * @param simpleGraph The simple graph where the path is.\n     * @param vertices A list of vertices that make up the path.\n     *\n     * @throws IllegalArgumentException if the vertices are not in the path or\n     * if they do not define a path in the graph.\n     */","methodSourceCode":"public SimpleGraphPath(SimpleGraph<V, E> simpleGraph, List<V> vertices, double weight){\n    this.graph = simpleGraph;\n    this.vertices = vertices;\n    this.edges = new ArrayList<E>();\n    this.weight = weight;\n    if (vertices.size() < 2) {\n        throw new IllegalArgumentException(\"At least two vertices are required to form a path\");\n    }\n    for (int i = 0; i < (getVertexList().size() - 1); i++) {\n        E currentEdge = getGraph().getEdge(getVertexList().get(i), getVertexList().get(i + 1));\n        if (currentEdge != null) {\n            edges.add(currentEdge);\n        } else {\n            throw new IllegalArgumentException(\"The specified vertices do not form a path\");\n        }\n    }\n}","classJavadoc":"/**\n * A vertex-based representation of a simple path. The graph must be simple for\n * the vertices to uniquely determine a path. See {@link SimpleGraph}\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------------\n * SimpleGraphPath.java\n * ------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Rodrigo López Dato\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 22-Jan-2014 : Initial revision;\n * 29-Jan-2013 : Added weight parameter. Edge list is now stored when validating\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * A vertex-based representation of a simple path. The graph must be simple for\n * the vertices to uniquely determine a path. See {@link SimpleGraph}\n */\npublic class SimpleGraphPath<V, E>\n    implements GraphPath<V, E>\n{\n    private SimpleGraph<V, E> graph;\n    private List<V> vertices;\n    private List<E> edges;\n    private double weight;\n\n    /**\n     * @param simpleGraph The simple graph where the path is.\n     * @param vertices A list of vertices that make up the path.\n     *\n     * @throws IllegalArgumentException if the vertices are not in the path or\n     * if they do not define a path in the graph.\n     */\n    public SimpleGraphPath(\n        SimpleGraph<V, E> simpleGraph,\n        List<V> vertices,\n        double weight)\n    {\n        this.graph = simpleGraph;\n        this.vertices = vertices;\n        this.edges = new ArrayList<E>();\n        this.weight = weight;\n\n        if (vertices.size() < 2) {\n            throw new IllegalArgumentException(\n                \"At least two vertices are required to form a path\");\n        }\n\n        for (int i = 0; i < (getVertexList().size() - 1); i++) {\n            E currentEdge =\n                getGraph().getEdge(\n                    getVertexList().get(i),\n                    getVertexList().get(i + 1));\n            if (currentEdge != null) {\n                edges.add(currentEdge);\n            } else {\n                throw new IllegalArgumentException(\n                    \"The specified vertices do not form a path\");\n            }\n        }\n    }\n\n    @Override public SimpleGraph<V, E> getGraph()\n    {\n        return this.graph;\n    }\n\n    @Override public V getStartVertex()\n    {\n        return this.getVertexList().get(0);\n    }\n\n    @Override public V getEndVertex()\n    {\n        return this.getVertexList().get(getVertexList().size() - 1);\n    }\n\n    @Override public List<E> getEdgeList()\n    {\n        return this.edges;\n    }\n\n    /**\n     * @return A list of the vertices that define the path.\n     */\n    public List<V> getVertexList()\n    {\n        return this.vertices;\n    }\n\n    @Override public double getWeight()\n    {\n        return weight;\n    }\n}\n\n// End SimpleGraphPath.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109487967,"label":true,"oracleId":26054,"oracleType":"EXCEPT_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph","className":"SimpleGraphPath","javadocTag":"@throws IllegalArgumentException if the vertices are not in the path or\nif they do not define a path in the graph.","methodJavadoc":"    /**\n     * @param simpleGraph The simple graph where the path is.\n     * @param vertices A list of vertices that make up the path.\n     *\n     * @throws IllegalArgumentException if the vertices are not in the path or\n     * if they do not define a path in the graph.\n     */","methodSourceCode":"public SimpleGraphPath(SimpleGraph<V, E> simpleGraph, List<V> vertices, double weight){\n    this.graph = simpleGraph;\n    this.vertices = vertices;\n    this.edges = new ArrayList<E>();\n    this.weight = weight;\n    if (vertices.size() < 2) {\n        throw new IllegalArgumentException(\"At least two vertices are required to form a path\");\n    }\n    for (int i = 0; i < (getVertexList().size() - 1); i++) {\n        E currentEdge = getGraph().getEdge(getVertexList().get(i), getVertexList().get(i + 1));\n        if (currentEdge != null) {\n            edges.add(currentEdge);\n        } else {\n            throw new IllegalArgumentException(\"The specified vertices do not form a path\");\n        }\n    }\n}","classJavadoc":"/**\n * A vertex-based representation of a simple path. The graph must be simple for\n * the vertices to uniquely determine a path. See {@link SimpleGraph}\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------------\n * SimpleGraphPath.java\n * ------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Rodrigo López Dato\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 22-Jan-2014 : Initial revision;\n * 29-Jan-2013 : Added weight parameter. Edge list is now stored when validating\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * A vertex-based representation of a simple path. The graph must be simple for\n * the vertices to uniquely determine a path. See {@link SimpleGraph}\n */\npublic class SimpleGraphPath<V, E>\n    implements GraphPath<V, E>\n{\n    private SimpleGraph<V, E> graph;\n    private List<V> vertices;\n    private List<E> edges;\n    private double weight;\n\n    /**\n     * @param simpleGraph The simple graph where the path is.\n     * @param vertices A list of vertices that make up the path.\n     *\n     * @throws IllegalArgumentException if the vertices are not in the path or\n     * if they do not define a path in the graph.\n     */\n    public SimpleGraphPath(\n        SimpleGraph<V, E> simpleGraph,\n        List<V> vertices,\n        double weight)\n    {\n        this.graph = simpleGraph;\n        this.vertices = vertices;\n        this.edges = new ArrayList<E>();\n        this.weight = weight;\n\n        if (vertices.size() < 2) {\n            throw new IllegalArgumentException(\n                \"At least two vertices are required to form a path\");\n        }\n\n        for (int i = 0; i < (getVertexList().size() - 1); i++) {\n            E currentEdge =\n                getGraph().getEdge(\n                    getVertexList().get(i),\n                    getVertexList().get(i + 1));\n            if (currentEdge != null) {\n                edges.add(currentEdge);\n            } else {\n                throw new IllegalArgumentException(\n                    \"The specified vertices do not form a path\");\n            }\n        }\n    }\n\n    @Override public SimpleGraph<V, E> getGraph()\n    {\n        return this.graph;\n    }\n\n    @Override public V getStartVertex()\n    {\n        return this.getVertexList().get(0);\n    }\n\n    @Override public V getEndVertex()\n    {\n        return this.getVertexList().get(getVertexList().size() - 1);\n    }\n\n    @Override public List<E> getEdgeList()\n    {\n        return this.edges;\n    }\n\n    /**\n     * @return A list of the vertices that define the path.\n     */\n    public List<V> getVertexList()\n    {\n        return this.vertices;\n    }\n\n    @Override public double getWeight()\n    {\n        return weight;\n    }\n}\n\n// End SimpleGraphPath.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109488175,"label":true,"oracleId":26055,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph","className":"DirectedWeightedMultigraph","javadocTag":"@param edgeClass class on which to base factory for edges","methodJavadoc":"    /**\n     * Creates a new directed weighted multigraph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */","methodSourceCode":"public DirectedWeightedMultigraph(Class<? extends E> edgeClass){\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","classJavadoc":"/**\n * A directed weighted multigraph. A directed weighted multigraph is a\n * non-simple directed graph in which no loops are permitted, but multiple edges\n * between any two vertices are permitted, and edges have weights.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------------\n * DirectedWeightedMultigraph.java\n * -------------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 06-Jun-2005 : Made generic (CH);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.builder.*;\n\n\n/**\n * A directed weighted multigraph. A directed weighted multigraph is a\n * non-simple directed graph in which no loops are permitted, but multiple edges\n * between any two vertices are permitted, and edges have weights.\n */\npublic class DirectedWeightedMultigraph<V, E>\n    extends DirectedMultigraph<V, E>\n    implements WeightedGraph<V, E>\n{\n    private static final long serialVersionUID = 4049071636005206066L;\n\n    /**\n     * Creates a new directed weighted multigraph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */\n    public DirectedWeightedMultigraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }\n\n    /**\n     * Creates a new directed weighted multigraph with the specified edge\n     * factory.\n     *\n     * @param ef the edge factory of the new graph.\n     */\n    public DirectedWeightedMultigraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n    }\n\n    public static <V, E> DirectedWeightedGraphBuilderBase<V,\n        E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new DirectedWeightedGraphBuilder<V,\n            E, DirectedWeightedMultigraph<V, E>>(\n                new DirectedWeightedMultigraph<V, E>(edgeClass));\n    }\n\n    public static <V, E> DirectedWeightedGraphBuilderBase<V,\n        E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(\n        EdgeFactory<V, E> ef)\n    {\n        return new DirectedWeightedGraphBuilder<V,\n            E, DirectedWeightedMultigraph<V, E>>(\n                new DirectedWeightedMultigraph<V, E>(ef));\n    }\n}\n\n// End DirectedWeightedMultigraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109488383,"label":true,"oracleId":26056,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph","className":"DirectedWeightedMultigraph","javadocTag":"@param ef the edge factory of the new graph.","methodJavadoc":"    /**\n     * Creates a new directed weighted multigraph with the specified edge\n     * factory.\n     *\n     * @param ef the edge factory of the new graph.\n     */","methodSourceCode":"public DirectedWeightedMultigraph(EdgeFactory<V, E> ef){\n    super(ef);\n}","classJavadoc":"/**\n * A directed weighted multigraph. A directed weighted multigraph is a\n * non-simple directed graph in which no loops are permitted, but multiple edges\n * between any two vertices are permitted, and edges have weights.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------------\n * DirectedWeightedMultigraph.java\n * -------------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 06-Jun-2005 : Made generic (CH);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.builder.*;\n\n\n/**\n * A directed weighted multigraph. A directed weighted multigraph is a\n * non-simple directed graph in which no loops are permitted, but multiple edges\n * between any two vertices are permitted, and edges have weights.\n */\npublic class DirectedWeightedMultigraph<V, E>\n    extends DirectedMultigraph<V, E>\n    implements WeightedGraph<V, E>\n{\n    private static final long serialVersionUID = 4049071636005206066L;\n\n    /**\n     * Creates a new directed weighted multigraph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */\n    public DirectedWeightedMultigraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }\n\n    /**\n     * Creates a new directed weighted multigraph with the specified edge\n     * factory.\n     *\n     * @param ef the edge factory of the new graph.\n     */\n    public DirectedWeightedMultigraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n    }\n\n    public static <V, E> DirectedWeightedGraphBuilderBase<V,\n        E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new DirectedWeightedGraphBuilder<V,\n            E, DirectedWeightedMultigraph<V, E>>(\n                new DirectedWeightedMultigraph<V, E>(edgeClass));\n    }\n\n    public static <V, E> DirectedWeightedGraphBuilderBase<V,\n        E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(\n        EdgeFactory<V, E> ef)\n    {\n        return new DirectedWeightedGraphBuilder<V,\n            E, DirectedWeightedMultigraph<V, E>>(\n                new DirectedWeightedMultigraph<V, E>(ef));\n    }\n}\n\n// End DirectedWeightedMultigraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109488593,"label":true,"oracleId":26057,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph","className":"DirectedSubgraph","javadocTag":"@param base the base (backing) graph on which the subgraph will be based.","methodJavadoc":"    /**\n     * Creates a new directed subgraph.\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param vertexSubset vertices to include in the subgraph. If <code>\n     * null</code> then all vertices are included.\n     * @param edgeSubset edges to in include in the subgraph. If <code>\n     * null</code> then all the edges whose vertices found in the graph are\n     * included.\n     */","methodSourceCode":"public DirectedSubgraph(DirectedGraph<V, E> base, Set<V> vertexSubset, Set<E> edgeSubset){\n    super(base, vertexSubset, edgeSubset);\n}","classJavadoc":"/**\n * A directed graph that is a subgraph on other graph.\n *\n * @see Subgraph\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * DirectedSubgraph.java\n * ---------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * A directed graph that is a subgraph on other graph.\n *\n * @see Subgraph\n */\npublic class DirectedSubgraph<V, E>\n    extends Subgraph<V, E, DirectedGraph<V, E>>\n    implements DirectedGraph<V, E>\n{\n    private static final long serialVersionUID = 3616445700507054133L;\n\n    /**\n     * Creates a new directed subgraph.\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param vertexSubset vertices to include in the subgraph. If <code>\n     * null</code> then all vertices are included.\n     * @param edgeSubset edges to in include in the subgraph. If <code>\n     * null</code> then all the edges whose vertices found in the graph are\n     * included.\n     */\n    public DirectedSubgraph(\n        DirectedGraph<V, E> base,\n        Set<V> vertexSubset,\n        Set<E> edgeSubset)\n    {\n        super(base, vertexSubset, edgeSubset);\n    }\n\n    /**\n     * @see DirectedGraph#inDegreeOf(Object)\n     */\n    @Override public int inDegreeOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        int degree = 0;\n\n        for (E e : getBase().incomingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                degree++;\n            }\n        }\n\n        return degree;\n    }\n\n    /**\n     * @see DirectedGraph#incomingEdgesOf(Object)\n     */\n    @Override public Set<E> incomingEdgesOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        Set<E> edges = new ArrayUnenforcedSet<E>();\n\n        for (E e : getBase().incomingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                edges.add(e);\n            }\n        }\n\n        return edges;\n    }\n\n    /**\n     * @see DirectedGraph#outDegreeOf(Object)\n     */\n    @Override public int outDegreeOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        int degree = 0;\n\n        for (E e : getBase().outgoingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                degree++;\n            }\n        }\n\n        return degree;\n    }\n\n    /**\n     * @see DirectedGraph#outgoingEdgesOf(Object)\n     */\n    @Override public Set<E> outgoingEdgesOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        Set<E> edges = new ArrayUnenforcedSet<E>();\n\n        for (E e : getBase().outgoingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                edges.add(e);\n            }\n        }\n\n        return edges;\n    }\n}\n\n// End DirectedSubgraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109488803,"label":true,"oracleId":26058,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph","className":"DirectedSubgraph","javadocTag":"@param vertexSubset vertices to include in the subgraph. If <code>\nnull</code> then all vertices are included.","methodJavadoc":"    /**\n     * Creates a new directed subgraph.\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param vertexSubset vertices to include in the subgraph. If <code>\n     * null</code> then all vertices are included.\n     * @param edgeSubset edges to in include in the subgraph. If <code>\n     * null</code> then all the edges whose vertices found in the graph are\n     * included.\n     */","methodSourceCode":"public DirectedSubgraph(DirectedGraph<V, E> base, Set<V> vertexSubset, Set<E> edgeSubset){\n    super(base, vertexSubset, edgeSubset);\n}","classJavadoc":"/**\n * A directed graph that is a subgraph on other graph.\n *\n * @see Subgraph\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * DirectedSubgraph.java\n * ---------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * A directed graph that is a subgraph on other graph.\n *\n * @see Subgraph\n */\npublic class DirectedSubgraph<V, E>\n    extends Subgraph<V, E, DirectedGraph<V, E>>\n    implements DirectedGraph<V, E>\n{\n    private static final long serialVersionUID = 3616445700507054133L;\n\n    /**\n     * Creates a new directed subgraph.\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param vertexSubset vertices to include in the subgraph. If <code>\n     * null</code> then all vertices are included.\n     * @param edgeSubset edges to in include in the subgraph. If <code>\n     * null</code> then all the edges whose vertices found in the graph are\n     * included.\n     */\n    public DirectedSubgraph(\n        DirectedGraph<V, E> base,\n        Set<V> vertexSubset,\n        Set<E> edgeSubset)\n    {\n        super(base, vertexSubset, edgeSubset);\n    }\n\n    /**\n     * @see DirectedGraph#inDegreeOf(Object)\n     */\n    @Override public int inDegreeOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        int degree = 0;\n\n        for (E e : getBase().incomingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                degree++;\n            }\n        }\n\n        return degree;\n    }\n\n    /**\n     * @see DirectedGraph#incomingEdgesOf(Object)\n     */\n    @Override public Set<E> incomingEdgesOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        Set<E> edges = new ArrayUnenforcedSet<E>();\n\n        for (E e : getBase().incomingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                edges.add(e);\n            }\n        }\n\n        return edges;\n    }\n\n    /**\n     * @see DirectedGraph#outDegreeOf(Object)\n     */\n    @Override public int outDegreeOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        int degree = 0;\n\n        for (E e : getBase().outgoingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                degree++;\n            }\n        }\n\n        return degree;\n    }\n\n    /**\n     * @see DirectedGraph#outgoingEdgesOf(Object)\n     */\n    @Override public Set<E> outgoingEdgesOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        Set<E> edges = new ArrayUnenforcedSet<E>();\n\n        for (E e : getBase().outgoingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                edges.add(e);\n            }\n        }\n\n        return edges;\n    }\n}\n\n// End DirectedSubgraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109489013,"label":true,"oracleId":26059,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph","className":"DirectedSubgraph","javadocTag":"@param edgeSubset edges to in include in the subgraph. If <code>\nnull</code> then all the edges whose vertices found in the graph are\nincluded.","methodJavadoc":"    /**\n     * Creates a new directed subgraph.\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param vertexSubset vertices to include in the subgraph. If <code>\n     * null</code> then all vertices are included.\n     * @param edgeSubset edges to in include in the subgraph. If <code>\n     * null</code> then all the edges whose vertices found in the graph are\n     * included.\n     */","methodSourceCode":"public DirectedSubgraph(DirectedGraph<V, E> base, Set<V> vertexSubset, Set<E> edgeSubset){\n    super(base, vertexSubset, edgeSubset);\n}","classJavadoc":"/**\n * A directed graph that is a subgraph on other graph.\n *\n * @see Subgraph\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * DirectedSubgraph.java\n * ---------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * A directed graph that is a subgraph on other graph.\n *\n * @see Subgraph\n */\npublic class DirectedSubgraph<V, E>\n    extends Subgraph<V, E, DirectedGraph<V, E>>\n    implements DirectedGraph<V, E>\n{\n    private static final long serialVersionUID = 3616445700507054133L;\n\n    /**\n     * Creates a new directed subgraph.\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param vertexSubset vertices to include in the subgraph. If <code>\n     * null</code> then all vertices are included.\n     * @param edgeSubset edges to in include in the subgraph. If <code>\n     * null</code> then all the edges whose vertices found in the graph are\n     * included.\n     */\n    public DirectedSubgraph(\n        DirectedGraph<V, E> base,\n        Set<V> vertexSubset,\n        Set<E> edgeSubset)\n    {\n        super(base, vertexSubset, edgeSubset);\n    }\n\n    /**\n     * @see DirectedGraph#inDegreeOf(Object)\n     */\n    @Override public int inDegreeOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        int degree = 0;\n\n        for (E e : getBase().incomingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                degree++;\n            }\n        }\n\n        return degree;\n    }\n\n    /**\n     * @see DirectedGraph#incomingEdgesOf(Object)\n     */\n    @Override public Set<E> incomingEdgesOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        Set<E> edges = new ArrayUnenforcedSet<E>();\n\n        for (E e : getBase().incomingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                edges.add(e);\n            }\n        }\n\n        return edges;\n    }\n\n    /**\n     * @see DirectedGraph#outDegreeOf(Object)\n     */\n    @Override public int outDegreeOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        int degree = 0;\n\n        for (E e : getBase().outgoingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                degree++;\n            }\n        }\n\n        return degree;\n    }\n\n    /**\n     * @see DirectedGraph#outgoingEdgesOf(Object)\n     */\n    @Override public Set<E> outgoingEdgesOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        Set<E> edges = new ArrayUnenforcedSet<E>();\n\n        for (E e : getBase().outgoingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                edges.add(e);\n            }\n        }\n\n        return edges;\n    }\n}\n\n// End DirectedSubgraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109489221,"label":true,"oracleId":26060,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph","className":"SimpleDirectedGraph","javadocTag":"@param edgeClass class on which to base factory for edges","methodJavadoc":"    /**\n     * Creates a new simple directed graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */","methodSourceCode":"public SimpleDirectedGraph(Class<? extends E> edgeClass){\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","classJavadoc":"/**\n * A simple directed graph. A simple directed graph is a directed graph in which\n * neither multiple edges between any two vertices nor loops are permitted.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------------\n * SimpleDirectedGraph.java\n * ------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 06-Aug-2005 : Made generic (CH);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.builder.*;\n\n\n/**\n * A simple directed graph. A simple directed graph is a directed graph in which\n * neither multiple edges between any two vertices nor loops are permitted.\n */\npublic class SimpleDirectedGraph<V, E>\n    extends AbstractBaseGraph<V, E>\n    implements DirectedGraph<V, E>\n{\n    private static final long serialVersionUID = 4049358608472879671L;\n\n    /**\n     * Creates a new simple directed graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */\n    public SimpleDirectedGraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }\n\n    /**\n     * Creates a new simple directed graph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     */\n    public SimpleDirectedGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef, false, false);\n    }\n\n    public static <V, E> DirectedGraphBuilderBase<V,\n        E, ? extends SimpleDirectedGraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(\n            new SimpleDirectedGraph<V, E>(edgeClass));\n    }\n\n    public static <V, E> DirectedGraphBuilderBase<V,\n        E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(\n            new SimpleDirectedGraph<V, E>(ef));\n    }\n}\n\n// End SimpleDirectedGraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109489429,"label":true,"oracleId":26061,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht.graph","className":"SimpleDirectedGraph","javadocTag":"@param ef the edge factory of the new graph.","methodJavadoc":"    /**\n     * Creates a new simple directed graph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     */","methodSourceCode":"public SimpleDirectedGraph(EdgeFactory<V, E> ef){\n    super(ef, false, false);\n}","classJavadoc":"/**\n * A simple directed graph. A simple directed graph is a directed graph in which\n * neither multiple edges between any two vertices nor loops are permitted.\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------------\n * SimpleDirectedGraph.java\n * ------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 06-Aug-2005 : Made generic (CH);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.builder.*;\n\n\n/**\n * A simple directed graph. A simple directed graph is a directed graph in which\n * neither multiple edges between any two vertices nor loops are permitted.\n */\npublic class SimpleDirectedGraph<V, E>\n    extends AbstractBaseGraph<V, E>\n    implements DirectedGraph<V, E>\n{\n    private static final long serialVersionUID = 4049358608472879671L;\n\n    /**\n     * Creates a new simple directed graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */\n    public SimpleDirectedGraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }\n\n    /**\n     * Creates a new simple directed graph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     */\n    public SimpleDirectedGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef, false, false);\n    }\n\n    public static <V, E> DirectedGraphBuilderBase<V,\n        E, ? extends SimpleDirectedGraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(\n            new SimpleDirectedGraph<V, E>(edgeClass));\n    }\n\n    public static <V, E> DirectedGraphBuilderBase<V,\n        E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(\n            new SimpleDirectedGraph<V, E>(ef));\n    }\n}\n\n// End SimpleDirectedGraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109489640,"label":true,"oracleId":26062,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param g the graph for which the edge to be added.","methodJavadoc":"    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */","methodSourceCode":"public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight){\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109489851,"label":true,"oracleId":26063,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param sourceVertex source vertex of the edge.","methodJavadoc":"    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */","methodSourceCode":"public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight){\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109490062,"label":true,"oracleId":26064,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param targetVertex target vertex of the edge.","methodJavadoc":"    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */","methodSourceCode":"public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight){\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109490273,"label":true,"oracleId":26065,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param weight weight of the edge.","methodJavadoc":"    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */","methodSourceCode":"public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight){\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109490485,"label":true,"oracleId":26066,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@return The newly created edge if added to the graph, otherwise <code>\nnull</code>.","methodJavadoc":"    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */","methodSourceCode":"public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight){\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109490695,"label":true,"oracleId":26067,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param g the graph for which the specified edge to be added.","methodJavadoc":"    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */","methodSourceCode":"public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex){\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109490905,"label":true,"oracleId":26068,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param sourceVertex source vertex of the edge.","methodJavadoc":"    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */","methodSourceCode":"public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex){\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109491115,"label":true,"oracleId":26069,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param targetVertex target vertex of the edge.","methodJavadoc":"    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */","methodSourceCode":"public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex){\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109491326,"label":true,"oracleId":26070,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@return The newly created edge if added to the graph, otherwise <code>\nnull</code>.","methodJavadoc":"    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */","methodSourceCode":"public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex){\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109491536,"label":true,"oracleId":26071,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param targetGraph the graph for which the specified edge to be added.","methodJavadoc":"    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */","methodSourceCode":"public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge){\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109491746,"label":true,"oracleId":26072,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param sourceGraph the graph in which the specified edge is already\npresent","methodJavadoc":"    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */","methodSourceCode":"public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge){\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109491956,"label":true,"oracleId":26073,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param edge edge to add","methodJavadoc":"    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */","methodSourceCode":"public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge){\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109492167,"label":true,"oracleId":26074,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param g the graph for which the specified edge to be added.","methodJavadoc":"    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */","methodSourceCode":"public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight){\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109492378,"label":true,"oracleId":26075,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param sourceVertex source vertex of the edge.","methodJavadoc":"    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */","methodSourceCode":"public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight){\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109492589,"label":true,"oracleId":26076,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param targetVertex target vertex of the edge.","methodJavadoc":"    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */","methodSourceCode":"public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight){\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109492800,"label":true,"oracleId":26077,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param weight weight of the edge.","methodJavadoc":"    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */","methodSourceCode":"public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight){\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109493012,"label":true,"oracleId":26078,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@return The newly created edge if added to the graph, otherwise <code>\nnull</code>.","methodJavadoc":"    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */","methodSourceCode":"public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight){\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109493221,"label":true,"oracleId":26079,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param destination the graph to which vertices and edges are added.","methodJavadoc":"    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */","methodSourceCode":"public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source){\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109493430,"label":true,"oracleId":26080,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param source the graph used as source for vertices and edges to add.","methodJavadoc":"    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */","methodSourceCode":"public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source){\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109493640,"label":true,"oracleId":26081,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@return <code>true</code> if and only if the destination graph has been\nchanged as a result of this operation.","methodJavadoc":"    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */","methodSourceCode":"public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source){\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109493849,"label":true,"oracleId":26082,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param destination the graph to which vertices and edges are added.","methodJavadoc":"    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */","methodSourceCode":"public static <V, E> void addGraphReversed(DirectedGraph<? super V, ? super E> destination, DirectedGraph<V, E> source){\n    addAllVertices(destination, source.vertexSet());\n    for (E edge : source.edgeSet()) {\n        destination.addEdge(source.getEdgeTarget(edge), source.getEdgeSource(edge));\n    }\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109494058,"label":true,"oracleId":26083,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param source the graph used as source for vertices and edges to add.","methodJavadoc":"    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */","methodSourceCode":"public static <V, E> void addGraphReversed(DirectedGraph<? super V, ? super E> destination, DirectedGraph<V, E> source){\n    addAllVertices(destination, source.vertexSet());\n    for (E edge : source.edgeSet()) {\n        destination.addEdge(source.getEdgeTarget(edge), source.getEdgeSource(edge));\n    }\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109494268,"label":true,"oracleId":26084,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param destination the graph to which edges are to be added","methodJavadoc":"    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */","methodSourceCode":"public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges){\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109494478,"label":true,"oracleId":26085,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param source the graph used as a source for edges to add","methodJavadoc":"    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */","methodSourceCode":"public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges){\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109494688,"label":true,"oracleId":26086,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param edges the edges to be added","methodJavadoc":"    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */","methodSourceCode":"public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges){\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109494899,"label":true,"oracleId":26087,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@return <tt>true</tt> if this graph changed as a result of the call","methodJavadoc":"    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */","methodSourceCode":"public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges){\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109495108,"label":true,"oracleId":26088,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param destination the graph to which edges are to be added","methodJavadoc":"    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */","methodSourceCode":"public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices){\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109495317,"label":true,"oracleId":26089,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param vertices the vertices to be added to the graph.","methodJavadoc":"    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */","methodSourceCode":"public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices){\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109495527,"label":true,"oracleId":26090,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@return <tt>true</tt> if graph changed as a result of the call","methodJavadoc":"    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */","methodSourceCode":"public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices){\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109495736,"label":true,"oracleId":26091,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param g the graph to look for neighbors in.","methodJavadoc":"    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */","methodSourceCode":"public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex){\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109495945,"label":true,"oracleId":26092,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param vertex the vertex to get the neighbors of.","methodJavadoc":"    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */","methodSourceCode":"public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex){\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109496155,"label":true,"oracleId":26093,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@return a list of the vertices that are the neighbors of the specified\nvertex.","methodJavadoc":"    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */","methodSourceCode":"public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex){\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109496364,"label":true,"oracleId":26094,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param g the graph to look for predecessors in.","methodJavadoc":"    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */","methodSourceCode":"public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex){\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109496573,"label":true,"oracleId":26095,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param vertex the vertex to get the predecessors of.","methodJavadoc":"    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */","methodSourceCode":"public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex){\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109496783,"label":true,"oracleId":26096,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@return a list of the vertices that are the direct predecessors of the\nspecified vertex.","methodJavadoc":"    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */","methodSourceCode":"public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex){\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109496992,"label":true,"oracleId":26097,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param g the graph to look for successors in.","methodJavadoc":"    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */","methodSourceCode":"public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex){\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109497201,"label":true,"oracleId":26098,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param vertex the vertex to get the successors of.","methodJavadoc":"    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */","methodSourceCode":"public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex){\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109497411,"label":true,"oracleId":26099,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@return a list of the vertices that are the direct successors of the\nspecified vertex.","methodJavadoc":"    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */","methodSourceCode":"public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex){\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109497619,"label":true,"oracleId":26100,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param g the graph for which an undirected view is to be returned.","methodJavadoc":"    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */","methodSourceCode":"public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g){\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109497828,"label":true,"oracleId":26101,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@return an undirected view of the specified graph, if it is directed, or\nor the specified graph itself if it is already undirected.","methodJavadoc":"    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */","methodSourceCode":"public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g){\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109498037,"label":true,"oracleId":26102,"oracleType":"EXCEPT_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@throws IllegalArgumentException if the graph is neither DirectedGraph\nnor UndirectedGraph.","methodJavadoc":"    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */","methodSourceCode":"public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g){\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109498247,"label":true,"oracleId":26103,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param g graph containing e and v","methodJavadoc":"    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */","methodSourceCode":"public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v){\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109498457,"label":true,"oracleId":26104,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param e edge in g","methodJavadoc":"    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */","methodSourceCode":"public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v){\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109498667,"label":true,"oracleId":26105,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param v vertex in g","methodJavadoc":"    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */","methodSourceCode":"public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v){\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109498878,"label":true,"oracleId":26106,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@return true iff e is incident on v","methodJavadoc":"    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */","methodSourceCode":"public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v){\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109499088,"label":true,"oracleId":26107,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param g graph containing e and v","methodJavadoc":"    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */","methodSourceCode":"public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v){\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109499298,"label":true,"oracleId":26108,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param e edge in g","methodJavadoc":"    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */","methodSourceCode":"public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v){\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109499508,"label":true,"oracleId":26109,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param v vertex in g","methodJavadoc":"    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */","methodSourceCode":"public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v){\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109499719,"label":true,"oracleId":26110,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@return vertex opposite to v across e","methodJavadoc":"    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */","methodSourceCode":"public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v){\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109499927,"label":true,"oracleId":26111,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@param path path of interest","methodJavadoc":"    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */","methodSourceCode":"public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path){\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109500136,"label":true,"oracleId":26112,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"Graphs","javadocTag":"@return corresponding vertex list","methodJavadoc":"    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */","methodSourceCode":"public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path){\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}","classJavadoc":"/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109500345,"label":true,"oracleId":26113,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"DirectedGraph","javadocTag":"@param vertex vertex whose degree is to be calculated.","methodJavadoc":"    /**\n     * Returns the \"in degree\" of the specified vertex. An in degree of a vertex\n     * in a directed graph is the number of inward directed edges from that\n     * vertex. See <a href=\"http://mathworld.wolfram.com/Indegree.html\">\n     * http://mathworld.wolfram.com/Indegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */","methodSourceCode":"public int inDegreeOf(V vertex);","classJavadoc":"/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------\n * DirectedGraph.java\n * ------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface DirectedGraph<V, E>\n    extends Graph<V, E>\n{\n    /**\n     * Returns the \"in degree\" of the specified vertex. An in degree of a vertex\n     * in a directed graph is the number of inward directed edges from that\n     * vertex. See <a href=\"http://mathworld.wolfram.com/Indegree.html\">\n     * http://mathworld.wolfram.com/Indegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int inDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges incoming into the specified vertex.\n     *\n     * @param vertex the vertex for which the list of incoming edges to be\n     * returned.\n     *\n     * @return a set of all edges incoming into the specified vertex.\n     */\n    public Set<E> incomingEdgesOf(V vertex);\n\n    /**\n     * Returns the \"out degree\" of the specified vertex. An out degree of a\n     * vertex in a directed graph is the number of outward directed edges from\n     * that vertex. See <a href=\"http://mathworld.wolfram.com/Outdegree.html\">\n     * http://mathworld.wolfram.com/Outdegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int outDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges outgoing from the specified vertex.\n     *\n     * @param vertex the vertex for which the list of outgoing edges to be\n     * returned.\n     *\n     * @return a set of all edges outgoing from the specified vertex.\n     */\n    public Set<E> outgoingEdgesOf(V vertex);\n}\n\n// End DirectedGraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109500555,"label":true,"oracleId":26114,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"DirectedGraph","javadocTag":"@return the degree of the specified vertex.","methodJavadoc":"    /**\n     * Returns the \"in degree\" of the specified vertex. An in degree of a vertex\n     * in a directed graph is the number of inward directed edges from that\n     * vertex. See <a href=\"http://mathworld.wolfram.com/Indegree.html\">\n     * http://mathworld.wolfram.com/Indegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */","methodSourceCode":"public int inDegreeOf(V vertex);","classJavadoc":"/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------\n * DirectedGraph.java\n * ------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface DirectedGraph<V, E>\n    extends Graph<V, E>\n{\n    /**\n     * Returns the \"in degree\" of the specified vertex. An in degree of a vertex\n     * in a directed graph is the number of inward directed edges from that\n     * vertex. See <a href=\"http://mathworld.wolfram.com/Indegree.html\">\n     * http://mathworld.wolfram.com/Indegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int inDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges incoming into the specified vertex.\n     *\n     * @param vertex the vertex for which the list of incoming edges to be\n     * returned.\n     *\n     * @return a set of all edges incoming into the specified vertex.\n     */\n    public Set<E> incomingEdgesOf(V vertex);\n\n    /**\n     * Returns the \"out degree\" of the specified vertex. An out degree of a\n     * vertex in a directed graph is the number of outward directed edges from\n     * that vertex. See <a href=\"http://mathworld.wolfram.com/Outdegree.html\">\n     * http://mathworld.wolfram.com/Outdegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int outDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges outgoing from the specified vertex.\n     *\n     * @param vertex the vertex for which the list of outgoing edges to be\n     * returned.\n     *\n     * @return a set of all edges outgoing from the specified vertex.\n     */\n    public Set<E> outgoingEdgesOf(V vertex);\n}\n\n// End DirectedGraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109500764,"label":true,"oracleId":26115,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"DirectedGraph","javadocTag":"@param vertex the vertex for which the list of incoming edges to be\nreturned.","methodJavadoc":"    /**\n     * Returns a set of all edges incoming into the specified vertex.\n     *\n     * @param vertex the vertex for which the list of incoming edges to be\n     * returned.\n     *\n     * @return a set of all edges incoming into the specified vertex.\n     */","methodSourceCode":"public Set<E> incomingEdgesOf(V vertex);","classJavadoc":"/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------\n * DirectedGraph.java\n * ------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface DirectedGraph<V, E>\n    extends Graph<V, E>\n{\n    /**\n     * Returns the \"in degree\" of the specified vertex. An in degree of a vertex\n     * in a directed graph is the number of inward directed edges from that\n     * vertex. See <a href=\"http://mathworld.wolfram.com/Indegree.html\">\n     * http://mathworld.wolfram.com/Indegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int inDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges incoming into the specified vertex.\n     *\n     * @param vertex the vertex for which the list of incoming edges to be\n     * returned.\n     *\n     * @return a set of all edges incoming into the specified vertex.\n     */\n    public Set<E> incomingEdgesOf(V vertex);\n\n    /**\n     * Returns the \"out degree\" of the specified vertex. An out degree of a\n     * vertex in a directed graph is the number of outward directed edges from\n     * that vertex. See <a href=\"http://mathworld.wolfram.com/Outdegree.html\">\n     * http://mathworld.wolfram.com/Outdegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int outDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges outgoing from the specified vertex.\n     *\n     * @param vertex the vertex for which the list of outgoing edges to be\n     * returned.\n     *\n     * @return a set of all edges outgoing from the specified vertex.\n     */\n    public Set<E> outgoingEdgesOf(V vertex);\n}\n\n// End DirectedGraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109500974,"label":true,"oracleId":26116,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"DirectedGraph","javadocTag":"@return a set of all edges incoming into the specified vertex.","methodJavadoc":"    /**\n     * Returns a set of all edges incoming into the specified vertex.\n     *\n     * @param vertex the vertex for which the list of incoming edges to be\n     * returned.\n     *\n     * @return a set of all edges incoming into the specified vertex.\n     */","methodSourceCode":"public Set<E> incomingEdgesOf(V vertex);","classJavadoc":"/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------\n * DirectedGraph.java\n * ------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface DirectedGraph<V, E>\n    extends Graph<V, E>\n{\n    /**\n     * Returns the \"in degree\" of the specified vertex. An in degree of a vertex\n     * in a directed graph is the number of inward directed edges from that\n     * vertex. See <a href=\"http://mathworld.wolfram.com/Indegree.html\">\n     * http://mathworld.wolfram.com/Indegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int inDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges incoming into the specified vertex.\n     *\n     * @param vertex the vertex for which the list of incoming edges to be\n     * returned.\n     *\n     * @return a set of all edges incoming into the specified vertex.\n     */\n    public Set<E> incomingEdgesOf(V vertex);\n\n    /**\n     * Returns the \"out degree\" of the specified vertex. An out degree of a\n     * vertex in a directed graph is the number of outward directed edges from\n     * that vertex. See <a href=\"http://mathworld.wolfram.com/Outdegree.html\">\n     * http://mathworld.wolfram.com/Outdegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int outDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges outgoing from the specified vertex.\n     *\n     * @param vertex the vertex for which the list of outgoing edges to be\n     * returned.\n     *\n     * @return a set of all edges outgoing from the specified vertex.\n     */\n    public Set<E> outgoingEdgesOf(V vertex);\n}\n\n// End DirectedGraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109501183,"label":true,"oracleId":26117,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"DirectedGraph","javadocTag":"@param vertex vertex whose degree is to be calculated.","methodJavadoc":"    /**\n     * Returns the \"out degree\" of the specified vertex. An out degree of a\n     * vertex in a directed graph is the number of outward directed edges from\n     * that vertex. See <a href=\"http://mathworld.wolfram.com/Outdegree.html\">\n     * http://mathworld.wolfram.com/Outdegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */","methodSourceCode":"public int outDegreeOf(V vertex);","classJavadoc":"/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------\n * DirectedGraph.java\n * ------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface DirectedGraph<V, E>\n    extends Graph<V, E>\n{\n    /**\n     * Returns the \"in degree\" of the specified vertex. An in degree of a vertex\n     * in a directed graph is the number of inward directed edges from that\n     * vertex. See <a href=\"http://mathworld.wolfram.com/Indegree.html\">\n     * http://mathworld.wolfram.com/Indegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int inDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges incoming into the specified vertex.\n     *\n     * @param vertex the vertex for which the list of incoming edges to be\n     * returned.\n     *\n     * @return a set of all edges incoming into the specified vertex.\n     */\n    public Set<E> incomingEdgesOf(V vertex);\n\n    /**\n     * Returns the \"out degree\" of the specified vertex. An out degree of a\n     * vertex in a directed graph is the number of outward directed edges from\n     * that vertex. See <a href=\"http://mathworld.wolfram.com/Outdegree.html\">\n     * http://mathworld.wolfram.com/Outdegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int outDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges outgoing from the specified vertex.\n     *\n     * @param vertex the vertex for which the list of outgoing edges to be\n     * returned.\n     *\n     * @return a set of all edges outgoing from the specified vertex.\n     */\n    public Set<E> outgoingEdgesOf(V vertex);\n}\n\n// End DirectedGraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109501393,"label":true,"oracleId":26118,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"DirectedGraph","javadocTag":"@return the degree of the specified vertex.","methodJavadoc":"    /**\n     * Returns the \"out degree\" of the specified vertex. An out degree of a\n     * vertex in a directed graph is the number of outward directed edges from\n     * that vertex. See <a href=\"http://mathworld.wolfram.com/Outdegree.html\">\n     * http://mathworld.wolfram.com/Outdegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */","methodSourceCode":"public int outDegreeOf(V vertex);","classJavadoc":"/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------\n * DirectedGraph.java\n * ------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface DirectedGraph<V, E>\n    extends Graph<V, E>\n{\n    /**\n     * Returns the \"in degree\" of the specified vertex. An in degree of a vertex\n     * in a directed graph is the number of inward directed edges from that\n     * vertex. See <a href=\"http://mathworld.wolfram.com/Indegree.html\">\n     * http://mathworld.wolfram.com/Indegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int inDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges incoming into the specified vertex.\n     *\n     * @param vertex the vertex for which the list of incoming edges to be\n     * returned.\n     *\n     * @return a set of all edges incoming into the specified vertex.\n     */\n    public Set<E> incomingEdgesOf(V vertex);\n\n    /**\n     * Returns the \"out degree\" of the specified vertex. An out degree of a\n     * vertex in a directed graph is the number of outward directed edges from\n     * that vertex. See <a href=\"http://mathworld.wolfram.com/Outdegree.html\">\n     * http://mathworld.wolfram.com/Outdegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int outDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges outgoing from the specified vertex.\n     *\n     * @param vertex the vertex for which the list of outgoing edges to be\n     * returned.\n     *\n     * @return a set of all edges outgoing from the specified vertex.\n     */\n    public Set<E> outgoingEdgesOf(V vertex);\n}\n\n// End DirectedGraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109501602,"label":true,"oracleId":26119,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"DirectedGraph","javadocTag":"@param vertex the vertex for which the list of outgoing edges to be\nreturned.","methodJavadoc":"    /**\n     * Returns a set of all edges outgoing from the specified vertex.\n     *\n     * @param vertex the vertex for which the list of outgoing edges to be\n     * returned.\n     *\n     * @return a set of all edges outgoing from the specified vertex.\n     */","methodSourceCode":"public Set<E> outgoingEdgesOf(V vertex);","classJavadoc":"/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------\n * DirectedGraph.java\n * ------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface DirectedGraph<V, E>\n    extends Graph<V, E>\n{\n    /**\n     * Returns the \"in degree\" of the specified vertex. An in degree of a vertex\n     * in a directed graph is the number of inward directed edges from that\n     * vertex. See <a href=\"http://mathworld.wolfram.com/Indegree.html\">\n     * http://mathworld.wolfram.com/Indegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int inDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges incoming into the specified vertex.\n     *\n     * @param vertex the vertex for which the list of incoming edges to be\n     * returned.\n     *\n     * @return a set of all edges incoming into the specified vertex.\n     */\n    public Set<E> incomingEdgesOf(V vertex);\n\n    /**\n     * Returns the \"out degree\" of the specified vertex. An out degree of a\n     * vertex in a directed graph is the number of outward directed edges from\n     * that vertex. See <a href=\"http://mathworld.wolfram.com/Outdegree.html\">\n     * http://mathworld.wolfram.com/Outdegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int outDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges outgoing from the specified vertex.\n     *\n     * @param vertex the vertex for which the list of outgoing edges to be\n     * returned.\n     *\n     * @return a set of all edges outgoing from the specified vertex.\n     */\n    public Set<E> outgoingEdgesOf(V vertex);\n}\n\n// End DirectedGraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109501812,"label":true,"oracleId":26120,"oracleType":"NORMAL_POST","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"DirectedGraph","javadocTag":"@return a set of all edges outgoing from the specified vertex.","methodJavadoc":"    /**\n     * Returns a set of all edges outgoing from the specified vertex.\n     *\n     * @param vertex the vertex for which the list of outgoing edges to be\n     * returned.\n     *\n     * @return a set of all edges outgoing from the specified vertex.\n     */","methodSourceCode":"public Set<E> outgoingEdgesOf(V vertex);","classJavadoc":"/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------\n * DirectedGraph.java\n * ------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http://mathworld.wolfram.com/DirectedGraph.html\">\n * http://mathworld.wolfram.com/DirectedGraph.html</a> for more on directed\n * graphs.</p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface DirectedGraph<V, E>\n    extends Graph<V, E>\n{\n    /**\n     * Returns the \"in degree\" of the specified vertex. An in degree of a vertex\n     * in a directed graph is the number of inward directed edges from that\n     * vertex. See <a href=\"http://mathworld.wolfram.com/Indegree.html\">\n     * http://mathworld.wolfram.com/Indegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int inDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges incoming into the specified vertex.\n     *\n     * @param vertex the vertex for which the list of incoming edges to be\n     * returned.\n     *\n     * @return a set of all edges incoming into the specified vertex.\n     */\n    public Set<E> incomingEdgesOf(V vertex);\n\n    /**\n     * Returns the \"out degree\" of the specified vertex. An out degree of a\n     * vertex in a directed graph is the number of outward directed edges from\n     * that vertex. See <a href=\"http://mathworld.wolfram.com/Outdegree.html\">\n     * http://mathworld.wolfram.com/Outdegree.html</a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     */\n    public int outDegreeOf(V vertex);\n\n    /**\n     * Returns a set of all edges outgoing from the specified vertex.\n     *\n     * @param vertex the vertex for which the list of outgoing edges to be\n     * returned.\n     *\n     * @return a set of all edges outgoing from the specified vertex.\n     */\n    public Set<E> outgoingEdgesOf(V vertex);\n}\n\n// End DirectedGraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":109502022,"label":true,"oracleId":26121,"oracleType":"PRE","projectName":"jgrapht-core-0.9.2","packageName":"org.jgrapht","className":"WeightedGraph","javadocTag":"@param e edge on which to set weight","methodJavadoc":"    /**\n     * Assigns a weight to an edge.\n     *\n     * @param e edge on which to set weight\n     * @param weight new weight for edge\n     */","methodSourceCode":"public void setEdgeWeight(E e, double weight);","classJavadoc":"/**\n * An interface for a graph whose edges have non-uniform weights.\n *\n * @author Barak Naveh\n * @since Jul 23, 2003\n */","classSourceCode":"/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------\n * WeightedGraph.java\n * ------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 13-Aug-2003 : Included weight methods in Edge interface (BN);\n * 11-Mar-2004 : Made generic (CH);\n *\n */\npackage org.jgrapht;\n\n/**\n * An interface for a graph whose edges have non-uniform weights.\n *\n * @author Barak Naveh\n * @since Jul 23, 2003\n */\npublic interface WeightedGraph<V, E>\n    extends Graph<V, E>\n{\n    /**\n     * The default weight for an edge.\n     */\n    public static double DEFAULT_EDGE_WEIGHT = 1.0;\n\n    /**\n     * Assigns a weight to an edge.\n     *\n     * @param e edge on which to set weight\n     * @param weight new weight for edge\n     */\n    public void setEdgeWeight(E e, double weight);\n}\n\n// End WeightedGraph.java\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]}]