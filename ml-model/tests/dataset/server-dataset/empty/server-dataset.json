{"datapoints":[{"id":0,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"bag","tokenClass":"MethodArgument","tokenInfo":["org.apache.commons.collections4.Bag","Bag<E>"]},{"id":1,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"BidiMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","BidiMap"]},{"id":2,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Equator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","Equator"]},{"id":3,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"MultiSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","MultiSet"]},{"id":4,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"IteratorUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","IteratorUtils"]},{"id":5,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ComparatorUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","ComparatorUtils"]},{"id":6,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"FunctorException","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","FunctorException"]},{"id":7,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractDualBidiMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bidimap","AbstractDualBidiMap"]},{"id":8,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableBidiMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bidimap","UnmodifiableBidiMap"]},{"id":9,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractOrderedBidiMapDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bidimap","AbstractOrderedBidiMapDecorator"]},{"id":10,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableOrderedBidiMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bidimap","UnmodifiableOrderedBidiMap"]},{"id":11,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractBidiMapDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bidimap","AbstractBidiMapDecorator"]},{"id":12,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"DualLinkedHashBidiMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bidimap","DualLinkedHashBidiMap"]},{"id":13,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableSortedBidiMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bidimap","UnmodifiableSortedBidiMap"]},{"id":14,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractSortedBidiMapDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bidimap","AbstractSortedBidiMapDecorator"]},{"id":15,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"DualHashBidiMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bidimap","DualHashBidiMap"]},{"id":16,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"DualTreeBidiMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bidimap","DualTreeBidiMap"]},{"id":17,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TreeBidiMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bidimap","TreeBidiMap"]},{"id":18,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"MultiMapUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","MultiMapUtils"]},{"id":19,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"BoundedCollection","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","BoundedCollection"]},{"id":20,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableBoundedCollection","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.collection","UnmodifiableBoundedCollection"]},{"id":21,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CompositeCollection","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.collection","CompositeCollection"]},{"id":22,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformedCollection","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.collection","TransformedCollection"]},{"id":23,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PredicatedCollection","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.collection","PredicatedCollection"]},{"id":24,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"IndexedCollection","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.collection","IndexedCollection"]},{"id":25,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SynchronizedCollection","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.collection","SynchronizedCollection"]},{"id":26,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableCollection","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.collection","UnmodifiableCollection"]},{"id":27,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractCollectionDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.collection","AbstractCollectionDecorator"]},{"id":28,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"OrderedBidiMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","OrderedBidiMap"]},{"id":29,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"FactoryUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","FactoryUtils"]},{"id":30,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"IterableGet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","IterableGet"]},{"id":31,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ListUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","ListUtils"]},{"id":32,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Closure","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","Closure"]},{"id":33,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"IterableSortedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","IterableSortedMap"]},{"id":34,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"MapUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","MapUtils"]},{"id":35,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Transformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","Transformer"]},{"id":36,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"DefaultEquator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","DefaultEquator"]},{"id":37,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"StringValueTransformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","StringValueTransformer"]},{"id":38,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PredicateDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","PredicateDecorator"]},{"id":39,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"IfTransformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","IfTransformer"]},{"id":40,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"IdentityPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","IdentityPredicate"]},{"id":41,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ExceptionClosure","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","ExceptionClosure"]},{"id":42,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"NOPClosure","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","NOPClosure"]},{"id":43,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ClosureTransformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","ClosureTransformer"]},{"id":44,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"FunctorUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","FunctorUtils"]},{"id":45,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformerPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","TransformerPredicate"]},{"id":46,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"NullPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","NullPredicate"]},{"id":47,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ConstantTransformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","ConstantTransformer"]},{"id":48,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PredicateTransformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","PredicateTransformer"]},{"id":49,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"WhileClosure","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","WhileClosure"]},{"id":50,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ForClosure","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","ForClosure"]},{"id":51,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"NullIsTruePredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","NullIsTruePredicate"]},{"id":52,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformedPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","TransformedPredicate"]},{"id":53,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"NonePredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","NonePredicate"]},{"id":54,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ExceptionTransformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","ExceptionTransformer"]},{"id":55,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SwitchTransformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","SwitchTransformer"]},{"id":56,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformerClosure","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","TransformerClosure"]},{"id":57,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"OrPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","OrPredicate"]},{"id":58,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"NOPTransformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","NOPTransformer"]},{"id":59,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"MapTransformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","MapTransformer"]},{"id":60,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ExceptionFactory","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","ExceptionFactory"]},{"id":61,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ChainedClosure","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","ChainedClosure"]},{"id":62,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AndPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","AndPredicate"]},{"id":63,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PrototypeFactory","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","PrototypeFactory"]},{"id":64,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ExceptionPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","ExceptionPredicate"]},{"id":65,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractQuantifierPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","AbstractQuantifierPredicate"]},{"id":66,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"InstanceofPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","InstanceofPredicate"]},{"id":67,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"InvokerTransformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","InvokerTransformer"]},{"id":68,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"FalsePredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","FalsePredicate"]},{"id":69,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CloneTransformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","CloneTransformer"]},{"id":70,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"NotPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","NotPredicate"]},{"id":71,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ConstantFactory","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","ConstantFactory"]},{"id":72,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ChainedTransformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","ChainedTransformer"]},{"id":73,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ComparatorPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","ComparatorPredicate"]},{"id":74,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CatchAndRethrowClosure","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","CatchAndRethrowClosure"]},{"id":75,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AllPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","AllPredicate"]},{"id":76,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"NullIsFalsePredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","NullIsFalsePredicate"]},{"id":77,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"NullIsExceptionPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","NullIsExceptionPredicate"]},{"id":78,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AnyPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","AnyPredicate"]},{"id":79,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TruePredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","TruePredicate"]},{"id":80,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"FactoryTransformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","FactoryTransformer"]},{"id":81,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"NotNullPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","NotNullPredicate"]},{"id":82,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SwitchClosure","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","SwitchClosure"]},{"id":83,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UniquePredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","UniquePredicate"]},{"id":84,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"InstantiateTransformer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","InstantiateTransformer"]},{"id":85,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"OnePredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","OnePredicate"]},{"id":86,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"EqualPredicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","EqualPredicate"]},{"id":87,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"InstantiateFactory","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","InstantiateFactory"]},{"id":88,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"IfClosure","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.functors","IfClosure"]},{"id":89,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ResettableListIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","ResettableListIterator"]},{"id":90,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"OrderedIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","OrderedIterator"]},{"id":91,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ComparatorChain","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.comparators","ComparatorChain"]},{"id":92,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"BooleanComparator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.comparators","BooleanComparator"]},{"id":93,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ReverseComparator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.comparators","ReverseComparator"]},{"id":94,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ComparableComparator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.comparators","ComparableComparator"]},{"id":95,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformingComparator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.comparators","TransformingComparator"]},{"id":96,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"FixedOrderComparator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.comparators","FixedOrderComparator"]},{"id":97,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"NullComparator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.comparators","NullComparator"]},{"id":98,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CollectionUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","CollectionUtils"]},{"id":99,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ListValuedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","ListValuedMap"]},{"id":100,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractIterableGetMapDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.splitmap","AbstractIterableGetMapDecorator"]},{"id":101,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformedSplitMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.splitmap","TransformedSplitMap"]},{"id":102,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Factory","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","Factory"]},{"id":103,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"IterableUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","IterableUtils"]},{"id":104,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Bag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","Bag"]},{"id":105,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Predicate","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","Predicate"]},{"id":106,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SortedBag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","SortedBag"]},{"id":107,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TrieUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","TrieUtils"]},{"id":108,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ClosureUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","ClosureUtils"]},{"id":109,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PatriciaTrie","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.trie","PatriciaTrie"]},{"id":110,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableTrie","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.trie","UnmodifiableTrie"]},{"id":111,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"KeyAnalyzer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.trie","KeyAnalyzer"]},{"id":112,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractPatriciaTrie","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.trie","AbstractPatriciaTrie"]},{"id":113,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractBitwiseTrie","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.trie","AbstractBitwiseTrie"]},{"id":114,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"StringKeyAnalyzer","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.trie.analyzer","StringKeyAnalyzer"]},{"id":115,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformedSortedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","TransformedSortedMap"]},{"id":116,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractLinkedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","AbstractLinkedMap"]},{"id":117,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Flat3Map","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","Flat3Map"]},{"id":118,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PredicatedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","PredicatedMap"]},{"id":119,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"FixedSizeSortedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","FixedSizeSortedMap"]},{"id":120,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableSortedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","UnmodifiableSortedMap"]},{"id":121,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PredicatedSortedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","PredicatedSortedMap"]},{"id":122,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"DefaultedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","DefaultedMap"]},{"id":123,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ReferenceIdentityMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","ReferenceIdentityMap"]},{"id":124,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractSortedMapDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","AbstractSortedMapDecorator"]},{"id":125,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractInputCheckedMapDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","AbstractInputCheckedMapDecorator"]},{"id":126,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"FixedSizeMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","FixedSizeMap"]},{"id":127,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"LazySortedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","LazySortedMap"]},{"id":128,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableOrderedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","UnmodifiableOrderedMap"]},{"id":129,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CaseInsensitiveMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","CaseInsensitiveMap"]},{"id":130,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractHashedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","AbstractHashedMap"]},{"id":131,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractOrderedMapDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","AbstractOrderedMapDecorator"]},{"id":132,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","UnmodifiableMap"]},{"id":133,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"EntrySetToMapIteratorAdapter","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","EntrySetToMapIteratorAdapter"]},{"id":134,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractIterableMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","AbstractIterableMap"]},{"id":135,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ListOrderedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","ListOrderedMap"]},{"id":136,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"LinkedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","LinkedMap"]},{"id":137,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SingletonMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","SingletonMap"]},{"id":138,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableEntrySet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","UnmodifiableEntrySet"]},{"id":139,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"StaticBucketMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","StaticBucketMap"]},{"id":140,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractMapDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","AbstractMapDecorator"]},{"id":141,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractReferenceMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","AbstractReferenceMap"]},{"id":142,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"MultiKeyMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","MultiKeyMap"]},{"id":143,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"HashedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","HashedMap"]},{"id":144,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"LazyMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","LazyMap"]},{"id":145,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PassiveExpiringMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","PassiveExpiringMap"]},{"id":146,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"MultiValueMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","MultiValueMap"]},{"id":147,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"LRUMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","LRUMap"]},{"id":148,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ReferenceMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","ReferenceMap"]},{"id":149,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","TransformedMap"]},{"id":150,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CompositeMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.map","CompositeMap"]},{"id":151,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableMapEntry","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.keyvalue","UnmodifiableMapEntry"]},{"id":152,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"MultiKey","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.keyvalue","MultiKey"]},{"id":153,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"DefaultMapEntry","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.keyvalue","DefaultMapEntry"]},{"id":154,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"DefaultKeyValue","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.keyvalue","DefaultKeyValue"]},{"id":155,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractMapEntryDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.keyvalue","AbstractMapEntryDecorator"]},{"id":156,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractKeyValue","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.keyvalue","AbstractKeyValue"]},{"id":157,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TiedMapEntry","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.keyvalue","TiedMapEntry"]},{"id":158,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractMapEntry","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.keyvalue","AbstractMapEntry"]},{"id":159,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"MultiSetUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","MultiSetUtils"]},{"id":160,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"MapIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","MapIterator"]},{"id":161,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractMultiValuedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multimap","AbstractMultiValuedMap"]},{"id":162,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableMultiValuedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multimap","UnmodifiableMultiValuedMap"]},{"id":163,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"HashSetValuedHashMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multimap","HashSetValuedHashMap"]},{"id":164,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformedMultiValuedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multimap","TransformedMultiValuedMap"]},{"id":165,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractSetValuedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multimap","AbstractSetValuedMap"]},{"id":166,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractListValuedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multimap","AbstractListValuedMap"]},{"id":167,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ArrayListValuedHashMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multimap","ArrayListValuedHashMap"]},{"id":168,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractMultiValuedMapDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multimap","AbstractMultiValuedMapDecorator"]},{"id":169,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"LazyList","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.list","LazyList"]},{"id":170,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractSerializableListDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.list","AbstractSerializableListDecorator"]},{"id":171,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TreeList","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.list","TreeList"]},{"id":172,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SetUniqueList","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.list","SetUniqueList"]},{"id":173,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractListDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.list","AbstractListDecorator"]},{"id":174,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"NodeCachingLinkedList","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.list","NodeCachingLinkedList"]},{"id":175,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableList","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.list","UnmodifiableList"]},{"id":176,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"FixedSizeList","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.list","FixedSizeList"]},{"id":177,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformedList","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.list","TransformedList"]},{"id":178,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"GrowthList","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.list","GrowthList"]},{"id":179,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractLinkedList","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.list","AbstractLinkedList"]},{"id":180,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CursorableLinkedList","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.list","CursorableLinkedList"]},{"id":181,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PredicatedList","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.list","PredicatedList"]},{"id":182,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"OrderedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","OrderedMap"]},{"id":183,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractQueueDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.queue","AbstractQueueDecorator"]},{"id":184,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformedQueue","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.queue","TransformedQueue"]},{"id":185,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableQueue","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.queue","UnmodifiableQueue"]},{"id":186,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CircularFifoQueue","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.queue","CircularFifoQueue"]},{"id":187,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PredicatedQueue","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.queue","PredicatedQueue"]},{"id":188,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"FluentIterable","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","FluentIterable"]},{"id":189,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformerUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","TransformerUtils"]},{"id":190,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PredicateUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","PredicateUtils"]},{"id":191,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ResettableIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","ResettableIterator"]},{"id":192,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"MultiValuedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","MultiValuedMap"]},{"id":193,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SetUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","SetUtils"]},{"id":194,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SortedBidiMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","SortedBidiMap"]},{"id":195,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ArrayStack","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","ArrayStack"]},{"id":196,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Put","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","Put"]},{"id":197,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"OrderedMapIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","OrderedMapIterator"]},{"id":198,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformedSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","TransformedSet"]},{"id":199,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CompositeSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","CompositeSet"]},{"id":200,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformedNavigableSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","TransformedNavigableSet"]},{"id":201,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PredicatedNavigableSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","PredicatedNavigableSet"]},{"id":202,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractSetDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","AbstractSetDecorator"]},{"id":203,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ListOrderedSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","ListOrderedSet"]},{"id":204,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","UnmodifiableSet"]},{"id":205,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractSerializableSetDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","AbstractSerializableSetDecorator"]},{"id":206,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"MapBackedSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","MapBackedSet"]},{"id":207,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableSortedSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","UnmodifiableSortedSet"]},{"id":208,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PredicatedSortedSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","PredicatedSortedSet"]},{"id":209,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractSortedSetDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","AbstractSortedSetDecorator"]},{"id":210,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PredicatedSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","PredicatedSet"]},{"id":211,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractNavigableSetDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","AbstractNavigableSetDecorator"]},{"id":212,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableNavigableSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","UnmodifiableNavigableSet"]},{"id":213,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformedSortedSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.set","TransformedSortedSet"]},{"id":214,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"IterableMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","IterableMap"]},{"id":215,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"EnumerationUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","EnumerationUtils"]},{"id":216,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"DeleteCommand","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.sequence","DeleteCommand"]},{"id":217,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ReplacementsHandler","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.sequence","ReplacementsHandler"]},{"id":218,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"InsertCommand","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.sequence","InsertCommand"]},{"id":219,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SequencesComparator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.sequence","SequencesComparator"]},{"id":220,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ReplacementsFinder","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.sequence","ReplacementsFinder"]},{"id":221,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"KeepCommand","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.sequence","KeepCommand"]},{"id":222,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"EditCommand","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.sequence","EditCommand"]},{"id":223,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CommandVisitor","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.sequence","CommandVisitor"]},{"id":224,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"EditScript","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.sequence","EditScript"]},{"id":225,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"QueueUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","QueueUtils"]},{"id":226,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SetValuedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","SetValuedMap"]},{"id":227,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SynchronizedBag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","SynchronizedBag"]},{"id":228,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractMapBag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","AbstractMapBag"]},{"id":229,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CollectionBag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","CollectionBag"]},{"id":230,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableBag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","UnmodifiableBag"]},{"id":231,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PredicatedSortedBag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","PredicatedSortedBag"]},{"id":232,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableSortedBag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","UnmodifiableSortedBag"]},{"id":233,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"HashBag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","HashBag"]},{"id":234,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractBagDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","AbstractBagDecorator"]},{"id":235,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformedSortedBag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","TransformedSortedBag"]},{"id":236,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TreeBag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","TreeBag"]},{"id":237,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PredicatedBag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","PredicatedBag"]},{"id":238,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SynchronizedSortedBag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","SynchronizedSortedBag"]},{"id":239,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CollectionSortedBag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","CollectionSortedBag"]},{"id":240,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformedBag","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","TransformedBag"]},{"id":241,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractSortedBagDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.bag","AbstractSortedBagDecorator"]},{"id":242,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"HashMultiSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multiset","HashMultiSet"]},{"id":243,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractMultiSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multiset","AbstractMultiSet"]},{"id":244,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PredicatedMultiSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multiset","PredicatedMultiSet"]},{"id":245,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractMultiSetDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multiset","AbstractMultiSetDecorator"]},{"id":246,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractMapMultiSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multiset","AbstractMapMultiSet"]},{"id":247,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableMultiSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multiset","UnmodifiableMultiSet"]},{"id":248,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SynchronizedMultiSet","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.multiset","SynchronizedMultiSet"]},{"id":249,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"BagUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","BagUtils"]},{"id":250,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Unmodifiable","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","Unmodifiable"]},{"id":251,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Get","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","Get"]},{"id":252,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"Trie","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","Trie"]},{"id":253,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"MultiMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","MultiMap"]},{"id":254,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"KeyValue","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","KeyValue"]},{"id":255,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"IteratorChain","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","IteratorChain"]},{"id":256,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"EmptyListIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","EmptyListIterator"]},{"id":257,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableOrderedMapIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","UnmodifiableOrderedMapIterator"]},{"id":258,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractListIteratorDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","AbstractListIteratorDecorator"]},{"id":259,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ZippingIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","ZippingIterator"]},{"id":260,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","UnmodifiableIterator"]},{"id":261,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"CollatingIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","CollatingIterator"]},{"id":262,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UniqueFilterIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","UniqueFilterIterator"]},{"id":263,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ReverseListIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","ReverseListIterator"]},{"id":264,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"BoundedIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","BoundedIterator"]},{"id":265,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractIteratorDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","AbstractIteratorDecorator"]},{"id":266,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"TransformIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","TransformIterator"]},{"id":267,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractEmptyIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","AbstractEmptyIterator"]},{"id":268,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"NodeListIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","NodeListIterator"]},{"id":269,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ArrayListIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","ArrayListIterator"]},{"id":270,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"LazyIteratorChain","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","LazyIteratorChain"]},{"id":271,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"LoopingListIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","LoopingListIterator"]},{"id":272,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PeekingIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","PeekingIterator"]},{"id":273,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ObjectGraphIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","ObjectGraphIterator"]},{"id":274,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ArrayIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","ArrayIterator"]},{"id":275,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PermutationIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","PermutationIterator"]},{"id":276,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SingletonListIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","SingletonListIterator"]},{"id":277,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"EmptyMapIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","EmptyMapIterator"]},{"id":278,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ObjectArrayIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","ObjectArrayIterator"]},{"id":279,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"EnumerationIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","EnumerationIterator"]},{"id":280,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"IteratorIterable","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","IteratorIterable"]},{"id":281,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractEmptyMapIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","AbstractEmptyMapIterator"]},{"id":282,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"LoopingIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","LoopingIterator"]},{"id":283,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"IteratorEnumeration","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","IteratorEnumeration"]},{"id":284,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SingletonIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","SingletonIterator"]},{"id":285,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ListIteratorWrapper","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","ListIteratorWrapper"]},{"id":286,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SkippingIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","SkippingIterator"]},{"id":287,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"EmptyOrderedIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","EmptyOrderedIterator"]},{"id":288,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractMapIteratorDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","AbstractMapIteratorDecorator"]},{"id":289,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"ObjectArrayListIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","ObjectArrayListIterator"]},{"id":290,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableListIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","UnmodifiableListIterator"]},{"id":291,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"EmptyOrderedMapIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","EmptyOrderedMapIterator"]},{"id":292,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"UnmodifiableMapIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","UnmodifiableMapIterator"]},{"id":293,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"EmptyIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","EmptyIterator"]},{"id":294,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"EntrySetMapIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","EntrySetMapIterator"]},{"id":295,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"PushbackIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","PushbackIterator"]},{"id":296,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"FilterIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","FilterIterator"]},{"id":297,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractUntypedIteratorDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","AbstractUntypedIteratorDecorator"]},{"id":298,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"AbstractOrderedMapIteratorDecorator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","AbstractOrderedMapIteratorDecorator"]},{"id":299,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"FilterListIterator","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4.iterators","FilterListIterator"]},{"id":300,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"SplitMapUtils","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","SplitMapUtils"]},{"id":301,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"BoundedMap","tokenClass":"Class","tokenInfo":["org.apache.commons.collections4","BoundedMap"]},{"id":302,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":";","tokenClass":"Semicolon","tokenInfo":[]},{"id":303,"label":false,"oracleId":0,"oracleType":"PRE","projectName":"","packageName":"org.apache.commons.collections4","className":"BagUtils","javadocTag":"@param <E> the element type","methodJavadoc":"    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */","methodSourceCode":"public static <E> Bag<E> synchronizedBag(final Bag<E> bag){\n    return SynchronizedBag.synchronizedBag(bag);\n}","classJavadoc":"/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */","classSourceCode":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport org.apache.commons.collections4.bag.CollectionBag;\nimport org.apache.commons.collections4.bag.HashBag;\nimport org.apache.commons.collections4.bag.PredicatedBag;\nimport org.apache.commons.collections4.bag.PredicatedSortedBag;\nimport org.apache.commons.collections4.bag.SynchronizedBag;\nimport org.apache.commons.collections4.bag.SynchronizedSortedBag;\nimport org.apache.commons.collections4.bag.TransformedBag;\nimport org.apache.commons.collections4.bag.TransformedSortedBag;\nimport org.apache.commons.collections4.bag.TreeBag;\nimport org.apache.commons.collections4.bag.UnmodifiableBag;\nimport org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n\n/**\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n * @version $Id: BagUtils.java 1686855 2015-06-22 13:00:27Z tn $\n */\npublic class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n\n    /**\n     * Instantiation of BagUtils is not intended or required.\n     */\n    private BagUtils() {}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behaviour, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Get an empty <code>Bag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return (Bag<E>) EMPTY_BAG;\n    }\n\n    /**\n     * Get an empty <code>SortedBag</code>.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n}\n","oracleSoFar":"","tokenClassesSoFar":[],"token":"(","tokenClass":"OpeningParenthesis","tokenInfo":[]}], "next_tokenClass": "Semicolon"}