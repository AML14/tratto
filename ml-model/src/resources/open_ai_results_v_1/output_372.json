"output=[\r\n  {\r\n    'tag': '@param checker Convergence checker.',\r\n    'alternatives': [\r\n      '@param checker Convergence detector.',\r\n      '@param checker Convergence validator.',\r\n      '@param checker Convergence tracker.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param initialStep initial step used to bracket the optimum in line search,\\nif a non-positive value is used, the initial step is reset to its\\ndefault value of 1.0',\r\n    'alternatives': [\r\n      '@param initialStep initial increment employed to bracket the maximum in line search,\\nif a non-positive value is employed, the initial increment is reset to its\\ndefault value of 1.0',\r\n      '@param initialStep starting step employed to find the optimal value in line search,\\nif a non-positive value is employed, the starting step is set to its\\ndefault value of 1.0',\r\n      '@param initialStep the initial step to be used to bound the optimum in line search,\\nif a non-positive value is used, the initial step is set to the\\ndefault value of 1.0'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param f function whose root must be bracketed.',\r\n    'alternatives': [\r\n      '@param f function where the root needs to be bounded.',\r\n      '@param f function for which the root should be bracketed.',\r\n      '@param f function that needs to have its root bounded.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param a lower bound of the interval.',\r\n    'alternatives': [\r\n      '@param a lower limit of the range.',\r\n      '@param a interval lower bound.',\r\n      '@param a lower endpoint of the interval.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param h initial step to try.',\r\n    'alternatives': [\r\n      '@param h starting increment to attempt.',\r\n      '@param h initial increment to test.',\r\n      '@param h initial step to experiment with.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return b such that f(a) and f(b) have opposite signs.',\r\n    'alternatives': [\r\n      '@return b for which f(a) and f(b) change sign.',\r\n      '@return b such that f(a) and f(b) exhibit different signs.',\r\n      '@return b such that f(a) and f(b) differ in signs.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@throws MathIllegalStateException if no bracket can be found.',\r\n    'alternatives': [\r\n      '@throws MathIllegalStateException when no bracket can be located.',\r\n      '@throws MathIllegalStateException if a bracket cannot be found.',\r\n      '@throws MathIllegalStateException if it is impossible to find a bracket.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param updateFormula formula to use for updating the &beta; parameter,\\nmust be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.',\r\n    'alternatives': [\r\n      '@param updateFormula equation to employ for updating the &beta; parameter,\\nmust be either {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.',\r\n      '@param updateFormula method to adopt for the &beta; parameter update,\\nmust be either {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.',\r\n      '@param updateFormula formula to be used for adjusting the value of &beta; parameter,\\nmust be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param updateFormula formula to use for updating the &beta; parameter,\\nmust be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.',\r\n    'alternatives': [\r\n      '@param updateFormula equation to employ for updating the &beta; parameter,\\nmust be either {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.',\r\n      '@param updateFormula method to adopt for the &beta; parameter update,\\nmust be either {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.',\r\n      '@param updateFormula formula to be used for adjusting the value of &beta; parameter,\\nmust be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param checker Convergence checker.',\r\n    'alternatives': [\r\n      '@param checker Convergence detector.',\r\n      '@param checker Convergence validator.',\r\n      '@param checker Convergence tracker.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param updateFormula formula to use for updating the &beta; parameter,\\nmust be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.',\r\n    'alternatives': [\r\n      '@param updateFormula equation to employ for updating the &beta; parameter,\\nmust be either {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.',\r\n      '@param updateFormula method to adopt for the &beta; parameter update,\\nmust be either {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.',\r\n      '@param updateFormula formula to be used for adjusting the value of &beta; parameter,\\nmust be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param checker Convergence checker.',\r\n    'alternatives': [\r\n      '@param checker Convergence detector.',\r\n      '@param checker Convergence validator.',\r\n      '@param checker Convergence tracker.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param lineSearchSolver Solver to use during line search.',\r\n    'alternatives': [\r\n      '@param lineSearchSolver Solver used for the line search.',\r\n      '@param lineSearchSolver Solver employed for the line search.',\r\n      '@param lineSearchSolver Solver to be used in the line search.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param updateFormula formula to use for updating the &beta; parameter,\\nmust be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.',\r\n    'alternatives': [\r\n      '@param updateFormula equation to employ for updating the &beta; parameter,\\nmust be either {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.',\r\n      '@param updateFormula method to adopt for the &beta; parameter update,\\nmust be either {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.',\r\n      '@param updateFormula formula to be used for adjusting the value of &beta; parameter,\\nmust be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\\nConjugateGradientFormula#POLAK_RIBIERE}.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param checker Convergence checker.',\r\n    'alternatives': [\r\n      '@param checker Convergence detector.',\r\n      '@param checker Convergence validator.',\r\n      '@param checker Convergence tracker.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param lineSearchSolver Solver to use during line search.',\r\n    'alternatives': [\r\n      '@param lineSearchSolver Solver used for the line search.',\r\n      '@param lineSearchSolver Solver employed for the line search.',\r\n      '@param lineSearchSolver Solver to be used in the line search.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param preconditioner Preconditioner.',\r\n    'alternatives': [\r\n      '@param preconditioner Function transforming using approximated inverses.',\r\n      '@param preconditioner Function modifying using approximated inverses.',\r\n      '@param preconditioner Function altering using approximated inverses.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return array containing the optima',\r\n    'alternatives': [\r\n      '@return array including the optima',\r\n      '@return array with the optimal values',\r\n      '@return array that contains the optimal values'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@throws MathIllegalStateException if {@link\\n#optimize(int,MultivariateVectorFunction,double[],double[],double[]) optimize} has not been\\ncalled.',\r\n    'alternatives': [\r\n      '@throws MathIllegalStateException when {@link\\n#optimize(int,MultivariateVectorFunction,double[],double[],double[]) optimize} is not invoked.',\r\n      '@throws MathIllegalStateException if {@link\\n#optimize(int,MultivariateVectorFunction,double[],double[],double[]) optimize} is never called.',\r\n      '@throws MathIllegalStateException if the {@link\\n#optimize(int,MultivariateVectorFunction,double[],double[],double[]) optimize} method is not called.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param target Target value for the objective functions at optimum.',\r\n    'alternatives': [\r\n      '@param target Desired value for the objective functions at optimum.',\r\n      '@param target Goal value for the objective functions at optimum.',\r\n      '@param target Objective functions desired value at optimum.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param weights Weights for the least-squares cost computation.',\r\n    'alternatives': [\r\n      '@param weights Weights used for the computation of the least-squares cost.',\r\n      '@param weights Weights employed to calculate the least-squares cost.',\r\n      '@param weights Weights to be applied in the least-squares cost computation.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param optimizer Single-start optimizer to wrap.',\r\n    'alternatives': [\r\n      '@param optimizer Wrap to a single-start optimizer.',\r\n      '@param optimizer Encapsulate a single-start optimizer.',\r\n      '@param optimizer Convert to a single-start optimizer.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param generator Random vector generator to use for restarts.',\r\n    'alternatives': [\r\n      '@param generator Random vector generator for the restarts.',\r\n      '@param generator Random vector generator employed for restarts.',\r\n      '@param generator Random vector generator to be used for restarts.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return {@code true} if the variables are restricted to non-negative values.',\r\n    'alternatives': [\r\n      '@return {@code true} if the variables are constrained with non-negative values.',\r\n      '@return {@code true} if the variables are bounded to non-negative values.',\r\n      '@return {@code true} if the variables are limited to non-negative values.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return the optimization type.',\r\n    'alternatives': [\r\n      '@return the type of optimization.',\r\n      '@return the optimization category.',\r\n      '@return the kind of optimization.'\r\n    ]\r\n  }\r\n]"