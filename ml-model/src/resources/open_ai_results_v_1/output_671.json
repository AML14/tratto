"output=[\n  {\n    'tag': '@return the hash code, as per the MapEntry specification',\n    'alternatives': [\n      '@return the hash code, according to the specification of MapEntry',\n      '@return the hash code, following the specification of MapEntry',\n      '@return the hash code as stated in the MapEntry specification',\n    ]\n  },\n  {\n    'tag': '@param key1 the first key to compare passed in from outside',\n    'alternatives': [\n      '@param key1 the initial key for the comparison brought from an external source',\n      '@param key1 the first key passed from an external source for comparison',\n      '@param key1 the first key received from outside to be compared',\n    ]\n  },\n  {\n    'tag': '@param key2 the second key extracted from the entry via <code>entry.key</code>',\n    'alternatives': [\n      '@param key2 the second key obtained from the entry through <code>entry.key</code>',\n      '@param key2 the second key derived from the entry using <code>entry.key</code>',\n      '@param key2 the second key extracted from the entry using <code>entry.key</code>',    \n    ]\n  },\n  {\n    'tag': '@return true if equal by identity',\n    'alternatives': [\n      '@return true if they are equal based on identity',\n      '@return true if they are identical',\n      '@return true if equal by identity check',\n    ]\n  },\n  {\n    'tag': '@param value1 the first value to compare passed in from outside',\n    'alternatives': [\n      '@param value1 the initial value for the comparison brought from an external source',\n      '@param value1 the first value passed from an external source for comparison',\n      '@param value1 the first value received from outside to be compared',\n    ]\n  },\n  {\n    'tag': '@param value2 the second value extracted from the entry via <code>getValue()</code>',\n    'alternatives': [\n      '@param value2 the second value obtained from the entry through <code>getValue()</code>',\n      '@param value2 the second value derived from the entry using <code>getValue()</code>',\n      '@param value2 the second value extracted from the entry using <code>getValue()</code>',    \n    ]\n  },\n  {\n    'tag': '@param keyType the type of reference to use for keys;\\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}',\n    'alternatives': [\n      '@param keyType the reference type to utilize for keys;\\n  should be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}',\n      '@param keyType the reference type used for keys;\\n  required to be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}',\n      '@param keyType the reference type for keys;\\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}',    \n    ]\n  },\n  {\n    'tag': '@param valueType the type of reference to use for values;\\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}',\n    'alternatives': [\n      '@param valueType the reference type to utilize for values;\\n  should be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}',\n      '@param valueType the reference type used for values;\\n  required to be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}',\n      '@param valueType the reference type for values;\\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}',    \n    ]\n  },\n  {\n    'tag': '@param purgeValues should the value be automatically purged when the\\n  key is garbage collected',\n    'alternatives': [\n      '@param purgeValues indicate whether the value should be automatically removed when the\\n  key is garbage collected',\n      '@param purgeValues specifies if the value should be purged automatically when the\\n  key is garbage collected',\n      '@param purgeValues determines if the value should be purged when the\\n  key is garbage collected',    \n    ]\n  },\n  {\n    'tag': '@return the decorated map',\n    'alternatives': [\n      '@return the map that has been decorated',\n      '@return the map with additional decorations',\n      '@return the map after decoration',    \n    ]\n  },\n  {\n    'tag': '@param value the value to check',\n    'alternatives': [\n      '@param value the value to verify',\n      '@param value the value to validate',\n      '@param value the value to examine',    \n    ]\n  },\n  {\n    'tag': '@throws UnsupportedOperationException if the map may not be changed by setValue',\n    'alternatives': [\n      '@throws UnsupportedOperationException if the map cannot be modified with setValue',\n      '@throws UnsupportedOperationException if setValue is not allowed in the map',\n      '@throws UnsupportedOperationException if setValue operation is unsupported by the map',    \n    ]\n  },\n  {\n    'tag': '@throws IllegalArgumentException if the specified value is invalid',\n    'alternatives': [\n      '@throws IllegalArgumentException if the provided value is not valid',\n      '@throws IllegalArgumentException if the passed value is invalid',\n      '@throws IllegalArgumentException if the value provided is not acceptable',    \n    ]\n  },\n]"