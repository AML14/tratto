"output=[\n  {\n    'tag': '@throws NotARotationMatrixException if the matrix is not a 3X3\\nmatrix, or if it cannot be transformed into an orthogonal matrix\\nwith the given threshold, or if the determinant of the resulting\\northogonal matrix is negative',\n    'alternatives': [\n      '@throws NotARotationMatrixException if the matrix does not have a size of 3X3, or if it cannot be converted to an orthogonal matrix with the provided threshold, or if the resulting orthogonal matrix has a negative determinant.',\n      '@throws NotARotationMatrixException if the matrix is not a 3X3 matrix or cannot be changed into an orthogonal matrix with the given threshold, or if the determinant of the resulting matrix is negative.',\n      '@throws NotARotationMatrixException if the matrix is not a 3X3 matrix, or if it cannot be transformed into an orthogonal matrix with the specified threshold, or if the determinant of the resulting orthogonal matrix is negative.',\n      '@throws NotARotationMatrixException if the matrix is not a 3X3 matrix or if it cannot be converted into an orthogonal matrix using the threshold provided, or if the determinant of the resulting orthogonal matrix is negative.',\n      '@throws NotARotationMatrixException if the matrix is not a 3X3 matrix, if it cannot be converted to an orthogonal matrix with the given threshold, or if the determinant of the resulting orthogonal matrix is negative.'\n    ]\n  },\n  {\n    'tag': '@param u1 first vector of the origin pair',\n    'alternatives': [\n      '@param u1 the initial vector of the origin pair',\n      '@param u1 the first vector of the pair of origins',\n      '@param u1 the vector that represents the starting point of the pair',\n      '@param u1 the first vector of the original pair',\n      '@param u1 the initial vector of the pair of origins'\n    ]\n  },\n  {\n    'tag': '@param u2 second vector of the origin pair',\n    'alternatives': [\n      '@param u2 the second vector of the origin pair',\n      '@param u2 the vector that represents the second point of the pair',\n      '@param u2 the second vector of the original pair',\n      '@param u2 the second vector of the pair of origins',\n      '@param u2 the vector that corresponds to the second point of the origin pair'\n    ]\n  },\n  {\n    'tag': '@param v1 desired image of u1 by the rotation',\n    'alternatives': [\n      '@param v1 the expected result of rotating u1',\n      '@param v1 the target image of the rotation applied to u1',\n      '@param v1 the desired output after rotating u1',\n      '@param v1 the image that should be obtained by rotating u1',\n      '@param v1 the expected image of the first vector after the rotation'\n    ]\n  },\n  {\n    'tag': '@param v2 desired image of u2 by the rotation',\n    'alternatives': [\n      '@param v2 the expected result of rotating u2',\n      '@param v2 the target image of the rotation applied to u2',\n      '@param v2 the desired output after rotating u2',\n      '@param v2 the image that should be obtained by rotating u2',\n      '@param v2 the expected image of the second vector after the rotation'\n    ]\n  },\n  {\n    'tag': '@throws MathArithmeticException if the norm of one of the vectors is zero,\\nor if one of the pair is degenerated (i.e. the vectors of the pair are collinear)',\n    'alternatives': [\n      '@throws MathArithmeticException if the magnitude of one of the vectors is zero, or if the pair is degenerate (i.e., the vectors are collinear).',\n      '@throws MathArithmeticException if the norm of one of the vectors is zero, or if one of the pairs is degenerate (i.e., the vectors of the pair are collinear).',\n      '@throws MathArithmeticException if the norm of any of the vectors is zero, or if one of the pairs is degenerate (i.e., the vectors of the pair are collinear).',\n      '@throws MathArithmeticException if the magnitude of one of the vectors is zero, or if any of the pairs is degenerate (i.e., the vectors of the pair are collinear).',\n      '@throws MathArithmeticException if the norm of one of the vectors is zero, or if one of the pairs is degenerated (i.e., the vectors of the pair are collinear).'\n    ]\n  },\n  {\n    'tag': '@param u origin vector',\n    'alternatives': [\n      '@param u the initial vector',\n      '@param u the vector representing the starting point',\n      '@param u the vector that denotes the origin',\n      '@param u the vector from which the rotation originates',\n      '@param u the vector that defines the starting position'\n    ]\n  },\n  {\n    'tag': '@param v desired image of u by the rotation',\n    'alternatives': [\n      '@param v the expected result of rotating u',\n      '@param v the target image of the rotation applied to u',\n      '@param v the desired output after rotating u',\n      '@param v the image that should be obtained by rotating u',\n      '@param v the expected image after applying the rotation to u'\n    ]\n  },\n  {\n    'tag': '@throws MathArithmeticException if the norm of one of the vectors is zero',\n    'alternatives': [\n      '@throws MathArithmeticException if the magnitude of any of the vectors is zero',\n      '@throws MathArithmeticException if the norm of any of the vectors is zero',\n      '@throws MathArithmeticException if the magnitude of one of the vectors is zero',\n      '@throws MathArithmeticException if the norm of one of the vectors is zero',\n      '@throws MathArithmeticException if one of the vector norms is zero'\n    ]\n  },\n  {\n    'tag': '@param order order of rotations to use',\n    'alternatives': [\n      '@param order the sequence of rotations to be applied',\n      '@param order the order in which rotations should be performed',\n      '@param order the specific sequence of rotations to be used',\n      '@param order the order in which to apply the rotations',\n      '@param order the rotation order to be utilized'\n    ]\n  },\n  {\n    'tag': '@param alpha1 angle of the first elementary rotation',\n    'alternatives': [\n      '@param alpha1 the angle of the initial elementary rotation',\n      '@param alpha1 the angle for the first elementary rotation',\n      '@param alpha1 the angle used in the first elementary rotation',\n      '@param alpha1 the angle that defines the first elementary rotation',\n      '@param alpha1 the angle representing the initial elementary rotation'\n    ]\n  },\n  {\n    'tag': '@param alpha2 angle of the second elementary rotation',\n    'alternatives': [\n      '@param alpha2 the angle of the subsequent elementary rotation',\n      '@param alpha2 the angle for the second elementary rotation',\n      '@param alpha2 the angle used in the second elementary rotation',\n      '@param alpha2 the angle that defines the second elementary rotation',\n      '@param alpha2 the angle representing the subsequent elementary rotation'\n    ]\n  },\n  {\n    'tag': '@param alpha3 angle of the third elementary rotation',\n    'alternatives': [\n      '@param alpha3 the angle of the third elementary rotation',\n      '@param alpha3 the angle used in the third elementary rotation',\n      '@param alpha3 the angle for the third elementary rotation',\n      '@param alpha3 the angle that defines the third elementary rotation',\n      '@param alpha3 the angle representing the third elementary rotation'\n    ]\n  },\n  {\n    'tag': '@param order order of rotations to compose, from left to right\\n(i.e. we will use {@code r1.compose(r2.compose(r3, convention), convention)})',\n    'alternatives': [\n      '@param order the sequence of rotations to be combined from left to right (i.e., using {@code r1.compose(r2.compose(r3, convention), convention)})',\n      '@param order the order in which to compose the rotations, from left to right (i.e., {@code r1.compose(r2.compose(r3, convention), convention)})',\n      '@param order the specified rotation order for composition, starting from the left and going to the right (i.e., {@code r1.compose(r2.compose(r3, convention), convention)})',\n      '@param order the order of rotations to be used for composition, from left to right (i.e., {@code r1.compose(r2.compose(r3, convention), convention)})',\n      '@param order the rotation order for composition, starting from the left and going to the right (i.e., using {@code r1.compose(r2.compose(r3, convention), convention)})'\n    ]\n  },\n  {\n    'tag': '@param convention convention to use for the semantics of the angle',\n    'alternatives': [\n      '@param convention the specified convention for interpreting the angle',\n      '@param convention the convention used to interpret the angle',\n      '@param convention the convention for understanding the angle',\n      '@param convention the convention to be employed for the angle interpretation',\n      '@param convention the convention that defines how the angle should be understood'\n    ]\n  },\n  {\n    'tag': '@param alpha1 angle of the first elementary rotation',\n    'alternatives': [\n      '@param alpha1 the angle of the starting elementary rotation',\n      '@param alpha1 the angle for the initial elementary rotation',\n      '@param alpha1 the angle used in the first elementary rotation',\n      '@param alpha1 the angle that defines the first elementary rotation',\n      '@param alpha1 the angle representing the starting elementary rotation'\n    ]\n  },\n  {\n    'tag': '@param minStep minimal step (sign is irrelevant, regardless of\\nintegration direction, forward or backward), the last step can\\nbe smaller than this',\n    'alternatives': [\n      '@param minStep the smallest step size allowed (regardless of integration direction)',\n      '@param minStep the minimum step size (direction of integration is not important), and the last step may be smaller',\n      '@param minStep the minimum step size (sign does not matter, regardless of integration direction), and the last step may be smaller',\n      '@param minStep the smallest allowed step size (regardless of the direction of integration, whether forward or backward), and the last step may be smaller than this',\n      '@param minStep the minimal step size (sign is not relevant, regardless of whether the integration is forward or backward), and the last step can be smaller'\n    ]\n  },\n  {\n    'tag': '@param maxStep maximal step (sign is irrelevant, regardless of\\nintegration direction, forward or backward), the last step can\\nbe smaller than this',\n    'alternatives': [\n      '@param maxStep the largest permitted step size (regardless of integration direction)',\n      '@param maxStep the maximum step size (direction of integration is not important), and the last step may be smaller',\n      '@param maxStep the maximum step size (sign does not matter, regardless of integration direction), and the last step may be smaller',\n      '@param maxStep the largest allowed step size (regardless of the direction of integration, whether forward or backward), and the last step may be smaller than this',\n      '@param maxStep the maximal step size (sign is not relevant, regardless of whether the integration is forward or backward), and the last step can be smaller'\n    ]\n  },\n  {\n    'tag': '@param scalAbsoluteTolerance allowed absolute error',\n    'alternatives': [\n      '@param scalAbsoluteTolerance the acceptable absolute error',\n      '@param scalAbsoluteTolerance the tolerated absolute error',\n      '@param scalAbsoluteTolerance the allowed absolute deviation',\n      '@param scalAbsoluteTolerance the maximum absolute deviation tolerated',\n      '@param scalAbsoluteTolerance the absolute error that is allowed'\n    ]\n  },\n  {\n    'tag': '@param scalRelativeTolerance allowed relative error',\n    'alternatives': [\n      '@param scalRelativeTolerance the acceptable relative error',\n      '@param scalRelativeTolerance the tolerated relative error',\n      '@param scalRelativeTolerance the allowed relative deviation',\n      '@param scalRelativeTolerance the maximum relative deviation tolerated',\n      '@param scalRelativeTolerance the relative error that is allowed'\n    ]\n  },\n  {\n    'tag': '@param field field to which the time and state vector elements belong',\n    'alternatives': [\n      '@param field the field to which the time and state vector elements belong',\n      '@param field the field that contains the time and state vector elements',\n      '@param field the field that represents the time and state vector elements',\n      '@param field the field encompassing the time and state vector elements',\n      '@param field the field that holds the time and state vector elements'\n    ]\n  },\n  {\n    'tag': '@param minStep minimal step (sign is irrelevant, regardless of\\nintegration direction, forward or backward), the last step can\\nbe smaller than this',\n    'alternatives': [\n      '@param minStep the smallest step size allowed (regardless of integration direction)',\n      '@param minStep the minimum step size (direction of integration is not important), and the last step may be smaller',\n      '@param minStep the minimum step size (sign does not matter, regardless of integration direction), and"