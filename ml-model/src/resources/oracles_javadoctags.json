[
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if\n{@code singletons.length != probabilities.length}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if any of the probabilities are negative."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if any of the probabilities are infinite."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotANumberException if any of the probabilities are NaN."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException all of the probabilities are 0."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng random number generator used for sampling"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data input dataset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data input dataset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the location parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scale parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu location parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code beta <= 0}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu location parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code beta <= 0}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return scale parameter of the distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return location parameter of the distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu location parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c scale parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng random generator to be used for sampling"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu location"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c scale parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the stored point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to the internal array storing the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return data transfer object that will be serialized"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point coordinates. This instance will store\na copy of the array, not the array passed as argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Value of the objective function at the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point coordinates."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Value of the objective function at the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyArray if {@code true}, the input array will be copied,\notherwise it will be referenced."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iteration Index of current iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous Best point in the previous iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@param current Best point in the current iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the algorithm has converged."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold relative tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold absolute tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold relative tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold absolute tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIter Maximum iteration count."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the relative threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the absolute threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold relative tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold absolute tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startPoint Initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the allowed number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance suitable for allowing {@link Integer#MAX_VALUE}\nevaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Allowed number of iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the constraints."
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraints Constraints."
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraints Constraints."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the coefficients of the constraint (left hand side)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the relationship between left and right hand sides."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the constraint (right hand side)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oos stream where object should be written"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be written to stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ois stream from which the object should be read"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if a class in the stream cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be read from the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients The coefficients of the constraint (left hand side)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relationship The type of (in)equality used in the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The value of the constraint (right hand side)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients The coefficients of the constraint (left hand side)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relationship The type of (in)equality used in the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The value of the constraint (right hand side)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhsCoefficients The coefficients of the linear expression on the left hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhsConstant The constant term of the linear expression on the left hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relationship The type of (in)equality used in the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhsCoefficients The coefficients of the linear expression on the right hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhsConstant The constant term of the linear expression on the right hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhsCoefficients The coefficients of the linear expression on the left hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhsConstant The constant term of the linear expression on the left hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relationship The type of (in)equality used in the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhsCoefficients The coefficients of the linear expression on the right hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhsConstant The constant term of the linear expression on the right hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. In addition to those documented in\n{@link LinearOptimizer#optimize(OptimizationData...)\nLinearOptimizer}, this method will register the following data:\n<ul>\n <li>{@link SolutionCallback}</li>\n <li>{@link PivotSelectionRule}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyIterationsException if the maximal number of iterations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data.\nIn addition to those documented in\n{@link LinearOptimizer#parseOptimizationData(OptimizationData[])\nLinearOptimizer}, this method will register the following data:\n<ul>\n <li>{@link SolutionCallback}</li>\n <li>{@link PivotSelectionRule}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tableau Simple tableau for the problem."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the column with the most negative coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param tableau simplex tableau for the problem"
    },
    {
        "oracle": ";",
        "javadocTag": "@param col the column to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the pivot column is valid, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tableau Simplex tableau for the problem."
    },
    {
        "oracle": ";",
        "javadocTag": "@param col Column to test the ratio of (see {@link #getPivotColumn(SimplexTableau)})."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the row with the minimum ratio."
    },
    {
        "oracle": ";",
        "javadocTag": "@param tableau Simple tableau for the problem."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyIterationsException if the allowed number of iterations has been exhausted."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnboundedSolutionException if the model is found not to have a bounded solution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param tableau Simple tableau for the problem."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyIterationsException if the allowed number of iterations has been exhausted."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnboundedSolutionException if the model is found not to have a bounded solution."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoFeasibleSolutionException if there is no feasible solution?"
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon Amount of error to accept for algorithm convergence."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon Amount of error to accept for algorithm convergence."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxUlps Amount of error to accept in floating point comparisons."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon Amount of error to accept for algorithm convergence."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxUlps Amount of error to accept in floating point comparisons."
    },
    {
        "oracle": ";",
        "javadocTag": "@param cutOff Values smaller than the cutOff are treated as zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\nexponential the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\nexponential the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\nlogarithm the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\nshifted logarithm the result array <em>cannot</em> be the input array)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\nbase 10 logarithm the result array <em>cannot</em> be the input array)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\ncosine the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\nsine the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\ntangent the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\narc cosine the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\narc sine the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\narc tangent the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array holding the first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yOffset offset of the first operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x array holding the second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xOffset offset of the second operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\ntwo arguments arc tangent the result array <em>cannot</em>\nbe the input array)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\nhyperbolic cosine the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\nhyperbolic sine the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\nhyperbolic tangent the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\ninverse hyperbolic cosine the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\ninverse hyperbolic sine the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\ninverse hyperbolic tangent the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f array of value and derivatives of the function at\nthe current point (i.e. at {@code operand[operandOffset]})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\ncomposition the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ds array holding the derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dsOffset offset of the derivative structure in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta parameters offsets (&Delta;x, &Delta;y, ...)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value of the Taylor expansion at x + &Delta;x, y + &Delta;y, ..."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if factorials becomes too large"
    },
    {
        "oracle": ";",
        "javadocTag": "@param compiler other compiler to check against instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters or orders are inconsistent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters number of free parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueCompiler compiler for the value part"
    },
    {
        "oracle": ";",
        "javadocTag": "@param derivativeCompiler compiler for the derivative part"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if order is too large"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value of the constant"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param idx index of the variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value of the variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index to differentiate with."
    },
    {
        "oracle": ";",
        "javadocTag": "@return derivative with respect to a particular index variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value of the function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a instance to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new object"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FunctorException (runtime) if the factory cannot create an object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an empty iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, combining the provided iterables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, combining the provided iterables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, combining the provided iterables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, combining the provided iterables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a filtered view on the specified iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator defining an ordering over the elements,\n  may be null, in which case natural ordering will be used"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a filtered view on the specified iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a filtered view on the specified iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a bounded view on the specified iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a view of the iterable, providing an infinite loop over its elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reversed view of the specified iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a view of the specified iterable, skipping the first N elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a transformed view of the specified iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a unique view of the specified iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the specified iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, interleaving the provided iterables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, interleaving the provided iterables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an empty iterable if the argument is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterator to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to search, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first element of the iterable which matches the predicate or null if none could be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to search, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the first element which matches the predicate or -1 if none matches"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the {@link Iterable} to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if every element of the collection matches the predicate or if the\n  collection is empty, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the {@link Iterable} to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if any element of the collection matches the predicate, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the {@link Iterable} to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of matches for the predicate in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the {@link Iterable to use}, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to check, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the object is contained in the iterable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to check, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the object is contained in the iterable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type that the {@link Iterable} may contain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the element type of the object to find"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the {@link Iterable} to search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to find the cardinality of"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the the number of occurrences of obj in iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object in the {@link Iterable}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the {@link Iterable} to get a value from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to get"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to check, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of elements contained in the iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to partition, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list containing the output collections"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the collection to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list containing the output collections"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <R> the type of the output {@link Collection}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the collection to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param partitionFactory the factory used to create the output collections"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list containing the output collections"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of the iterator contents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to convert to a string, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of {@code iterable}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result placeholder where to put the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first term of the multiplication"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second term of the multiplication"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result placeholder where to put the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p integer whose exponential is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result placeholder where to put the result in extended precision"
    },
    {
        "oracle": ";",
        "javadocTag": "@return exp(p) in standard precision (equal to result[0] + result[1])"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xi number from which log is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return log(xi)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out text output stream where output should be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name array name"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedLen expected length of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array2d array data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out text output stream where output should be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name array name"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedLen expected length of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array array data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d double number to format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return formatted number"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedLen expected length"
    },
    {
        "oracle": ";",
        "javadocTag": "@param actual actual length"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the two lengths are not equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d the value to split"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the high order part of the mantissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number on which evaluation is done"
    },
    {
        "oracle": ";",
        "javadocTag": "@return square root of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number on which evaluation is done"
    },
    {
        "oracle": ";",
        "javadocTag": "@return hyperbolic cosine of x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number on which evaluation is done"
    },
    {
        "oracle": ";",
        "javadocTag": "@return hyperbolic sine of x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number on which evaluation is done"
    },
    {
        "oracle": ";",
        "javadocTag": "@return hyperbolic tangent of x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number on which evaluation is done"
    },
    {
        "oracle": ";",
        "javadocTag": "@return inverse hyperbolic cosine of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number on which evaluation is done"
    },
    {
        "oracle": ";",
        "javadocTag": "@return inverse hyperbolic sine of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number on which evaluation is done"
    },
    {
        "oracle": ";",
        "javadocTag": "@return inverse hyperbolic tangent of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number on which evaluation is done"
    },
    {
        "oracle": ";",
        "javadocTag": "@return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number on which evaluation is done"
    },
    {
        "oracle": ";",
        "javadocTag": "@return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number to which neighbor should be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return neighbor of a towards positive infinity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number to which neighbor should be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return neighbor of a towards positive infinity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number to which neighbor should be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return neighbor of a towards negative infinity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number to which neighbor should be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return neighbor of a towards negative infinity"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random number between 0.0 and 1.0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x a double"
    },
    {
        "oracle": ";",
        "javadocTag": "@return double e<sup>x</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x original argument of the exponential function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param extra extra bits of precision on input (To Be Confirmed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hiPrec extra bits of precision on output (To Be Confirmed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return exp(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number to compute shifted exponential"
    },
    {
        "oracle": ";",
        "javadocTag": "@return exp(x) - 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number to compute shifted exponential"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hiPrecOut receive high precision result for -1.0 < x < 1.0"
    },
    {
        "oracle": ";",
        "javadocTag": "@return exp(x) - 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x a double"
    },
    {
        "oracle": ";",
        "javadocTag": "@return log(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x original argument of the natural logarithm function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hiPrec extra bits of precision on output (To Be Confirmed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return log(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code log(1 + x)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x a number"
    },
    {
        "oracle": ";",
        "javadocTag": "@return log10(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x a double"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y a double"
    },
    {
        "oracle": ";",
        "javadocTag": "@return double"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Number to raise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e Exponent."
    },
    {
        "oracle": ";",
        "javadocTag": "@return d<sup>e</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Number to raise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e Exponent."
    },
    {
        "oracle": ";",
        "javadocTag": "@return d<sup>e</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x a number smaller than 1/16"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sin(x) - x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x a number smaller than 1/16"
    },
    {
        "oracle": ";",
        "javadocTag": "@return cos(x) - 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xa number from which sine is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xb extra bits for x (may be 0.0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sin(xa + xb)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xa number from which cosine is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xb extra bits for x (may be 0.0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return cos(xa + xb)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xa number from which sine is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xb extra bits for x (may be 0.0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cotanFlag if true, compute the cotangent instead of the tangent"
    },
    {
        "oracle": ";",
        "javadocTag": "@return tan(xa+xb) (or cotangent, depending on cotanFlag)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number to reduce"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result placeholder where to put the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return sin(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return cos(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicatesAndClosures a map of predicates to closures"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>switch</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any closure in the map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the map elements are of the wrong type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the predicates"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the closures"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clone if {@code true} the input arguments will be cloned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicates array of predicates, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closures matching array of closures, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultClosure the closure to use if no match, null means nop"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicates array of predicates, cloned, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closures matching array of closures, cloned, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultClosure the closure to use if no match, null means nop"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the predicate is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this is the first time the object is seen"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the objects to be created"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Transformer<Class<? extends T>, T>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the objects to be created"
    },
    {
        "oracle": ";",
        "javadocTag": "@param paramTypes the constructor parameter types"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the constructor arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an instantiate transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if paramTypes does not match args"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param paramTypes the constructor parameter types"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the constructor arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>any</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>one</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any predicate in the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if only one decorated predicate returns true"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equator the equator to use for comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if input object equals stored value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equator the equator to use for comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type the factory creates"
    },
    {
        "oracle": ";",
        "javadocTag": "@param paramTypes the constructor parameter types, cloned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the constructor arguments, cloned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instantiate factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if paramTypes does not match args"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param classToInstantiate the class to instantiate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param classToInstantiate the class to instantiate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param paramTypes the constructor parameter types, cloned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the constructor arguments, cloned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate predicate to switch on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param trueClosure closure used if true"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>if</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate predicate to switch on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param trueClosure closure used if true"
    },
    {
        "oracle": ";",
        "javadocTag": "@param falseClosure closure used if false"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>if</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the iterator has a previous element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous element in the iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.util.NoSuchElementException if the iteration is finished"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator Comparator with the forward sort order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator Comparator to add to the end of the chain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the Comparator to replace"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator Comparator to place at the given index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if index &lt; 0 or index &gt;= size()"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the Comparator to replace"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator Comparator to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index of the ComparatorChain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index of the ComparatorChain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Comparator count"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true = ComparatorChain cannot be modified; false =\n        ComparatorChain can still be modified."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the {@link ComparatorChain} is locked"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the {@link ComparatorChain} is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o1 the first object to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o2 the second object to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return -1, 0, or 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the ComparatorChain does not contain at least one Comparator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a suitable hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare with"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator First comparator in the Comparator chain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator First Comparator in the ComparatorChain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list List of Comparators"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list List of Comparators.  NOTE: This constructor does not perform a\n              defensive copy of the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of first element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number of elements to be retrieved."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector containing n elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of first element to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector containing the values to set."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if any coordinate of this vector is {@code NaN},\n{@code false} otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if any coordinate of this vector is infinite and\nnone are {@code NaN}, {@code false} otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to compare instance with."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the vectors do not\nhave the same dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Expected dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension is\ninconsistent with the vector size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code index} is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry of the subvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry of the subvector (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code start} of {@code end} are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} + {@code v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this} vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to be subtracted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} - {@code v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this} vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Value to be added to each entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} + {@code d}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Value to be added to each entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector with which dot product should be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scalar dot product between this instance and {@code v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this} vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cosine of the angle between this vector and {@code v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if {@code this} or {@code v} is the null\nvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimensions of {@code this} and\n{@code v} do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector by which instance elements must be divided."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector containing this[i] / v[i] for all i."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this} vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector by which instance elements must be multiplied"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector containing this[i] * v[i] for all i."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this} vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to which distance is requested."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between two vectors."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this} vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the norm."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the norm."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the norm."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to which distance is requested."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between two vectors."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this} vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to which distance is requested."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between two vectors."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this} vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the minimum entry or -1 if vector length is 0\nor all entries are {@code NaN}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the minimum entry or {@code NaN} if all\nentries are {@code NaN}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the maximum entry or -1 if vector length is 0\nor all entries are {@code NaN}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the maximum entry or {@code NaN} if all\nentries are {@code NaN}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Multiplication factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} * {@code d}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Multiplication factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Value to be subtracted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} - {@code d}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Value to be subtracted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Value to divide by."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} / {@code d}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Value to divide by."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector with which outer product should be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the matrix outer product between this instance and {@code v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector onto which instance must be projected."
    },
    {
        "oracle": ";",
        "javadocTag": "@return projection of the instance onto {@code v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this} vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if {@code this} or {@code v} is the null\nvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Single value to set for all elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing a copy of the vector elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a unit vector pointing in direction of this vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a sparse iterator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a dense iterator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param function Function to apply to each entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param function Function to apply to each entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to this vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Coefficient of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Coefficient of {@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Vector with which {@code this} is linearly combined."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector containing {@code a * this[i] + b * y[i]} for all\n{@code i}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code y} is not the same size as\n{@code this} vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Weight of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Weight of {@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Vector with which {@code this} is linearly combined."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this}, with components equal to\n{@code a * this[i] + b * y[i]} for all {@code i}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code y} is not the same size as\n{@code this} vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be used to process the entries of this\nvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealVectorPreservingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor to be used to process the entries of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IdAlreadyInUseException If an edge with the same id already exists and strict\n            checking is enabled."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws EdgeRejectedException If strict checking is enabled and the edge is not accepted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique and arbitrary string identifying the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node1 The first node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node2 The second node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The newly created edge, an existing edge or {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IdAlreadyInUseException If an edge with the same id already exists and strict\n            checking is enabled."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws EdgeRejectedException If strict checking is enabled and the edge is not accepted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique and arbitrary string identifying the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param from The first node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to The second node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param directed Is the edge directed?"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The newly created edge, an existing edge or {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IdAlreadyInUseException If an edge with the same id already exists and strict\n            checking is enabled."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws EdgeRejectedException If strict checking is enabled and the edge is not accepted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index The index of the edge to be removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The removed edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is negative or greater than {@code\n            getEdgeCount() - 1}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fromIndex the index of the source node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param toIndex the index of the target node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the removed edge or {@code null} if no edge is removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException If one of the node indices is negative or greater than\n            {@code getNodeCount() - 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ElementNotFoundException if strict checking is enabled and there is no edge between\n            the two nodes."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node1 the first node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node2 the second node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the removed edge or {@code null} if no edge is removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ElementNotFoundException if strict checking is enabled and there is no edge between\n            the two nodes."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge The edge to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The removed edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index The index of the node to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The removed node"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is negative or greater than {@code\n            getNodeCount() - 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node The node to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The removed node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The conversion of this attribute to a hash."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The attribute usual name."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The number of nodes."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The number of edges."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The iterator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The iterator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An \"iterable\" view of the set of nodes."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An \"iterable\" view of the set of edges."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A set of nodes that can only be read, not changed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A set of edges that can only be read, not changed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param message The message to throw."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The new edge identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param src The source node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dst The target node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param directed Is the edge directed (in the direction source toward target)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The newly created edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param message The message to throw."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source of the change."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId The source time of the change, for synchronization."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name that changed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event The type of event among ADD, CHANGE and REMOVE."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The unique identifier of this element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the new index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name that changed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event The type of event among ADD, CHANGE and REMOVE."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The unique identifier of this element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique identifier of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param strictChecking If true any non-fatal error throws an exception."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialNodeCapacity Initial capacity of the node storage data structures. Use this\n           if you know the approximate maximum number of nodes of the\n           graph. The graph can grow beyond this limit, but storage\n           reallocation is expensive operation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialEdgeCapacity Initial capacity of the edge storage data structures. Use this\n           if you know the approximate maximum number of edges of the\n           graph. The graph can grow beyond this limit, but storage\n           reallocation is expensive operation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique identifier of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param strictChecking If true any non-fatal error throws an exception."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique identifier of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge a new edge incident to this node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge an edge incident to this node that will be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e an edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code e} is entering edge for this node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e an edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code e} is leaving edge for this node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e an edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code e} is incident edge for this node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graph to which this node belongs."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique identifier of this node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique identifier of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param strictChecking If true any non-fatal error throws an exception."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialNodeCapacity Initial capacity of the node storage data structures. Use this\n           if you know the approximate maximum number of nodes of the\n           graph. The graph can grow beyond this limit, but storage\n           reallocation is expensive operation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialEdgeCapacity Initial capacity of the edge storage data structures. Use this\n           if you know the approximate maximum number of edges of the\n           graph. The graph can grow beyond this limit, but storage\n           reallocation is expensive operation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique identifier of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param strictChecking If true any non-fatal error throws an exception."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique identifier of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique identifier of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param strictChecking If true any non-fatal error throws an exception."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialNodeCapacity Initial capacity of the node storage data structures. Use this\n           if you know the approximate maximum number of nodes of the\n           graph. The graph can grow beyond this limit, but storage\n           reallocation is expensive operation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialEdgeCapacity Initial capacity of the edge storage data structures. Use this\n           if you know the approximate maximum number of edges of the\n           graph. The graph can grow beyond this limit, but storage\n           reallocation is expensive operation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique identifier of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param strictChecking If true any non-fatal error throws an exception."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique identifier of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph to synchronize"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized wrapper for g"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graphs graphs to merge"
    },
    {
        "oracle": ";",
        "javadocTag": "@return merge result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result destination graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graphs all graphs that will be merged in result."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph to clone"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of g"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source "
    },
    {
        "oracle": ";",
        "javadocTag": "@param count the number of times to repeat it; a nonnegative integer"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an instance of the appropriate type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param finalizableReferenceClass FinalizableReference.class."
    },
    {
        "oracle": ";",
        "javadocTag": "@param queue a reference queue that the thread will poll."
    },
    {
        "oracle": ";",
        "javadocTag": "@param frqReference a phantom reference to the FinalizableReferenceQueue, which will be\nqueued either when the FinalizableReferenceQueue is no longer referenced anywhere, or when\nits close() method is called."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the caller should continue, false if the associated FinalizableReferenceQueue\nis no longer referenced."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Finalizer.class"
    },
    {
        "oracle": ";",
        "javadocTag": "@param self the object to generate the string for (typically {@code this}), used only for its\n    class name"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clazz the {@link Class} of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param className the name of the instance type"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code sequence} contains ill-formed UTF-16 (unpaired\n    surrogates)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bytes the input buffer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param off the offset in the buffer of the first byte to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len the number of bytes to read from the buffer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param throwable the Throwable to possibly propagate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param declaredType the single checked exception type declared by the calling method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param throwable the Throwable to possibly propagate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param declaredType1 any checked exception type declared by the calling method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param declaredType2 any other checked exception type declared by the calling method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param throwable the Throwable to propagate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return nothing will ever be returned; this return type is only for your convenience, as\n    illustrated in the example above"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable list containing the cause chain starting with {@code throwable}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if backward conversion is not implemented; this should be\n    very rare. Note that if backward conversion is not only unimplemented but\n    unimplement<i>able</i> (for example, consider a {@code Converter<Chicken, ChickenNugget>}),\n    then this is not logically a {@code Converter} at all, and should just implement {@link\n    Function}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator the character to recognize as a separator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a splitter, with default settings, that recognizes that separator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separatorMatcher a {@link CharMatcher} that determines whether a\n    character is a separator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a splitter, with default settings, that uses this matcher"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator the literal, nonempty string to recognize as a separator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a splitter, with default settings, that recognizes that separator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separatorPattern the pattern that determines whether a subsequence\n    is a separator. This pattern may not match the empty string."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a splitter, with default settings, that uses this pattern"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code separatorPattern} matches the\n    empty string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separatorPattern the pattern that determines whether a subsequence\n    is a separator. This pattern may not match the empty string."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a splitter, with default settings, that uses this pattern"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.util.regex.PatternSyntaxException if {@code separatorPattern}\n    is a malformed expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code separatorPattern} matches the\n    empty string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the desired length of pieces after splitting, a positive\n    integer"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a splitter, with default settings, that can split into fixed sized\n    pieces"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a splitter with the desired configuration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param limit the maximum number of items returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a splitter with the desired configuration"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a splitter with the desired configuration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence the sequence of characters to split"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iteration over the segments split from the parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence the sequence of characters to split"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an immutable list of the segments split from the parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence the character sequence to examine, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if this matcher matches at least one character in the sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence the character sequence to examine, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if this matcher matches every character in the sequence, including when\n        the sequence is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence the character sequence to examine, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence the character sequence to examine from the beginning"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an index, or {@code -1} if no character matches"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence the character sequence to examine"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the first index to examine; must be nonnegative and no greater than {@code\n       sequence.length()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the first matching character, guaranteed to be no less than {@code start},\n        or {@code -1} if no character matches"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence the character sequence to examine from the end"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an index, or {@code -1} if no character matches"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence the character sequence to replace matching characters in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param replacement the character to append to the result string in place of each matching\n       character in {@code sequence}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence the character sequence to replace matching characters in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param replacement the characters to append to the result string in place of each matching\n       character in {@code sequence}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence the character sequence to replace matching groups of characters in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param replacement the character to append to the result string in place of each group of\n       matching characters in {@code sequence}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target the collection that may contain the function input"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the composition of the provided function and predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.util.regex.PatternSyntaxException if the pattern is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expression a boolean expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorMessageTemplate a template for the exception message should the\n    check fail. The message is formed by replacing each {@code %s}\n    placeholder in the template with an argument. These are matched by\n    position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.\n    Unmatched arguments will be appended to the formatted message in square\n    braces. Unmatched placeholders will be left as-is."
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorMessageArgs the arguments to be substituted into the message\n    template. Arguments are converted to strings using\n    {@link String#valueOf(Object)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorMessageTemplate a template for the exception message should the\n    check fail. The message is formed by replacing each {@code %s}\n    placeholder in the template with an argument. These are matched by\n    position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.\n    Unmatched arguments will be appended to the formatted message in square\n    braces. Unmatched placeholders will be left as-is."
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorMessageArgs the arguments to be substituted into the message\n    template. Arguments are converted to strings using\n    {@link String#valueOf(Object)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param referent to weakly reference"
    },
    {
        "oracle": ";",
        "javadocTag": "@param queue that should finalize the referent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param referent to phantom reference"
    },
    {
        "oracle": ";",
        "javadocTag": "@param queue that should finalize the referent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stack The prefixes that preceed the characters represented by this\n    node. Each entry of the stack is in reverse order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param encoded The serialized trie."
    },
    {
        "oracle": ";",
        "javadocTag": "@param builder A map builder to which all entries will be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The number of characters consumed from {@code encoded}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the algorithm failed due to finite\nprecision."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param method <em>Secant</em>-based root-finding method to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param method <em>Secant</em>-based root-finding method to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Maximum relative error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Maximum absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param functionValueAccuracy Maximum function value error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param method <em>Secant</em>-based root-finding method to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy absolute accuracy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy relative accuracy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy absolute accuracy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the coefficients of the polynomial function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Maximum absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Maximum relative error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Maximum absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Maximum relative error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Maximum absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param functionValueAccuracy Maximum function value error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fMin function value at the lower bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fMax function value at the upper bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point at which the function value is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the allowed number of calls to\nthe function to be solved has been exhausted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lower end of the search interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the higher end of the search interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point at which the objective function must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective function value at specified point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of evaluations\nis exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to solve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startValue Start value to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the root."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of evaluations\nis exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the initial search interval does not bracket\na root and the solver requires it."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower Lower endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper Upper endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the function values have opposite signs at the\ngiven points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start First number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mid Second number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param end Third number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the arguments form an increasing sequence."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower Lower endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper Upper endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower Lower endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initial Initial value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper Upper endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower Lower endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper Upper endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if the function has not been set."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the function has the same sign at\nthe endpoints."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException when the allowed number of function\nevaluations has been exhausted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Maximum absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Maximum relative error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Maximum absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Maximum relative error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Maximum absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param functionValueAccuracy Maximum function value error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lo Lower bound of the search interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hi Higher bound of the search interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fLo Function value at the lower bound of the search interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fHi Function value at the higher bound of the search interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value where the function is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param functionValueAccuracy Function value accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lo Lower bound of the search interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hi Higher bound of the search interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fLo Function value at the lower bound of the search interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fHi Function value at the higher bound of the search interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients Polynomial coefficients."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initial Start value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the full set of complex roots of the polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximum number of evaluations is exceeded when solving for one of the roots"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients polynomial coefficients"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initial start value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval maximum number of evaluations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the full set of complex roots of the polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximum number of evaluations is exceeded when solving for one of the roots"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients Polynomial coefficients."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initial Start value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a complex root of the polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximum number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients polynomial coefficients"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initial start value"
    },
    {
        "oracle": "data.length==0;",
        "javadocTag": "@throws NoDataException if {@code data} is empty."
    },
    {
        "oracle": "data==null;",
        "javadocTag": "@throws NullArgumentException if {@code data} is {@code null}."
    },
    {
        "oracle": "data.length==0;",
        "javadocTag": "@throws NoDataException if {@code data} is empty."
    },
    {
        "oracle": "data==null;",
        "javadocTag": "@throws NullArgumentException if {@code data} is {@code null}."
    },
    {
        "oracle": "rowData.length==0;",
        "javadocTag": "@throws NoDataException if {@code rowData} is empty."
    },
    {
        "oracle": "rowData==null;",
        "javadocTag": "@throws NullArgumentException if {@code rowData} is {@code null}."
    },
    {
        "oracle": "rowData.length==0;",
        "javadocTag": "@throws NoDataException if {@code rowData} is empty."
    },
    {
        "oracle": "rowData==null;",
        "javadocTag": "@throws NullArgumentException if {@code rowData} is {@code null}."
    },
    {
        "oracle": "columnData.length==0;",
        "javadocTag": "@throws NoDataException if {@code columnData} is empty."
    },
    {
        "oracle": "columnData==null;",
        "javadocTag": "@throws NullArgumentException if {@code columnData} is {@code null}."
    },
    {
        "oracle": "columnData.length==0;",
        "javadocTag": "@throws NoDataException if {@code data} is empty."
    },
    {
        "oracle": "columnData==null;",
        "javadocTag": "@throws NullArgumentException if {@code columnData} is {@code null}."
    },
    {
        "oracle": "(((matrix==null)==false) && (matrix.isSquare())) == false;",
        "javadocTag": "@throws NonSquareMatrixException if the matrix is not square."
    },
    {
        "oracle": "(MatrixUtils.isSymmetric(matrix,eps)) == false;",
        "javadocTag": "@throws NonSymmetricMatrixException if the matrix is not symmetric."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "selectedRows==null || selectedColumns==null;",
        "javadocTag": "@throws NullArgumentException if {@code selectedRows} or\n{@code selectedColumns} are {@code null}."
    },
    {
        "oracle": "(((rm==null)==false) && (rm.isSquare())) == false;",
        "javadocTag": "@throws NonSquareMatrixException if the matrix {@code rm} is not square"
    },
    {
        "oracle": "(((rm==null)==false) && (rm.isSquare())) == false;",
        "javadocTag": "@throws NonSquareMatrixException if the matrix {@code rm} is not\nsquare"
    },
    {
        "oracle": "(((m==null)==false) && (m.isSquare())) == false;",
        "javadocTag": "@throws NonSquareMatrixException if {@code m} is not square."
    },
    {
        "oracle": "matrix==null;",
        "javadocTag": "@throws NullArgumentException if {@code matrix} is {@code null}"
    },
    {
        "oracle": "(((matrix==null)==false) && (matrix.isSquare())) == false;",
        "javadocTag": "@throws NonSquareMatrixException if matrix is not square"
    },
    {
        "oracle": "matrix==null;",
        "javadocTag": "@throws NullArgumentException if {@code matrix} is {@code null}"
    },
    {
        "oracle": "(((matrix==null)==false) && (matrix.isSquare())) == false;",
        "javadocTag": "@throws NonSquareMatrixException if matrix is not square"
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}."
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}."
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}."
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "(minimalIterationCount>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive"
    },
    {
        "oracle": "(minimalIterationCount>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive"
    },
    {
        "oracle": "minStep>0;",
        "javadocTag": "@param minStep minimal step (must be positive even for backward\nintegration), the last step can be smaller than this"
    },
    {
        "oracle": "maxStep>0;",
        "javadocTag": "@param maxStep maximal step (must be positive even for backward\nintegration)"
    },
    {
        "oracle": "(start==null) == false;",
        "javadocTag": "@param start Initial guess for the parameters.  Cannot be {@code null}.\nIts length must be consistent with the number of parameters of the\nfunction to fit."
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the input array is null or the array\nindex parameters are not valid"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "xval.length==0;",
        "javadocTag": "@throws NoDataException if an array has zero-length."
    },
    {
        "oracle": "xval==null || yval==null;",
        "javadocTag": "@throws NullArgumentException if the arguments are {@code null}."
    },
    {
        "oracle": "a==null;",
        "javadocTag": "@throws NullArgumentException if {@code a} is {@code null}."
    },
    {
        "oracle": "a==null;",
        "javadocTag": "@throws NullArgumentException if {@code a} is {@code null}."
    },
    {
        "oracle": "a==null;",
        "javadocTag": "@throws NullArgumentException if {@code a} is {@code null}."
    },
    {
        "oracle": "a==null;",
        "javadocTag": "@throws NullArgumentException if {@code a} is {@code null}."
    },
    {
        "oracle": "(this.isSupported(name)) == false;",
        "javadocTag": "@throws UnknownParameterException if parameter is not supported"
    },
    {
        "oracle": "(this.isSupported(name)) == false;",
        "javadocTag": "@throws UnknownParameterException if parameter is not supported"
    },
    {
        "oracle": "x==null || y==null;",
        "javadocTag": "@throws NullArgumentException if {@code x} or {@code y} are {@code null}."
    },
    {
        "oracle": "x.length==0 || y.length==0;",
        "javadocTag": "@throws NoDataException if {@code x} or {@code y} are zero-length."
    },
    {
        "oracle": "maximalOrder<2;",
        "javadocTag": "@throws NumberIsTooSmallException if maximal order is lower than 2"
    },
    {
        "oracle": "f==null;",
        "javadocTag": "@throws NullArgumentException if f is null."
    },
    {
        "oracle": "f==null;",
        "javadocTag": "@throws NullArgumentException if f is null."
    },
    {
        "oracle": "(rowDimension>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if row or column dimension is not\npositive."
    },
    {
        "oracle": "p<0;",
        "javadocTag": "@throws NotPositiveException if {@code p < 0}"
    },
    {
        "oracle": "(this.isSquare()) == false;",
        "javadocTag": "@throws NonSquareMatrixException if {@code this matrix} is not square"
    },
    {
        "oracle": "selectedRows.length==0 || selectedColumns.length==0;",
        "javadocTag": "@throws NoDataException if {@code selectedRows} or\n{@code selectedColumns} is empty"
    },
    {
        "oracle": "selectedRows==null || selectedColumns==null;",
        "javadocTag": "@throws NullArgumentException if {@code selectedRows} or\n{@code selectedColumns} is {@code null}."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "selectedRows.length==0 || selectedColumns.length==0;",
        "javadocTag": "@throws NoDataException if {@code selectedRows} or\n{@code selectedColumns} is empty"
    },
    {
        "oracle": "selectedRows==null || selectedColumns==null;",
        "javadocTag": "@throws NullArgumentException if {@code selectedRows} or\n{@code selectedColumns} is {@code null}."
    },
    {
        "oracle": "subMatrix==null;",
        "javadocTag": "@throws NullArgumentException if {@code subMatrix} is {@code null}."
    },
    {
        "oracle": "(this.isSquare()) == false;",
        "javadocTag": "@throws NonSquareMatrixException if the matrix is not square."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if orginal is null"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "true ? methodResultID==x+originalDelta : true;",
        "javadocTag": "@return a number {@code delta} so that {@code x + delta} and {@code x}\ndiffer by a representable floating number."
    },
    {
        "oracle": "optimizer==null || generator==null;",
        "javadocTag": "@throws NullArgumentException if {@code optimizer} or {@code generator}\nis {@code null}."
    },
    {
        "oracle": "starts<1;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code starts < 1}."
    },
    {
        "oracle": "starts==1;",
        "javadocTag": "@param starts Number of starts to perform. If {@code starts == 1},\nthe {@link #optimize(int,MultivariateVectorFunction,double[],double[],double[])\noptimize} will return the same solution as {@code optimizer} would."
    },
    {
        "oracle": "(rowDimension>0) == false;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if row or column dimension is not positive."
    },
    {
        "oracle": "f==null || target==null || weight==null || startPoint==null;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NullArgumentException if\nany argument is {@code null}."
    },
    {
        "oracle": "(index==0) == false;",
        "javadocTag": "@throws OutOfRangeException if {@code index} is not between\n{@code 0} and the value returned by {@link #getSize()} (excluded)."
    },
    {
        "oracle": "true ? methodResultID==0 : true;",
        "javadocTag": "@return A value where the function is zero."
    },
    {
        "oracle": "true ? methodResultID==0 : true;",
        "javadocTag": "@return A value where the function is zero."
    },
    {
        "oracle": "true ? methodResultID == x : true;",
        "javadocTag": "@return predicted <code>y</code> value"
    },
    {
        "oracle": "variablesToInclude==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the variablesToInclude array is null or zero length"
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "x==null || y==null || f==null;",
        "javadocTag": "@throws NullArgumentException if any of the arguments are null"
    },
    {
        "oracle": "x.length==0 || y.length==0 || f.length==0;",
        "javadocTag": "@throws NoDataException if any of the arrays has zero length."
    },
    {
        "oracle": "true ? methodResultID==a : true;",
        "javadocTag": "@return a new array {@code r} where {@code r[i] = a[i] - b[i]}."
    },
    {
        "oracle": "abort==true;",
        "javadocTag": "@throws DimensionMismatchException if the lengths differ and\n{@code abort} is {@code true}."
    },
    {
        "oracle": "abort==true;",
        "javadocTag": "@throws DimensionMismatchException if the lengths differ and\n{@code abort} is {@code true}."
    },
    {
        "oracle": "in==null;",
        "javadocTag": "@throws NullArgumentException if input array is null"
    },
    {
        "oracle": "in.length<0;",
        "javadocTag": "@throws NotPositiveException if any array entries are less than 0."
    },
    {
        "oracle": "in.length<0;",
        "javadocTag": "@throws NotPositiveException if any array entries are less than 0."
    },
    {
        "oracle": "x==null || yList==null;",
        "javadocTag": "@throws NullArgumentException if {@code x} or any {@code y} is null."
    },
    {
        "oracle": "x==null || yList==null;",
        "javadocTag": "@throws NullArgumentException if {@code x} or any {@code y} is null"
    },
    {
        "oracle": "true ? methodResultID==b1+a2 : true;",
        "javadocTag": "@return a<sub>1</sub>&times;b<sub>1</sub> +\na<sub>2</sub>&times;b<sub>2</sub>"
    },
    {
        "oracle": "true ? methodResultID==b1+a2 : true;",
        "javadocTag": "@return a<sub>1</sub>&times;b<sub>1</sub> +\na<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>"
    },
    {
        "oracle": "true ? methodResultID==b1+a2 : true;",
        "javadocTag": "@return a<sub>1</sub>&times;b<sub>1</sub> +\na<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\na<sub>4</sub>&times;b<sub>4</sub>"
    },
    {
        "oracle": "x==null || h==null;",
        "javadocTag": "@throws NullArgumentException if either {@code x} or {@code h} is {@code null}."
    },
    {
        "oracle": "x.length==0 || h.length==0;",
        "javadocTag": "@throws NoDataException if either {@code x} or {@code h} is empty."
    },
    {
        "oracle": "x==null;",
        "javadocTag": "@throws NullPointerException if any of the arrays are null"
    },
    {
        "oracle": "data==null;",
        "javadocTag": "@throws NullPointerException if data is null"
    },
    {
        "oracle": "index<0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n        zero or is greater than <code>getNumElements() - 1</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m sample mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu constant to test against"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v sample variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n sample n"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m1 first sample mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m2 second sample mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first sample variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second sample variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n1 first sample n"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n2 second sample n"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if the estimated degrees of freedom is not\nstrictly positive"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m1 first sample mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m2 second sample mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first sample variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second sample variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n1 first sample n"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n2 second sample n"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if the estimated degrees of freedom is not\nstrictly positive"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the significance level is out of bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param data Sample data."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if {@code data} is {@code null}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if there is not enough sample data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stat Statistical summary."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if {@code data} is {@code null}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if there is not enough sample data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed array of observed frequency counts"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected array of expected frequency counts"
    },
    {
        "oracle": ";",
        "javadocTag": "@return G-Test statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if {@code observed} has negative entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code expected} has entries that\nare not strictly positive"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths do not match or\nare less than 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed array of observed frequency counts"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected array of expected frequency counts"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if {@code observed} has negative entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code expected} has entries that\nare not strictly positive"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths do not match or\nare less than 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the\np-value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed array of observed frequency counts"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected array of expected frequency counts"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if {@code observed} has negative entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException {@code expected} has entries that are\nnot strictly positive"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths do not match or\nare less than 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the\np-value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed array of observed frequency counts"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected array of expected frequency counts"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level of the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff null hypothesis can be rejected with confidence 1 -\nalpha"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if {@code observed} has negative entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code expected} has entries that\nare not strictly positive"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths do not match or\nare less than 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the\np-value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if alpha is not strictly greater than zero\nand less than or equal to 0.5"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k 2 Dimensional Matrix of long values (for ex. the counts of a\ntrials)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Shannon Entropy of the given Matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Vector (for ex. Row Sums of a trials)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Shannon Entropy of the given Vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed1 array of observed frequency counts of the first data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed2 array of observed frequency counts of the second data\nset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return G-Test statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException the the lengths of the arrays do not\nmatch or their common length is less than 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if any entry in {@code observed1} or\n{@code observed2} is negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if either all counts of\n{@code observed1} or {@code observed2} are zero, or if the count\nat the same index is zero for both arrays."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k11 number of times the two events occurred together (AB)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k12 number of times the second event occurred WITHOUT the\nfirst event (notA,B)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k21 number of times the first event occurred WITHOUT the\nsecond event (A, notB)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k22 number of times something else occurred (i.e. was neither\nof these events (notA, notB)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return root log-likelihood ratio"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed1 array of observed frequency counts of the first data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed2 array of observed frequency counts of the second data\nset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if any of the entries in {@code observed1} or\n{@code observed2} are negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if either all counts of {@code observed1} or\n{@code observed2} are zero, or if the count at some index is\nzero for both arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the\np-value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed1 array of observed frequency counts of the first data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed2 array of observed frequency counts of the second data\nset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level of the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff null hypothesis can be rejected with confidence 1 -\nalpha"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException the the length of the arrays does not\nmatch"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if any of the entries in {@code observed1} or\n{@code observed2} are negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if either all counts of {@code observed1} or\n{@code observed2} are zero, or if the count at some index is\nzero for both arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code alpha} is not in the range\n(0, 0.5]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs performing the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if {@code x} or {@code y} are {@code null}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if {@code x} or {@code y} are zero-length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return concatenated array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y the second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the linear operator A of the system"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the right-hand side vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x0 the initial guess of the solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareOperatorException if {@code a} is not square"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code b} or {@code x0} have\ndimensions inconsistent with {@code a}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the manager"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the linear operator A of the system"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the right-hand side vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector containing the solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareOperatorException if {@code a} is not square"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code b} has dimensions\ninconsistent with {@code a}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException at exhaustion of the iteration count,\nunless a custom\n{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}\nhas been set at construction of the {@link IterationManager}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the linear operator A of the system"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the right-hand side vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x0 the initial guess of the solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector containing the solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareOperatorException if {@code a} is not square"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code b} or {@code x0} have\ndimensions inconsistent with {@code a}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException at exhaustion of the iteration count,\nunless a custom\n{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}\nhas been set at construction of the {@link IterationManager}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the linear operator A of the system"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the right-hand side vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x0 initial guess of the solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to {@code x0} (shallow copy) updated with the\nsolution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareOperatorException if {@code a} is not square"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code b} or {@code x0} have\ndimensions inconsistent with {@code a}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException at exhaustion of the iteration count,\nunless a custom\n{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}\nhas been set at construction of the {@link IterationManager}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param manager the custom iteration manager"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of entries."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to append to this one."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index of first element to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector containing the values to set."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the index is inconsistent with the vector\nsize."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to compare instance with."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the vectors do not\nhave the same dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Expected dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension is\ninconsistent with vector size."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if any coordinate of this vector is {@code NaN},\n{@code false} otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if any coordinate of this vector is infinite and\nnone are {@code NaN}, {@code false} otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Size of the vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Size of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param preset All entries will be set with this value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Data for the new vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyArray if {@code true}, the input array will be copied,\notherwise it will be referenced."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos Position of first entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Number of entries to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the size of {@code d} is less\nthan {@code pos + size}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param net Network."
    },
    {
        "oracle": ";",
        "javadocTag": "@param features Training data."
    },
    {
        "oracle": ";",
        "javadocTag": "@return absolute accuracy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return relative accuracy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return function accuracy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to solve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowedSolution The kind of solutions that the root-finding algorithm may\naccept as solutions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a value where the function is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if root cannot be bracketed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to solve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startValue Start value to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowedSolution The kind of solutions that the root-finding algorithm may\naccept as solutions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a value where the function is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if root cannot be bracketed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param functionValueAccuracy Function value accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximalOrder maximal order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Point at which the function value should be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException when the activated method itself can\nascertain that preconditions, specified in the API expressed at the\nlevel of the activated method, have been violated.  In the vast\nmajority of cases where Commons-Math throws IllegalArgumentException,\nit is the result of argument checking of actual parameters immediately\npassed to a method."
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of decimal digits this class is going to represent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factory factory linked to this instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factory factory linked to this instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factory factory linked to this instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factory factory linked to this instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factory factory linked to this instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factory factory linked to this instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string representation of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factory factory linked to this instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sign sign of the Dfp to create"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the Dfp must belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a string representation to split"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of two {@link Dfp} which sum is a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number to split"
    },
    {
        "oracle": ";",
        "javadocTag": "@return two elements array containing the split number"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first factor of the multiplication, in split form"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second factor of the multiplication, in split form"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a &times; b, in split form"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a dividend, in split form"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b divisor, in split form"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a / b, in split form"
    },
    {
        "oracle": ";",
        "javadocTag": "@param base number to raise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a power"
    },
    {
        "oracle": ";",
        "javadocTag": "@return base<sup>a</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param base number to raise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a power"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a power at which e should be raised"
    },
    {
        "oracle": ";",
        "javadocTag": "@return e<sup>a</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a power at which e should be raised"
    },
    {
        "oracle": ";",
        "javadocTag": "@return e<sup>a</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number from which logarithm is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return log(a)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number from which logarithm is requested, in split form"
    },
    {
        "oracle": ";",
        "javadocTag": "@return log(a)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x base to be raised"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y power to which base should be raised"
    },
    {
        "oracle": ";",
        "javadocTag": "@return x<sup>y</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number from which sine is desired, in split form"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sin(a)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number from which cosine is desired, in split form"
    },
    {
        "oracle": ";",
        "javadocTag": "@return cos(a)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number from which sine is desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sin(a)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number from which cosine is desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return cos(a)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number from which tangent is desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return tan(a)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number from which arc-tangent is desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return atan(a)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number from which arc-tangent is desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return atan(a)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number from which arc-sine is desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return asin(a)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number from which arc-cosine is desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return acos(a)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance with a value of 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance with value x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance with value x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance with value x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance with value x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance with the same value as d"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string representation of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance parsed from specified string"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if {@code set} is null"
    },
    {
        "oracle": "defaultTransformer==null;",
        "javadocTag": "@param defaultTransformer the transformer to use if no match, null means return null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "defaultTransformer==null;",
        "javadocTag": "@param defaultTransformer the transformer to use if no match, null means return null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return the transformed result"
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException if the key is {@code null} and this map\n           does not not permit {@code null} keys (optional)."
    },
    {
        "oracle": "value==null;",
        "javadocTag": "@throws NullPointerException if the value is {@code null} and this map\n           does not not permit {@code null} values (optional)."
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException key is {@code null} and this map does not\n        not permit {@code null} keys (optional)."
    },
    {
        "oracle": "this.containsKey(key) ? methodResultID==null : true;",
        "javadocTag": "@return the value to which this map maps the specified key, or\n        {@code null} if the map contains no mapping for this key."
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException the specified map is {@code null}, or if\n        this map does not permit {@code null} keys or values, and the\n        specified map contains {@code null} keys or values."
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException if the key is {@code null} and the composited map\n           does not not permit {@code null} keys (optional)."
    },
    {
        "oracle": "defaultValue==null;",
        "javadocTag": "@param defaultValue what to return if the value is null"
    },
    {
        "oracle": "defaultValue==null;",
        "javadocTag": "@param defaultValue what to return if the value is null or if the\n  conversion fails"
    },
    {
        "oracle": "defaultValue==null;",
        "javadocTag": "@param defaultValue what to return if the value is null or if the\n  conversion fails"
    },
    {
        "oracle": "defaultValue==null;",
        "javadocTag": "@param defaultValue what to return if the value is null or if the\n  conversion fails"
    },
    {
        "oracle": "defaultValue==null;",
        "javadocTag": "@param defaultValue what to return if the value is null or if the\n  conversion fails"
    },
    {
        "oracle": "defaultValue==null;",
        "javadocTag": "@param defaultValue what to return if the value is null or if the\n  conversion fails"
    },
    {
        "oracle": "defaultValue==null;",
        "javadocTag": "@param defaultValue what to return if the value is null or if the\n  conversion fails"
    },
    {
        "oracle": "defaultValue==null;",
        "javadocTag": "@param defaultValue what to return if the value is null or if the\n  conversion fails"
    },
    {
        "oracle": "defaultValue==null;",
        "javadocTag": "@param defaultValue what to return if the value is null or if the\n  conversion fails"
    },
    {
        "oracle": "defaultValue==null;",
        "javadocTag": "@param defaultValue what to return if the value is null or if the\n  conversion fails"
    },
    {
        "oracle": "resourceBundle==null;",
        "javadocTag": "@throws NullPointerException if the bundle is null"
    },
    {
        "oracle": "(resourceBundle==null) == false;",
        "javadocTag": "@param resourceBundle the resource bundle to convert, may not be null"
    },
    {
        "oracle": "(out==null) == false;",
        "javadocTag": "@param out the stream to print to, must not be null"
    },
    {
        "oracle": "(out==null) == false;",
        "javadocTag": "@param out the stream to print to, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to invert, may not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to add to, may not be null"
    },
    {
        "oracle": "value==null;",
        "javadocTag": "@param value the value, null converted to \"\""
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to populate, must not be null"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@param array an array to populate from, null ignored"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to synchronize, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to make unmodifiable, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the Map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to predicate, must not be null"
    },
    {
        "oracle": "keyPred==null;",
        "javadocTag": "@param keyPred the predicate for keys, null means no check"
    },
    {
        "oracle": "valuePred==null;",
        "javadocTag": "@param valuePred the predicate for values, null means no check"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the Map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to transform, must not be null, typically empty"
    },
    {
        "oracle": "keyTransformer==null;",
        "javadocTag": "@param keyTransformer the transformer for the map keys, null means no transformation"
    },
    {
        "oracle": "valueTransformer==null;",
        "javadocTag": "@param valueTransformer the transformer for the map values, null means no transformation"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the Map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map whose size to fix, must not be null"
    },
    {
        "oracle": "map==null || factory==null;",
        "javadocTag": "@throws NullPointerException if the Map or Factory is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to make lazy, must not be null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory for creating new objects, must not be null"
    },
    {
        "oracle": "map==null || transformerFactory==null;",
        "javadocTag": "@throws NullPointerException if the Map or Transformer is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to make lazy, must not be null"
    },
    {
        "oracle": "(transformerFactory==null) == false;",
        "javadocTag": "@param transformerFactory the factory for creating new objects, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the Map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to order, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to synchronize, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the sorted map to make unmodifiable, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the SortedMap is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to predicate, must not be null"
    },
    {
        "oracle": "keyPred==null;",
        "javadocTag": "@param keyPred the predicate for keys, null means no check"
    },
    {
        "oracle": "valuePred==null;",
        "javadocTag": "@param valuePred the predicate for values, null means no check"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the SortedMap is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to transform, must not be null, typically empty"
    },
    {
        "oracle": "keyTransformer==null;",
        "javadocTag": "@param keyTransformer the transformer for the map keys, null means no transformation"
    },
    {
        "oracle": "valueTransformer==null;",
        "javadocTag": "@param valueTransformer the transformer for the map values, null means no transformation"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the SortedMap is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map whose size to fix, must not be null"
    },
    {
        "oracle": "map==null || factory==null;",
        "javadocTag": "@throws NullPointerException if the SortedMap or Factory is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to make lazy, must not be null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory for creating new objects, must not be null"
    },
    {
        "oracle": "map==null || transformerFactory==null;",
        "javadocTag": "@throws NullPointerException if the Map or Transformer is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to make lazy, must not be null"
    },
    {
        "oracle": "(transformerFactory==null) == false;",
        "javadocTag": "@param transformerFactory the factory for creating new objects, must not be null"
    },
    {
        "oracle": "map==null || keyTransformer==null;",
        "javadocTag": "@throws NullPointerException if the map, elements or transformer are null"
    },
    {
        "oracle": "map==null || keyTransformer==null || valueTransformer==null;",
        "javadocTag": "@throws NullPointerException if the map, elements or transformers are null"
    },
    {
        "oracle": "map==null || keyTransformer==null;",
        "javadocTag": "@throws NullPointerException if the map, elements or transformer are null"
    },
    {
        "oracle": "map==null || keyTransformer==null || valueTransformer==null;",
        "javadocTag": "@throws NullPointerException if the map, collection or transformers are null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "sortedMap==null;",
        "javadocTag": "@throws NullPointerException if sortedMap is null"
    },
    {
        "oracle": "coll==null;",
        "javadocTag": "@throws NullPointerException if coll is null"
    },
    {
        "oracle": "map==null || factory==null;",
        "javadocTag": "@throws NullPointerException if map or factory is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory to use, must not be null"
    },
    {
        "oracle": "map==null || factory==null;",
        "javadocTag": "@throws NullPointerException if map or factory is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory to use, must not be null"
    },
    {
        "oracle": "map==null || factory==null;",
        "javadocTag": "@throws NullPointerException if map or factory is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory to use, must not be null"
    },
    {
        "oracle": "map==null || factory==null;",
        "javadocTag": "@throws NullPointerException if map or factory is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory to use, must not be null"
    },
    {
        "oracle": "multiset==null;",
        "javadocTag": "@throws NullPointerException if multiset is null"
    },
    {
        "oracle": "(multiset==null) == false;",
        "javadocTag": "@param multiset the multiset to decorate, must not be null"
    },
    {
        "oracle": "queue==null;",
        "javadocTag": "@throws NullPointerException if queue is null"
    },
    {
        "oracle": "(queue==null) == false;",
        "javadocTag": "@param queue the queue to decorate, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the distribution has been loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed random generator seed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the index of the bin"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the probability that selection begins in bin i"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the index of the bin"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the probability that selection begins in a bin below bin i."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i index of the bin"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the difference in the within-bin kernel cdf between the\nupper and lower endpoints of bin i"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value to locate within a bin"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the within-bin kernel of the bin containing x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param binIndex maximum bin index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sum of the probabilities of bins through binIndex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bStats summary statistics for the bin"
    },
    {
        "oracle": ";",
        "javadocTag": "@return within-bin kernel parameterized by bStats"
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator random data generator (may be null, resulting in default JDK generator)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator random data generator (may be null, resulting in default JDK generator)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param binCount number of bins"
    },
    {
        "oracle": ";",
        "javadocTag": "@param randomData random data generator (may be null, resulting in default JDK generator)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param randomData random data generator (may be null, resulting in default JDK generator)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param binCount number of bins. Must be strictly positive."
    },
    {
        "oracle": ";",
        "javadocTag": "@param randomData Random data generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code binCount <= 0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param is the input stream to read the direction vector from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the last dimension that has been read from the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if the stream could not be read"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathParseException if the content could not be parsed successfully"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d the dimension, zero-based"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the coefficients of the primitive polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m the initial direction numbers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index in the sequence to skip to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the i-th point in the Sobol sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the next point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension the space dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension the space dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param is the stream to read the direction vectors from"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if the space dimension is &lt; 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the space dimension is outside the range [1, max], where\n  max refers to the maximum dimension found in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathParseException if the content in the stream could not be parsed successfully"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an error occurs while reading from the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integers array), if null\nthe seed of the generator will be the current system time plus the\nsystem identity hash code of this instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (64 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bits number of random bits to produce"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random bits generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integers array), if null\nthe seed of the generator will be related to the current time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (64 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension Space dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rand RNG for the individual components of the vectors."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension Space dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a element to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new element representing this + a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a element to subtract"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new element representing this - a"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the opposite of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of times {@code this} must be added to itself."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A new element representing n &times; this."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a element to multiply"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new element representing this &times; a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a element to divide by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new element representing this &divide; a"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if {@code a} is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if {@code this} is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link Field} to which the instance belongs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return available complex format locales."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f BigFraction object to format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return A formatted BigFraction in proper form."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default complex format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale the specific locale used by the format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the complex format specific to the given locale."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default complex format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale the specific locale used by the format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the complex format specific to the given locale."
    },
    {
        "oracle": ";",
        "javadocTag": "@param BigFraction the object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if <code>obj</code> is not a valid type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link BigFraction} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathParseException if the beginning of the specified string\n           cannot be parsed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/output parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link BigFraction} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/output parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a parsed <code>BigInteger</code> or null if string does not\ncontain a BigInteger at the specified position"
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for both the numerator and denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numeratorFormat the custom format for the numerator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param denominatorFormat the custom format for the denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the absolute value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return -1 if this is less than {@code object}, +1 if this is greater\n        than {@code object}, 0 if they are equal."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fraction as a {@code double}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other fraction to test for equality to this fraction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialBracketingRange Extent of the initial interval used to\nfind an interval that brackets the optimum.\nIf the optimized function varies a lot in the vicinity of the optimum,\nit may be necessary to provide a value lower than the distance between\nsuccessive local minima."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to be optimized."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. In addition to those documented in\n{@link BaseMultivariateOptimizer#parseOptimizationData(OptimizationData[])\nBaseMultivariateOptimizer}, this method will register the following data:\n<ul>\n <li>{@link ObjectiveFunction}</li>\n <li>{@link GoalType}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data.\nThe following data will be looked for:\n<ul>\n <li>{@link ObjectiveFunction}</li>\n <li>{@link GoalType}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the optimization type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param params Point at which the objective function must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective function value at the specified point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the dimension of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param evaluationFunction Evaluation function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator Comparator to use to sort simplex vertices from best\nto worst."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startPoint First point of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the start point does not match\nsimplex dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param evaluationFunction Evaluation function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator Comparator to use to sort simplex vertices from best to worst."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pointValuePair Point to insert."
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator Comparator to use for sorting the simplex vertices\nfrom best to worst."
    },
    {
        "oracle": ";",
        "javadocTag": "@return all the simplex points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Location."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point at location {@code index}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Location."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point New value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param points New Points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the hypercube."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sideLength Length of the sides of the hypercube."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the steps."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sideLength Length of the sides of the hypercube."
    },
    {
        "oracle": ";",
        "javadocTag": "@param steps Steps along the canonical axes representing box edges. They\nmay be negative but not zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param referenceSimplex Reference simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if the reference simplex does not\ncontain at least one point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if there is a dimension mismatch\nin the reference simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if one of its vertices is duplicated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. In addition to those documented in\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\nMultivariateOptimizer}, this method will register the following data:\n<ul>\n <li>{@link AbstractSimplex}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data.\nThe following data will be looked for:\n<ul>\n <li>{@link AbstractSimplex}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathUnsupportedOperationException if bounds were passed to the\n{@link #optimize(OptimizationData[]) optimize} method."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if no initial simplex was passed to the\n{@link #optimize(OptimizationData[]) optimize} method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel Relative threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abs Absolute threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound Lower bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound Upper bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the objective at the optimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound Lower bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound Upper bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the objective at the optimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param knew "
    },
    {
        "oracle": ";",
        "javadocTag": "@param adelt "
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound Lower bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound Upper bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta "
    },
    {
        "oracle": ";",
        "javadocTag": "@param gnew "
    },
    {
        "oracle": ";",
        "javadocTag": "@param xbdi "
    },
    {
        "oracle": ";",
        "javadocTag": "@param s "
    },
    {
        "oracle": ";",
        "javadocTag": "@param hs "
    },
    {
        "oracle": ";",
        "javadocTag": "@param hred "
    },
    {
        "oracle": ";",
        "javadocTag": "@param beta "
    },
    {
        "oracle": ";",
        "javadocTag": "@param denom "
    },
    {
        "oracle": ";",
        "javadocTag": "@param knew "
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound Lower bounds (constraints) of the objective variables."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound Upperer bounds (constraints) of the objective variables."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfInterpolationPoints Number of interpolation conditions.\nFor a problem of dimension {@code n}, its value must be in the interval\n{@code [n+2, (n+1)(n+2)/2]}.\nChoices that exceed {@code 2n+1} are not recommended."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfInterpolationPoints Number of interpolation conditions.\nFor a problem of dimension {@code n}, its value must be in the interval\n{@code [n+2, (n+1)(n+2)/2]}.\nChoices that exceed {@code 2n+1} are not recommended."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialTrustRegionRadius Initial trust region radius."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stoppingTrustRegionRadius Stopping trust region radius."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sideLength Length of the sides of the default (hypercube)\nsimplex. See {@link AbstractSimplex#AbstractSimplex(int,double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex. See\n{@link AbstractSimplex#AbstractSimplex(int,double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sideLength Length of the sides of the default (hypercube)\nsimplex. See {@link AbstractSimplex#AbstractSimplex(int,double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rho Reflection coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sigma Shrinkage coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex. See\n{@link AbstractSimplex#AbstractSimplex(int)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rho Reflection coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sigma Shrinkage coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param steps Steps along the canonical axes representing box edges.\nThey may be negative but not zero. See"
    },
    {
        "oracle": ";",
        "javadocTag": "@param steps Steps along the canonical axes representing box edges.\nThey may be negative but not zero. See\n{@link AbstractSimplex#AbstractSimplex(double[])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rho Reflection coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sigma Shrinkage coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param referenceSimplex Reference simplex. See\n{@link AbstractSimplex#AbstractSimplex(double[][])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param referenceSimplex Reference simplex. See\n{@link AbstractSimplex#AbstractSimplex(double[][])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rho Reflection coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sigma Shrinkage coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxOffset offset below which a cut sub-hyperplane is considered\nclose to the point (in absolute value)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return close cells (may be empty if all cut sub-hyperplanes are farther\nthan maxOffset from the point)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxOffset offset below which a cut sub-hyperplane is considered\nclose to the point (in absolute value)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param close list to fill"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tree other tree to merge with the instance (will be\n<em>unusable</em> after the operation, as well as the\ninstance itself)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param leafMerger object implementing the final merging phase\n(this is where the semantic of the operation occurs, generally\ndepending on the attribute of the leaf node)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new tree, result of <code>instance &lt;op&gt;\ntree</code>, this value can be ignored if parentTree is not null\nsince all connections have already been established"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tree other tree to merge with the instance (will be\n<em>unusable</em> after the operation, as well as the\ninstance itself)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param leafMerger object implementing the final merging phase\n(this is where the semantic of the operation occurs, generally\ndepending on the attribute of the leaf node)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parentTree parent tree to connect to (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isPlusChild if true and if parentTree is not null, the\nresulting tree should be the plus child of its parent, ignored if\nparentTree is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new tree, result of <code>instance &lt;op&gt;\ntree</code>, this value can be ignored if parentTree is not null\nsince all connections have already been established"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sub partitioning sub-hyperplane, must be already clipped\nto the convex region represented by the instance, will be used as\nthe cut sub-hyperplane of the returned tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a tree having the specified sub-hyperplane as its cut\nsub-hyperplane, the two parts of the split instance as its two\nsub-trees and a null parent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parentTree parent tree to connect to (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parentTree parent tree to connect to (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vanishingHandler handler to use for handling very rare corner\ncases of vanishing cut sub-hyperplanes in internal nodes during merging"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cellAttribute attribute to set for the leaf node\ncorresponding to the initial instance cell"
    },
    {
        "oracle": ";",
        "javadocTag": "@param otherLeafsAttributes attribute to set for the other leaf\nnodes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param internalAttributes attribute to set for the internal nodes"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new tree (the original tree is left untouched) containing\na single branch with the cell as a leaf node, and other leaf nodes\nas the remnants of the pruned branches"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane chopping hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vanishingHandler handler to use for handling very rare corner\ncases of vanishing cut sub-hyperplanes in internal nodes during merging"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane chopping hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vanishingHandler handler to use for handling very rare corner\ncases of vanishing cut sub-hyperplanes in internal nodes during merging"
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute attribute of the tree (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cut cut sub-hyperplane for the tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param plus plus side sub-tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minus minus side sub-tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute attribute associated with the node (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplanes collection of bounding hyperplanes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param region1 first region (will be unusable after the operation as\nparts of it will be reused in the new region)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param region2 second region (will be unusable after the operation as\nparts of it will be reused in the new region)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new region, result of {@code region1 union region2}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param region1 first region (will be unusable after the operation as\nparts of it will be reused in the new region)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param region2 second region (will be unusable after the operation as\nparts of it will be reused in the new region)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new region, result of {@code region1 intersection region2}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param region1 first region (will be unusable after the operation as\nparts of it will be reused in the new region)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param region2 second region (will be unusable after the operation as\nparts of it will be reused in the new region)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new region, result of {@code region1 xor region2}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param region1 first region (will be unusable after the operation as\nparts of it will be reused in the new region)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param region2 second region (will be unusable after the operation as\nparts of it will be reused in the new region)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new region, result of {@code region1 minus region2}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param region region to complement, it will not modified, a new\nregion independent region will be built"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new region, complement of the specified one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current node of the original tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@return new tree, complement of the node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current node of the original tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map transformed nodes map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return new tree, complement of the node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return size of the boundary"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element element to insert (silently ignored if null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element element to delete (silently ignored if null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the element was deleted from the tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the tree is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of elements contained in the tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reference reference object (may not be in the tree)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reference reference object (may not be in the tree)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minOffset minimal scale of the offset to add to all\ncomponents (must be greater than the MSBs of all components)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ot T-uple to compare instance with"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a negative integer if the instance is less than the\nobject, zero if they are equal, or a positive integer if the\ninstance is greater than the object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return array containing the T-uple components"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bits binary representation of the double"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sign bit (zero if positive, non zero if negative)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bits binary representation of the double"
    },
    {
        "oracle": ";",
        "javadocTag": "@return exponent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bits binary representation of the double"
    },
    {
        "oracle": ";",
        "javadocTag": "@return mantissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l long from which the most significant bit is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return scale of the most significant bit of {@code l},\nor 0 if {@code l} is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l long from which the least significant bit is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return scale of the least significant bit of {@code l},\nor 63 if {@code l} is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i index of the component"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k scale of the requested bit"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the specified bit (either 0 or 1), after the offset has\nbeen added to the double"
    },
    {
        "oracle": ";",
        "javadocTag": "@param components double components of the T-uple"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node BSP node guaranteed to have a non null cut sub-hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return desired visit order, must be one of\n{@link Order#PLUS_MINUS_SUB}, {@link Order#PLUS_SUB_MINUS},\n{@link Order#MINUS_PLUS_SUB}, {@link Order#MINUS_SUB_PLUS},\n{@link Order#SUB_PLUS_MINUS}, {@link Order#SUB_MINUS_PLUS}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node BSP node guaranteed to have a non null cut sub-hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node leaf BSP node having a null sub-hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new hyperplane, copy of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to project"
    },
    {
        "oracle": ";",
        "javadocTag": "@return tolerance below which points are considered to belong to the hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other other hyperplane to check against the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the instance and the other hyperplane have\nthe same orientation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a sub-hyperplane covering the whole hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a region containing the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point n-dimension point of the space"
    },
    {
        "oracle": ";",
        "javadocTag": "@return (n-1)-dimension point of the sub-space corresponding to\nthe specified space point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point (n-1)-dimension point of the sub-space"
    },
    {
        "oracle": ";",
        "javadocTag": "@return n-dimension point of the space corresponding to the\nspecified sub-space point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return part of the node cut sub-hyperplane that belongs to the\nboundary and has the outside of the region on the plus side of\nits underlying hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return part of the node cut sub-hyperplane that belongs to the\nboundary and has the inside of the region on the plus side of\nits underlying hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sub-hyperplanes that were used to split the boundary part"
    },
    {
        "oracle": ";",
        "javadocTag": "@param plusOutside part of the node cut sub-hyperplane that\nbelongs to the boundary and has the outside of the region on\nthe plus side of its underlying hyperplane (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param plusInside part of the node cut sub-hyperplane that\nbelongs to the boundary and has the inside of the region on the\nplus side of its underlying hyperplane (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dim the dimension of the square covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dim the dimension of the covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param biasCorrected if <code>true</code> the covariance estimate is corrected\nfor bias, i.e. n-1 in the denominator, otherwise there is no bias correction,\ni.e. n in the denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the x value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y the y value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cov StorelessBivariateCovariance instance to append."
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of observations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current covariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of observations\nis &lt; 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param biasCorrection if <code>true</code> the covariance estimate is corrected\nfor bias, i.e. n-1 in the denominator, otherwise there is no bias correction,\ni.e. n in the denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return correlation matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix with columns representing variables to correlate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return correlation matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix with columns representing variables to correlate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return correlation matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xArray first data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yArray second data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Returns Kendall's Tau rank correlation coefficient for the two arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the arrays lengths do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the summation end"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of the number from 1 to n"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data rectangular array with columns representing variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the input data array is not\nrectangular with at least two rows and two columns."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix with columns representing variables to correlate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of observations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix input matrix (must have at least one column and two rows)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param biasCorrected determines whether or not covariance estimates are bias-corrected"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the matrix does not contain sufficient data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix input matrix (must have at least one column and two rows)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if matrix does not contain sufficient data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data input array (must have at least one column and two rows)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param biasCorrected determines whether or not covariance estimates are bias-corrected"
    },
    {
        "oracle": ";",
        "javadocTag": "@return covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the data array does not contain sufficient\ndata"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if the input data array is not\nrectangular with at least one row and one column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param data input array (must have at least one column and two rows)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the data array does not contain sufficient data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if the input data array is not\nrectangular with at least one row and one column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xArray first data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yArray second data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param biasCorrected if true, returned value will be bias-corrected"
    },
    {
        "oracle": ";",
        "javadocTag": "@return returns the covariance for the two arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the arrays lengths do not match or\nthere is insufficient data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xArray first data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yArray second data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return returns the covariance for the two arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the arrays lengths do not match or\nthere is insufficient data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the matrix does not contain sufficient data\nto compute covariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data rectangular array with columns representing covariates"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the input data array is not\nrectangular with at least two rows and one column."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if the input data array is not\nrectangular with at least one row and one column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param data rectangular array with columns representing covariates"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the input data array is not\nrectangular with at least two rows and one column."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if the input data array is not\nrectangular with at least one row and one column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix with columns representing covariates"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the input matrix does not have\nat least two rows and one column"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix with columns representing covariates"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the input matrix does not have\nat least two rows and one column"
    },
    {
        "oracle": ";",
        "javadocTag": "@return correlation matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return matrix of correlation standard errors"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if this instance was created with no data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return matrix of p-values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.MaxCountExceededException if an error occurs estimating probabilities"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if this instance was created with no data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix with columns representing variables to correlate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return correlation matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the matrix does not contain sufficient data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data matrix with columns representing variables to correlate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return correlation matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the array does not contain sufficient data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xArray first data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yArray second data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Returns Pearson's correlation coefficient for the two arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the arrays lengths do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if there is insufficient data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param covarianceMatrix the covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return correlation matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix to check for sufficiency"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if there is insufficient data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data rectangular array with columns representing variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the input data array is not\nrectangular with at least two rows and two columns."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix with columns representing variables to correlate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the matrix does not contain sufficient data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param covariance Covariance instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param covarianceMatrix covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfObservations the number of observations in the dataset used to compute\nthe covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Spearman Rank Correlation Matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if this instance was created with no data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return PearsonsCorrelation among ranked column data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix with columns representing variables to correlate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return correlation matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix with columns representing variables to correlate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return correlation matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xArray first data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yArray second data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Returns Spearman's rank correlation coefficient for the two arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the arrays lengths do not match"
    },
    {
        "oracle": "p!=null;",
        "javadocTag": "@param p non-null Process to limit the execution of"
    },
    {
        "oracle": "p!=null;",
        "javadocTag": "@param p non-null Process to limit the execution of"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if the array has length 0"
    },
    {
        "oracle": "a.length==2;",
        "javadocTag": "@param a a 2d array"
    },
    {
        "oracle": "a.length==2;",
        "javadocTag": "@param a a 2d array"
    },
    {
        "oracle": "obj==null;",
        "javadocTag": "@throws IllegalArgumentException if obj is null or is not one of the types mentioned above."
    },
    {
        "oracle": "obj==null;",
        "javadocTag": "@throws IllegalArgumentException if obj is null or is not one of the types mentioned above."
    },
    {
        "oracle": "arange==0;",
        "javadocTag": "@param arange length of the argument's range and the result's domain"
    },
    {
        "oracle": "initialCapacity<0 || loadFactor<=0;",
        "javadocTag": "@throws IllegalArgumentException If the initial capacity is negative,\n     or if the load factor is nonpositive."
    },
    {
        "oracle": "initialCapacity<0;",
        "javadocTag": "@throws IllegalArgumentException If the initial capacity is negative."
    },
    {
        "oracle": "t==null;",
        "javadocTag": "@throws NullPointerException if the specified map is null."
    },
    {
        "oracle": "m==null;",
        "javadocTag": "@throws NullPointerException if the specified map is null."
    },
    {
        "oracle": "true ? (methodResultID==key||methodResultID==null) : true;",
        "javadocTag": "@return the object in this set that is equal to key, or null"
    },
    {
        "oracle": "n==1 ? methodResultID.equals(noun) : methodResultID.equals(noun);",
        "javadocTag": "@return noun, if n==1; otherwise, pluralization of noun"
    },
    {
        "oracle": "true ? methodResultID.equals(s) : true;",
        "javadocTag": "@return s truncated or padded to length characters"
    },
    {
        "oracle": "true ? methodResultID.equals(s) : true;",
        "javadocTag": "@return s truncated or padded to length characters"
    },
    {
        "oracle": "filename!=null;",
        "javadocTag": "@param filename non-null file name for stream being read"
    },
    {
        "oracle": "(RegexUtil.isRegex(s,groups)) == false;",
        "javadocTag": "@throws Error if argument is not a regex"
    },
    {
        "oracle": "true ? methodResultID.equals(s) : true;",
        "javadocTag": "@return its argument"
    },
    {
        "oracle": "true ? methodResultID==x*y : true;",
        "javadocTag": "@return x * y"
    },
    {
        "oracle": "true ? methodResultID==x*y : true;",
        "javadocTag": "@return x * y"
    },
    {
        "oracle": "true ? methodResultID==x*y : true;",
        "javadocTag": "@return x * y"
    },
    {
        "oracle": "true ? methodResultID==x/y : true;",
        "javadocTag": "@return x / y"
    },
    {
        "oracle": "true ? methodResultID==x/y : true;",
        "javadocTag": "@return x / y"
    },
    {
        "oracle": "true ? methodResultID==x/y : true;",
        "javadocTag": "@return x / y"
    },
    {
        "oracle": "true ? methodResultID==x%y : true;",
        "javadocTag": "@return x % y"
    },
    {
        "oracle": "true ? methodResultID==x%y : true;",
        "javadocTag": "@return x % y"
    },
    {
        "oracle": "true ? methodResultID==x<<y : true;",
        "javadocTag": "@return x &lt;&lt; y"
    },
    {
        "oracle": "true ? methodResultID==x<<y : true;",
        "javadocTag": "@return x &lt;&lt; y"
    },
    {
        "oracle": "true ? methodResultID==x>>y : true;",
        "javadocTag": "@return x &gt;&gt; y"
    },
    {
        "oracle": "true ? methodResultID==x>>y : true;",
        "javadocTag": "@return x &gt;&gt; y"
    },
    {
        "oracle": "true ? methodResultID==x>>>y : true;",
        "javadocTag": "@return x &gt;&gt;&gt; y"
    },
    {
        "oracle": "true ? methodResultID==x>>>y : true;",
        "javadocTag": "@return x &gt;&gt;&gt; y"
    },
    {
        "oracle": "true ? methodResultID==x&y : true;",
        "javadocTag": "@return x &amp; y"
    },
    {
        "oracle": "true ? methodResultID==x&y : true;",
        "javadocTag": "@return x &amp; y"
    },
    {
        "oracle": "true ? (methodResultID==0||methodResultID==1) : true;",
        "javadocTag": "@return the logical and of x and y; the result is always 0 or 1"
    },
    {
        "oracle": "true ? (methodResultID==0||methodResultID==1) : true;",
        "javadocTag": "@return the logical and of x and y; the result is always 0 or 1"
    },
    {
        "oracle": "true ? methodResultID==x^y : true;",
        "javadocTag": "@return x ^ y"
    },
    {
        "oracle": "true ? methodResultID==x^y : true;",
        "javadocTag": "@return x ^ y"
    },
    {
        "oracle": "true ? (methodResultID==0||methodResultID==1) : true;",
        "javadocTag": "@return the logical xor of x and y; the result is always 0 or 1"
    },
    {
        "oracle": "true ? (methodResultID==0||methodResultID==1) : true;",
        "javadocTag": "@return the logical xor of x and y; the result is always 0 or 1"
    },
    {
        "oracle": "true ? methodResultID==x|y : true;",
        "javadocTag": "@return x | y"
    },
    {
        "oracle": "true ? methodResultID==x|y : true;",
        "javadocTag": "@return x | y"
    },
    {
        "oracle": "true ? (methodResultID==0||methodResultID==1) : true;",
        "javadocTag": "@return the logical or of x and y; the result is always 0 or 1"
    },
    {
        "oracle": "true ? (methodResultID==0||methodResultID==1) : true;",
        "javadocTag": "@return the logical or of x and y; the result is always 0 or 1"
    },
    {
        "oracle": "true ? methodResultID == base : true;",
        "javadocTag": "@return base to the expt power"
    },
    {
        "oracle": "true ? methodResultID == base : true;",
        "javadocTag": "@return base to the expt power"
    },
    {
        "oracle": "true ? methodResultID==x%y : true;",
        "javadocTag": "@return x % y, where the result is constrained to be positive"
    },
    {
        "oracle": "true ? methodResultID==x%y : true;",
        "javadocTag": "@return x % y, where the result is constrained to be positive"
    },
    {
        "oracle": "initialCapacity<0 || loadFactor<=0;",
        "javadocTag": "@throws IllegalArgumentException If the initial capacity is less than\n                                  zero, or if the load factor is\n                                  nonpositive"
    },
    {
        "oracle": "initialCapacity<0;",
        "javadocTag": "@throws IllegalArgumentException If the initial capacity is less than\n                                  zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to negate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return negative of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to negate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return negative of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to negate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return negative of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to bitwise-complement"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ~a, the bitwise complement of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to bitwise-complement"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ~a, the bitwise complement of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first multiplicand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second multiplicand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first multiplicand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second multiplicand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first multiplicand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second multiplicand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x dividend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y divisor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x dividend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y divisor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x dividend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y divisor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x valued to be modded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y modulus"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x valued to be modded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y modulus"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x valued to be left-shifted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y magnitude of the left-shift"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x valued to be left-shifted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y magnitude of the left-shift"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x valued to be right-shifted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y magnitude of the right-shift"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x valued to be right-shifted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y magnitude of the right-shift"
    },
    {
        "oracle": ";",
        "javadocTag": "@param address the InetAddress to increment"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new InetAddress that is one more than the passed in address"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if InetAddress is at the end of its range"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the InetAddress is either 255.255.255.255 for IPv4 or\n    ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a validated port number, in the range [0..65535]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if no port is defined.  You can use\n        {@link #withDefaultPort(int)} to prevent this from occurring."
    },
    {
        "oracle": ";",
        "javadocTag": "@param host the host string to parse.  Must not contain a port number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param port a port number from [0..65535]"
    },
    {
        "oracle": ";",
        "javadocTag": "@return if parsing was successful, a populated HostAndPort object."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code host} contains a port number,\n    or {@code port} is out of range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param host the host-only string to parse.  Must not contain a port number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return if parsing was successful, a populated HostAndPort object."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code host} contains a port number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hostPortString the input string to parse."
    },
    {
        "oracle": ";",
        "javadocTag": "@return if parsing was successful, a populated HostAndPort object."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if nothing meaningful could be parsed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hostPortString the full bracketed host-port specification. Post might not be specified."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array with 2 strings: host and port, in that order."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if parsing the bracketed host-port string fails."
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultPort a port number, from [0..65535]"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a HostAndPort instance, guaranteed to have a defined port."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this}, to enable chaining of calls."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if bracketless IPv6 is detected."
    },
    {
        "oracle": ";",
        "javadocTag": "@param h hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hash the hash code for the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the segment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the String representation of the {@link #sum}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExecutionException if a checked exception was thrown while loading the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UncheckedExecutionException if an unchecked exception was thrown while loading the\n    value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExecutionError if an error was thrown while loading the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the weight of the entry; must be non-negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param listener the backing listener"
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor the executor with which removal notifications are\n    asynchronously executed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExecutionException if a checked exception was thrown while loading the value. ({@code\n    ExecutionException} is thrown <a\n    href=\"https://github.com/google/guava/wiki/CachesExplained#interruption\">even if\n    computation was interrupted by an {@code InterruptedException}</a>.)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UncheckedExecutionException if an unchecked exception was thrown while loading the\n    value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExecutionError if an error was thrown while loading the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UncheckedExecutionException if an exception was thrown while loading the value. (As\n    explained in the last paragraph above, this should be an unchecked exception only.)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExecutionError if an error was thrown while loading the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExecutionException if a checked exception was thrown while loading the value. ({@code\n    ExecutionException} is thrown <a\n    href=\"https://github.com/google/guava/wiki/CachesExplained#interruption\">even if\n    computation was interrupted by an {@code InterruptedException}</a>.)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UncheckedExecutionException if an unchecked exception was thrown while loading the\n    values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExecutionError if an error was thrown while loading the values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UncheckedExecutionException if an exception was thrown while loading the value. (As\n    described in the documentation for {@link #getUnchecked}, {@code LoadingCache} should be\n    used as a {@code Function} only with cache loaders that throw only unchecked exceptions.)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws Exception if unable to load the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InterruptedException if this method is interrupted. {@code InterruptedException} is\n    treated like any other {@code Exception} in all respects except that, when it is caught,\n    the thread's interrupt status is set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws Exception if unable to reload the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InterruptedException if this method is interrupted. {@code InterruptedException} is\n    treated like any other {@code Exception} in all respects except that, when it is caught,\n    the thread's interrupt status is set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keys the unique, non-null keys whose values should be loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map from each key in {@code keys} to the value associated with that key;\n    <b>may not contain null values</b>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws Exception if unable to load the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InterruptedException if this method is interrupted. {@code InterruptedException} is\n    treated like any other {@code Exception} in all respects except that, when it is caught,\n    the thread's interrupt status is set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a cache loader that loads values by passing each key to {@code function}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a cache loader that loads values by calling {@link Supplier#get}, irrespective of the\n    key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param spec a String in the format specified by {@link CacheBuilderSpec}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if an initial capacity was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if a concurrency level was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the maximum size of the cache"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if a maximum size or weight was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight the maximum total weight of entries the cache may contain"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if a maximum weight or size was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weigher the weigher to use in calculating the weight of cache entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if a maximum size was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the key strength was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the value strength was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the value strength was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param duration the length of time after an entry is created that it should be automatically\n    removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the unit that {@code duration} is expressed in"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the time to live or time to idle was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param duration the length of time after an entry is last accessed that it should be\n    automatically removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the unit that {@code duration} is expressed in"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the time to idle or time to live was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param duration the length of time after an entry is created that it should be considered\n    stale, and thus eligible for refresh"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the unit that {@code duration} is expressed in"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the refresh interval was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if a ticker was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cache builder reference that should be used instead of {@code this} for any\n    remaining configuration and cache building"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if a removal listener was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loader the cache loader used to obtain new values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a cache having the requested features"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a cache having the requested features"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cacheBuilderSpecification the string form"
    },
    {
        "oracle": ";",
        "javadocTag": "@param currentValue the current value (of either base or a cell)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue the argument from a user update call"
    },
    {
        "oracle": ";",
        "javadocTag": "@return result of the update function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hc the hash code holder"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a sun.misc.Unsafe"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the length of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param listener A {@code IterationListener} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e The {@link IterationEvent} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e The {@link IterationEvent} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e The {@link IterationEvent} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e The {@link IterationEvent} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum number of iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the maximum number of iterations is\nreached."
    },
    {
        "oracle": ";",
        "javadocTag": "@param listener The {@link IterationListener} to be removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param callBack the function to be called when the maximum number of\niterations has been reached"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NullArgumentException if {@code callBack} is {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param callBack the function to be called when the maximum number of\niterations has been reached"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NullArgumentException if {@code callBack} is {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default number format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale the specific locale used by the format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default number format specific to the given locale."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/output parsing parameter.  On output, <code>pos</code>\n       holds the index of the next non-whitespace character."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/output parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first non-whitespace character."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the special value to parse."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/output parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the special number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the number format used to parse normal, numeric values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/output parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected expected string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/output parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the expected string was there"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the double to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the format used."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@return pivoting strategy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param work work array to use to find out the K<sup>th</sup> value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pivotsHeap cached pivots heap that can be used for efficient estimation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the index whose value in the array is of interest"
    },
    {
        "oracle": ";",
        "javadocTag": "@return K<sup>th</sup> value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param work work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first element of the slice of work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end index after the last element of the slice of work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pivot initial index of the pivot"
    },
    {
        "oracle": ";",
        "javadocTag": "@return index of the pivot after partition"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pivotingStrategy pivoting strategy to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of iterations performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the iterative algorithm on which the event initially\noccurred"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterations the number of iterations performed at the time\n{@code this} event is created"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key Class to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true|false"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value NumberTransformer to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true|false"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The Class of the object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mapped NumberTransformer or null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The Class"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer The NumberTransformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the replaced transformer if one is present"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The Class"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the removed transformer if one is present or\nnull if none was present."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Set of Classes"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Set of NumberTransformers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o the Object to be transformed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the double value of the Object."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the Object can not be\ntransformed into a Double."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start First value of the range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param end Last value of the range."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start First value of the range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Last value of the range that satisfies the above\nconstruction rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@param step Increment."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a range."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a clone of the data array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a clone of the data array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a clone of the data array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a clone of the data array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a clone of the data array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the size of the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the size of the subsets to be counted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code n choose k}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result is too large to be\nrepresented by a long integer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the size of the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the size of the subsets to be counted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code n choose k}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result is too large to be\nrepresented by a long integer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the size of the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the size of the subsets to be counted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code n choose k}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result is too large to be\nrepresented by a long integer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code n!}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result is too large to be represented\nby a {@code long}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code n!}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x0 The left corner of the area."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 The bottom corner of the area."
    },
    {
        "oracle": ";",
        "javadocTag": "@param width The area width."
    },
    {
        "oracle": ";",
        "javadocTag": "@param height The area height."
    },
    {
        "oracle": ";",
        "javadocTag": "@param style The style."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A gradient paint or null if the style does not specify a\n        gradient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x0 The start point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 The start point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x1 The end point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y1 The end point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param style The style."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A paint for the gradient or null if the style specifies no\n        gradient (the fill mode is not a linear gradient or there is only\n        one fill colour)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param cx The center point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param cy The center point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fx The start point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fy The start point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param radius The gradient radius."
    },
    {
        "oracle": ";",
        "javadocTag": "@param style The style."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A paint for the gradient or null if the style specifies no\n        gradient (the fill mode is not a radial gradient or there is only\n        one fill colour)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The lowest point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The highest point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The value to convert."
    },
    {
        "oracle": ";",
        "javadocTag": "@param units The units the value to convert is expressed in."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The value to convert (it contains its own units)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values The values set containing the value to convert (it contains\n           its own units)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index of the value to convert."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The value to convert."
    },
    {
        "oracle": ";",
        "javadocTag": "@param units The units the value to convert is expressed in."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The value converted in pixels."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The value to convert (it contains its own units)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values The values set containing the value to convert (it contains\n           its own units)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index of the value to convert."
    },
    {
        "oracle": ";",
        "javadocTag": "@param viewportWidth The width in pixels of the view port."
    },
    {
        "oracle": ";",
        "javadocTag": "@param viewportHeight The width in pixels of the view port."
    },
    {
        "oracle": ";",
        "javadocTag": "@param ratio The ratio."
    },
    {
        "oracle": ";",
        "javadocTag": "@param minx Lowest abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param miny Lowest ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param minz Lowest depth."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxx Highest abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxy Highest ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxz Highest depth."
    },
    {
        "oracle": ";",
        "javadocTag": "@param outputName The name of the output to use, for some renderers it is a file,\nfor others it is an URL, a string description of the output, etc."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The default singleton image cache instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileNameOrUrl A file name or an URL pointing at the image."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An image or null if the image cannot be found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileNameOrUrl A file name or an URL pointing at the image."
    },
    {
        "oracle": ";",
        "javadocTag": "@param forceTryReload If true, try to reload an image that where not found before."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An image or null if the image cannot be found."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An image."
    },
    {
        "oracle": ";",
        "javadocTag": "@param style The style to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param metrics The metrics to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The stroke or null if the style specifies a \"none\" stroke mode."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A font."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The default singleton font cache instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param name The font name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param style A style, taken from the styles available in the style sheets."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size The font size in points."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A font."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g The Swing graphics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param camera The camera."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g The Swing graphics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param camera The camera."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g The Swing graphics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param camera The camera."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The graphic element concerned by the dynamic style change."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g The Swing graphics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param camera The camera."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to render."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g The Swing graphics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param camera The camera."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to render."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Point at which the edge crosses the node shape."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Point at which the edge crosses the node shape."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dx The arrow vector (and length)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dy The arrow vector (and length)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge The edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param metrics The metrics."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The length from the node centre along the edge to position the\n        arrow."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge The edge representing the vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param w The ellipse first radius (width/2)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param h The ellipse second radius (height/2)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The length of the radius along the edge vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g The Swing graphics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g The Swing graphics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g The Swing graphics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g The Swing graphics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g The Swing graphics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g The Swing graphics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param group The group to render."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Camera instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The first node or sprite at the given coordinates or null if\n        nothing found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x1 The rectangle lowest point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y1 The rectangle lowest point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x2 The rectangle highest point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y2 The rectangle highest point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The set of sprites and nodes in the given rectangle."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x1 The selection start abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y1 The selection start ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the number of crossoverPoints is too large for the actual chromosomes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param crossoverPoints the number of crossover points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mixing ratio"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the two chromosomes is different"
    },
    {
        "oracle": ";",
        "javadocTag": "@param first the first chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@param second the second chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the pair of new chromosomes that resulted from the crossover"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the two chromosomes is different"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ratio the mixing ratio"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the mixing ratio is outside the [0, 1] range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the original chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mutated chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the given chromosome is not compatible with this {@link MutationPolicy}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param population ignored (no impact on result)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> IFF the maximum allowed time period has elapsed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxTime maximum number of seconds generations are allowed to evolve"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxTime maximum time generations are allowed to evolve"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit {@link TimeUnit} of the maxTime argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the starting index is chosen randomly, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the two chromosomes is different"
    },
    {
        "oracle": ";",
        "javadocTag": "@param first the first chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@param second the second chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the pair of new chromosomes that resulted from the crossover"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the two chromosomes is different"
    },
    {
        "oracle": ";",
        "javadocTag": "@param randomStart whether the start index shall be chosen randomly or be set to 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the original chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mutated chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@param length length of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random binary array of length <code>length</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param representation list of {0,1} values representing the chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@param representation array of {0,1} values representing the chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the beginnings of the next generation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param chromosome the chromosome to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the population would exceed the population limit when adding\n  this chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fittest chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if <code>original</code> is not a {@link RandomKey} instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return fitness"
    },
    {
        "oracle": ";",
        "javadocTag": "@param first the first chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@param second the second chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the pair of new chromosomes that resulted from the crossover."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the given chromosomes are not compatible with this {@link CrossoverPolicy}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return null vector of the vectorial space or origin point of the affine space"
    },
    {
        "oracle": ";",
        "javadocTag": "@return L<sub>1</sub> norm for the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Euclidean norm for the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return square of the Euclidean norm for the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return L<sub>&infin;</sub> norm for the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor scale factor to apply to v before adding it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to subtract"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor scale factor to apply to v before subtracting it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to subtract"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector which is opposite to the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new normalized vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a scalar"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if any coordinate of this vector is infinite and none are NaN;\nfalse otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between the instance and p according to the L<sub>1</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between the instance and p according to the L<sub>2</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between the instance and p according to the L<sub>&infin;</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square of the distance between the instance and p"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the dot product this.v"
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for components"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return available point/vector format locales."
    },
    {
        "oracle": ";",
        "javadocTag": "@return format prefix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return format suffix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return format separator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return components format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector the object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a formatted string."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector the object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coordinates coordinates of the object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link Vector} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathParseException if the beginning of the specified string\ncannot be parsed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/output parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link Vector} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension dimension of the space"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the covariance matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.linear.SingularMatrixException if the covariance matrix cannot be computed (singular problem)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param params Model parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param covarianceSingularityThreshold Singularity threshold (see\n{@link #computeCovariances(double[],double) computeCovariances})."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an estimate of the standard deviation of the optimized parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.linear.SingularMatrixException if the covariance matrix cannot be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. In addition to those documented in\n{@link JacobianMultivariateVectorOptimizer#parseOptimizationData(OptimizationData[])\nJacobianMultivariateVectorOptimizer}, this method will register the following data:\n<ul>\n <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Weight}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the initial guess, target, and weight\narguments have inconsistent dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param objectiveValue Value of the the objective function. This is\nthe value returned from a call to\n{@link #computeObjectiveValue(double[]) computeObjectiveValue}\n(whose array argument contains the model parameters)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the residuals."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code params} has a wrong\nlength."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link Weight}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Symmetric, positive-definite (weight) matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square-root of the weight matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathUnsupportedOperationException if bounds were passed to the\n{@link #optimize(OptimizationData[]) optimize} method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param useLU If {@code true}, the normal equations will be solved\nusing LU decomposition, otherwise they will be solved using QR\ndecomposition."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the model function Jacobian."
    },
    {
        "oracle": ";",
        "javadocTag": "@param j Jacobian of the model function to be optimized."
    },
    {
        "oracle": ";",
        "javadocTag": "@param params Point at which the Jacobian must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Jacobian at the specified point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. In addition to those documented in\n{@link MultivariateVectorOptimizer#optimize(OptimizationData...)}\nMultivariateOptimizer}, this method will register the following data:\n<ul>\n <li>{@link ModelFunctionJacobian}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the initial guess, target, and weight\narguments have inconsistent dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data.\nThe following data will be looked for:\n<ul>\n <li>{@link ModelFunctionJacobian}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param params Point at which the objective function must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective function value at the specified point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of evaluations\n(of the model vector function) is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. In addition to those documented in\n{@link BaseMultivariateOptimizer#parseOptimizationData(OptimizationData[])\nBaseMultivariateOptimizer}, this method will register the following data:\n<ul>\n <li>{@link Target}</li>\n <li>{@link Weight}</li>\n <li>{@link ModelFunction}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the initial guess, target, and weight\narguments have inconsistent dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the weight matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the target values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the length of the target vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link Target}</li>\n <li>{@link Weight}</li>\n <li>{@link ModelFunction}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@link #target} and\n{@link #weightMatrix} have inconsistent dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param observations Target values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight List of the values of the diagonal."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight Weight matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareMatrixException if the argument is not\na square matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a comparator for sorting the optima."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Single-start optimizer to wrap."
    },
    {
        "oracle": ";",
        "javadocTag": "@param starts Number of starts to perform.\nIf {@code starts == 1}, the result will be same as if {@code optimizer}\nis called directly."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator Random vector generator to use for restarts."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the error function erf(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.MaxCountExceededException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the complementary error function erfc(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.MaxCountExceededException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x1 the first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x2 the second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return erf(x2) - erf(x1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return t such that x = erf(t)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return t such that x = erfc(t)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Value of the Bessel function at x"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if {@code x} is too large relative to {@code order}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the algorithm fails to converge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order Order of the Bessel function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Value of the Bessel function of the first kind, \\(J_{order}(x)\\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if {@code x} is too large relative to {@code order}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the algorithm fails to converge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x non-negative real argument for which J's are to be calculated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha fractional part of order for which J's or exponentially\nscaled J's (\\(J\\cdot e^{x}\\)) are to be calculated. 0 <= alpha < 1.0."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nb integer number of functions to be calculated, nb > 0. The first\nfunction calculated is of order alpha, and the last is of order\nnb - 1 + alpha."
    },
    {
        "oracle": ";",
        "javadocTag": "@return BesselJResult a vector of the functions\n\\(J_{alpha}(x)\\) through \\(J_{nb-1+alpha}(x)\\), or the corresponding exponentially\nscaled functions and an integer output variable indicating possible errors"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of the function computed when using {@link #value(double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of {@code log(Gamma(x))}, {@code Double.NaN} if\n{@code x <= 0.0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the regularized gamma function P(a, x)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the a parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon When the absolute value of the nth item in the\nseries is less than epsilon the approximation ceases to calculate\nfurther elements in the series."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations Maximum number of \"iterations\" to complete."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the regularized gamma function P(a, x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the a parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the regularized gamma function Q(a, x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the a parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon When the absolute value of the nth item in the\nseries is less than epsilon the approximation ceases to calculate\nfurther elements in the series."
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the listener to be removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the listener to be removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the new value to set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param anotherInteger the <code>ModifiableInteger</code> to be compared."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value <code>0</code> if this <code>ModifiableInteger</code>\nis equal to the argument <code>ModifiableInteger</code>; a value less\nthan <code>0</code> if this <code>ModifiableInteger</code> is numerically\nless than the argument <code>ModifiableInteger</code>; and a value\ngreater than <code>0</code> if this <code>ModifiableInteger</code> is\nnumerically greater than the argument <code>ModifiableInteger</code>\n(signed comparison)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param o the object to compare with."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the objects are the same; <code>false</code>\notherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code value for this object, equal to the primitive <code>\nint</code> value represented by this <code>ModifiableInteger</code>\nobject."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an <code>Integer</code> representation of the value of this\nobject."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the value of this object in\nbase&nbsp;10."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to be represented by the <code>\nModifiableInteger</code> object."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return string representing this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data data for this node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first weight"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second weight"
    },
    {
        "oracle": ";",
        "javadocTag": "@return result of the operator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the heap is empty, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x node to decrease the key of"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k new key value for node x"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException Thrown if k is larger than x.key\nvalue."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x node to remove from heap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node new node to insert into heap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key value associated with data object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return heap node with the smallest key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return node with the smallest key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of elements in the heap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h1 first heap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h2 second heap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return new heap containing h1 and h2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return String of this."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y node to perform cascading cut on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x child of y to be removed from y's child list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y parent of x about to lose a child"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y node to become child"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x node to become parent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o object to be cast"
    },
    {
        "oracle": ";",
        "javadocTag": "@param typeDecl conveys the target type information; the actual value is\nunused and can be null since this is all just stupid compiler tricks"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the result of the cast"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v The vertex in question"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if contains, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertex source vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex target vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set of all edges connecting source vertex to target vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertex source vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex target vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an edge connecting source vertex to target vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the edge factory using which this graph creates new edges."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertex source vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex target vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The newly created edge if added to the graph, otherwise <code>\nnull</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if source or target vertices are not\nfound in the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any of the specified vertices is <code>\nnull</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertex source vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex target vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e edge to be added to this graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if source or target vertices are not\nfound in the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the specified edge is not assignment\ncompatible with the class of edges produced by the edge factory of this\ngraph."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any of the specified vertices is <code>\nnull</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vertex to be added to this graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertex source vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex target vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>true</tt> if this graph contains the specified edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e edge whose presence in this graph is to be tested."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>true</tt> if this graph contains the specified edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vertex whose presence in this graph is to be tested."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>true</tt> if this graph contains the specified vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set of the edges contained in this graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex for which a set of touching edges is to be\nreturned."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set of all edges touching the specified vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edges edges to be removed from this graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>true</tt> if this graph changed as a result of the call"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertex source vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex target vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the removed edges, or <code>null</code> if either vertex is not\npart of graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices vertices to be removed from this graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>true</tt> if this graph changed as a result of the call"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertex source vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex target vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The removed edge, or <code>null</code> if no edge removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e edge to be removed from this graph, if present."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vertex to be removed from this graph, if present."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set view of the vertices contained in this graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e edge of interest"
    },
    {
        "oracle": ";",
        "javadocTag": "@return source vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e edge of interest"
    },
    {
        "oracle": ";",
        "javadocTag": "@return target vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e edge of interest"
    },
    {
        "oracle": ";",
        "javadocTag": "@return edge weight"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the containing graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the start vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the end vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of edges traversed by the path"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the weight of the path"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the edge factory of the new graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g1ToG2 "
    },
    {
        "oracle": ";",
        "javadocTag": "@param g2ToG1 "
    },
    {
        "oracle": ";",
        "javadocTag": "@param g1 "
    },
    {
        "oracle": ";",
        "javadocTag": "@return the optimizer to use for fitting the curve to the\ngiven {@code points}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param points Sample points."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the least squares problem to use for fitting the curve to the\ngiven {@code points}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a curve fitter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newStart new start point (initial guess)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newMaxIter maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialGuess Initial guess. If set to {@code null}, the initial guess\nwill be estimated using the {@link ParameterGuesser}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIter Maximum number of iterations of the optimization algorithm."
    },
    {
        "oracle": ";",
        "javadocTag": "@param degree Degree of the polynomial to be fitted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a curve fitter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newStart new start point (initial guess)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newMaxIter maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialGuess Initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIter Maximum number of iterations of the optimization algorithm."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathInternalError if {@code initialGuess} is {@code null}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the point for which the function value should be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f List of functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the composite function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f List of functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the composite function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f List of functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the composite function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f List of functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function that computes the sum of the functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f List of functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function that computes the sum of the functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f List of functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function that computes the sum of the functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f List of functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function that computes the product of the functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f List of functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function that computes the product of the functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f List of functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function that computes the product of the functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param combiner Combiner function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g Function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the composite function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param combiner Combiner function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialValue Initial value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a collector function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param combiner Combiner function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialValue Initial value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a collector function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Binary function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fixed value to which the first argument of {@code f} is set."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unary function h(x) = f(fixed, x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Binary function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fixed value to which the second argument of {@code f} is set."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unary function h(x) = f(x, fixed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to be sampled"
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound of the interval (included)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound of the interval (excluded)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of sample points."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of samples."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the lower bound {@code min} is\ngreater than, or equal to the upper bound {@code max}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if the number of sample points\n{@code n} is negative."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f function to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return converted function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f function to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return converted function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f function to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return converted function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f function to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return converted function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f function to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return converted function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f function to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return converted function"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the derivative function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of steps."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of n-th stage integral."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximum number of evaluations\nis exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of integration points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy of the result."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy of the result."
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimalIterationCount Minimum number of iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximalIterationCount Maximum number of iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if minimal number of iterations\nor number of points are not strictly positive."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if maximal number of iterations\nis smaller than or equal to the minimal number of iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of integration points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy of the result."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy of the result."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of integration points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimalIterationCount Minimum number of iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximalIterationCount Maximum number of iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if maximal number of iterations\nis smaller than or equal to the minimal number of iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number of steps"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of n-th stage integral"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximum number of evaluations\nis exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number of points desired (must be between 2 and 5 inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy relative accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy absolute accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimalIterationCount minimum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of effective modifications"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable queue backed by that queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a predicated queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a transformed queue backed by the given queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@code Set} of values, implementations should return an\n  empty {@code Set} for no mapping"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to remove values from"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the map is unmodifiable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new synchronized Bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the map being used by the Bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current size of the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if bag is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of occurrences of the object, zero if not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the bag contains the given element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to check against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the Bag contains all the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other the bag to check against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the Bag contains all the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the object was not already in the <code>uniqueSet</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nCopies the number of copies to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the object was not already in the <code>uniqueSet</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if this call changed the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the bag changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nCopies the number of copies to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the bag changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the bag changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to retain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this call changed the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other the bag to retain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if this call changed the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of all of this bag's elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the array elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to populate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of all of this bag's elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArrayStoreException if the runtime type of the specified array is not\n  a supertype of the runtime type of the elements in this list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the set of unique elements in this bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException any of the usual I/O related exceptions"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException any of the usual I/O related exceptions"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if the stream contains an object which class can not be loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the stream does not contain the correct objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the Bag to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code of the Bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a debugging toString"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to assign"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Bag that complies to the Collection contract"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if deserialised object has wrong type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to check against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the Bag contains at least one of every object in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if this call changed the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if this call changed the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to retain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if this call changed the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param count the number of copies to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable Bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if deserialised object has wrong type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new predicated SortedBag"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the bag contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the bag contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable SortedBag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": "e<0;",
        "javadocTag": "@throws NotPositiveException if {@code e < 0}."
    },
    {
        "oracle": "e>0 || e==0;",
        "javadocTag": "@param e Exponent (must be positive or zero)."
    },
    {
        "oracle": "e<0;",
        "javadocTag": "@throws NotPositiveException if {@code e < 0}."
    },
    {
        "oracle": "e>0 || e==0;",
        "javadocTag": "@param e Exponent (must be positive or zero)."
    },
    {
        "oracle": "k<0;",
        "javadocTag": "@throws NotPositiveException if {@code k < 0}."
    },
    {
        "oracle": "k>n;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code k > n}."
    },
    {
        "oracle": "points==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the data points are null or the number\n    of clusters is larger than the number of data points"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if values is null or the indices\nare not valid"
    },
    {
        "oracle": "this.getData()==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the stored data array is null"
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "(sampleSize>0) == false;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code sampleSize} is not positive."
    },
    {
        "oracle": "prototypeStatistics==null;",
        "javadocTag": "@throws NullArgumentException if prototypeStatistics is null"
    },
    {
        "oracle": "exponent<0;",
        "javadocTag": "@throws NotPositiveException if {@code exponent < 0}."
    },
    {
        "oracle": "elements<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code elements <= 0}."
    },
    {
        "oracle": "maxIter<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code maxIter <= 0}."
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "dimension<1 || dimension>40;",
        "javadocTag": "@throws OutOfRangeException if the space dimension is outside the allowed range of [1, 40]"
    },
    {
        "oracle": "bases==null;",
        "javadocTag": "@throws NullArgumentException if base is null"
    },
    {
        "oracle": "weights!=null;",
        "javadocTag": "@throws DimensionMismatchException if weights is non-null and the length of the input arrays differ"
    },
    {
        "oracle": "(bases==null) == false;",
        "javadocTag": "@param bases the base number for each dimension, entries should be (pairwise) prime, may not be null"
    },
    {
        "oracle": "index<0;",
        "javadocTag": "@throws NotPositiveException if index &lt; 0"
    },
    {
        "oracle": "optimizer==null || generator==null;",
        "javadocTag": "@throws NullArgumentException if {@code optimizer} or {@code generator}\nis {@code null}."
    },
    {
        "oracle": "starts<1;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code starts < 1}."
    },
    {
        "oracle": "starts==1;",
        "javadocTag": "@param starts Number of starts to perform. If {@code starts == 1},\nthe {@code optimize} methods will return the same solution as\n{@code optimizer} would."
    },
    {
        "oracle": "true ? methodResultID==0 : true;",
        "javadocTag": "@return a value where the function is zero."
    },
    {
        "oracle": "true ? methodResultID==0 : true;",
        "javadocTag": "@return a value where the function is zero."
    },
    {
        "oracle": "true ? methodResultID==0 : true;",
        "javadocTag": "@return a value where the function is zero."
    },
    {
        "oracle": "x==null;",
        "javadocTag": "@throws NullArgumentException if x is null"
    },
    {
        "oracle": "x==null;",
        "javadocTag": "@throws NullArgumentException if x is null"
    },
    {
        "oracle": "x==null;",
        "javadocTag": "@throws NullArgumentException if x is null"
    },
    {
        "oracle": "mean<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code mean <= 0}."
    },
    {
        "oracle": "mean<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code mean <= 0}."
    },
    {
        "oracle": "mean<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code mean <= 0}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "(p>0) == false && p<=100;",
        "javadocTag": "@throws OutOfRangeException if p is not greater than 0 and less\nthan or equal to 100"
    },
    {
        "oracle": "knots==null || polynomials==null;",
        "javadocTag": "@throws NullArgumentException if either of the input arrays is {@code null}."
    },
    {
        "oracle": "a==null || m==null || b==null;",
        "javadocTag": "@throws NullArgumentException if one of the parameters is {@code null}"
    },
    {
        "oracle": "a==null || b==null;",
        "javadocTag": "@throws NullArgumentException if one of the parameters is {@code null}"
    },
    {
        "oracle": "a==null || m==null || b==null || x==null;",
        "javadocTag": "@throws NullArgumentException if one of the parameters is {@code null}"
    },
    {
        "oracle": "initValue<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code initValue <= 0}."
    },
    {
        "oracle": "valueAtNumCall<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code valueAtNumCall <= 0}."
    },
    {
        "oracle": "valueAtNumCall>=initValue;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code valueAtNumCall >= initValue}."
    },
    {
        "oracle": "numCall<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code numCall <= 0}."
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "initialStepBoundFactor==100.0;",
        "javadocTag": "@param initialStepBoundFactor Positive input variable used in\ndetermining the initial step bound. This bound is set to the\nproduct of initialStepBoundFactor and the euclidean norm of\n{@code diag * x} if non-zero, or else to {@code initialStepBoundFactor}\nitself. In most cases factor should lie in the interval\n{@code (0.1, 100.0)}. {@code 100} is a generally recommended value."
    },
    {
        "oracle": "initialStepBoundFactor==100.0;",
        "javadocTag": "@param initialStepBoundFactor Positive input variable used in\ndetermining the initial step bound. This bound is set to the\nproduct of initialStepBoundFactor and the euclidean norm of\n{@code diag * x} if non-zero, or else to {@code initialStepBoundFactor}\nitself. In most cases factor should lie in the interval\n{@code (0.1, 100.0)}. {@code 100} is a generally recommended value."
    },
    {
        "oracle": "dimension<=0 || size<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code dimension <= 0}\nor {@code size <= 0}."
    },
    {
        "oracle": "darkThreshold<0;",
        "javadocTag": "@throws NotPositiveException if {@code darkThreshold < 0}."
    },
    {
        "oracle": "dimension<=0 || size<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code dimension <= 0}\nor {@code size <= 0}."
    },
    {
        "oracle": "darkThreshold<0;",
        "javadocTag": "@throws NotPositiveException if {@code darkThreshold < 0}."
    },
    {
        "oracle": "exponent<0;",
        "javadocTag": "@throws NotPositiveException if {@code exponent < 0}."
    },
    {
        "oracle": "alpha>0;",
        "javadocTag": "@param alpha First shape parameter (must be positive)."
    },
    {
        "oracle": "beta>0;",
        "javadocTag": "@param beta Second shape parameter (must be positive)."
    },
    {
        "oracle": "alpha>0;",
        "javadocTag": "@param alpha First shape parameter (must be positive)."
    },
    {
        "oracle": "beta>0;",
        "javadocTag": "@param beta Second shape parameter (must be positive)."
    },
    {
        "oracle": "alpha>0;",
        "javadocTag": "@param alpha First shape parameter (must be positive)."
    },
    {
        "oracle": "beta>0;",
        "javadocTag": "@param beta Second shape parameter (must be positive)."
    },
    {
        "oracle": "alpha>0;",
        "javadocTag": "@param alpha First shape parameter (must be positive)."
    },
    {
        "oracle": "beta>0;",
        "javadocTag": "@param beta Second shape parameter (must be positive)."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "order==1;",
        "javadocTag": "@throws NumberIsTooSmallException if order is 1 or less"
    },
    {
        "oracle": "order==1;",
        "javadocTag": "@throws IllegalArgumentException if order is 1 or less"
    },
    {
        "oracle": "true ? methodResultID.equals(highOrder) : true;",
        "javadocTag": "@return updated high order derivatives"
    },
    {
        "oracle": "this==this;",
        "javadocTag": "@param v Vector to subtract from {@code this}."
    },
    {
        "oracle": "optimizer==null || generator==null;",
        "javadocTag": "@throws NullArgumentException if {@code optimizer} or {@code generator}\nis {@code null}."
    },
    {
        "oracle": "starts<1;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code starts < 1}."
    },
    {
        "oracle": "n<1;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code n < 1}."
    },
    {
        "oracle": "(minimalIterationCount>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive."
    },
    {
        "oracle": "n<1;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code n < 1}."
    },
    {
        "oracle": "sd<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code sd <= 0}."
    },
    {
        "oracle": "sd<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code sd <= 0}."
    },
    {
        "oracle": "sd<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code sd <= 0}."
    },
    {
        "oracle": "sd<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code sd <= 0}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "nSteps<2;",
        "javadocTag": "@throws NumberIsTooSmallException if number of steps is smaller than 2"
    },
    {
        "oracle": "minStep>0;",
        "javadocTag": "@param minStep minimal step (must be positive even for backward\nintegration), the last step can be smaller than this"
    },
    {
        "oracle": "maxStep>0;",
        "javadocTag": "@param maxStep maximal step (must be positive even for backward\nintegration)"
    },
    {
        "oracle": "minStep>0;",
        "javadocTag": "@param minStep minimal step (must be positive even for backward\nintegration), the last step can be smaller than this"
    },
    {
        "oracle": "maxStep>0;",
        "javadocTag": "@param maxStep maximal step (must be positive even for backward\nintegration)"
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "this.isBiasCorrected();",
        "javadocTag": "@param biasCorrected The isBiasCorrected to set."
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "(minimalIterationCount>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive"
    },
    {
        "oracle": "maximalIterationCount>MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@throws NumberIsTooLargeException if maximal number of iterations\nis greater than {@link #MIDPOINT_MAX_ITERATIONS_COUNT}"
    },
    {
        "oracle": "maximalIterationCount<=MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@param maximalIterationCount maximum number of iterations\n(must be less than or equal to {@link #MIDPOINT_MAX_ITERATIONS_COUNT}"
    },
    {
        "oracle": "(minimalIterationCount>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive"
    },
    {
        "oracle": "maximalIterationCount>MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@throws NumberIsTooLargeException if maximal number of iterations\nis greater than {@link #MIDPOINT_MAX_ITERATIONS_COUNT}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param imaginaryFormat the custom format for the imaginary part."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if {@code imaginaryCharacter} is an\nempty string."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unique instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the roots of unity are stored in\ncounter-clockwise order"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if no roots of unity have been computed\nyet"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the (signed) number of roots of unity to be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k index of the {@code n}-th root of unity"
    },
    {
        "oracle": ";",
        "javadocTag": "@return real part of the {@code k}-th {@code n}-th root of unity"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if no roots of unity have been\ncomputed yet"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if {@code k} is out of range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k index of the {@code n}-th root of unity"
    },
    {
        "oracle": ";",
        "javadocTag": "@return imaginary part of the {@code k}-th {@code n}-th root of unity"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if no roots of unity have been\ncomputed yet"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code k} is out of range"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of roots of unity currently stored"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the conjugate quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q1 First quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q2 Second quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the product {@code q1} and {@code q2}, in that order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q Quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the product of this instance with {@code q}, in that order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q1 Quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q2 Quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of {@code q1} and {@code q2}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q Quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of this instance and {@code q}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q1 First Quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q2 Second quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the difference between {@code q1} and {@code q2}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q Quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the difference between this instance and {@code q}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q1 Quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q2 Quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the dot product of {@code q1} and {@code q2}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q Quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the dot product of this instance and {@code q}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the norm."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a normalized quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if the norm of the quaternion is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q Quaternion with which to compare the current quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps Tolerance."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the each of the components are equal\nwithin the allowed absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps Tolerance (absolute error)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps Tolerance (absolute error)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the scalar part of the quaternion is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unit quaternion with positive scalar part."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if the norm (squared) of the quaternion is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scalar part."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first component of the vector part."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the second component of the vector part."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the third component of the vector part."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scalar part."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the vector part."
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha Scalar factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a scaled quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Scalar component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b First vector component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Second vector component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Third vector component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalar Scalar part of the quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Components of the vector part of the quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Components of the vector part of the pure quaternion."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the absolute value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param addend Value to be added to this {@code Complex}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this + addend}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param addend Value to be added to this {@code Complex}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this + addend}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the conjugate of this Complex object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param divisor Value by which this {@code Complex} is to be divided."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this / divisor}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param divisor Value by which this {@code Complex} is to be divided."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this / divisor}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Object to test for equality with this instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the objects are equal, {@code false} if object\nis {@code null}, not an instance of {@code Complex}, or not equal to\nthis instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxUlps {@code (maxUlps - 1)} is the number of floating point\nvalues between the real (resp. imaginary) parts of {@code x} and\n{@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if there are fewer than {@code maxUlps} floating\npoint values between the real (resp. imaginary) parts of {@code x}\nand {@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the values are equal."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps Amount of allowed absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the values are two adjacent floating point\nnumbers or they are within range of each other."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps Amount of allowed relative error."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the values are two adjacent floating point\nnumbers or they are within range of each other."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code value for this object."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the imaginary part."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the real part."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if either or both parts of this complex number is\n{@code NaN}; false otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if one or both parts of this complex number are infinite\nand neither part is {@code NaN}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor value to be multiplied by this {@code Complex}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this * factor}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor value to be multiplied by this {@code Complex}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this * factor}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor value to be multiplied by this {@code Complex}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this * factor}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code -this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param subtrahend value to be subtracted from this {@code Complex}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this - subtrahend}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param subtrahend value to be subtracted from this {@code Complex}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this - subtrahend}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse cosine of this complex number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to switch on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param trueTransformer the transformer called if the predicate is true"
    },
    {
        "oracle": ";",
        "javadocTag": "@param falseTransformer the transformer called if the predicate is false"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicates an array of predicates to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformers an array of transformers to call"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the either array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the arrays have different sizes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicates an array of predicates to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformers an array of transformers to call"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the either array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the arrays have different sizes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicatesAndTransformers a map of predicates to transformers"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any transformer in the map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the map elements are of the wrong type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param objectsAndTransformers a map of objects to transformers"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any transformer in the map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param paramTypes parameter types for the constructor, can be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the arguments to pass to the constructor, can be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the paramTypes and args don't match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use to transform the objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer, or {@link ConstantTransformer#nullTransformer()} if the\n  {@code map} is {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param methodName the name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param paramTypes the parameter types"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the paramTypes and args don't match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to compare against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to compare against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param paramTypes the parameter types"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the paramTypes and args don't match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>and</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>all</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>all</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any predicate in the collection is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>or</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>any</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>any</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any predicate in the collection is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>either</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>one</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>one</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any predicate in the collection is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>neither</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnData the input column data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a columnData x 1 RealMatrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnData the input column data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a columnData x 1 FieldMatrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Matrix to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeTolerance Tolerance of the symmetry check."
    },
    {
        "oracle": ";",
        "javadocTag": "@param raiseException If {@code true}, an exception will be raised if\nthe matrix is not symmetric."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code matrix} is symmetric."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareMatrixException if the matrix is not square."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSymmetricMatrixException if the matrix is not symmetric."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Matrix to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps Relative tolerance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Matrix to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps Relative tolerance."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code matrix} is symmetric."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row index to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column index to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code row} or {@code column} is not\na valid index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row index to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code row} is not a valid index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column index to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code column} is not a valid index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param selectedRows Array of row indices."
    },
    {
        "oracle": ";",
        "javadocTag": "@param selectedColumns Array of column indices."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if the row or column selections are empty (zero\nlength)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if row or column selections are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param left Left hand side matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param right Right hand side matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the matrices are not addition\ncompatible."
    },
    {
        "oracle": ";",
        "javadocTag": "@param left Left hand side matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param right Right hand side matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the matrices are not addition\ncompatible."
    },
    {
        "oracle": ";",
        "javadocTag": "@param left Left hand side matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param right Right hand side matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if matrices are not multiplication\ncompatible."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to convert."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the converted matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to convert."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the converted matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector real vector to serialize"
    },
    {
        "oracle": ";",
        "javadocTag": "@param oos stream where the real vector should be written"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be written to stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param instance instance in which the field must be set up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fieldName name of the field within the class (may be private and final)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ois stream from which the real vector should be read"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if a class in the stream cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be read from the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix real matrix to serialize"
    },
    {
        "oracle": ";",
        "javadocTag": "@param oos stream where the real matrix should be written"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be written to stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param instance instance in which the field must be set up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fieldName name of the field within the class (may be private and final)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ois stream from which the real matrix should be read"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if a class in the stream cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be read from the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rm RealMatrix which is lower triangular"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b RealVector this is overwritten"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the matrix and vector are not\nconformable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the absolute value of one of the diagonal\ncoefficient of {@code rm} is lower than {@link Precision#SAFE_MIN}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rm RealMatrix which is upper triangular"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b RealVector this is overwritten"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the matrix and vector are not\nconformable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the absolute value of one of the diagonal\ncoefficient of {@code rm} is lower than {@link Precision#SAFE_MIN}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix whose inverse must be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param splitIndex Index that determines the \"split\" line and\ncolumn.\nThe element corresponding to this index will part of the\nupper-left sub-matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse of {@code m}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Matrix whose inverse shall be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse of {@code matrix}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if m is singular"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Matrix whose inverse shall be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Singularity threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse of {@code m}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if matrix is singular"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entries of this instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Value to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if this value is within epsilon to zero,\n{@code false} otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of {@code this} and {@code v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimensions do not match."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to append"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The result of appending {@code v} to self"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the dot product of this vector with {@code v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this} vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to compute distance to."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance from {@code this} and {@code v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimensions do not match."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to which distance is requested."
    },
    {
        "oracle": ";",
        "javadocTag": "@return distance between this vector and {@code v}."
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if {@code collection} or any of its elements\n    is null"
    },
    {
        "oracle": "array!=null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null&&(array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code char} values"
    },
    {
        "oracle": "array!=null&&array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null&&(array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code char} values"
    },
    {
        "oracle": "minLength<0 || padding<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code minLength} or {@code padding} is\n    negative"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if {@code collection} or any of its elements\n    is null"
    },
    {
        "oracle": "(((countMap==null)==false) && (countMap.isEmpty())) == false;",
        "javadocTag": "@throws IllegalArgumentException if {@code countMap} is not empty"
    },
    {
        "oracle": "((countMap==null)==false) && (countMap.isEmpty());",
        "javadocTag": "@param countMap backing map for storing the elements in the multiset and\n    their counts. It must be empty."
    },
    {
        "oracle": "occurrences<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code occurrences} is negative, or if\n    the resulting amount would exceed {@link Integer#MAX_VALUE}"
    },
    {
        "oracle": "occurrences<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code occurrences} is negative"
    },
    {
        "oracle": "count<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code count} is negative"
    },
    {
        "oracle": "expectedOldCount<0 || newCount<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code expectedOldCount} or {@code newCount} is negative"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "comparator==null;",
        "javadocTag": "@throws NullPointerException if {@code comparator} or any of\n    {@code elements} is null"
    },
    {
        "oracle": "comparator==null;",
        "javadocTag": "@throws NullPointerException if {@code comparator} or any of {@code\n        elements} is null"
    },
    {
        "oracle": "comparator==null;",
        "javadocTag": "@throws NullPointerException if {@code comparator} or any of\n    {@code elements} is null"
    },
    {
        "oracle": "sortedSet==null;",
        "javadocTag": "@throws NullPointerException if {@code sortedSet} or any of its elements\n    is null"
    },
    {
        "oracle": "comparator==null;",
        "javadocTag": "@throws NullPointerException if {@code comparator} is null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "array!=null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null && (array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of unsigned {@code int} values"
    },
    {
        "oracle": "array!=null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null && (array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of unsigned {@code int} values"
    },
    {
        "oracle": "divisor==0;",
        "javadocTag": "@throws ArithmeticException if divisor is 0"
    },
    {
        "oracle": "divisor==0;",
        "javadocTag": "@throws ArithmeticException if divisor is 0"
    },
    {
        "oracle": "s==null;",
        "javadocTag": "@throws NullPointerException if {@code s} is null\n        (in contrast to {@link Integer#parseInt(String)})"
    },
    {
        "oracle": "initialArraySize<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code initialArraySize} is negative"
    },
    {
        "oracle": "estimatedSize<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code estimatedSize} is negative"
    },
    {
        "oracle": "lists==null;",
        "javadocTag": "@throws NullPointerException if {@code lists}, any one of the {@code lists},\n    or any element of a provided list is null"
    },
    {
        "oracle": "lists==null;",
        "javadocTag": "@throws NullPointerException if {@code lists}, any one of the\n    {@code lists}, or any element of a provided list is null"
    },
    {
        "oracle": "value<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code value} is negative"
    },
    {
        "oracle": "comparator==null;",
        "javadocTag": "@throws NullPointerException if {@code comparator} is null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "(duration>0) == false;",
        "javadocTag": "@throws IllegalArgumentException if {@code duration} is not positive"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true} always"
    },
    {
        "oracle": "(((backingMap==null)==false) && (backingMap.isEmpty())) == false;",
        "javadocTag": "@throws IllegalArgumentException if {@code backingMap} is not empty"
    },
    {
        "oracle": "((guard==null)==false) && (guard.isSatisfied()) ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return whether the guard is now satisfied"
    },
    {
        "oracle": "((guard==null)==false) && (guard.isSatisfied()) ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return whether the guard is now satisfied"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "input==null;",
        "javadocTag": "@throws NullPointerException if {@code input} is null and this function does not accept null\n    arguments"
    },
    {
        "oracle": "x<=0;",
        "javadocTag": "@throws IllegalArgumentException if {@code x <= 0}"
    },
    {
        "oracle": "x<=0;",
        "javadocTag": "@throws IllegalArgumentException if {@code x <= 0}"
    },
    {
        "oracle": "k<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code k < 0}"
    },
    {
        "oracle": "x<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code x < 0}"
    },
    {
        "oracle": "q==0;",
        "javadocTag": "@throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}\n        is not an integer multiple of {@code b}"
    },
    {
        "oracle": "m<=0;",
        "javadocTag": "@throws ArithmeticException if {@code m <= 0}"
    },
    {
        "oracle": "a<0 || b<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code a < 0} or {@code b < 0}"
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code n < 0}"
    },
    {
        "oracle": "rowKeys==null || columnKeys==null;",
        "javadocTag": "@throws NullPointerException if any of the provided keys is null"
    },
    {
        "oracle": "table.isEmpty();",
        "javadocTag": "@throws IllegalArgumentException if the provided table is empty"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code n < 0}"
    },
    {
        "oracle": "wasUncontended==false;",
        "javadocTag": "@param wasUncontended false if CAS failed before call"
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code n} is negative"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true} always"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true} always"
    },
    {
        "oracle": "expectedKeys<0 || expectedValuesPerKey<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code expectedKeys} or {@code\n     expectedValuesPerKey} is negative"
    },
    {
        "oracle": "this.isRunning();",
        "javadocTag": "@throws IllegalStateException if the stopwatch is already running."
    },
    {
        "oracle": "array!=null&&array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null&&(array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code byte} values"
    },
    {
        "oracle": "array!=null&&array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null&&(array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code byte} values"
    },
    {
        "oracle": "distinctElements<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code distinctElements} is negative"
    },
    {
        "oracle": "sources==null;",
        "javadocTag": "@throws NullPointerException if any of {@code sources} is {@code null}"
    },
    {
        "oracle": "sources==null;",
        "javadocTag": "@throws NullPointerException if any of {@code sources} is {@code null}"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "sample==null;",
        "javadocTag": "@throws NullPointerException if {@code sample} is null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "(InternetDomainName.isValid(domain)) == false;",
        "javadocTag": "@throws IllegalArgumentException if {@code name} is not syntactically valid\n    according to {@link #isValid}"
    },
    {
        "oracle": "leftParts==null;",
        "javadocTag": "@throws NullPointerException if leftParts is null"
    },
    {
        "oracle": "(InternetDomainName.isValid(leftParts)) == false;",
        "javadocTag": "@throws IllegalArgumentException if the resulting name is not valid"
    },
    {
        "oracle": "true ? methodResultID.equals(defaultValue) : true;",
        "javadocTag": "@return function that returns {@code map.get(a)} when {@code a} is a key, or {@code\n        defaultValue} otherwise"
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code n < 0}"
    },
    {
        "oracle": "true ? methodResultID.equals(outputCollection) : true;",
        "javadocTag": "@return the outputCollection"
    },
    {
        "oracle": "(inputCollection==null) == false && (predicate==null) == false || (outputCollection==null) == false;",
        "javadocTag": "@param outputCollection the collection to output selected elements into, may not be null if the\n  inputCollection and predicate are not null"
    },
    {
        "oracle": "(inputCollection==null) == false || (predicate==null) == false || (rejectedCollection==null) == false;",
        "javadocTag": "@param rejectedCollection the collection to output rejected elements into, may not be null if the\n  inputCollection or predicate are not null"
    },
    {
        "oracle": "true ? methodResultID.equals(outputCollection) : true;",
        "javadocTag": "@return the outputCollection"
    },
    {
        "oracle": "inputCollection==null;",
        "javadocTag": "@throws NullPointerException if the input collection is null"
    },
    {
        "oracle": "(inputCollection==null) == false;",
        "javadocTag": "@param inputCollection the collection to get the input from, may not be null"
    },
    {
        "oracle": "(outputCollection==null) == false;",
        "javadocTag": "@param outputCollection the collection to output into, may not be null if the inputCollection\n  and predicate or not null"
    },
    {
        "oracle": "true ? methodResultID.equals(outputCollection) : true;",
        "javadocTag": "@return outputCollection"
    },
    {
        "oracle": "inputCollection==null;",
        "javadocTag": "@throws NullPointerException if the input collection is null"
    },
    {
        "oracle": "(inputCollection==null) == false;",
        "javadocTag": "@param inputCollection the collection to get the input from, may not be null"
    },
    {
        "oracle": "outputCollection==null && (inputCollection==null) == false && (transformer==null) == false;",
        "javadocTag": "@throws NullPointerException if the outputCollection is null and both, inputCollection and\n  transformer are not null"
    },
    {
        "oracle": "(inputCollection==null) == false && (transformer==null) == false || (outputCollection==null) == false;",
        "javadocTag": "@param outputCollection the collection to output into, may not be null if inputCollection\n  and transformer are not null"
    },
    {
        "oracle": "outputCollection==null && (inputIterator==null) == false && (transformer==null) == false;",
        "javadocTag": "@throws NullPointerException if the output collection is null and both, inputIterator and\n  transformer are not null"
    },
    {
        "oracle": "(inputIterator==null) == false && (transformer==null) == false || (outputCollection==null) == false;",
        "javadocTag": "@param outputCollection the collection to output into, may not be null if inputIterator\n  and transformer are not null"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": "(collection==null) == false;",
        "javadocTag": "@param collection the collection to add to, must not be null"
    },
    {
        "oracle": "collection==null || iterable==null;",
        "javadocTag": "@throws NullPointerException if the collection or iterator is null"
    },
    {
        "oracle": "(collection==null) == false;",
        "javadocTag": "@param collection the collection to add to, must not be null"
    },
    {
        "oracle": "(iterable==null) == false;",
        "javadocTag": "@param iterable the iterable of elements to add, must not be null"
    },
    {
        "oracle": "collection==null || iterator==null;",
        "javadocTag": "@throws NullPointerException if the collection or iterator is null"
    },
    {
        "oracle": "(collection==null) == false;",
        "javadocTag": "@param collection the collection to add to, must not be null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator of elements to add, must not be null"
    },
    {
        "oracle": "collection==null || enumeration==null;",
        "javadocTag": "@throws NullPointerException if the collection or enumeration is null"
    },
    {
        "oracle": "(collection==null) == false;",
        "javadocTag": "@param collection the collection to add to, must not be null"
    },
    {
        "oracle": "(enumeration==null) == false;",
        "javadocTag": "@param enumeration the enumeration of elements to add, must not be null"
    },
    {
        "oracle": "collection==null || elements==null;",
        "javadocTag": "@throws NullPointerException if the collection or array is null"
    },
    {
        "oracle": "(collection==null) == false;",
        "javadocTag": "@param collection the collection to add to, must not be null"
    },
    {
        "oracle": "(elements==null) == false;",
        "javadocTag": "@param elements the array of elements to add, must not be null"
    },
    {
        "oracle": "index<0;",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is negative."
    },
    {
        "oracle": "coll==null;",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": "coll==null;",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": "a==null || b==null;",
        "javadocTag": "@throws NullPointerException if either collection is null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first collection, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second collection, must not be null"
    },
    {
        "oracle": "a==null || b==null;",
        "javadocTag": "@throws NullPointerException if either collection is null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first collection, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second collection, must not be null"
    },
    {
        "oracle": "a==null || b==null || c==null;",
        "javadocTag": "@throws NullPointerException if either collection or the comparator is null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first collection, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second collection, must not be null"
    },
    {
        "oracle": "a==null || b==null || c==null;",
        "javadocTag": "@throws NullPointerException if either collection or the comparator is null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first collection, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second collection, must not be null"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if collection is null"
    },
    {
        "oracle": "(collection==null) == false;",
        "javadocTag": "@param collection the collection to create permutations for, may not be null"
    },
    {
        "oracle": "collection==null || retain==null;",
        "javadocTag": "@throws NullPointerException if either parameter is null"
    },
    {
        "oracle": "collection==null || retain==null || equator==null;",
        "javadocTag": "@throws NullPointerException if any of the parameters is null"
    },
    {
        "oracle": "collection==null || remove==null;",
        "javadocTag": "@throws NullPointerException if either parameter is null"
    },
    {
        "oracle": "collection==null || remove==null || equator==null;",
        "javadocTag": "@throws NullPointerException if any of the parameters is null"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": "(collection==null) == false;",
        "javadocTag": "@param collection the collection to synchronize, must not be null"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": "(collection==null) == false;",
        "javadocTag": "@param collection the collection to make unmodifiable, must not be null"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if the Collection is null"
    },
    {
        "oracle": "(collection==null) == false;",
        "javadocTag": "@param collection the collection to predicate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate for the collection, must not be null"
    },
    {
        "oracle": "collection==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if the Collection or Transformer is null"
    },
    {
        "oracle": "(collection==null) == false;",
        "javadocTag": "@param collection the collection to predicate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer for the collection, must not be null"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if collection is null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if list is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "bag==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if bag or predicate is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "bag==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if bag or predicate is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "keys==null;",
        "javadocTag": "@throws IllegalArgumentException if the key array is null"
    },
    {
        "oracle": "(keys==null) == false;",
        "javadocTag": "@param keys the array of keys, not null"
    },
    {
        "oracle": "keys==null;",
        "javadocTag": "@throws IllegalArgumentException if the key array is null"
    },
    {
        "oracle": "(keys==null) == false;",
        "javadocTag": "@param keys the array of keys, not null"
    },
    {
        "oracle": "makeClone==false;",
        "javadocTag": "@param makeClone true to clone the array, false to assign it"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, may not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "expiringPolicy==null;",
        "javadocTag": "@throws NullPointerException if expiringPolicy is null"
    },
    {
        "oracle": "map==null || expiringPolicy==null;",
        "javadocTag": "@throws NullPointerException if the map or expiringPolicy is null."
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null."
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null."
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null."
    },
    {
        "oracle": "timeUnit==null;",
        "javadocTag": "@throws NullPointerException if the time unit is null."
    },
    {
        "oracle": "(timeUnit==null) == false;",
        "javadocTag": "@param timeUnit the unit of time for the <code>timeToLive</code>\n       parameter, must not be null."
    },
    {
        "oracle": "timeUnit==null;",
        "javadocTag": "@throws NullPointerException if the map or time unit is null."
    },
    {
        "oracle": "(timeUnit==null) == false;",
        "javadocTag": "@param timeUnit the unit of time for the <code>timeToLive</code>\n       parameter, must not be null."
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null."
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null."
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null."
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to check, not cloned, not null"
    },
    {
        "oracle": "multiset==null;",
        "javadocTag": "@throws NullPointerException if the MultiSet is null"
    },
    {
        "oracle": "(multiset==null) == false;",
        "javadocTag": "@param multiset the multiset to synchronize, must not be null"
    },
    {
        "oracle": "multiset==null;",
        "javadocTag": "@throws NullPointerException if the MultiSet is null"
    },
    {
        "oracle": "(multiset==null) == false;",
        "javadocTag": "@param multiset the multiset whose unmodifiable view is to be returned, must not be null"
    },
    {
        "oracle": "multiset==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if the MultiSet or Predicate is null"
    },
    {
        "oracle": "(multiset==null) == false;",
        "javadocTag": "@param multiset the multiset to predicate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate for the multiset, must not be null"
    },
    {
        "oracle": "(queue==null) == false;",
        "javadocTag": "@param queue the queue to decorate, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "value==null;",
        "javadocTag": "@throws NullPointerException if the specified value is null and nulls are invalid"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return true always"
    },
    {
        "oracle": "map==null || defaultValueTransformer==null;",
        "javadocTag": "@throws NullPointerException if map or transformer is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "map==null || factory==null;",
        "javadocTag": "@throws NullPointerException if map or factory is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory to use to create entries, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map or factory is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use as a factory to create entries, must not be null"
    },
    {
        "oracle": "value==null;",
        "javadocTag": "@throws NullPointerException if the value is null and null value are invalid"
    },
    {
        "oracle": "(pair==null) == false;",
        "javadocTag": "@param pair the pair to copy, must not be null"
    },
    {
        "oracle": "entry==null;",
        "javadocTag": "@throws NullPointerException if the entry is null"
    },
    {
        "oracle": "(entry==null) == false;",
        "javadocTag": "@param entry the entry to copy, must not be null"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return the value"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to check, not cloned, not null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates array is null"
    },
    {
        "oracle": "Arrays.stream(predicates).anyMatch(jdVar -> jdVar==null);",
        "javadocTag": "@throws NullPointerException if any predicate in the array is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to check, cloned, not null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates array is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to check, cloned, not null"
    },
    {
        "oracle": "obj1==null;",
        "javadocTag": "@throws NullPointerException if <i>obj1</i> is <code>null</code>,\n        or when <code>((Comparable)obj1).compareTo(obj2)</code> does"
    },
    {
        "oracle": "classToInstantiate==null;",
        "javadocTag": "@throws NullPointerException if the classToInstantiate is null"
    },
    {
        "oracle": "classToInstantiate==null;",
        "javadocTag": "@throws NullPointerException if the classToInstantiate is null"
    },
    {
        "oracle": "get==null;",
        "javadocTag": "@throws NullPointerException if the argument is null"
    },
    {
        "oracle": "(get==null) == false;",
        "javadocTag": "@param get to wrap, must not be null"
    },
    {
        "oracle": "put==null;",
        "javadocTag": "@throws NullPointerException if the argument is null"
    },
    {
        "oracle": "(put==null) == false;",
        "javadocTag": "@param put to wrap, must not be null"
    },
    {
        "oracle": "set==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if set or predicate is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "set==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if set or predicate is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if the list is null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws FunctorException always"
    },
    {
        "oracle": "classToInstantiate==null;",
        "javadocTag": "@throws NullPointerException if classToInstantiate is null"
    },
    {
        "oracle": "(classToInstantiate==null) == false;",
        "javadocTag": "@param classToInstantiate the class to instantiate, not null"
    },
    {
        "oracle": "list==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if list or transformer is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "list==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if list or transformer is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "list==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if list or transformer is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "trie==null;",
        "javadocTag": "@throws NullPointerException if trie is null"
    },
    {
        "oracle": "(trie==null) == false;",
        "javadocTag": "@param trie the trie to make unmodifiable, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if the specified array is null"
    },
    {
        "oracle": "reverse==true;",
        "javadocTag": "@param reverse false = forward sort; true = reverse sort"
    },
    {
        "oracle": "reverse==true;",
        "javadocTag": "@param reverse false = forward sort order; true = reverse sort order"
    },
    {
        "oracle": "reverse==true;",
        "javadocTag": "@param reverse false = forward sort order; true = reverse sort order"
    },
    {
        "oracle": "true ? methodResultID.equals(CollectionUtils.EMPTY_COLLECTION) : true;",
        "javadocTag": "@return immutable empty collection"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first collection, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second collection, must not be null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first collection, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second collection, must not be null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first collection, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second collection, must not be null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the collection to subtract from, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the collection to subtract, must not be null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the collection to subtract from, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the collection to subtract, must not be null"
    },
    {
        "oracle": "(coll1==null) == false;",
        "javadocTag": "@param coll1 the first collection, must not be null"
    },
    {
        "oracle": "(coll2==null) == false;",
        "javadocTag": "@param coll2 the second collection, must not be null"
    },
    {
        "oracle": "(coll1==null) == false;",
        "javadocTag": "@param coll1 the first collection, must not be null"
    },
    {
        "oracle": "(coll2==null) == false;",
        "javadocTag": "@param coll2 the second collection, must not be null"
    },
    {
        "oracle": "(coll==null) == false;",
        "javadocTag": "@param coll the collection to get the cardinality map for, must not be null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first (sub?) collection, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second (super?) collection, must not be null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first (sub?) collection, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second (super?) collection, must not be null"
    },
    {
        "oracle": "CollectionUtils.isSubCollection(a,b) ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return <code>true</code> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first collection, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second collection, must not be null"
    },
    {
        "oracle": "equator==null;",
        "javadocTag": "@throws NullPointerException if the equator is null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first collection, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second collection, must not be null"
    },
    {
        "oracle": "coll==null;",
        "javadocTag": "@throws NullPointerException if coll is null"
    },
    {
        "oracle": "true ? methodResultID.equals(closure) : true;",
        "javadocTag": "@return closure"
    },
    {
        "oracle": "true ? methodResultID.equals(closure) : true;",
        "javadocTag": "@return closure"
    },
    {
        "oracle": "inputCollection==null;",
        "javadocTag": "@throws NullPointerException if the input collection is null"
    },
    {
        "oracle": "(inputCollection==null) == false;",
        "javadocTag": "@param inputCollection the collection to get the input from, may not be null"
    },
    {
        "oracle": "(outputCollection==null) == false;",
        "javadocTag": "@param outputCollection the collection to output into, may not be null if the inputCollection\n  and predicate or not null"
    },
    {
        "oracle": "tolerance<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code tolerance} is {@code < 0} or NaN"
    },
    {
        "oracle": "tolerance<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code tolerance} is {@code < 0} or NaN"
    },
    {
        "oracle": "values.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code values} is empty or contains any non-finite value"
    },
    {
        "oracle": "values!=null && (values.length==0) == false;",
        "javadocTag": "@param values a nonempty series of values"
    },
    {
        "oracle": "values!=null && values.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code values} is empty"
    },
    {
        "oracle": "values!=null && (values.length==0) == false;",
        "javadocTag": "@param values a nonempty series of values"
    },
    {
        "oracle": "values!=null && values.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code values} is empty"
    },
    {
        "oracle": "(((map==null)==false) && (map.isEmpty())) == false;",
        "javadocTag": "@throws IllegalArgumentException if {@code map} is not empty"
    },
    {
        "oracle": "(((map==null)==false) && (map.isEmpty())) == false;",
        "javadocTag": "@throws IllegalArgumentException if {@code map} is not empty"
    },
    {
        "oracle": "(((map==null)==false) && (map.isEmpty())) == false;",
        "javadocTag": "@throws IllegalArgumentException if {@code map} is not empty"
    },
    {
        "oracle": "(((map==null)==false) && (map.isEmpty())) == false;",
        "javadocTag": "@throws IllegalArgumentException if {@code map} is not empty"
    },
    {
        "oracle": "true ? methodResultID.equals(dest) : true;",
        "javadocTag": "@return {@code dest}"
    },
    {
        "oracle": "(((map==null)==false) && (map.isEmpty())) == false;",
        "javadocTag": "@throws IllegalArgumentException if {@code map} is not empty"
    },
    {
        "oracle": "tasks==null;",
        "javadocTag": "@throws NullPointerException if any task is null"
    },
    {
        "oracle": "tasks==null;",
        "javadocTag": "@throws NullPointerException if any task is null"
    },
    {
        "oracle": "length==0 || length<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code length} is zero or negative"
    },
    {
        "oracle": "size<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is negative"
    },
    {
        "oracle": "position<0 || position>size;",
        "javadocTag": "@throws IndexOutOfBoundsException if {@code position} is negative or is\n        greater than {@code size}"
    },
    {
        "oracle": "size<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is negative"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "comparator==null;",
        "javadocTag": "@throws NullPointerException if {@code comparator} or any of {@code elements} is null"
    },
    {
        "oracle": "comparator==null;",
        "javadocTag": "@throws NullPointerException if {@code comparator} or any of {@code elements} is null"
    },
    {
        "oracle": "sortedMultiset==null;",
        "javadocTag": "@throws NullPointerException if {@code sortedMultiset} or any of its elements is null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "comparator==null;",
        "javadocTag": "@throws NullPointerException if {@code comparator} is null"
    },
    {
        "oracle": "columnKey==null;",
        "javadocTag": "@throws NullPointerException if {@code columnKey} is {@code null}"
    },
    {
        "oracle": "rowKey==null;",
        "javadocTag": "@throws NullPointerException if {@code rowKey} is {@code null}"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "swallowIOException==false;",
        "javadocTag": "@throws IOException if {@code swallowIOException} is false and {@code close} throws an\n    {@code IOException}."
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if the specified iterable is null or has any\n    null elements."
    },
    {
        "oracle": "elements==null || comparator==null;",
        "javadocTag": "@throws NullPointerException If the specified iterable is null, has any\n    null elements, or if the specified comparator is null."
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if the specified collection is null or has any\n    null elements."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true} always"
    },
    {
        "oracle": "this.isEmpty();",
        "javadocTag": "@throws NoSuchElementException if the queue is empty"
    },
    {
        "oracle": "this.isEmpty();",
        "javadocTag": "@throws NoSuchElementException if the queue is empty"
    },
    {
        "oracle": "permitsPerSecond<0 || warmupPeriod<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero or\n    {@code warmupPeriod} is negative"
    },
    {
        "oracle": "permitsPerSecond<0 || permitsPerSecond==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero"
    },
    {
        "oracle": "permits<0 || permits==0;",
        "javadocTag": "@throws IllegalArgumentException if the requested number of permits is negative or zero"
    },
    {
        "oracle": "permits<0 || permits==0;",
        "javadocTag": "@throws IllegalArgumentException if the requested number of permits is negative or zero"
    },
    {
        "oracle": "permits<0 || permits==0;",
        "javadocTag": "@throws IllegalArgumentException if the requested number of permits is negative or zero"
    },
    {
        "oracle": "true ? methodResultID==false : true;",
        "javadocTag": "@return {@code false} always"
    },
    {
        "oracle": "endInclusive<startInclusive;",
        "javadocTag": "@throws IllegalArgumentException if {@code endInclusive < startInclusive}"
    },
    {
        "oracle": "this.matchesAllOf(sequence) ? methodResultID == true : true;",
        "javadocTag": "@return {@code true} if this matcher matches every character in the sequence, including when\n        the sequence is empty"
    },
    {
        "oracle": "start<0 || start>sequence.length();",
        "javadocTag": "@throws IndexOutOfBoundsException if start is negative or greater than {@code\n        sequence.length()}"
    },
    {
        "oracle": "string==null;",
        "javadocTag": "@throws NullPointerException if {@code string} is null"
    },
    {
        "oracle": "s==null;",
        "javadocTag": "@throws NullPointerException if {@code string} is null"
    },
    {
        "oracle": "string!=null ? methodResultID.equals(string) : methodResultID.equals(\"\");",
        "javadocTag": "@return {@code string} itself if it is non-null; {@code \"\"} if it is null"
    },
    {
        "oracle": "(((string==null)==false) && (string.isEmpty())) == false ? (methodResultID.equals(string)||methodResultID==null) : true;",
        "javadocTag": "@return {@code string} itself if it is nonempty; {@code null} if it is\n    empty or null"
    },
    {
        "oracle": "string==null ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return {@code true} if the string is null or is the empty string"
    },
    {
        "oracle": "count<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code count} is negative"
    },
    {
        "oracle": "string!=null;",
        "javadocTag": "@param string any non-null string"
    },
    {
        "oracle": "count==0 ? methodResultID.equals(string) : true;",
        "javadocTag": "@return a string containing {@code string} repeated {@code count} times\n    (the empty string if {@code count} is zero)"
    },
    {
        "oracle": "start<0;",
        "javadocTag": "@throws IndexOutOfBoundsException if {@code start} is negative or greater\n    than the length of the array"
    },
    {
        "oracle": "size<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is negative"
    },
    {
        "oracle": "minLength<0 || padding<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code minLength} or {@code padding} is\n    negative"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if {@code collection} or any of its elements\n    is null"
    },
    {
        "oracle": "occurrences<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code occurrences} is negative, or if\n    this operation would result in more than {@link Integer#MAX_VALUE}\n    occurrences of the element"
    },
    {
        "oracle": "(element==null) || (occurrences==0);",
        "javadocTag": "@throws NullPointerException if {@code element} is null and this\n    implementation does not permit null elements. Note that if {@code\n    occurrences} is zero, the implementation may opt to return normally."
    },
    {
        "oracle": "occurrences==0;",
        "javadocTag": "@param occurrences the number of occurrences of the element to add. May be\n    zero, in which case no change will be made."
    },
    {
        "oracle": "occurrences<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code occurrences} is negative"
    },
    {
        "oracle": "this.remove(element);",
        "javadocTag": "@param element the element to conditionally remove occurrences of"
    },
    {
        "oracle": "occurrences==0;",
        "javadocTag": "@param occurrences the number of occurrences of the element to remove. May\n    be zero, in which case no change will be made."
    },
    {
        "oracle": "count<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code count} is negative"
    },
    {
        "oracle": "(element==null) || (count==0);",
        "javadocTag": "@throws NullPointerException if {@code element} is null and this\n    implementation does not permit null elements. Note that if {@code\n    count} is zero, the implementor may optionally return zero instead."
    },
    {
        "oracle": "oldCount<0 || newCount<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code oldCount} or {@code newCount} is\n    negative"
    },
    {
        "oracle": "(element==null) || (oldCount==0&&newCount==0);",
        "javadocTag": "@throws NullPointerException if {@code element} is null and the\n    implementation does not permit null elements. Note that if {@code\n    oldCount} and {@code newCount} are both zero, the implementor may\n    optionally return {@code true} instead."
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if {@code elements} is null"
    },
    {
        "oracle": "element==null;",
        "javadocTag": "@throws NullPointerException if {@code element} is null and this\n    implementation does not permit null elements"
    },
    {
        "oracle": "value<0 || value>255;",
        "javadocTag": "@throws IllegalArgumentException if {@code value} is negative or greater\n    than 255"
    },
    {
        "oracle": "array!= null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null && (array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code byte} values"
    },
    {
        "oracle": "array!= null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null && (array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code byte} values"
    },
    {
        "oracle": "(HostSpecifier.isValid(specifier)) == false;",
        "javadocTag": "@throws IllegalArgumentException if the specifier is not valid."
    },
    {
        "oracle": "(HostSpecifier.isValid(specifier)) == false;",
        "javadocTag": "@throws ParseException if the specifier is not valid."
    },
    {
        "oracle": "expectedKeys<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code expectedKeys} is negative"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true} always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "result==null;",
        "javadocTag": "@param result the result to return on successful completion. If you don't\n    need a particular result, consider using constructions of the form:\n    {@code ListenableFuture<?> f = ListenableFutureTask.create(runnable,\n    null)}"
    },
    {
        "oracle": "this.isEmpty();",
        "javadocTag": "@throws NoSuchElementException if this set is empty"
    },
    {
        "oracle": "this.isEmpty();",
        "javadocTag": "@throws NoSuchElementException if this set is empty"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>none</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>none</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any predicate in the collection is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to not"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer wrapping predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to call first"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to call with the result of the transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the total size of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if this map contains no key-value mappings"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key whose presence in this map is to be tested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this map contains a mapping for the specified key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@code Collection} of values, implementations should\n  return an empty collection for no mapping"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to store against"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to add to the collection at the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map changed as a result of this put operation, or false\n  if the map already contained the key-value mapping and the collection\n  type does not allow duplicate values, e.g. when using a Set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the put operation is not supported by\n  this multi-valued map, e.g. if it is unmodifiable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the key or value is null and null is invalid (optional)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if some aspect of the specified key or value prevents\n  it from being stored in this multi-valued map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to store against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map changed as a result of this operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map changed as a result of this operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the {@code putAll} operation is\n  not supported by this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if some property of a key or value in\n  the specified map prevents it from being stored in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map changed as a result of this operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the {@code putAll} operation is\n  not supported by this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if some property of a key or value in\n  the specified map prevents it from being stored in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to remove values from"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the map is unmodifiable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to remove from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param item the item to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the mapping was removed, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the map is unmodifiable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the key or value is null and null is invalid (optional)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the map is unmodifiable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set view of the mappings contained in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a multiset view of the keys contained in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set view of the keys contained in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a collection view of the values contained in this multi-valued map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map view of the mappings in this multi-valued map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an empty Set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an empty sorted Set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set the set, possibly <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an empty set if the argument is <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set1 the first set, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set2 the second set, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set the set to calculate the hash code for, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new identity hash set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized set backed by the given set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable set backed by the given set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a predicated set backed by the given set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a transformed set backed by the given set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an ordered set backed by the given set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized set backed by the given set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable set backed by the given set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a predicated sorted set backed by the given sorted set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a transformed set backed by the given set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable set backed by the given set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a predicated navigable set backed by the given navigable set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a transformed set backed by the given set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the generic type that is able to represent the types contained\n  in both input sets."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a view of the union of the two set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the generic type that is able to represent the types contained\n  in both input sets."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a view of the relative complement of  of the two sets"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the generic type that is able to represent the types contained\n  in both input sets."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a view of the intersection of the two sets"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the generic type that is able to represent the types contained\n  in both input sets."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a view of the symmetric difference of the two sets"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an inverted bidirectional map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimensions do not match."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to compute distance from."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the LInfDistance."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimensions do not match."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the difference of {@code this} and {@code v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimensions do not match."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the percentage of none zero elements as a decimal percent."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension Size of the vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension Size of the vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon Tolerance below which a value considered zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Original vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param resize Amount to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension Size of the vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedSize The expected number of non-zero entries."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension Size of the vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedSize Expected number of non-zero entries."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon Tolerance below which a value is considered zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values Set of values to create from."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values Set of values to create from."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon Tolerance below which a value is considered zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values The set of values to create from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values Set of values to create from."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon Tolerance below which a value is considered zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Instance to copy from."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Instance to copy from."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows number of rows of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columns number of columns of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row row index of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param column column index of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value current value of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value that the <code>walkInXxxOrder</code> must return"
    },
    {
        "oracle": ";",
        "javadocTag": "@param zero additive identity of the field"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension the size of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index of the entry being visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value of the entry being visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new value of the entry being visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned after visiting all entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Q matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Q matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the T matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the main diagonal elements of the B matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the main diagonal elements of the T matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the secondary diagonal elements of the T matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Symmetrical matrix to transform."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of rows."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of columns."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation for this matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to test equality against."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if object equals this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return hashcode for matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowDimension the number of rows in the new matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnDimension the number of columns in the new matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this + m}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to be subtracted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this - m}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m matrix to postmultiply by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this * m}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if\n{@code columnDimension(this) != rowDimension(m)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return 2-dimensional array of entries."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the underlying data array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in Data to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if the input array is empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the input array is not rectangular."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if the input array is {@code null}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowDimension Number of rows in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnDimension Number of columns in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Data for the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code d} is not rectangular."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Data for new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyArray if {@code true}, the input array will be copied,\notherwise it will be referenced."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code d} is not rectangular."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Column vector holding data for new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> Type of the field elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rawData Data array in raw layout."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new data array containing the same entries but in blocks layout"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code rawData} is not rectangular\n (not all rows have the same length)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> Type of the field elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows Number of rows in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param columns Number of columns in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new data array in blocks layout."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m matrix to be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this + m}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m matrix to be subtracted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this - m}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m matrix to postmultiply by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this * m}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the matrices are not compatible."
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcBlock source block"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if deserialised object has wrong type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll a collection to copy into this bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed SortedBag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed SortedBag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the object to be added does not implement\n{@link Comparable} and the {@link TreeBag} is using natural ordering"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the specified key is null and this bag uses\nnatural ordering, or its comparator does not permit null keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to copy into the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new predicated Bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the bag contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the bag contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new synchronized SortedBag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a SortedBag that complies to the Collection contract"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if deserialised object has wrong type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed Bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed Bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll a collection to copy into this multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current size of the multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of occurrences of the object, zero if not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the multiset contains the given element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the set of unique elements in this multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a view of the set of unique elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the uniqueSet iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the set of entries in this multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a view of the set of entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of unique elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entrySet iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException any of the usual I/O related exceptions"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException any of the usual I/O related exceptions"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if the stream contains an object which class can not be loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the stream does not contain the correct objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a debugging toString"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new predicated MultiSet"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the multiset contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the multiset contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the map being used by the MultiSet"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current size of the multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if multiset is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of occurrences of the object, zero if not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the multiset contains the given element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException any of the usual I/O related exceptions"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException any of the usual I/O related exceptions"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if the stream contains an object which class can not be loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the stream does not contain the correct objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of all of this multiset's elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the array elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to populate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of all of this multiset's elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArrayStoreException if the runtime type of the specified array is not\n  a supertype of the runtime type of the elements in this list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to assign"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable MultiSet"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if deserialised object has wrong type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multiset the multiset to decorate, may not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if multiset is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new synchronized MultiSet"
    },
    {
        "oracle": "maximalIterationCount<=MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@param maximalIterationCount maximum number of iterations\n(must be less than or equal to {@link #MIDPOINT_MAX_ITERATIONS_COUNT}"
    },
    {
        "oracle": "p<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code p <= 0}."
    },
    {
        "oracle": "p<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code p <= 0}."
    },
    {
        "oracle": "p<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code p <= 0}."
    },
    {
        "oracle": "p<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code p <= 0}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "nans==1;",
        "javadocTag": "@param nans code of the value, must be one of {@link #INFINITE},\n{@link #SNAN},  {@link #QNAN}"
    },
    {
        "oracle": "z==null;",
        "javadocTag": "@throws NullArgumentException if the measurement vector is {@code null}"
    },
    {
        "oracle": "z==null;",
        "javadocTag": "@throws NullArgumentException if the measurement vector is {@code null}"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\nparameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\nparameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\nparameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\nparameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\nparameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\nparameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\nparameters are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if <code>values</code> is null\nor p is invalid"
    },
    {
        "oracle": "sample1.length<2 || sample2.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the arrays length is less than 2."
    },
    {
        "oracle": "(n>0) == false;",
        "javadocTag": "@throws IllegalArgumentException if n is not positive."
    },
    {
        "oracle": "n>0;",
        "javadocTag": "@param n the bound on the random number to be returned.  Must be\npositive."
    },
    {
        "oracle": "(bytes==null) == false;",
        "javadocTag": "@param bytes Array in which to put the generated bytes. Cannot be {@code null}."
    },
    {
        "oracle": "start<0 || start>=bytes.length;",
        "javadocTag": "@throws OutOfRangeException if {@code start < 0} or {@code start >= bytes.length}."
    },
    {
        "oracle": "(bytes==null) == false;",
        "javadocTag": "@param bytes Array in which to put the generated bytes. Cannot be {@code null}."
    },
    {
        "oracle": "isLast==true;",
        "javadocTag": "@param isLast true if the step is the last one"
    },
    {
        "oracle": "(numberOfPoints>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if number of points is not positive"
    },
    {
        "oracle": "(numberOfPoints>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if number of points is not positive"
    },
    {
        "oracle": "(numberOfPoints>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if number of points is not positive"
    },
    {
        "oracle": "abs<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code abs <= 0}."
    },
    {
        "oracle": "abs<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code abs <= 0}."
    },
    {
        "oracle": "abs<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code abs <= 0}."
    },
    {
        "oracle": "abs<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code abs <= 0}."
    },
    {
        "oracle": "hyperplanes.length==0 ? methodResultID==null : true;",
        "javadocTag": "@return a new convex region, or null if the collection is empty"
    },
    {
        "oracle": "true ? methodResultID<=x : true;",
        "javadocTag": "@return the probability that a random variable with this\ndistribution takes a value less than or equal to {@code x}"
    },
    {
        "oracle": "x0>x1;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code x0 > x1}"
    },
    {
        "oracle": "p<0 || p>1;",
        "javadocTag": "@throws OutOfRangeException if {@code p < 0} or {@code p > 1}"
    },
    {
        "oracle": "(sampleSize>0) == false;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code sampleSize} is not positive"
    },
    {
        "oracle": "r<0;",
        "javadocTag": "@throws MathIllegalArgumentException if {@code r} is negative."
    },
    {
        "oracle": "initValue<=0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.OutOfRangeException if {@code initValue <= 0} or {@code initValue > 1}."
    },
    {
        "oracle": "valueAtNumCall<=0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code valueAtNumCall <= 0}."
    },
    {
        "oracle": "valueAtNumCall>=initValue;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if {@code valueAtNumCall >= initValue}."
    },
    {
        "oracle": "numCall<=0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code numCall <= 0}."
    },
    {
        "oracle": "initValue<=0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.OutOfRangeException if {@code initValue <= 0} or {@code initValue > 1}."
    },
    {
        "oracle": "slope>=0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if {@code slope >= 0}."
    },
    {
        "oracle": "numCall<=0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code numCall <= 0}."
    },
    {
        "oracle": "trials<0;",
        "javadocTag": "@throws NotPositiveException if {@code trials < 0}."
    },
    {
        "oracle": "p<0 || p>1;",
        "javadocTag": "@throws OutOfRangeException if {@code p < 0} or {@code p > 1}."
    },
    {
        "oracle": "trials<0;",
        "javadocTag": "@throws NotPositiveException if {@code trials < 0}."
    },
    {
        "oracle": "p<0 || p>1;",
        "javadocTag": "@throws OutOfRangeException if {@code p < 0} or {@code p > 1}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "(((matrix==null)==false) && (matrix.isSquare())) == false;",
        "javadocTag": "@throws NonSquareMatrixException if the matrix is not square"
    },
    {
        "oracle": "max<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code max <= 0}."
    },
    {
        "oracle": "manager==null;",
        "javadocTag": "@throws NullArgumentException if {@code manager} is {@code null}"
    },
    {
        "oracle": "a==null || b==null || x0==null;",
        "javadocTag": "@throws NullArgumentException if one of the parameters is {@code null}"
    },
    {
        "oracle": "a==null || b==null;",
        "javadocTag": "@throws NullArgumentException if one of the parameters is {@code null}"
    },
    {
        "oracle": "a==null || b==null || x0==null;",
        "javadocTag": "@throws NullArgumentException if one of the parameters is {@code null}"
    },
    {
        "oracle": "a==null || b==null || x0==null;",
        "javadocTag": "@throws NullArgumentException if one of the parameters is {@code null}"
    },
    {
        "oracle": "maximalOrder<2;",
        "javadocTag": "@throws NumberIsTooSmallException if maximal order is lower than 2"
    },
    {
        "oracle": "f==null;",
        "javadocTag": "@throws NullArgumentException if f is null."
    },
    {
        "oracle": "f==null;",
        "javadocTag": "@throws NullArgumentException if f is null."
    },
    {
        "oracle": "shape<=0 || scale<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code shape <= 0} or\n{@code scale <= 0}."
    },
    {
        "oracle": "shape<=0 || scale<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code shape <= 0} or\n{@code scale <= 0}."
    },
    {
        "oracle": "shape<=0 || scale<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code shape <= 0} or\n{@code scale <= 0}."
    },
    {
        "oracle": "shape<=0 || scale<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code shape <= 0} or\n{@code scale <= 0}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "k>n;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if {@code k > n}."
    },
    {
        "oracle": "data==null;",
        "javadocTag": "@throws NullArgumentException if {@code data} is null"
    },
    {
        "oracle": "data==null;",
        "javadocTag": "@throws NullArgumentException if {@code data} is null"
    },
    {
        "oracle": "x==null || y==null;",
        "javadocTag": "@throws NullArgumentException if either {@code x} or {@code y} is null"
    },
    {
        "oracle": "x==null || y==null;",
        "javadocTag": "@throws NullArgumentException if either {@code x} or {@code y} is null"
    },
    {
        "oracle": "x==null || y==null;",
        "javadocTag": "@throws NullArgumentException if either {@code x} or {@code y} is null"
    },
    {
        "oracle": "data==null;",
        "javadocTag": "@throws NullArgumentException if {@code data} is null"
    },
    {
        "oracle": "data==null;",
        "javadocTag": "@throws NullArgumentException if {@code data} is null"
    },
    {
        "oracle": "true ? methodResultID<d : true;",
        "javadocTag": "@return \\(P(D_n < d)\\)"
    },
    {
        "oracle": "true ? methodResultID<d : true;",
        "javadocTag": "@return \\(P(D_n < d)\\)"
    },
    {
        "oracle": "true ? methodResultID<d : true;",
        "javadocTag": "@return \\(P(D_n < d)\\)"
    },
    {
        "oracle": "true ? methodResultID<d : true;",
        "javadocTag": "@return \\(P(D_n < d)\\)"
    },
    {
        "oracle": "a>=b || c>b;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code a >= b} or if {@code c > b}."
    },
    {
        "oracle": "c<a;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code c < a}."
    },
    {
        "oracle": "a>=b || c>b;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code a >= b} or if {@code c > b}."
    },
    {
        "oracle": "c<a;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code c < a}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "addend==null;",
        "javadocTag": "@throws NullArgumentException if {@code addend} is {@code null}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse sine of this complex number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse tangent of this complex number"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cosine of this complex number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hyperbolic cosine of this complex number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code><i>e</i><sup>this</sup></code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value <code>ln &nbsp; this</code>, the natural logarithm\nof {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x exponent to which this {@code Complex} is to be raised."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code> this<sup>x</sup></code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x exponent to which this {@code Complex} is to be raised."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>this<sup>x</sup></code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sine of this complex number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hyperbolic sine of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square root of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square root of <code>1 - this<sup>2</sup></code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the tangent of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hyperbolic tangent of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the argument of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Degree of root."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a List of all {@code n}-th roots of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param realPart Real part."
    },
    {
        "oracle": ";",
        "javadocTag": "@param imaginaryPart Imaginary part."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new complex number instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param realPart Real part."
    },
    {
        "oracle": ";",
        "javadocTag": "@param imaginaryPart Imaginary part."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Complex instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param realPart Real part."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Complex instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A Complex instance with all fields resolved."
    },
    {
        "oracle": ";",
        "javadocTag": "@param real Real part."
    },
    {
        "oracle": ";",
        "javadocTag": "@param real Real part."
    },
    {
        "oracle": ";",
        "javadocTag": "@param imaginary Imaginary part."
    },
    {
        "oracle": ";",
        "javadocTag": "@param r the modulus of the complex number to create"
    },
    {
        "oracle": ";",
        "javadocTag": "@param theta the argument of the complex number to create"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>r&middot;e<sup>i&middot;theta</sup></code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param real Array of numbers to be converted to their {@code Complex}\nequivalent."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of {@code Complex} objects."
    },
    {
        "oracle": ";",
        "javadocTag": "@param function vectorial residuals function to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observations observations to be compared to objective function to compute residuals"
    },
    {
        "oracle": ";",
        "javadocTag": "@param function vectorial residuals function to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observations observations to be compared to objective function to compute residuals"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights weights to apply to the residuals"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the observations vector and the weights\nvector dimensions do not match (objective function dimension is checked only when\nthe {@link #value(double[])} method is called)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param function vectorial residuals function to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observations observations to be compared to objective function to compute residuals"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale scaling matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the observations vector and the scale\nmatrix dimensions do not match (objective function dimension is checked only when\nthe {@link #value(double[])} method is called)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType Type of optimization goal: either\n{@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startPoint Start point for optimization."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound Lower bound for each of the parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound Upper bound for each of the parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value for objective\nfunction."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the array sizes are wrong."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NumberIsTooSmallException if any\nof the initial values is less than its lower bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if any\nof the initial values is greater than its upper bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the stored point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to the internal array storing the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return data transfer object that will be serialized"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point coordinates. This instance will store\na copy of the array, not the array passed as argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Value of the objective function at the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point coordinates."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Value of the objective function at the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyArray if {@code true}, the input array will be copied,\notherwise it will be referenced."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iteration Index of current iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous Best point in the previous iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@param current Best point in the current iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the algorithm has converged."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold relative tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold absolute tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold relative tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold absolute tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIter Maximum iteration count."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x abscissa of the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y observed value of the point at x, after fitting we should\nhave f(x) as close as possible to this value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight weight of the observed point in the fit"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x abscissa of the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y observed value of the point at x, after fitting we should\nhave f(x) as close as possible to this value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed observed point to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return observed points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f parametric function to fit."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialGuess first guess of the function parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fitted parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f parametric function to fit."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialGuess first guess of the function parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fitted parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the number of allowed evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer optimizer to use for the fitting"
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer optimizer to use for the fitting"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the coefficients of the polynomial that best fits the observed points."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.ConvergenceException if the algorithm failed to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param guess First guess for the coefficients. They must be sorted in\nincreasing order of the polynomial's degree."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations of the polynomial."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the coefficients of the polynomial that best fits the observed points."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if\nthe number of evaluations exceeds {@code maxEval}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.ConvergenceException if the algorithm failed to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight the weight matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker convergence checker"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEvaluations the maximum number of times to evaluate the model"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number to times to iterate in the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lazyEvaluation Whether the call to {@link Evaluation#evaluate(RealVector)}\nwill defer the evaluation until access to the value is requested."
    },
    {
        "oracle": ";",
        "javadocTag": "@param paramValidator Model parameters validator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the specified General Least Squares problem."
    },
    {
        "oracle": ";",
        "javadocTag": "@param model the model function. Produces the computed values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed the observed (target) values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker convergence checker"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEvaluations the maximum number of times to evaluate the model"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number to times to iterate in the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the specified General Least Squares problem."
    },
    {
        "oracle": ";",
        "javadocTag": "@param model the model function. Produces the computed values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed the observed (target) values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight the weight matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker convergence checker"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEvaluations the maximum number of times to evaluate the model"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number to times to iterate in the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the specified General Least Squares problem."
    },
    {
        "oracle": ";",
        "javadocTag": "@param model the model function. Produces the computed values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param jacobian the jacobian of the model with respect to the parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed the observed (target) values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight the weight matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker convergence checker"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEvaluations the maximum number of times to evaluate the model"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number to times to iterate in the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the specified General Least Squares problem."
    },
    {
        "oracle": ";",
        "javadocTag": "@param problem the unweighted problem"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the matrix of weights"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@link LeastSquaresProblem} with the weights applied. The original\n        {@code problem} is not modified."
    },
    {
        "oracle": ";",
        "javadocTag": "@param problem the unweighted problem"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the diagonal of the weight matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@link LeastSquaresProblem} with the weights applied. The original\n        {@code problem} is not modified."
    },
    {
        "oracle": ";",
        "javadocTag": "@param problem the problem to track."
    },
    {
        "oracle": ";",
        "javadocTag": "@param counter the counter to increment."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a least squares problem that tracks evaluations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker the convergence checker to adapt."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Symmetric, positive-definite (weight) matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square-root of the weight matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the vector value function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param jacobian the Jacobian function"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function that computes both at the same time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param params Point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value at the given point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param params Point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Jacobian at the given point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point the abscissae"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the values and their Jacobian of this vector valued function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@link LeastSquaresProblem}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newMaxEvaluations the maximum number of evaluations permitted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newMaxIterations the maximum number of iterations permitted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newChecker the convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newChecker the convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the model function value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param jacobian the Jacobian of {@code value}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newModel the model function value and Jacobian"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newTarget the observed data."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newTarget the observed data."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newStart the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newStart the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newWeight the weight matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue Whether to perform lazy evaluation."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValidator Parameter validator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this object."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of scalar observations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of scalar parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point the parameter values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the model's value and derivative at the given point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations (of the model vector function) is\n         exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Abscissa of the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Observed value  at {@code x}. After fitting we should\nhave {@code f(x)} as close as possible to this value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight Weight of the observed point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Abscissa of the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Observed value  at {@code x}. After fitting we should\nhave {@code f(x)} as close as possible to this value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed Observed point to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the observed points, in the order they were added to this\ncontainer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialGuess First guess values in the following order:\n<ul>\n <li>Norm</li>\n <li>Mean</li>\n <li>Sigma</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parameters of the Gaussian function that best fits the\nobserved points (in the same order as above)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parameters of the Gaussian function that best fits the\nobserved points (in the same order as above)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Optimizer to use for the fitting."
    },
    {
        "oracle": ";",
        "javadocTag": "@param points Observations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fitted parameters."
    },
    {
        "oracle": "graph==null || startVertex==null;",
        "javadocTag": "@throws NullPointerException if the specified graph or startVertex is\n<code>null</code>."
    },
    {
        "oracle": "nPaths<0 || nPaths==0;",
        "javadocTag": "@throws IllegalArgumentException if nMaxHops is negative or 0."
    },
    {
        "oracle": "nMaxHops<0 || nMaxHops==0;",
        "javadocTag": "@throws IllegalArgumentException if nPaths is negative or 0."
    },
    {
        "oracle": "graph==null;",
        "javadocTag": "@throws IllegalArgumentException if the graph argument is <code>\nnull</code>."
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return event edge"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return event source vertex"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return event target vertex"
    },
    {
        "oracle": "g==null;",
        "javadocTag": "@throws IllegalArgumentException if <code>g==null</code> or does not\ncontain <code>startVertex</code>"
    },
    {
        "oracle": "this.hasNext();",
        "javadocTag": "@param edge the edge via which the vertex was encountered, or null if the\nvertex is a starting point"
    },
    {
        "oracle": "((queue==null)==false) && (queue.isEmpty());",
        "javadocTag": "@param queue queue to use for tie-break in case of partial order (e.g. a\nPriorityQueue can be used to break ties according to vertex priority);\nmust be initially empty"
    },
    {
        "oracle": "(((targetGraph==null)==false) && (targetGraph.containsEdge(edge))) == false ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return <tt>true</tt> if the target graph did not already contain the\nspecified edge."
    },
    {
        "oracle": "((vertices==null)==false) && (vertices.contains(null)) || vertices==null;",
        "javadocTag": "@throws NullPointerException if the specified vertices contains one or\nmore null vertices, or if the specified vertex collection is <tt>\nnull</tt>."
    },
    {
        "oracle": "graph==null;",
        "javadocTag": "@throws IllegalArgumentException if the graph argument is <code>\nnull</code>."
    },
    {
        "oracle": "g==null;",
        "javadocTag": "@throws IllegalArgumentException iff <code>g==null</code>"
    },
    {
        "oracle": "graph==null;",
        "javadocTag": "@throws IllegalArgumentException if the argument is <code>null</code>."
    },
    {
        "oracle": "this.getGraph()==null;",
        "javadocTag": "@throws IllegalArgumentException if the current graph is null."
    },
    {
        "oracle": "graph==null;",
        "javadocTag": "@throws IllegalArgumentException if the graph argument is <code>\nnull</code>."
    },
    {
        "oracle": "this.addEdge(source,target,edge);",
        "javadocTag": "@param edge the edge that was added."
    },
    {
        "oracle": "this.removeEdge(edge);",
        "javadocTag": "@param edge the edge that was removed."
    },
    {
        "oracle": "this.addVertex(vertex);",
        "javadocTag": "@param vertex the vertex that was added."
    },
    {
        "oracle": "this.removeVertex(vertex);",
        "javadocTag": "@param vertex the vertex that was removed."
    },
    {
        "oracle": "size<0;",
        "javadocTag": "@throws IllegalArgumentException if the specified size is negative."
    },
    {
        "oracle": "size<0;",
        "javadocTag": "@throws IllegalArgumentException if the specified size is negative."
    },
    {
        "oracle": "(this.containsEdge(sourceVertex,targetVertex)) == false ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return <tt>true</tt> if this graph did not already contain the specified\nedge."
    },
    {
        "oracle": "v==null;",
        "javadocTag": "@throws NullPointerException if the specified vertex is <code>\nnull</code>."
    },
    {
        "oracle": "(this.containsVertex(v)) == false ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return <tt>true</tt> if this graph did not already contain the specified\nvertex."
    },
    {
        "oracle": "(this.containsVertex(vertex)) == false;",
        "javadocTag": "@throws IllegalArgumentException if vertex is not found in the graph."
    },
    {
        "oracle": "vertex==null;",
        "javadocTag": "@throws NullPointerException if vertex is <code>null</code>."
    },
    {
        "oracle": "edges==null;",
        "javadocTag": "@throws NullPointerException if the specified edge collection is <tt>\nnull</tt>."
    },
    {
        "oracle": "vertices==null;",
        "javadocTag": "@throws NullPointerException if the specified vertex collection is <tt>\nnull</tt>."
    },
    {
        "oracle": "this.containsEdge(e) ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return <code>true</code> if and only if the graph contained the\nspecified edge."
    },
    {
        "oracle": "this.containsVertex(v) ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return <code>true</code> if the graph contained the specified vertex;\n<code>false</code> otherwise."
    },
    {
        "oracle": "graph==null;",
        "javadocTag": "@throws IllegalArgumentException if the graph argument is <code>\nnull</code>."
    },
    {
        "oracle": "v==null;",
        "javadocTag": "@throws NullPointerException if specified vertex is <code>null</code>."
    },
    {
        "oracle": "directed==false;",
        "javadocTag": "@param directed true to use parens for each edge (representing directed);\nfalse to use curly braces (representing undirected)"
    },
    {
        "oracle": "graph==null;",
        "javadocTag": "@throws IllegalArgumentException if the graph argument is <code>\nnull</code>."
    },
    {
        "oracle": "size<0;",
        "javadocTag": "@throws IllegalArgumentException if the specified size is negative."
    },
    {
        "oracle": "graph==null;",
        "javadocTag": "@throws IllegalArgumentException if the graph argument is <code>\nnull</code>."
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return this builder object"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return this builder object"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return this builder object"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return this builder object"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return this builder object"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return this builder object"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return this builder object"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return this builder object"
    },
    {
        "oracle": "true ? methodResultID == this.value : true;",
        "javadocTag": "@return the value."
    },
    {
        "oracle": "ef==null;",
        "javadocTag": "@throws NullPointerException if the specified edge factory is <code>\nnull</code>."
    },
    {
        "oracle": "graph==null;",
        "javadocTag": "@throws IllegalArgumentException if the argument is <code>null</code>."
    },
    {
        "oracle": "this.getGraph()==null;",
        "javadocTag": "@throws IllegalArgumentException if the current graph is null."
    },
    {
        "oracle": "maxSize<0 || maxSize==0;",
        "javadocTag": "@throws IllegalArgumentException if <code>maxSize</code> is negative or\n0."
    },
    {
        "oracle": "pathElement==null;",
        "javadocTag": "@throws NullPointerException if the specified path-element is <code>\nnull</code>."
    },
    {
        "oracle": "maxSize<0 || maxSize==0;",
        "javadocTag": "@throws IllegalArgumentException if <code>maxSize</code> is negative or\n0."
    },
    {
        "oracle": "maxSize<0 || maxSize==0;",
        "javadocTag": "@throws IllegalArgumentException if <code>maxSize</code> is negative or\n0."
    },
    {
        "oracle": "size<0;",
        "javadocTag": "@throws IllegalArgumentException if the specified size is negative."
    },
    {
        "oracle": "true ? methodResultID.equals(this.getG2()) : true;",
        "javadocTag": "@return G<sub>1</sub>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target "
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexFactory "
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultMap some array of vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numVertices1 number of vertices in the first partition"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numVertices2 number of vertices in the second partition"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numEdges number of edges to be generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param numVertices number of vertices in the k partitions"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numEdges number of edges to be generated between any two\npartitions"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param target "
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexFactory "
    },
    {
        "oracle": ";",
        "javadocTag": "@param numVertices "
    },
    {
        "oracle": ";",
        "javadocTag": "@return vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator that will traverse the graph in topological order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v "
    },
    {
        "oracle": ";",
        "javadocTag": "@param addToTop "
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether new vertex was added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return null if the edge is already in the graph, else the created edge\nis returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException If either fromVertex or toVertex is not\na member of the graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CycleFoundException if the edge would induce a cycle in the graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the edge was added to the graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CycleFoundException if adding an edge (fromVertex, toVertex) to\nthe graph would induce a cycle."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex being visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param df the set we are populating with forward connected vertices in\nthe Affected Region"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visited a simple data structure that lets us know if we already\nvisited a node with a given topo index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param topoIndexMap for quick lookups, a map from vertex to topo index in\nthe AR"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ub the topo index of the original fromVertex -- used for cycle\ndetection"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CycleFoundException if a cycle is discovered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex being visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param db the set we are populating with back-connected vertices in the\nAR"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visited "
    },
    {
        "oracle": ";",
        "javadocTag": "@param topoIndexMap "
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph of which a square is to be created."
    },
    {
        "oracle": ";",
        "javadocTag": "@param createLoops "
    },
    {
        "oracle": ";",
        "javadocTag": "@param numVertices number of vertices to be generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numEdges number of edges to be generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param g "
    },
    {
        "oracle": ";",
        "javadocTag": "@param g "
    },
    {
        "oracle": ";",
        "javadocTag": "@param g "
    },
    {
        "oracle": ";",
        "javadocTag": "@param g "
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the listener to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the listener to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/output parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return coordinates array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for components."
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix prefix to use instead of the default \"{\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix suffix to use instead of the default \"}\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator separator to use instead of the default \"; \""
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix prefix to use instead of the default \"{\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix suffix to use instead of the default \"}\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator separator to use instead of the default \"; \""
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for components."
    },
    {
        "oracle": ";",
        "javadocTag": "@return containing space"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if any coordinate of this point is NaN; false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p second point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between the instance and p"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane splitting hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an object containing both the part of the instance\non the plus side of the instance and the part of the\ninstance on the minus side of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane underlying hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param remainingRegion remaining region of the hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default 3D vector format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale the specific locale used by the format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the 3D vector format specific to the given locale."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector the object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link Vector3D} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathParseException if the beginning of the specified string\ncannot be parsed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/ouput parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link Vector3D} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for components."
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix prefix to use instead of the default \"{\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix suffix to use instead of the default \"}\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator separator to use instead of the default \"; \""
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix prefix to use instead of the default \"{\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix suffix to use instead of the default \"}\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator separator to use instead of the default \"; \""
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for components."
    },
    {
        "oracle": ";",
        "javadocTag": "@return start point of the segment"
    },
    {
        "oracle": ";",
        "javadocTag": "@return end point of the segment"
    },
    {
        "oracle": ";",
        "javadocTag": "@return line containing the segment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start start point of the segment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end end point of the segment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line line containing the segment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param polyhedronsSet polyhedrons set whose outline must be extracted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an outline, as an array of loops."
    },
    {
        "oracle": ";",
        "javadocTag": "@param loop points array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number of points to consider in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i index of the point to check (must be between 0 and n-1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the point is exactly between its neighbors"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u abscissa axis of the projection point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v ordinate axis of the projection point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xMin low bound along the x direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xMax high bound along the x direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yMin low bound along the y direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yMax high bound along the y direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param zMin low bound along the z direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param zMax high bound along the z direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@return boundary tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices list of polyhedrons set vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param facets list of facets, as vertices indices in the vertices list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@return boundary as a list of sub-hyperplanes"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if some basic sanity checks fail"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices list of polyhedrons set vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param facets list of facets, as vertices indices in the vertices list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return references array such that r[v][k] = f for some k if facet f contains vertex v"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if some facets have fewer than 3 vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices list of polyhedrons set vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param facets list of facets, as vertices indices in the vertices list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param references facets references array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return indices of vertices that follow vertex v in some facet (the array\nmay contain extra entries at the end, set to negative indices)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the same vertex appears more than\nonce in the successors list (which means one facet orientation is wrong)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point start point of the part of the line considered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line line to consider (contains point)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first sub-hyperplane crossed by the line after the\ngiven point, or null if the line does not intersect any\nsub-hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point start point of the part of the line considered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line line to consider (contains point)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first sub-hyperplane crossed by the line after the\ngiven point, or null if the line does not intersect any\nsub-hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node node containing the boundary facet to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the boundary facet this points belongs to (or null if it\ndoes not belong to any boundary facet)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param center rotation center"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rotation vectorial rotation operator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance representing the rotated region"
    },
    {
        "oracle": ";",
        "javadocTag": "@param translation translation to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance representing the translated region"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tree inside/outside BSP tree representing the region"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param boundary collection of boundary elements, as a\ncollection of {@link SubHyperplane SubHyperplane} objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices list of polyhedrons set vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param facets list of facets, as vertices indices in the vertices list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if some basic sanity checks fail"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xMin low bound along the x direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a 2-element array containing the new point (at index 0) and\nthe new direction (at index 1)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathUnsupportedOperationException if bounds were passed to the\n{@link #optimize(OptimizationData[]) optimize} method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel Relative threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abs Absolute threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel Relative threshold for this optimizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abs Absolute threshold for this optimizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lineRel Relative threshold for the internal line search optimizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lineAbs Absolute threshold for the internal line search optimizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel Relative threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abs Absolute threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel Relative threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abs Absolute threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lineRel Relative threshold for the internal line search optimizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lineAbs Absolute threshold for the internal line search optimizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param evaluationFunction Evaluation function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param original Original simplex (to be preserved)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param coeff Linear coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator Comparator to use to sort simplex vertices from best\nto poorest."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the best point in the transformed simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sideLength Length of the sides of the default (hypercube)\nsimplex. See {@link AbstractSimplex#AbstractSimplex(int,double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex. See\n{@link AbstractSimplex#AbstractSimplex(int,double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex. See\n{@link AbstractSimplex#AbstractSimplex(int,double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sideLength Length of the sides of the default (hypercube)\nsimplex. See {@link AbstractSimplex#AbstractSimplex(int,double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param steps Steps along the canonical axes representing box edges.\nThey may be negative but not zero. See"
    },
    {
        "oracle": ";",
        "javadocTag": "@param steps Steps along the canonical axes representing box edges.\nThey may be negative but not zero. See\n{@link AbstractSimplex#AbstractSimplex(double[])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param referenceSimplex Reference simplex. See\n{@link AbstractSimplex#AbstractSimplex(double[][])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param referenceSimplex Reference simplex. See\n{@link AbstractSimplex#AbstractSimplex(double[][])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if the reference simplex does not contain at least one point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if there is a dimension mismatch in the reference simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a comparator for sorting the optima."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Single-start optimizer to wrap."
    },
    {
        "oracle": ";",
        "javadocTag": "@param starts Number of starts to perform.\nIf {@code starts == 1}, the result will be same as if {@code optimizer}\nis called directly."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator Random vector generator to use for restarts."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point unbounded point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return either underlying function value or penalty function value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bounded bounded function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower lower bounds for each element of the input parameters array\n(some elements may be set to {@code Double.NEGATIVE_INFINITY} for\nunbounded values)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper upper bounds for each element of the input parameters array\n(some elements may be set to {@code Double.POSITIVE_INFINITY} for\nunbounded values)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset base offset of the penalty function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale scale of the penalty function"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if lower bounds, upper bounds and\nscales are not consistent, either according to dimension or to bounadary\nvalues"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective function gradient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g Gradient of the function to be optimized."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the model function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Model function to be optimized."
    },
    {
        "oracle": ";",
        "javadocTag": "@param qy array containing qTy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta upper bound on the euclidean norm of diagR * lmDir"
    },
    {
        "oracle": ";",
        "javadocTag": "@param diag diagonal matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param work1 work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param work2 work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param work3 work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param qy array containing qTy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param diag diagonal matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lmDiag diagonal elements associated with lmDir"
    },
    {
        "oracle": ";",
        "javadocTag": "@param work work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param jacobian Weighted Jacobian matrix at the current point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the decomposition cannot be performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y vector to multiply (will be overwritten with the result)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathUnsupportedOperationException if bounds were passed to the\n{@link #optimize(OptimizationData[]) optimize} method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param costRelativeTolerance Desired relative error in the sum of\nsquares."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parRelativeTolerance Desired relative error in the approximate\nsolution parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param orthoTolerance Desired max cosine on the orthogonality between\nthe function vector and the columns of the Jacobian."
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Desired threshold for QR ranking. If the squared norm\nof a column vector is smaller or equal to this threshold during QR\ndecomposition, it is considered to be a zero vector and hence the rank\nof the matrix is reduced."
    },
    {
        "oracle": ";",
        "javadocTag": "@param costRelativeTolerance Desired relative error in the sum of\nsquares."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parRelativeTolerance Desired relative error in the approximate\nsolution parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param orthoTolerance Desired max cosine on the orthogonality between\nthe function vector and the columns of the Jacobian."
    },
    {
        "oracle": ";",
        "javadocTag": "@param costRelativeTolerance Desired relative error in the sum of\nsquares."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parRelativeTolerance Desired relative error in the approximate\nsolution parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param orthoTolerance Desired max cosine on the orthogonality between\nthe function vector and the columns of the Jacobian."
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Desired threshold for QR ranking. If the squared norm\nof a column vector is smaller or equal to this threshold during QR\ndecomposition, it is considered to be a zero vector and hence the rank\nof the matrix is reduced."
    },
    {
        "oracle": ";",
        "javadocTag": "@param params Model parameters at which to compute the Jacobian."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the weighted Jacobian: W<sup>1/2</sup> J."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the Jacobian dimension does not\nmatch problem dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param residuals Residuals."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cost."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the RMS value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return chi-square value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square-root of the weight matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param cost Cost value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param params Model parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Singularity threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param contractionCriteria Contraction criteria."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if parameters are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity Initial size of the internal storage array.."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expansionFactor The array will be expanded based on this\nparameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param contractionCriterion Contraction criterion."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial size of the internal storage array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expansionFactor the array will be expanded based on this\n                       parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param contractionCriteria the contraction Criteria"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expansionMode the expansion mode"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if parameters are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity Initial size of the internal storage array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expansionFactor The array will be expanded based on this\nparameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param contractionCriterion Contraction criteria."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expansionMode Expansion mode."
    },
    {
        "oracle": ";",
        "javadocTag": "@param data Initial contents of the array."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param original array to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unique instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unique instance of this class"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size of the universe."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size of the subsets to be enumerated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a lexicographic comparator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Size of the set from which subsets are selected."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Size of the subsets to be enumerated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Size of the set from which subsets are selected."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Size of the subsets to be enumerated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterationOrder Specifies the {@link #iterator() iteration order}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if {@code k > n}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code new Double(x).equals(new Double(y))}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to be hashed (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a angle to normalize"
    },
    {
        "oracle": ";",
        "javadocTag": "@param center center of the desired 2&pi; interval for the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e1 first element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e2 second element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e1 first element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e2 second element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Value to reduce."
    },
    {
        "oracle": ";",
        "javadocTag": "@param period Period."
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset Value that will be mapped to {@code 0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value, within the interval {@code [0 |period|)},\nthat corresponds to {@code a}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param magnitude Magnitude of the returned value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sign Sign of the returned value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if {@code magnitude == Byte.MIN_VALUE}\nand {@code sign >= 0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param magnitude Magnitude of the returned value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sign Sign of the returned value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if {@code magnitude == Short.MIN_VALUE}\nand {@code sign >= 0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param magnitude Magnitude of the returned value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sign Sign of the returned value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if {@code magnitude == Integer.MIN_VALUE}\nand {@code sign >= 0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param magnitude Magnitude of the returned value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sign Sign of the returned value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if {@code magnitude == Long.MIN_VALUE}\nand {@code sign >= 0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if {@code x} is not a\nfinite real number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if any values of the array is not a\nfinite real number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param o Object to be checked."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Message pattern."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args Arguments to replace the placeholders in {@code pattern}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param o Object to be checked."
    },
    {
        "oracle": ";",
        "javadocTag": "@param o the Object to be transformed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the double value of the Object."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the Object can not be transformed into a Double."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the coefficient index to retrieve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the evaluation point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the n-th a coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the coefficient index to retrieve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the evaluation point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the n-th b coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the evaluation point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the continued fraction evaluated at x."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the evaluation point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon maximum error allowed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the continued fraction evaluated at x."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the evaluation point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations maximum number of convergents"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the continued fraction evaluated at x."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if maximal number of iterations is reached"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the evaluation point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon maximum error allowed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations maximum number of convergents"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the continued fraction evaluated at x."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if maximal number of iterations is reached"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The index corresponding to a random uniformly selected\nvalue between first and the last indices of the array slice"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException when indices exceeds range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param random random generator to use for selecting pivot"
    },
    {
        "oracle": "value==0;",
        "javadocTag": "@param value The new stabilization limit, 0 means no need to stabilize.\n           Else a value larger than zero or equal to 1 is accepted."
    },
    {
        "oracle": "strictChecking==false;",
        "javadocTag": "@param autoCreate If true (and strict checking is false), nodes are\n           automatically created when referenced when creating a edge,\n           even if not yet inserted in the graph."
    },
    {
        "oracle": "strictChecking==false;",
        "javadocTag": "@param autoCreate If true (and strict checking is false), nodes are\n           automatically created when referenced when creating a edge,\n           even if not yet inserted in the graph."
    },
    {
        "oracle": "digraph==true;",
        "javadocTag": "@param digraph true if the graph is directed"
    },
    {
        "oracle": "digraph==true;",
        "javadocTag": "@param digraph true is exported graph is directed"
    },
    {
        "oracle": "oldValue==null;",
        "javadocTag": "@param oldValue The old value of the attribute, null if the attribute was\n           added."
    },
    {
        "oracle": "newValue==null;",
        "javadocTag": "@param newValue The new value of the attribute, null if the attribute is about\n           to be removed."
    },
    {
        "oracle": "true ? ((methodResultID!=null&&methodResultID.equals(this.groups))||methodResultID==null) : true;",
        "javadocTag": "@return The group set or null."
    },
    {
        "oracle": "true ? methodResultID.equals(word1) : true;",
        "javadocTag": "@return The word eaten."
    },
    {
        "oracle": "strictChecking==false;",
        "javadocTag": "@param autoCreate If true (and strict checking is false), nodes are\n           automatically created when referenced when creating a edge,\n           even if not yet inserted in the graph."
    },
    {
        "oracle": "strictChecking==false;",
        "javadocTag": "@param autoCreate If true (and strict checking is false), nodes are\n           automatically created when referenced when creating a edge,\n           even if not yet inserted in the graph."
    },
    {
        "oracle": "on==true;",
        "javadocTag": "@param on true to enable autoflush"
    },
    {
        "oracle": "on==true;",
        "javadocTag": "@param on true to enable message for this event"
    },
    {
        "oracle": "on==true;",
        "javadocTag": "@param on true to enable events"
    },
    {
        "oracle": "on==true;",
        "javadocTag": "@param on true to enable events"
    },
    {
        "oracle": "replay==true;",
        "javadocTag": "@param replay true if the source should be replayed. You need a\n           {@link org.graphstream.stream.Replayable} source to enable\n           replay, else nothing happens."
    },
    {
        "oracle": "strictChecking==false;",
        "javadocTag": "@param autoCreate If true (and strict checking is false), nodes are\n           automatically created when referenced when creating a edge,\n           even if not yet inserted in the graph."
    },
    {
        "oracle": "strictChecking==false;",
        "javadocTag": "@param autoCreate If true (and strict checking is false), nodes are\n           automatically created when referenced when creating a edge,\n           even if not yet inserted in the graph."
    },
    {
        "oracle": "this.isLocked();",
        "javadocTag": "@param on If true the environment is locked."
    },
    {
        "oracle": "source==null;",
        "javadocTag": "@throws NullPointerException if source array is null"
    },
    {
        "oracle": "source==null;",
        "javadocTag": "@throws NullPointerException if source array is null"
    },
    {
        "oracle": "source==null;",
        "javadocTag": "@throws NullPointerException if source array is null"
    },
    {
        "oracle": "source==null;",
        "javadocTag": "@throws NullPointerException if source array is null"
    },
    {
        "oracle": "source==null;",
        "javadocTag": "@throws NullPointerException if source array is null"
    },
    {
        "oracle": "source==null;",
        "javadocTag": "@throws NullPointerException if source array is null"
    },
    {
        "oracle": "s==null;",
        "javadocTag": "@throws NullPointerException if <tt>s</tt> is null"
    },
    {
        "oracle": "encodedObject==null;",
        "javadocTag": "@throws NullPointerException if encodedObject is null"
    },
    {
        "oracle": "encodedObject==null;",
        "javadocTag": "@throws NullPointerException if encodedObject is null"
    },
    {
        "oracle": "dataToEncode==null;",
        "javadocTag": "@throws NullPointerException if dataToEncode is null"
    },
    {
        "oracle": "true ? methodResultID.equals(value) : true;",
        "javadocTag": "@return A value."
    },
    {
        "oracle": "oldValue==null;",
        "javadocTag": "@param oldValue The old value of the attribute, null if the attribute was\n           added."
    },
    {
        "oracle": "newValue==null;",
        "javadocTag": "@param newValue The new value of the attribute, null if the attribute is about\n           to be removed."
    },
    {
        "oracle": "true ? methodResultID == this.diagonal : true;",
        "javadocTag": "@return The diagonal."
    },
    {
        "oracle": "true ? methodResultID.equals(this.size) : true;",
        "javadocTag": "@return The size."
    },
    {
        "oracle": "true ? methodResultID == value : true;",
        "javadocTag": "@return The value converted to GU."
    },
    {
        "oracle": "strictChecking==false;",
        "javadocTag": "@param autoCreate If true (and strict checking is false), nodes are\n           automatically created when referenced when creating a edge,\n           even if not yet inserted in the graph."
    },
    {
        "oracle": "strictChecking==false;",
        "javadocTag": "@param autoCreate If true (and strict checking is false), nodes are\n           automatically created when referenced when creating a edge,\n           even if not yet inserted in the graph."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return Always true."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to test."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the element is visible and therefore must be rendered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graph to search for."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The first node or sprite at the given coordinates or null if\n        nothing found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graph to search for."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x1 The rectangle lowest point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y1 The rectangle lowest point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x2 The rectangle highest point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y2 The rectangle highest point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The set of sprites and nodes in the given rectangle."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sprite The sprite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos Receiver for the sprite 2D position, can be null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param units The units in which the position must be computed (the sprite\n           already contains units)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The same instance as the one given by parameter pos or a new one\n        if pos was null, containing the computed position in the given\n        units."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g2 The Swing graphics to change."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g2 The Swing graphics to restore."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g2 The Swing graphics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g2 The Swing graphics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param on If true, automatic adjustment is enabled."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z The zoom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param theta The rotation angle in degrees."
    },
    {
        "oracle": ";",
        "javadocTag": "@param viewportWidth The width in pixels of the view port."
    },
    {
        "oracle": ";",
        "javadocTag": "@param viewportHeight The width in pixels of the view port."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graphic graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sprite The sprite to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if visible."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge The edge to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if visible."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node The node to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@param X1 The min abscissa of the area."
    },
    {
        "oracle": ";",
        "javadocTag": "@param Y1 The min ordinate of the area."
    },
    {
        "oracle": ";",
        "javadocTag": "@param X2 The max abscissa of the area."
    },
    {
        "oracle": ";",
        "javadocTag": "@param Y2 The max ordinate of the area."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the node lies in the given area."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sprite The sprite to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@param X1 The min abscissa of the area."
    },
    {
        "oracle": ";",
        "javadocTag": "@param Y1 The min ordinate of the area."
    },
    {
        "oracle": ";",
        "javadocTag": "@param X2 The max abscissa of the area."
    },
    {
        "oracle": ";",
        "javadocTag": "@param Y2 The max ordinate of the area."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the node lies in the given area."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elt The node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if (x,y) is in the given element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elt The sprite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if (x,y) is in the given element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sprite The sprite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos Where to stored the computed position, if null, the position\n           is created."
    },
    {
        "oracle": ";",
        "javadocTag": "@param units The units the computed position must be given into."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The same instance as pos, or a new one if pos was null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sprite The sprite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos Where to stored the computed position, if null, the position\n           is created."
    },
    {
        "oracle": ";",
        "javadocTag": "@param units The units the computed position must be given into."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The same instance as pos, or a new one if pos was null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sprite The sprite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos Where to stored the computed position, if null, the position\n           is created."
    },
    {
        "oracle": ";",
        "javadocTag": "@param units The units the computed position must be given into."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The same instance as pos, or a new one if pos was null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param exceptionHandler Handler for subscriber exceptions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the source of this event."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the 'dead' event that could not be delivered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source object broadcasting the DeadEvent (generally the\n               {@link EventBus})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event the event that could not be delivered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier short name for the bus, for logging purposes."
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor Executor to use to dispatch events. It is the caller's\n       responsibility to shut down the executor after the last event has\n       been posted to this event bus."
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor Executor to use to dispatch events. It is the caller's\n       responsibility to shut down the executor after the last event has\n       been posted to this event bus."
    },
    {
        "oracle": ";",
        "javadocTag": "@param subscriberExceptionHandler Handler used to handle exceptions thrown from subscribers.\n   See {@link SubscriberExceptionHandler} for more information."
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor Executor to use to dispatch events. It is the caller's\n       responsibility to shut down the executor after the last event has\n       been posted to this event bus."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The {@link EventBus} that handled the event and the subscriber.\n    Useful for broadcasting a a new event based on the error."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The event object that caused the subscriber to throw."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The object context that the subscriber was called on."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The subscribed method that threw the exception."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eventBus The {@link EventBus} that handled the event and the\n    subscriber. Useful for broadcasting a a new event based on the error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event The event object that caused the subscriber to throw."
    },
    {
        "oracle": ";",
        "javadocTag": "@param subscriber The source subscriber context."
    },
    {
        "oracle": ";",
        "javadocTag": "@param subscriberMethod the subscribed method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param safeChars a non null string specifying additional safe characters\n       for this escaper (the ranges 0..9, a..z and A..Z are always safe and\n       should not be specified here)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if any of the parameters were invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param domain A domain name (not IP address)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Is the domain name syntactically valid?"
    },
    {
        "oracle": ";",
        "javadocTag": "@param part The domain name part to be validated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isFinalPart Is this the final (rightmost) domain part?"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Whether the part is valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if this domain name appears exactly on the public\n    suffix list"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if this domain does not end with a\n    public suffix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the domain has no parent, as determined\n    by {@link #hasParent}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if multiple charset values have been set for this media type"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalCharsetNameException if a charset value is present, but illegal"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedCharsetException if a charset value is present, but no support is available\n    in this instance of the Java virtual machine"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if any parameter or value is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if either {@code attribute} or {@code value} is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if type or subtype is invalid or if a wildcard is used for the\ntype, but not the subtype."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if subtype is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if subtype is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if subtype is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if subtype is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if subtype is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the input is not parsable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bytes byte array representing an IPv4 address (should be of length 4)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link Inet4Address} corresponding to the supplied byte array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if a valid {@link Inet4Address} can not be created"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g.\n    {@code \"192.168.0.1\"} or {@code \"2001:db8::1\"}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link InetAddress} representing the argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the argument is not a valid IP string literal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ipString {@code String} to evaluated as an IP string literal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the argument is a valid IP string literal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param addr the raw 4-byte or 16-byte IP address in big-endian order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an InetAddress object created from the raw IP address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ip {@link InetAddress} to be converted to an address string"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code String} containing the text-formatted IP address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hextets {@code int[]} mutable array of eight 16-bit hextets"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hextets {@code int[]} array of eight 16-bit hextets, or -1s"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ip {@link InetAddress} to be converted to URI string literal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code String} containing URI-safe string literal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an InetAddress representing the address in {@code hostAddr}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code hostAddr} is not a valid\n    IPv4 address, or IPv6 address surrounded by square brackets"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ipString {@code String} to evaluated as an IP URI host string literal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the argument is a valid IP URI host"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the argument is a valid \"compat\" address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ip {@link Inet6Address} to be examined for an embedded IPv4 address"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link Inet4Address} of the embedded IPv4 address"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the argument is not a valid IPv4 compatible address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ip {@link Inet6Address} to be examined for 6to4 address format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the argument is a 6to4 address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link Inet4Address} of embedded IPv4 in 6to4 address"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ip {@link Inet6Address} to be examined for Teredo address format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the argument is a Teredo address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ip {@link Inet6Address} to be examined for embedded Teredo information"
    },
    {
        "oracle": ";",
        "javadocTag": "@return extracted {@code TeredoInfo}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ip {@link Inet6Address} to be examined for ISATAP address format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the argument is an ISATAP address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link Inet4Address} of embedded IPv4 in an ISATAP address"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ip {@link Inet6Address} to be examined for embedded IPv4 client address"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if there is an embedded IPv4 client address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ip {@link Inet6Address} to be examined for embedded IPv4 client address"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link Inet4Address} of embedded IPv4 client address"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the argument is a valid \"mapped\" address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ip {@link InetAddress} to \"coerce\""
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link Inet4Address} represented \"coerced\" address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ip {@link InetAddress} to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code int}, \"coerced\" if ip is not an IPv4 address"
    },
    {
        "oracle": ";",
        "javadocTag": "@param address {@code int}, the 32bit integer address to be converted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link Inet4Address} equivalent of the argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param addr the raw IP address in little-endian byte order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an InetAddress object created from the raw IP address"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnknownHostException if IP address is of illegal length"
    },
    {
        "oracle": ";",
        "javadocTag": "@param address the InetAddress to decrement"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new InetAddress that is one less than the passed in address"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if InetAddress is at the beginning of its range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x valued to be right-shifted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y magnitude of the right-shift"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x valued to be right-shifted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y magnitude of the right-shift"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to have its sign taken"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sign of a: -1, 0, or 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param base the base"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expt the exponent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param base the base"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expt the exponent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@return greatest common divisor of a and b"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a array of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@return greatest common divisor of the elements of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a array of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@return greatest common divisor of the differences between the elements of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@return greatest common divisor of a and b"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a array of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@return greatest common divisor of the elements of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a array of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@return greatest common divisor of the differences between the elements of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@return greatest common divisor of a and b"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a array of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@return greatest common divisor of the elements of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a array of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@return greatest common divisor of the differences between the elements of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to be modded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y modulus"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nums array of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param itor iterator of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nums array of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nonstrict_ends whether endpoints are NOT subject to the strict density requirement"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the array contains fewer than 3 elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param itor iterator of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nonstrict_ends whether endpoints are NOT subject to the strict density requirement"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to be modded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y modulus"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nums array of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param itor iterator of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nums array of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nonstrict_ends whether endpoints are NOT subject to the strict density requirement"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the array contains fewer than 3 elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param itor iterator of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nonstrict_ends whether endpoints are NOT subject to the strict density requirement"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nums numbers to be excluded; length &gt; 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the set: [min(nums)..max(nums)] - nums"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nums the list of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a (remainder, modulus) pair that fails to match elements of nums"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nums the list of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a (remainder, modulus) pair that fails to match elements of nums"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nums numbers to be excluded; length &gt; 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the set: [min(nums)..max(nums)] - nums"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nums the list of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a (remainder, modulus) pair that fails to match elements of nums"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nums the list of operands"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a (remainder, modulus) pair that fails to match elements of nums"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename the file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@param md the MessageDigest"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the message digest"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is a problem reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bytes the bytes to convert to a String"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a String representation of the input bytes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the String to convert to an array of bytes"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the bytes equivalent to the input String"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delimiter the delimiter to be put between strings that are\nappended to this"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if the reference simplex does not contain at least one point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if there is a dimension mismatch in the reference simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return History of sigma values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return History of mean matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return History of fitness values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return History of D matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. In addition to those documented in\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\nMultivariateOptimizer}, this method will register the following data:\n<ul>\n <li>{@link Sigma}</li>\n <li>{@link PopulationSize}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the initial guess, target, and weight\narguments have inconsistent dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link Sigma}</li>\n <li>{@link PopulationSize}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param guess Initial guess for the arguments of the fitness function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param zmean Weighted row matrix of the gaussian random numbers generating\nthe current offspring."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xold xmean matrix of the previous generation."
    },
    {
        "oracle": ";",
        "javadocTag": "@return hsig flag indicating a small correction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hsig Flag indicating a small correction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param bestArz Fitness-sorted matrix of the gaussian random values of the\ncurrent offspring."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hsig Flag indicating a small correction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param bestArx Fitness-sorted matrix of the argument vectors producing the\ncurrent offspring."
    },
    {
        "oracle": ";",
        "javadocTag": "@param arz Unsorted matrix containing the gaussian random values of the\ncurrent offspring."
    },
    {
        "oracle": ";",
        "javadocTag": "@param arindex Indices indicating the fitness-order of the current offspring."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xold xmean matrix of the previous generation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param negccov Negative covariance factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vals History queue."
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Current best fitness value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param doubles Array of values to be sorted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a sorted array of indices pointing into doubles."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vpPairs Array of valuePenaltyPairs to get range from."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a double equal to maximum value minus minimum value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Matrix representing the element-wise logarithm of m."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Matrix representing the element-wise square root of m."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Matrix representing the element-wise square of m."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Input matrix 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the matrix where the elements of m and n are element-wise multiplied."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Input matrix 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Matrix where the elements of m and n are element-wise divided."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param cols Columns to select."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Matrix representing the selected columns."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Diagonal position."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Upper triangular part of matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Row matrix representing the sums of the rows."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the diagonal n-by-n matrix if m is a column matrix or the column\nmatrix representing the diagonal if m is a n-by-n matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m1 Source matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param col1 Source column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m2 Target matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param col2 Target column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of rows."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Number of columns."
    },
    {
        "oracle": ";",
        "javadocTag": "@return n-by-m matrix filled with 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of rows."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Number of columns."
    },
    {
        "oracle": ";",
        "javadocTag": "@return n-by-m matrix of 0 values out of diagonal, and 1 values on\nthe diagonal."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of rows."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Number of columns."
    },
    {
        "oracle": ";",
        "javadocTag": "@return n-by-m matrix of zero values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mat Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of row replicates."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Number of column replicates."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a matrix which replicates the input matrix in both directions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start Start value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param end End value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param step Step size."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a sequence as column matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum of the matrix element values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the minimum of the matrix element values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum of the array values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the minimum of the array values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param indices Input index array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse of the mapping defined by indices."
    },
    {
        "oracle": ";",
        "javadocTag": "@param indices Input index array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the indices in inverse order (last is first)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Length of random array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of Gaussian random numbers."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Number of rows."
    },
    {
        "oracle": ";",
        "javadocTag": "@param popSize Population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a 2-dimensional matrix of Gaussian random numbers."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations Maximal number of iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stopFitness Whether to stop if objective function value is smaller than\n{@code stopFitness}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param isActiveCMA Chooses the covariance matrix update method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param diagonalOnly Number of initial iterations, where the covariance matrix\nremains diagonal."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checkFeasableCount Determines how often new random objective variables are\ngenerated in case they are out of bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param random Random generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generateStatistics Whether statistic data is collected."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Point used in the line search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Direction used in the line search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimum Optimum found by the line search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param plusOutside part of the node cut sub-hyperplane that\nbelongs to the boundary and has the outside of the region on\nthe plus side of its underlying hyperplane (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param plusInside part of the node cut sub-hyperplane that\nbelongs to the boundary and has the inside of the region on the\nplus side of its underlying hyperplane (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param splitters sub-hyperplanes that were used to\nsplit the boundary part (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new sub-hyperplane, copy of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return underlying hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the instance is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size of the instance (this is a length in 1D, an area\nin 2D, a volume in 3D ...)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane hyperplane to check instance against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH},\n{@link Side#HYPER}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane splitting hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an object containing both the part of the instance\non the plus side of the hyperplane and the part of the\ninstance on the minus side of the hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other other sub-hyperplane to union (<em>must</em> be in the\nsame hyperplane as the instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new sub-hyperplane, union of the instance and other"
    },
    {
        "oracle": ";",
        "javadocTag": "@return dimension of the space"
    },
    {
        "oracle": ";",
        "javadocTag": "@return n-1 dimension sub-space of this space"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathUnsupportedOperationException for dimension-1 spaces\nwhich do not have sub-spaces"
    },
    {
        "oracle": ";",
        "javadocTag": "@return additive identity of the field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return multiplicative identity of the field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The {@code Class} object that represents the runtime\n        class of this object."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the state transition matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the control matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the process noise matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial state estimation vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial error covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the measurement matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the measurement noise matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the state dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the measurement vector dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the state estimation vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the state estimation vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the error covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the error covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u the control vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of the control vector does not fit"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u the control vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of the control vector does not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param z the measurement vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of the measurement vector does not fit"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if the covariance matrix could not be inverted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param z the measurement vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of the measurement vector does not fit"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if the covariance matrix could not be inverted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param process the model defining the underlying process dynamics"
    },
    {
        "oracle": ";",
        "javadocTag": "@param measurement the model defining the given measurement characteristics"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if any of the given inputs is null (except for the control matrix)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareMatrixException if the transition matrix is non square"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the column dimension of the transition matrix does not match the dimension of the\n            initial state estimation vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the matrix dimensions do not fit together"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stateTransition the state transition matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param control the control matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param processNoise the process noise matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialStateEstimate the initial state estimate vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialErrorCovariance the initial error covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if any row / column dimension of the input matrices is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if any of the input matrices is non-rectangular"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stateTransition the state transition matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param control the control matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param processNoise the process noise matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if any row / column dimension of the input matrices is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if any of the input matrices is non-rectangular"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stateTransition the state transition matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param control the control matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param processNoise the process noise matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialStateEstimate the initial state estimate vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialErrorCovariance the initial error covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param measMatrix the measurement matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param measNoise the measurement noise matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if any of the input matrices is {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if any row / column dimension of the input matrices is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if any of the input matrices is non-rectangular"
    },
    {
        "oracle": ";",
        "javadocTag": "@param measMatrix the measurement matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param measNoise the measurement noise matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random scalar with null mean and unit standard deviation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random scalar with null mean and unit standard deviation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator underlying random generator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the seed value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the seed value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the seed value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed <code>int</code>\n value from this random number generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a pseudorandom, uniformly distributed {@code int}\nvalue between 0 (inclusive) and n (exclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed <code>long</code>\nvalue from this random number generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed\n<code>boolean</code> value from this random number generator's\nsequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed <code>float</code>\nvalue between <code>0.0</code> and <code>1.0</code> from this\nrandom number generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed\n <code>double</code> value between <code>0.0</code> and\n <code>1.0</code> from this random number generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, Gaussian (\"normally\") distributed\n<code>double</code> value with mean <code>0.0</code> and\nstandard deviation <code>1.0</code> from this random number\n generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start First index into {@link #mem} array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed Initial seed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed Initial seed. If {@code null}, the seed will be related\nto the current time."
    },
    {
        "oracle": ";",
        "javadocTag": "@return underlying uncorrelated components generator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return rank of the square matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return root of the square matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random vector as an array of double. The returned array\nis created at each call, the caller can do what it wants with it."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean Expected mean values for all components."
    },
    {
        "oracle": ";",
        "javadocTag": "@param covariance Covariance matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param small Diagonal elements threshold under which  column are\nconsidered to be dependent on previous ones and are discarded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator underlying generator for uncorrelated normalized\ncomponents."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.linear.NonPositiveDefiniteMatrixException if the covariance matrix is not strictly positive definite."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the mean and covariance\narrays dimensions do not match."
    },
    {
        "oracle": ";",
        "javadocTag": "@param covariance Covariance matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param small Diagonal elements threshold under which  column are\nconsidered to be dependent on previous ones and are discarded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the minimum of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values input array of values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the percentile value to compute"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the percentile value or Double.NaN if the array is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values array of input values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the percentile to compute"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin the first (0-based) element to include in the computation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of array elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the percentile value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid or the\ninput array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample1 the first array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample2 the second array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sum of paired differences"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the arrays do not have the same\n(positive) length."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if the sample arrays are empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample1 the first array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample2 the second array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return mean of paired differences"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the arrays do not have the same\n(positive) length."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if the sample arrays are empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample1 the first array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample2 the second array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param meanDifference the mean difference between corresponding entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return variance of paired differences"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the arrays do not have the same\nlength."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample Sample to normalize."
    },
    {
        "oracle": ";",
        "javadocTag": "@return normalized (standardized) sample."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample input data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return array of array of the most frequently occurring element(s) sorted in ascending order."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the indices are invalid or the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample input data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index (0-based) of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return array of array of the most frequently occurring element(s) sorted in ascending order."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the indices are invalid or the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values input data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index (0-based) of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return array of array of the most frequently occurring element(s) sorted in ascending order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfTrials number of trials"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfSuccesses number of successes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param confidenceLevel desired probability that the true probability of\n       success falls within the returned interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Confidence interval containing the probability of success with\n        probability {@code confidenceLevel}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfTrials number of trials"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfSuccesses number of successes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param confidenceLevel desired probability that the true probability of\n       success falls within the returned interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Confidence interval containing the probability of success with\n        probability {@code confidenceLevel}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfTrials number of trials"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfSuccesses number of successes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param confidenceLevel desired probability that the true probability of\n       success falls within the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Confidence interval containing the probability of success with\n        probability {@code confidenceLevel}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfTrials number of trials"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfSuccesses number of successes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param confidenceLevel desired probability that the true probability of\n       success falls within the returned interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Confidence interval containing the probability of success with\n        probability {@code confidenceLevel}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfSuccesses number of successes (must not exceed numberOfTrials)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lower endpoint of the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the upper endpoint of the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the asserted probability that the interval contains the\n        population parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return String representation of the confidence interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower lower endpoint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper upper endpoint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param confidence confidence level"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound lower endpoint of the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound upper endpoint of the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param confidenceLevel coverage probability"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the preconditions are not met"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfTrials number of trials"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfSuccesses number of successes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param confidenceLevel desired probability that the true probability of\n       success falls within the returned interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Confidence interval containing the probability of success with\n        probability {@code confidenceLevel}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param biasCorrected if the covariance estimate shall be corrected for bias"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param j the column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the corresponding index in the matrix array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param j the column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@link StorelessBivariateCovariance} element at the given index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param j the column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cov the {@link StorelessBivariateCovariance} element to be set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xIndex row index in the covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yIndex column index in the covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the covariance of the given element"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of observations\nin the cell is &lt; 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data array representing one row of data."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of <code>rowData</code>\ndoes not match with the covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sc externally computed StorelessCovariance to add to this"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of sc does not match this"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of observations\nin a cell is &lt; 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a two-dimensional double array of covariance values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of observations\nfor a cell is &lt; 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return nothing as this implementation always throws a\n{@link MathUnsupportedOperationException}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathUnsupportedOperationException in all cases"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed\n <code>double</code> value between <code>0.0</code> and\n <code>1.0</code> from this random number generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed <code>float</code>\nvalue between <code>0.0</code> and <code>1.0</code> from this\nrandom number generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, Gaussian (\"normally\") distributed\n<code>double</code> value with mean <code>0.0</code> and\nstandard deviation <code>1.0</code> from this random number\n generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed <code>int</code>\n value from this random number generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a pseudorandom, uniformly distributed {@code int}\nvalue between 0 (inclusive) and n (exclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed <code>long</code>\nvalue from this random number generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param randomGenerator the wrapped generator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng JDK {@link Random} instance that will generate the\nthe random data."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the given RNG, wrapped in a {@link RandomGenerator}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed Original seed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the converted seed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integers array). If null\nthe seed of the generator will be the system time plus the system identity\nhash code of the instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (64 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k number of bits in the pool (not necessarily a multiple of 32)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m1 first parameter of the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m2 second parameter of the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m3 third parameter of the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k number of bits in the pool (not necessarily a multiple of 32)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m1 first parameter of the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m2 second parameter of the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m3 third parameter of the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k number of bits in the pool (not necessarily a multiple of 32)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m1 first parameter of the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m2 second parameter of the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m3 third parameter of the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integers array), if null\nthe seed of the generator will be related to the current time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k number of bits in the pool (not necessarily a multiple of 32)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m1 first parameter of the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m2 second parameter of the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m3 third parameter of the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (64 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the delegate object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param len the desired string length."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the random string."
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha first distribution shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param beta second distribution shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the beta(alpha, beta) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfTrials number of trials of the Binomial distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param probabilityOfSuccess probability of success of the Binomial distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Binomial(numberOfTrials, probabilityOfSuccess) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param median the median of the Cauchy distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale the scale parameter of the Cauchy distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Cauchy(median, scale) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param df the degrees of freedom of the ChiSquare distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the ChiSquare(df) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numeratorDf the numerator degrees of freedom of the F distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param denominatorDf the denominator degrees of freedom of the F distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the F(numeratorDf, denominatorDf) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape the median of the Gamma distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale the scale parameter of the Gamma distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Gamma(shape, scale) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param populationSize the population size of the Hypergeometric distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfSuccesses number of successes in the population of the Hypergeometric distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleSize the sample size of the Hypergeometric distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Hypergeometric(numberOfSuccesses, sampleSize) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r the number of successes of the Pascal distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the probability of success of the Pascal distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Pascal(r, p) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param df the degrees of freedom of the T distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value from the T(df) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape the shape parameter of the Weibull distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale the scale parameter of the Weibull distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Weibull(shape, size) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfElements the number of elements of the ZipfDistribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param exponent the exponent of the ZipfDistribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Zipf(numberOfElements, exponent) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the seed value to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the seed value to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param algorithm the name of the PRNG algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param provider the name of the provider"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchAlgorithmException if the specified algorithm is not available"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchProviderException if the specified provider is not installed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param distribution Continuous distribution to generate a random value from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random value sampled from the given distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the underlynig distribution throws one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param distribution Integer distribution to generate a random value from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random value sampled from the given distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the underlynig distribution throws one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rand the source of (non-secure) random data\n(may be null, resulting in the default generator)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param url url of the input file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an IO error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if URL contains no data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the input file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an IO error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param da object providing access to the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an IO error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value whose bin we are trying to find"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the bin containing the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the random value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if the distribution has not been loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sample statistics"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the distribution has not been loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of bins."
    },
    {
        "oracle": ";",
        "javadocTag": "@return List of bin statistics."
    },
    {
        "oracle": ";",
        "javadocTag": "@return array of bin upper bounds"
    },
    {
        "oracle": ";",
        "javadocTag": "@return array of upper bounds of subintervals used in data generation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException unless a {@code load} method has been\ncalled beforehand."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Array of {@code Double}s."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos Position of first entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Number of entries to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the size of {@code d} is less\nthan {@code pos + size}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param deep If {@code true} perform a deep copy, otherwise perform a\nshallow copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 First vector (will be put in front of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 Second vector (will be put at back of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 First vector (will be put in front of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 Second vector (will be put at back of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 First vector (will be put in front of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 Second vector (will be put at back of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 First vector (will be put in front of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 Second vector (will be put at back of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 First vector (will be put in front of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 Second vector (will be put at back of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector (will be put in front of the new vector)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector (will be put at back of the new vector)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the expected row dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the expected row dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the wrong column dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the expected column dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrongRowDim Wrong row dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrongColDim Wrong column dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedRowDim Expected row dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedColDim Expected column dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this + v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to be subtracted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this - v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector by which instance elements must be multiplied"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector containing {@code this[i] * v[i]} for all {@code i}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector by which instance elements must be divided"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector containing {@code this[i] / v[i]} for all {@code i}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if one entry of {@code v} is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@return array of entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector with which dot product should be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scalar dot product of {@code this} and {@code v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector onto which {@code this} must be projected"
    },
    {
        "oracle": ";",
        "javadocTag": "@return projection of {@code this} onto {@code v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if {@code v} is the null vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector with which outer product should be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the matrix outer product between instance and v"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to append to this one."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of first element to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector containing the values to set."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to compare instance with"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the vectors do not\nhave the same dimensions"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Expected dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension is not equal to the\nsize of {@code this} vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be used to process the entries of this\nvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorPreservingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor to be used to process the entries of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorPreservingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be used to process the entries of this\nvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorPreservingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor to be used to process the entries of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorPreservingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be used to process and modify the entries\nof this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorChangingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor to be used to process the entries of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorChangingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be used to process the entries of this\nvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorChangingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor to be used to process the entries of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorChangingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Object to test for equality."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if two vector objects are equal, {@code false}\notherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code value for this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry of the subvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry of the subvector (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code start} of {@code end} are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sig sign of the Dfp to create"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance with a non-finite value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link org.apache.commons.math3.Field Field} (really a {@link DfpField}) to which the instance belongs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of radix digits"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Dfp with value zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Dfp with value one"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Dfp with value two"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e desired exponent"
    },
    {
        "oracle": ";",
        "javadocTag": "@return last digit destroyed by shifting right"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number to check instance against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if instance is less than x and neither are NaN, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number to check instance against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if instance is greater than x and neither are NaN, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if instance is not NaN and less than or equal to 0, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if instance is not NaN and less than or equal to 0, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if instance is not NaN and greater than or equal to 0, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if instance is not NaN and greater than or equal to 0, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return absolute value of instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if instance is infinite"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if instance is not a number"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if instance is equal to zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other object to check instance against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if instance is equal to x and neither are NaN, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code value for this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number to check instance against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if instance is not equal to x and neither are NaN, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first instance in comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second instance in comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@return -1 if a<b, 1 if a>b and 0 if a==b\n Note this method does not properly handle NaNs or numbers with different precision."
    },
    {
        "oracle": ";",
        "javadocTag": "@return rounded value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return rounded value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return rounded value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d divisor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this less n &times; d, where n is the integer closest to this/d"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rmode rounding mode to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return truncated value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return converted number"
    },
    {
        "oracle": ";",
        "javadocTag": "@return integer base 10000 logarithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e desired power"
    },
    {
        "oracle": ";",
        "javadocTag": "@return 10000<sup>e</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return integer base 10 logarithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e desired power"
    },
    {
        "oracle": ";",
        "javadocTag": "@return 10<sup>e</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param extra ???"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ???"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sum of this and x"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the opposite of this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number to subtract"
    },
    {
        "oracle": ";",
        "javadocTag": "@return difference of this and a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n ???"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the IEEE flag if an exception occurred"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x multiplicand"
    },
    {
        "oracle": ";",
        "javadocTag": "@return product of this and x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x multiplicand"
    },
    {
        "oracle": ";",
        "javadocTag": "@return product of this and x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x multiplicand"
    },
    {
        "oracle": ";",
        "javadocTag": "@return product of this and x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param divisor divisor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return quotient of this by divisor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param divisor divisor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return quotient of this by divisor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return square root of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return string representation of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return string representation of the instance in scientific notation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return string representation of the instance in normal notation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the trap type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param what - name of routine trap occurred in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param oper - input operator to function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result - the result computed prior to the trap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The suggested return value from the trap handler"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type The exception type - e.g. FLAG_OVERFLOW"
    },
    {
        "oracle": ";",
        "javadocTag": "@param what The name of the routine we were in e.g. divide()"
    },
    {
        "oracle": ";",
        "javadocTag": "@param oper An operand to this function if any"
    },
    {
        "oracle": ";",
        "javadocTag": "@param def The default return value if trap not enabled"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result The result that is specified to be delivered per\n                  IEEE 854, if any"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value that should be return by the operation triggering the trap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return type of the number"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number to get the value from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y number to get the sign from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a number with the value of x and the sign of y"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x direction where to look at"
    },
    {
        "oracle": ";",
        "javadocTag": "@return closest number next to instance in the direction of x"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a double approximating the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of two doubles which sum represent the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return integer base 10 logarithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which this instance belongs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which this instance belongs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which this instance belongs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which this instance belongs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which this instance belongs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which this instance belongs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string representation of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which this instance belongs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sign sign of the Dfp to create"
    },
    {
        "oracle": "(second==null) == false;",
        "javadocTag": "@param second the second child iterator in the IteratorChain, not null"
    },
    {
        "oracle": "iteratorChain==null;",
        "javadocTag": "@throws NullPointerException if iterators array is or contains null"
    },
    {
        "oracle": "(iteratorChain==null) == false;",
        "javadocTag": "@param iteratorChain the array of iterators, not null"
    },
    {
        "oracle": "iteratorChain==null || ((iteratorChain==null)==false) && (iteratorChain.contains(null));",
        "javadocTag": "@throws NullPointerException if iterators collection is or contains null"
    },
    {
        "oracle": "(iteratorChain==null) == false;",
        "javadocTag": "@param iteratorChain the collection of iterators, not null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "(closure==null) == false;",
        "javadocTag": "@param closure the closure to execute, not null"
    },
    {
        "oracle": "(closure==null) == false;",
        "javadocTag": "@param closure the closure to execute, not null"
    },
    {
        "oracle": "trie==null;",
        "javadocTag": "@throws NullPointerException if trie is null"
    },
    {
        "oracle": "(trie==null) == false;",
        "javadocTag": "@param trie the trie to decorate, must not be null"
    },
    {
        "oracle": "trie==null;",
        "javadocTag": "@throws NullPointerException if trie is null"
    },
    {
        "oracle": "(trie==null) == false;",
        "javadocTag": "@param trie the trie to decorate, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "this.containsKey(value) ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return true if the map contains the key"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(key==null) == false;",
        "javadocTag": "@param key the key to check, may not be null"
    },
    {
        "oracle": "true ? methodResultID == offsetInBits : true;",
        "javadocTag": "@return the bit index where the key and other first differ"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return the transformed result"
    },
    {
        "oracle": "set==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if set or transformer is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "set==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if set or transformer is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "set==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if set or transformer is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "object==null ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return true if input is null"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if <code>array</code> is <code>null</code>"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if <code>array</code> is <code>null</code>"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if <code>array</code> is <code>null</code>"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@param defaultList the returned values if list is {@code null}"
    },
    {
        "oracle": "list1==null || list2==null;",
        "javadocTag": "@throws NullPointerException if either list is null"
    },
    {
        "oracle": "list1==null || list2==null;",
        "javadocTag": "@throws NullPointerException if either list is null"
    },
    {
        "oracle": "list1==null || list2==null;",
        "javadocTag": "@throws NullPointerException if either list is null"
    },
    {
        "oracle": "list1==null || list2==null;",
        "javadocTag": "@throws NullPointerException if either list is null"
    },
    {
        "oracle": "inputCollection==null;",
        "javadocTag": "@throws NullPointerException if the input list is null"
    },
    {
        "oracle": "(inputCollection==null) == false;",
        "javadocTag": "@param inputCollection the collection to get the input from, may not be null"
    },
    {
        "oracle": "inputCollection==null;",
        "javadocTag": "@throws NullPointerException if the input collection is null"
    },
    {
        "oracle": "(inputCollection==null) == false;",
        "javadocTag": "@param inputCollection the collection to get the input from, may not be null"
    },
    {
        "oracle": "((list1==null)==false) && (list1.equals(list2)) ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return whether the lists are equal by value comparison"
    },
    {
        "oracle": "collection==null || retain==null;",
        "javadocTag": "@throws NullPointerException if either parameter is null"
    },
    {
        "oracle": "collection==null || remove==null;",
        "javadocTag": "@throws NullPointerException if either parameter is null"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if the list is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to synchronize, must not be null"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if the list is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to make unmodifiable, must not be null"
    },
    {
        "oracle": "list==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if the List or Predicate is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to predicate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate for the list, must not be null"
    },
    {
        "oracle": "list==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if the List or Transformer is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to predicate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer for the list, must not be null"
    },
    {
        "oracle": "list==null || factory==null;",
        "javadocTag": "@throws NullPointerException if the List or Factory is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to make lazy, must not be null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory for creating new objects, must not be null"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if the List is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list whose size to fix, must not be null"
    },
    {
        "oracle": "a==null || b==null;",
        "javadocTag": "@throws NullPointerException if either list is {@code null}"
    },
    {
        "oracle": "a==null || b==null || equator==null;",
        "javadocTag": "@throws NullPointerException if either list or the equator is {@code null}"
    },
    {
        "oracle": "a==null || b==null;",
        "javadocTag": "@throws NullPointerException if either sequence is {@code null}"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if list is null"
    },
    {
        "oracle": "(size>0) == false;",
        "javadocTag": "@throws IllegalArgumentException if size is not strictly positive"
    },
    {
        "oracle": "set==null || list==null;",
        "javadocTag": "@throws NullPointerException if set or list is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if list is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the {@link Set} to be used as return type, must not be null"
    },
    {
        "oracle": "set==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if set or predicate is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "set==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if set or predicate is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "this.getIterator()==null || this.getPredicate()==null;",
        "javadocTag": "@throws NullPointerException if either the iterator or predicate are null"
    },
    {
        "oracle": "this.getIterator()==null || this.getPredicate()==null;",
        "javadocTag": "@throws NullPointerException if either the iterator or predicate are null"
    },
    {
        "oracle": "queue==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if queue or transformer is null"
    },
    {
        "oracle": "(queue==null) == false;",
        "javadocTag": "@param queue the queue to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "queue==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if queue or transformer is null"
    },
    {
        "oracle": "(queue==null) == false;",
        "javadocTag": "@param queue the queue to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "queue==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if queue or transformer is null"
    },
    {
        "oracle": "(queue==null) == false;",
        "javadocTag": "@param queue the queue to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to decorate, must not be null"
    },
    {
        "oracle": "multiset==null;",
        "javadocTag": "@throws NullPointerException if multiset is null"
    },
    {
        "oracle": "(multiset==null) == false;",
        "javadocTag": "@param multiset the multiset to decorate, may not be null"
    },
    {
        "oracle": "queue==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if queue or predicate is null"
    },
    {
        "oracle": "(queue==null) == false;",
        "javadocTag": "@param queue the queue to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "Queue==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if queue or predicate is null"
    },
    {
        "oracle": "(Queue==null) == false;",
        "javadocTag": "@param Queue the queue to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws FunctorException always"
    },
    {
        "oracle": "index<0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n        zero."
    },
    {
        "oracle": "isLast==true;",
        "javadocTag": "@param isLast true if the step is the last one"
    },
    {
        "oracle": "cb==null;",
        "javadocTag": "@throws NullArgumentException if {@code cb} is {@code null}"
    },
    {
        "oracle": "(parentTree==null) == false;",
        "javadocTag": "@param isPlusChild if true and if parentTree is not null, the\nresulting tree should be the plus child of its parent, ignored if\nparentTree is null"
    },
    {
        "oracle": "(parentTree==null) == false;",
        "javadocTag": "@param isPlusChild if true and if parentTree is not null, the\nresulting tree should be the plus child of its parent, ignored if\nparentTree is null"
    },
    {
        "oracle": "true ? methodResultID==v : true;",
        "javadocTag": "@return the proportion of values equal to v"
    },
    {
        "oracle": "true ? methodResultID==v : true;",
        "javadocTag": "@return the proportion of values equal to v"
    },
    {
        "oracle": "true ? methodResultID==v : true;",
        "javadocTag": "@return the proportion of values equal to v"
    },
    {
        "oracle": "true ? methodResultID==v : true;",
        "javadocTag": "@return the proportion of values equal to v"
    },
    {
        "oracle": "true ? methodResultID==v : true;",
        "javadocTag": "@return the proportion of values equal to v"
    },
    {
        "oracle": "true ? methodResultID==v : true;",
        "javadocTag": "@return the proportion of values equal to v"
    },
    {
        "oracle": "true ? methodResultID<=v : true;",
        "javadocTag": "@return the proportion of values less than or equal to v"
    },
    {
        "oracle": "true ? methodResultID<=v : true;",
        "javadocTag": "@return the proportion of values less than or equal to v"
    },
    {
        "oracle": "true ? methodResultID<=v : true;",
        "javadocTag": "@return the proportion of values less than or equal to v"
    },
    {
        "oracle": "other==null;",
        "javadocTag": "@throws NullArgumentException if {@code other} is null"
    },
    {
        "oracle": "others==null;",
        "javadocTag": "@throws NullArgumentException if the collection is null"
    },
    {
        "oracle": "initialCapacity<=0;",
        "javadocTag": "@throws MathIllegalArgumentException if {@code initialCapacity <= 0}."
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "contraction<expansion;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code contraction <= 1}."
    },
    {
        "oracle": "contraction<=1;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code contraction < expansion}."
    },
    {
        "oracle": "expansion<=1;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code expansion <= 1 }."
    },
    {
        "oracle": "i>this.getNumElements();",
        "javadocTag": "@throws MathIllegalArgumentException if i is greater than numElements."
    },
    {
        "oracle": "i>this.getNumElements();",
        "javadocTag": "@throws MathIllegalArgumentException if i is greater than numElements."
    },
    {
        "oracle": "index<0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\nzero or is greater than <code>getNumElements() - 1</code>."
    },
    {
        "oracle": "index<0;",
        "javadocTag": "@throws ArrayIndexOutOfBoundsException if {@code index < 0}."
    },
    {
        "oracle": "expansionFactor<=1;",
        "javadocTag": "@throws MathIllegalArgumentException if expansionFactor is <= 1 or greater\nthan contractionFactor"
    },
    {
        "oracle": "(initialCapacity>0) == false;",
        "javadocTag": "@throws MathIllegalArgumentException if <code>initialCapacity</code> is not\npositive."
    },
    {
        "oracle": "i<0;",
        "javadocTag": "@throws MathIllegalArgumentException if <code>i</code> is negative."
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "true ? methodResultID.equals(f) : true;",
        "javadocTag": "@return the complex transformed array"
    },
    {
        "oracle": "true ? methodResultID<=x : true;",
        "javadocTag": "@return the probability that a random variable with this\ndistribution takes a value less than or equal to {@code x}"
    },
    {
        "oracle": "x0>x1;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code x0 > x1}"
    },
    {
        "oracle": "p<0 || p>1;",
        "javadocTag": "@throws OutOfRangeException if {@code p < 0} or {@code p > 1}"
    },
    {
        "oracle": "(sampleSize>0) == false;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code sampleSize} is not positive"
    },
    {
        "oracle": "alpha<=0 || beta<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code alpha <= 0} or\n{@code beta <= 0}."
    },
    {
        "oracle": "alpha<=0 || beta<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code alpha <= 0} or\n{@code beta <= 0}."
    },
    {
        "oracle": "alpha<=0 || beta<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code alpha <= 0} or {@code beta <= 0}."
    },
    {
        "oracle": "alpha<=0 || beta<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code alpha <= 0} or {@code beta <= 0}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return chosen cluster center"
    },
    {
        "oracle": "numberOfTrials<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}."
    },
    {
        "oracle": "numberOfSuccesses<0;",
        "javadocTag": "@throws NotPositiveException if {@code numberOfSuccesses < 0}."
    },
    {
        "oracle": "numberOfSuccesses>numberOfTrials;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}."
    },
    {
        "oracle": "x.length==0 || y.length==0 || f.length==0 || dFdX.length==0 || dFdY.length==0 || d2FdXdY.length==0;",
        "javadocTag": "@throws NoDataException if any of the arrays has zero length."
    },
    {
        "oracle": "(sampleSize>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code sampleSize} is not\npositive."
    },
    {
        "oracle": "(sampleSize>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code sampleSize} is not positive."
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullArgumentException if {@code array} is null"
    },
    {
        "oracle": "(dimension>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if the dimension is\nnot positive."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if d is null"
    },
    {
        "oracle": "this.isSingular(threshold);",
        "javadocTag": "@throws SingularMatrixException if the matrix is singular"
    },
    {
        "oracle": "x.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the number of points is less than 2."
    },
    {
        "oracle": "z<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the size of {@code x} is less\nthan 2."
    },
    {
        "oracle": "x.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the size of {@code x} is less\nthan 2."
    },
    {
        "oracle": "x.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the number of points is less than 2."
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if values is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if values is null or the indices are invalid"
    },
    {
        "oracle": "window<1 && (window==DescriptiveStatistics.INFINITE_WINDOW) == false;",
        "javadocTag": "@throws MathIllegalArgumentException if window size is less than 1 but\nnot equal to {@link #INFINITE_WINDOW}"
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "windowSize<1 && (windowSize==DescriptiveStatistics.INFINITE_WINDOW) == false;",
        "javadocTag": "@throws MathIllegalArgumentException if window size is less than 1 but\nnot equal to {@link #INFINITE_WINDOW}"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "lower>upper;",
        "javadocTag": "@throws NumberIsTooLargeException if lower is greater than upper"
    },
    {
        "oracle": "min>maxEval;",
        "javadocTag": "@throws IllegalArgumentException if {@code min > max} or the endpoints\ndo not satisfy the requirements specified by the optimizer."
    },
    {
        "oracle": "min>maxEval;",
        "javadocTag": "@throws IllegalArgumentException if {@code min > max} or the endpoints\ndo not satisfy the requirements specified by the optimizer."
    },
    {
        "oracle": "f==null || goalType==null;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NullArgumentException if any\nargument is {@code null}."
    },
    {
        "oracle": "n>0;",
        "javadocTag": "@param n the number to factor, must be &gt; 0."
    },
    {
        "oracle": "n>=SmallPrimes.PRIMES_LAST+2;",
        "javadocTag": "@param n the number to factorize, must be >= PRIME_LAST+2 and must not contain any factor below PRIME_LAST+2"
    },
    {
        "oracle": "maxIter<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code maxIter <= 0}."
    },
    {
        "oracle": "points==null;",
        "javadocTag": "@throws MathIllegalArgumentException if points are null or the number of\n  data points is not compatible with this clusterer"
    },
    {
        "oracle": "(first instanceof AbstractListChromosome) == false || (second instanceof AbstractListChromosome) == false;",
        "javadocTag": "@throws MathIllegalArgumentException iff one of the chromosomes is\n  not an instance of {@link AbstractListChromosome}"
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}."
    },
    {
        "oracle": "lower>upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower > upper}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "(minimalIterationCount>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive"
    },
    {
        "oracle": "maximalIterationCount>TrapezoidIntegrator.TRAPEZOID_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@throws NumberIsTooLargeException if maximal number of iterations\nis greater than {@link #TRAPEZOID_MAX_ITERATIONS_COUNT}"
    },
    {
        "oracle": "maximalIterationCount<=TrapezoidIntegrator.TRAPEZOID_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@param maximalIterationCount maximum number of iterations\n(must be less than or equal to {@link #TRAPEZOID_MAX_ITERATIONS_COUNT}"
    },
    {
        "oracle": "(minimalIterationCount>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive"
    },
    {
        "oracle": "maximalIterationCount>TrapezoidIntegrator.TRAPEZOID_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@throws NumberIsTooLargeException if maximal number of iterations\nis greater than {@link #TRAPEZOID_MAX_ITERATIONS_COUNT}"
    },
    {
        "oracle": "maximalIterationCount<=TrapezoidIntegrator.TRAPEZOID_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@param maximalIterationCount maximum number of iterations\n(must be less than or equal to {@link #TRAPEZOID_MAX_ITERATIONS_COUNT}"
    },
    {
        "oracle": "maxGenerations<1;",
        "javadocTag": "@throws NumberIsTooSmallException if the number of generations is &lt; 1"
    },
    {
        "oracle": "sample1==null || sample2==null;",
        "javadocTag": "@throws NullArgumentException if the arrays are <code>null</code>"
    },
    {
        "oracle": "sample1.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the length of the arrays is &lt; 2"
    },
    {
        "oracle": "sample1==null || sample2==null;",
        "javadocTag": "@throws NullArgumentException if the arrays are <code>null</code>"
    },
    {
        "oracle": "sample1.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the length of the arrays is &lt; 2"
    },
    {
        "oracle": "sample1==null || sample2==null;",
        "javadocTag": "@throws NullArgumentException if the arrays are <code>null</code>"
    },
    {
        "oracle": "sample1.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the length of the arrays is &lt; 2"
    },
    {
        "oracle": "observed==null;",
        "javadocTag": "@throws NullArgumentException if <code>observed</code> is <code>null</code>"
    },
    {
        "oracle": "observed.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the length of <code>observed</code> is &lt; 2"
    },
    {
        "oracle": "sampleStats==null;",
        "javadocTag": "@throws NullArgumentException if <code>sampleStats</code> is <code>null</code>"
    },
    {
        "oracle": "sample1==null || sample2==null;",
        "javadocTag": "@throws NullArgumentException if the arrays are <code>null</code>"
    },
    {
        "oracle": "sample1.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the length of the arrays is &lt; 2"
    },
    {
        "oracle": "sample1==null || sample2==null;",
        "javadocTag": "@throws NullArgumentException if the arrays are <code>null</code>"
    },
    {
        "oracle": "sample1.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the length of the arrays is &lt; 2"
    },
    {
        "oracle": "sampleStats1==null;",
        "javadocTag": "@throws NullArgumentException if the sample statistics are <code>null</code>"
    },
    {
        "oracle": "sampleStats1==null;",
        "javadocTag": "@throws NullArgumentException if the sample statistics are <code>null</code>"
    },
    {
        "oracle": "sample==null;",
        "javadocTag": "@throws NullArgumentException if the sample array is <code>null</code>"
    },
    {
        "oracle": "sample.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the length of the array is &lt; 2"
    },
    {
        "oracle": "sample==null;",
        "javadocTag": "@throws NullArgumentException if the sample array is <code>null</code>"
    },
    {
        "oracle": "sample.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the length of the array is &lt; 2"
    },
    {
        "oracle": "sampleStats==null;",
        "javadocTag": "@throws NullArgumentException if <code>sampleStats</code> is <code>null</code>"
    },
    {
        "oracle": "sampleStats==null;",
        "javadocTag": "@throws NullArgumentException if <code>sampleStats</code> is <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Mann-Whitney U statistic (maximum of U<sup>x</sup> and U<sup>y</sup>)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param Umin smallest Mann-Whitney U value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n1 number of subjects in first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n2 number of subjects in second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return two-sided asymptotic p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the p-value can not be computed\ndue to a convergence error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the maximum number of\niterations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y the second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return asymptotic p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the p-value can not be computed due to a\nconvergence error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the maximum number of iterations\nis exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nanStrategy specifies the strategy that should be used for Double.NaN's"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tiesStrategy specifies the strategy that should be used for ties"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if {@code x} or {@code y} are {@code null}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if {@code x} or {@code y} are zero-length."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code x} and {@code y} do not\nhave the same length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return z = y - x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param z sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return |z|"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if {@code z} is {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if {@code z} is zero-length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y the second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return wilcoxonSignedRank statistic (the larger of W+ and W-)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code x} and {@code y} do not\nhave the same length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param Wmax largest Wilcoxon signed rank value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param N number of subjects (corresponding to x.length)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return two-sided exact p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param Wmin smallest Wilcoxon signed rank value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param N number of subjects (corresponding to x.length)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return two-sided asymptotic p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y the second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param exactPValue if the exact p-value is wanted (only works for x.length <= 30,\n           if true and x.length > 30, this is ignored because\n           calculations may take too long)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code x} and {@code y} do not\nhave the same length."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the p-value can not be computed due to\na convergence error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the maximum number of iterations\nis exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nanStrategy specifies the strategy that should be used for Double.NaN's"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tiesStrategy specifies the strategy that should be used for ties"
    },
    {
        "oracle": ";",
        "javadocTag": "@param categoryData <code>Collection</code> of <code>double[]</code>\narrays each containing data for one category"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Fvalue"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the <code>categoryData</code>\narray is less than 2 or a contained <code>double[]</code> array does not have\nat least two values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param categoryData <code>Collection</code> of <code>double[]</code>\narrays each containing data for one category"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Pvalue"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the <code>categoryData</code>\narray is less than 2 or a contained <code>double[]</code> array does not have\nat least two values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the p-value can not be computed due to a convergence error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the maximum number of iterations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param categoryData <code>Collection</code> of {@link SummaryStatistics}\neach containing data for one category"
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowOneElementData if true, allow computation for one catagory\nonly or for one data element per category"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Pvalue"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the <code>categoryData</code>\narray is less than 2 or a contained {@link SummaryStatistics} does not have\nat least two values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the p-value can not be computed due to a convergence error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the maximum number of iterations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param categoryData <code>Collection</code> of <code>double[]</code> arrays each\n           containing data for one category"
    },
    {
        "oracle": ";",
        "javadocTag": "@return computed AnovaStats"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if <code>categoryData</code> is <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the <code>categoryData</code> array is less\n            than 2 or a contained <code>double[]</code> array does not\n            contain at least two values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param categoryData <code>Collection</code> of <code>double[]</code>\narrays each containing data for one category"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level of the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the null hypothesis can be rejected with\nconfidence 1 - alpha"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the <code>categoryData</code>\narray is less than 2 or a contained <code>double[]</code> array does not have\nat least two values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if <code>alpha</code> is not in the range (0, 0.5]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the p-value can not be computed due to a convergence error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the maximum number of iterations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param categoryData <code>Collection</code> of <code>double[]</code>\narrays each containing data for one category"
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowOneElementData if true, allow computation for one catagory\nonly or for one data element per category"
    },
    {
        "oracle": ";",
        "javadocTag": "@return computed AnovaStats"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if <code>categoryData</code> is <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if <code>allowOneElementData</code> is false and the number of\ncategories is less than 2 or a contained SummaryStatistics does not contain\nat least two values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed array of observed frequency counts"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected array of expected frequency counts"
    },
    {
        "oracle": ";",
        "javadocTag": "@return chiSquare test statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if <code>observed</code> has negative entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if <code>expected</code> has entries that are\nnot strictly positive"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed array of observed frequency counts"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected array of expected frequency counts"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if <code>observed</code> has negative entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if <code>expected</code> has entries that are\nnot strictly positive"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed array of observed frequency counts"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected array of expected frequency counts"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level of the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff null hypothesis can be rejected with confidence\n1 - alpha"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if <code>observed</code> has negative entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if <code>expected</code> has entries that are\nnot strictly positive"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if <code>alpha</code> is not in the range (0, 0.5]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param counts array representation of 2-way table"
    },
    {
        "oracle": ";",
        "javadocTag": "@return chiSquare test statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array is not rectangular"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if {@code counts} has negative entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param counts array representation of 2-way table"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startValue Start value to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowedSolution The kind of solutions that the root-finding algorithm may\naccept as solutions."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.MathIllegalArgumentException if the arguments do not satisfy the requirements specified by the solver."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if\nthe allowed number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param function Function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x0 Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x1 Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the function has the same sign at the\nendpoints."
    },
    {
        "oracle": ";",
        "javadocTag": "@param function Function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x0 Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x1 Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Accuracy to be used by the solver."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the function has the same sign at the\nendpoints."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval maximal number of new evaluations of the function\n(evaluations already done for finding the root should have already been subtracted\nfrom this number)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f function to solve"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bracketing bracketing solver to use for shifting the root"
    },
    {
        "oracle": ";",
        "javadocTag": "@param baseRoot original root found by a previous non-bracketing solver"
    },
    {
        "oracle": ";",
        "javadocTag": "@param min minimal bound of the search interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max maximal bound of the search interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowedSolution the kind of solutions that the root-finding algorithm may\naccept as solutions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a root approximation, on the specified side of the exact root"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the function has the same sign at the\nendpoints."
    },
    {
        "oracle": ";",
        "javadocTag": "@param function Function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initial Initial midpoint of interval being expanded to\nbracket a root."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound Lower bound (a is never lower than this value)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound Upper bound (b never is greater than this\nvalue)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a two-element array holding a and b."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if a root cannot be bracketted."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code maximumIterations <= 0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param function Function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initial Initial midpoint of interval being expanded to\nbracket a root."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound Lower bound (a is never lower than this value)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound Upper bound (b never is greater than this\nvalue)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximumIterations Maximum number of iterations to perform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a two element array holding a and b."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the algorithm fails to find a and b\nsatisfying the desired conditions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param function function to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initial Initial midpoint of interval being expanded to\nbracket a root."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound Lower bound (a is never lower than this value)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound Upper bound (b never is greater than this\nvalue)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param r multiplicative factor used to compute bounds sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximumIterations Maximum number of iterations to perform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a two element array holding the bracketing values."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if function cannot be bracketed in the search interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the midpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@param function Function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower Lower endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper Upper endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the function values have opposite signs at the\ngiven points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start First number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mid Second number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param end Third number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the arguments form an increasing sequence."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower Lower endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper Upper endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower Lower endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initial Initial value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper Upper endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@param function Function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower Lower endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper Upper endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the function has the same sign at the\nendpoints."
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximal order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximal number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of evaluations of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return absolute accuracy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return relative accuracy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return function accuracy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to solve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowedSolution The kind of solutions that the root-finding algorithm may\naccept as solutions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a value where the function is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if root cannot be bracketed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to solve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startValue Start value to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowedSolution The kind of solutions that the root-finding algorithm may\naccept as solutions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a value where the function is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if root cannot be bracketed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetY target value for y"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x reference points abscissas for interpolation,\nnote that this array <em>is</em> modified during computation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y reference points ordinates for interpolation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start start index of the points to consider (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end end index of the points to consider (exclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return guessed root (will be a NaN if two points share the same y)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param functionValueAccuracy Function value accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximalOrder maximal order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to solve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximum evaluation count is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the least index {@code i} for which {@code array[i] == target}, or\n    {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to search for the sequence {@code target}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target the array to search for as a sub-sequence of {@code array}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code long} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code long} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the greatest index {@code i} for which {@code array[i] == target},\n    or {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is less than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is greater than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arrays zero or more {@code long} arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a single array containing all the values from the source arrays, in\n    order"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code bytes} has fewer than 8\n    elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the string representation of a long value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the long value represented by {@code string}, or {@code null} if\n    {@code string} has a length of zero or cannot be parsed as a long\n    value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the string representation of an long value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param radix the radix to use when parsing"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the long value represented by {@code string} using\n    {@code radix}, or {@code null} if {@code string} has a length of zero\n    or cannot be parsed as a long value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code radix < Character.MIN_RADIX} or\n    {@code radix > Character.MAX_RADIX}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the source array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minLength the minimum length the returned array must guarantee"
    },
    {
        "oracle": ";",
        "javadocTag": "@param padding an extra amount to \"grow\" the array by if growth is\n    necessary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the values of {@code array}, with guaranteed\n    minimum length {@code minLength}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator the text that should appear between consecutive values in\n    the resulting string (but not at the start or end)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code long} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection a collection of {@code Number} instances"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the same values as {@code collection}, in the\n    same order, converted to primitives"
    },
    {
        "oracle": ";",
        "javadocTag": "@param backingArray the array to back the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list view of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expression a boolean expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expression a boolean expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorMessage the exception message to use if the check fails; will be converted to a\n    string using {@link String#valueOf(Object)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expression a boolean expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorMessageTemplate a template for the exception message should the check fail. The\n    message is formed by replacing each {@code %s} placeholder in the template with an\n    argument. These are matched by position - the first {@code %s} gets {@code\n    errorMessageArgs[0]}, etc.  Unmatched arguments will be appended to the formatted message\n    in square braces. Unmatched placeholders will be left as-is."
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorMessageArgs the arguments to be substituted into the message template. Arguments\n    are converted to strings using {@link String#valueOf(Object)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expression a boolean expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expression a boolean expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorMessage the exception message to use if the check fails; will be converted to a\n    string using {@link String#valueOf(Object)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expression a boolean expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorMessageTemplate a template for the exception message should the check fail. The\n    message is formed by replacing each {@code %s} placeholder in the template with an\n    argument. These are matched by position - the first {@code %s} gets {@code\n    errorMessageArgs[0]}, etc.  Unmatched arguments will be appended to the formatted message\n    in square braces. Unmatched placeholders will be left as-is."
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorMessageArgs the arguments to be substituted into the message template. Arguments\n    are converted to strings using {@link String#valueOf(Object)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param reference an object reference"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the non-null reference that was validated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reference an object reference"
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorMessage the exception message to use if the check fails; will be converted to a\n    string using {@link String#valueOf(Object)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the non-null reference that was validated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reference an object reference"
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorMessageTemplate a template for the exception message should the check fail. The\n    message is formed by replacing each {@code %s} placeholder in the template with an\n    argument. These are matched by position - the first {@code %s} gets {@code\n    errorMessageArgs[0]}, etc.  Unmatched arguments will be appended to the formatted message\n    in square braces. Unmatched placeholders will be left as-is."
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorMessageArgs the arguments to be substituted into the message template. Arguments\n    are converted to strings using {@link String#valueOf(Object)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the non-null reference that was validated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index a user-supplied index identifying an element of an array, list or string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the size of that array, list or string"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of {@code index}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index a user-supplied index identifying an element of an array, list or string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the size of that array, list or string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param desc the text to use to describe this index in an error message"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of {@code index}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index a user-supplied index identifying a position in an array, list or string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the size of that array, list or string"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of {@code index}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index a user-supplied index identifying a position in an array, list or string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the size of that array, list or string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param desc the text to use to describe this index in an error message"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of {@code index}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start a user-supplied index identifying a starting position in an array, list or string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end a user-supplied index identifying a ending position in an array, list or string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the size of that array, list or string"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code maxLength} is less than the length of\n    {@code truncationIndicator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param duration the length of time after a value is created that it\n    should stop being returned by subsequent {@code get()} calls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the unit that {@code duration} is expressed in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map source map that determines the function behavior"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue the value to return for inputs that aren't map keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the second function to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f the first function to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the composition of {@code f} and {@code g}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the constant value for the function to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function that always returns {@code value}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param self the object to generate the string for (typically {@code this}),\n       used only for its class name"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clazz the {@link Class} of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param className the name of the instance type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code first} if {@code first} is not {@code null}, or\n    {@code second} if {@code first} is {@code null} and {@code second} is\n    not {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if both {@code first} and {@code second} were\n    {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the instance is absent ({@link #isPresent} returns\n    {@code false}); depending on this <i>specific</i> exception type (over the more general\n    {@link RuntimeException}) is discouraged"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if this optional's value is absent and the supplier returns\n    {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the function returns {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this {@code Stopwatch} instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this {@code Stopwatch} instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the stopwatch is already stopped."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this {@code Stopwatch} instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param referent to softly reference"
    },
    {
        "oracle": ";",
        "javadocTag": "@param queue that should finalize the referent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the string to test and possibly return"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the string to test and possibly return"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string a string reference to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the string which should appear at the end of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minLength the minimum length the resulting string must have. Can be\n    zero or negative, in which case the input string is always returned."
    },
    {
        "oracle": ";",
        "javadocTag": "@param padChar the character to insert at the beginning of the result until\n    the minimum length is reached"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the padded string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the string which should appear at the beginning of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minLength the minimum length the resulting string must have. Can be\n    zero or negative, in which case the input string is always returned."
    },
    {
        "oracle": ";",
        "javadocTag": "@param padChar the character to append to the end of the result until the\n    minimum length is reached"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the padded string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealVectorPreservingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be used to process the entries of this\nvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealVectorPreservingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor to be used to process the entries of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealVectorPreservingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be used to process and modify the entries\nof this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealVectorChangingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor to be used to process the entries of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealVectorChangingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be used to process the entries of this\nvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealVectorChangingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor to be used to process the entries of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealVectorChangingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Object to test for equality."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if two vector objects are equal, {@code false} if\n{@code other} is null, not an instance of {@code RealVector}, or\nnot equal to this {@code RealVector} instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathUnsupportedOperationException if this method is not\noverridden."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathUnsupportedOperationException if this method is not\noverridden."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector for which an unmodifiable view is to be returned."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of {@code v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows number of rows of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columns number of columns of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row row index of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param column column index of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value current value of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value that the <code>walkInXxxOrder</code> must return"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the linear operator A of the system"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m the preconditioner, M (can be {@code null})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the right-hand side vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x0 the initial guess of the solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector containing the solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareOperatorException if {@code a} or {@code m} is not\nsquare"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code m}, {@code b} or\n{@code x0} have dimensions inconsistent with {@code a}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException at exhaustion of the iteration count,\nunless a custom\n{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}\nhas been set at construction of the {@link IterationManager}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the linear operator A of the system"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m the preconditioner, M (can be {@code null})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the right-hand side vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x0 the initial guess of the solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareOperatorException if {@code a} or {@code m} is not\nsquare"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code m}, {@code b} or\n{@code x0} have dimensions inconsistent with {@code a}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the linear operator A of the system"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m the preconditioner, M (can be {@code null})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the right-hand side vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector containing the solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareOperatorException if {@code a} or {@code m} is not\nsquare"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code m} or {@code b} have\ndimensions inconsistent with {@code a}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException at exhaustion of the iteration count,\nunless a custom\n{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}\nhas been set at construction of the {@link IterationManager}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the linear operator A of the system"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m the preconditioner, M (can be {@code null})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the right-hand side vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x0 the initial guess of the solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to {@code x0} (shallow copy) updated with the\nsolution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareOperatorException if {@code a} or {@code m} is not\nsquare"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code m}, {@code b} or\n{@code x0} have dimensions inconsistent with {@code a}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException at exhaustion of the iteration count,\nunless a custom\n{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}\nhas been set at construction of the {@link IterationManager}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param manager the custom iteration manager"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix transposed matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minor minor index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix transposed matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the R matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Q matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transpose of the Q matrix, Q<sup>T</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a matrix containing the Householder reflector vectors"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a solver"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix The matrix to decompose."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix The matrix to decompose."
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Singularity threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the tests are to be performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n{@code true}, and {@code a} or {@code m} is not self-adjoint"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonPositiveDefiniteOperatorException if {@code m} is not\npositive definite"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllConditionedOperatorException if {@code a} is ill-conditioned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the linear operator A of the system"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m the preconditioner, M (can be {@code null})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the right-hand side vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param goodb usually {@code false}, except if {@code x} is expected to\ncontain a large multiple of {@code b}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shift the amount to be subtracted to all diagonal elements of A"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to {@code x} (shallow copy)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareOperatorException if {@code a} or {@code m} is not square"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code m} or {@code b} have dimensions\ninconsistent with {@code a}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException at exhaustion of the iteration count,\nunless a custom\n{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}\nhas been set at construction of the {@link IterationManager}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n{@code true}, and {@code a} or {@code m} is not self-adjoint"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonPositiveDefiniteOperatorException if {@code m} is not\npositive definite"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllConditionedOperatorException if {@code a} is ill-conditioned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x not meaningful in this implementation; should not be considered\nas an initial guess (<a href=\"#initguess\">more</a>)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n{@code true}, and {@code a} or {@code m} is not self-adjoint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target "
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique identifier of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param strictChecking If true any non-fatal error throws an exception."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialNodeCapacity Initial capacity of the node storage data structures. Use this\n           if you know the approximate maximum number of nodes of the\n           graph. The graph can grow beyond this limit, but storage\n           reallocation is expensive operation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialEdgeCapacity Initial capacity of the edge storage data structures. Use this\n           if you know the approximate maximum number of edges of the\n           graph. The graph can grow beyond this limit, but storage\n           reallocation is expensive operation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique identifier of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param strictChecking If true any non-fatal error throws an exception."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique identifier of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node to be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge to be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graphCallback if {@code false}, {@code removeNodeCallback(node)} is not\n           called"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graphCallback if {@code false}, {@link #removeEdgeCallback(AbstractEdge)} of\n           the graph is not called"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceCallback if {@code false},\n           {@link AbstractNode#removeEdgeCallback(AbstractEdge)} is not\n           called for the source node of the edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetCallback if {@code false},\n           {@link AbstractNode#removeEdgeCallback(AbstractEdge)} is not\n           called for the target node of the edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Identifier of the graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param id "
    },
    {
        "oracle": ";",
        "javadocTag": "@param strictChecking "
    },
    {
        "oracle": ";",
        "javadocTag": "@param autoCreate "
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique identifier of this edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Source node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param target Target node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param directed Indicates if the edge is directed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A graph instance or null if the graph class was not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The newly created edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the edge is directed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if this edge is a loop."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The first node of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The second node of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The origin node of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The destination node of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node The node we search the opposite of."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the opposite node of the given node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the root of the path."
    },
    {
        "oracle": ";",
        "javadocTag": "@param root The root of the path."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node The node tested for existence in the path."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the path contains the node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge The edge tested for existence in the path."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the path contains the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the path is empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@param characteristic The characteristic."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Sum of the characteristics."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The list of edges representing the path."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A list of nodes representing the path."
    },
    {
        "oracle": ";",
        "javadocTag": "@param from The start node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge The edge used."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge The edge to add to the path."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The edge that have just been removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The node that have just been removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The node at the top of the stack."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A copy of this path."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p A path to compare to the curent one."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if both paths are equal."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A String representation of the path."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The size of the path."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the input array contains infinite\nelements or sums to zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which array elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which array elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows number of rows in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columns number of columns (may be negative to build partial\narrays in the same way <code>new Field[rows][]</code> works)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x First sequence.\nTypically, this sequence will represent an input signal to a system."
    },
    {
        "oracle": ";",
        "javadocTag": "@param h Second sequence.\nTypically, this sequence will represent the impulse response of the system."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the convolution of {@code x} and {@code h}.\nThis array's length will be {@code x.length + h.length - 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param list Array whose entries will be shuffled (in-place)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start Index at which shuffling begins."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos Shuffling is performed for index positions between\n{@code start} and either the end (if {@link Position#TAIL})\nor the beginning (if {@link Position#HEAD}) of the array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param list Array whose entries will be shuffled (in-place)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start Index at which shuffling begins."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos Shuffling is performed for index positions between\n{@code start} and either the end (if {@link Position#TAIL})\nor the beginning (if {@link Position#HEAD}) of the array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param list Array whose entries will be shuffled (in-place)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param list Array whose entries will be shuffled (in-place)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Natural number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array whose entries are the numbers 0, 1, ..., {@code n}-1.\nIf {@code n == 0}, the returned array is empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Natural number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start Natural number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stride Natural number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array whose entries are the numbers\n{@code start, start + stride, ..., start + (size - 1) * stride}.\nIf {@code size == 0}, the returned array is empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the parameters are valid and designate a subarray of positive length"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the indices are invalid or the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowEmpty if <code>true</code> then zero length arrays are allowed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the parameters are valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the indices are invalid or the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the parameters are valid and designate a subarray of positive length"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the indices are invalid or the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include."
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include."
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowEmpty if {@code true} than allow zero length arrays to pass."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the parameters are valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if either of the arrays are null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the array indices are not valid,\nthe weights array contains NaN, infinite or negative elements, or there\nare no positive weights."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x list of double[] arrays to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new array consisting of the entries of the argument arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data array to scan"
    },
    {
        "oracle": ";",
        "javadocTag": "@return descending list of values included in the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the key (first element of the pair)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value (second element of the pair)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first element of the pair."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the second element of the pair."
    },
    {
        "oracle": ";",
        "javadocTag": "@param o Object."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the given object is also a map entry and\nthe two entries represent the same mapping."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k First element of the pair."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Second element of the pair."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code Pair} containing {@code k} and {@code v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Key (first element of the pair)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Value (second element of the pair)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry Entry to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param SINE_TABLE_A table of the most significant part of the sines"
    },
    {
        "oracle": ";",
        "javadocTag": "@param SINE_TABLE_B table of the least significant part of the sines"
    },
    {
        "oracle": ";",
        "javadocTag": "@param COSINE_TABLE_A table of the most significant part of the cosines"
    },
    {
        "oracle": ";",
        "javadocTag": "@param COSINE_TABLE_B table of the most significant part of the cosines"
    },
    {
        "oracle": ";",
        "javadocTag": "@param SINE_TABLE_LEN length of the tables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param TANGENT_TABLE_A table of the most significant part of the tangents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param TANGENT_TABLE_B table of the most significant part of the tangents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number from which cosine is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result placeholder where to put the result in extended precision\n(may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return cos(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number from which sine is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result placeholder where to put the result in extended precision\n(may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sin(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x argument of exponential"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result placeholder where to place exp(x) split in two terms\n for extra precision (i.e. exp(x) = result[0] + result[1]"
    },
    {
        "oracle": ";",
        "javadocTag": "@return exp(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d number to split"
    },
    {
        "oracle": ";",
        "javadocTag": "@param split placeholder where to place the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a input/out array containing the split, changed\non output"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first term of multiplication"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second term of multiplication"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ans placeholder where to put the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first term of addition"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second term of addition"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ans placeholder where to put the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in initial number, in split form"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed result, null if null input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param methodName the method to call"
    },
    {
        "oracle": ";",
        "javadocTag": "@param methodName the method to call"
    },
    {
        "oracle": ";",
        "javadocTag": "@param paramTypes the constructor parameter types"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the constructor arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the objects to be cloned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if predicate returns false"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate as the only element in an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to call after the null check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the constant"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constantToReturn the constant object to return each time in the factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>constant</code> factory."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the stored constant value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the constant"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constantToReturn the constant to return each time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the object type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformers the transformers to chain, copied, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>chained</code> transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the object type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformers a collection of transformers to chain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>chained</code> transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any transformer in the collection is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object passed to the first transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the transformers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clone if {@code true} the input argument will be cloned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformers the transformers to chain, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformers the transformers to chain, copied, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator to use for comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator to use for comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@param criterion the criterion to use to evaluate comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target the target object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the comparison succeeds according to the selected criterion"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the criterion is invalid (really not possible)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator to use for comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@param criterion the criterion to use to evaluate comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input to execute on"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FunctorException (runtime) if the closure execution resulted in a\n            checked exception."
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input to execute on"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws Throwable if the closure execution resulted in a checked\n            exception."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>all</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>all</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any predicate in the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if all decorated predicates return true"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if decorated predicate returns true, false if input is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate as the only element in an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to call after the null check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if decorated predicate returns true"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate as the only element in an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to call after the null check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>any</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>all</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any predicate in the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if any decorated predicate return true"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>factory</code> transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to evaluate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if not null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicates array of predicates, cloned, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closures matching array of closures, cloned, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultClosure the closure to use if no match, null means nop"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>chained</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element in the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the array lengths of predicates and closures do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param destP number of free parameters in destination derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param destO derivation order in destination derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param destSizes sizes array for the destination derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@return index of the partial derivative with the <em>same</em> characteristics\nin destination derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if order is too large"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index of the partial derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@return orders derivation orders with respect to each parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of free parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@return derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return array size required for holding partial derivatives data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c1 first base (unscaled) component"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset1 offset of first operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c2 second base (unscaled) component"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset2 offset of second operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (it may be\none of the input arrays)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c1 first base (unscaled) component"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset1 offset of first operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c2 second base (unscaled) component"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset2 offset of second operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c3 third base (unscaled) component"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset3 offset of third operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (it may be\none of the input arrays)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c1 first base (unscaled) component"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset1 offset of first operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c2 second base (unscaled) component"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset2 offset of second operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c3 third base (unscaled) component"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset3 offset of third operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a4 fourth scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c4 fourth base (unscaled) component"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset4 offset of fourth operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (it may be\none of the input arrays)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhs array holding left hand side of addition"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhsOffset offset of the left hand side in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhs array right hand side of addition"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhsOffset offset of the right hand side in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (it may be\none of the input arrays)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhs array holding left hand side of subtraction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhsOffset offset of the left hand side in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhs array right hand side of subtraction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhsOffset offset of the right hand side in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (it may be\none of the input arrays)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhs array holding left hand side of multiplication"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhsOffset offset of the left hand side in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhs array right hand side of multiplication"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhsOffset offset of the right hand side in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\nmultiplication the result array <em>cannot</em> be one of\nthe input arrays)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhs array holding left hand side of division"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhsOffset offset of the left hand side in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhs array right hand side of division"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhsOffset offset of the right hand side in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\ndivision the result array <em>cannot</em> be one of\nthe input arrays)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhs array holding left hand side of remainder"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhsOffset offset of the left hand side in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhs array right hand side of remainder"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhsOffset offset of the right hand side in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (it may be\none of the input arrays)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number to exponentiate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the power"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the power in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\npower the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p power to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\npower the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n power to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\npower the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x array holding the base"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xOffset offset of the base in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array holding the exponent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yOffset offset of the exponent in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\npower the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operandOffset offset of the operand in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n order of the root"
    },
    {
        "oracle": ";",
        "javadocTag": "@param result array where result must be stored (for\nn<sup>th</sup> root the result array <em>cannot</em> be the input\narray)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultOffset offset of the result in its array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param operand array holding the operand"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the object type is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the {@link Iterable} to get a value from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to get"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object in the {@link Iterable}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to get a value from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to get"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the object type is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type in the {@link Map}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the key type in the {@link Map}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the object to get a value from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to get"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to get the size of, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size of the specified collection or 0 if the object was null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException thrown if object is not recognised"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to get the size of, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if empty or null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException thrown if object is not recognised"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to check, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if empty or null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to check, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if non-null and non-empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to reverse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the BoundedCollection is full"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum size of the BoundedCollection, -1 if no maximum size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new sorted List, containing the elements of Collection a and b"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param includeDuplicates if {@code true} duplicate elements will be retained, otherwise\n  they will be removed in the output collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new sorted List, containing the elements of Collection a and b"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the comparator to use for the merge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new sorted List, containing the elements of Collection a and b"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the comparator to use for the merge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param includeDuplicates if {@code true} duplicate elements will be retained, otherwise\n  they will be removed in the output collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new sorted List, containing the elements of Collection a and b"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unordered collection of all permutations of the input collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the type of object the {@link Collection} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection whose contents are the target of the #retailAll operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param retain the collection containing the elements to be retained in the returned collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a <code>Collection</code> containing all the elements of <code>collection</code>\nthat occur at least once in <code>retain</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object the {@link Collection} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection whose contents are the target of the {@code retainAll} operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param retain the collection containing the elements to be retained in the returned collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equator the Equator used for testing equality"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a <code>Collection</code> containing all the elements of <code>collection</code>\nthat occur at least once in <code>retain</code> according to the <code>equator</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object the {@link Collection} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection from which items are removed (in the returned collection)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param remove the items to be removed from the returned <code>collection</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a <code>Collection</code> containing all the elements of <code>collection</code> except\nany elements that also occur in <code>remove</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object the {@link Collection} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection from which items are removed (in the returned collection)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param remove the items to be removed from the returned collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equator the Equator used for testing equality"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a <code>Collection</code> containing all the elements of <code>collection</code>\nexcept any element that if equal according to the <code>equator</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the type of object the {@link Collection} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized collection backed by the given collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the type of object the {@link Collection} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable collection backed by the given collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the type of objects in the Collection."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a predicated collection backed by the given collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object the {@link Collection} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a transformed collection backed by the given collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> collection type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sole member of collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if collection is empty or contains more than one element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@code List} of values, implementations should return an\n  empty {@code List} for no mapping"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to remove values from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@code List} of values removed, implementations\n  typically return an empty, unmodifiable {@code List} for no mapping found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the map is unmodifiable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return MapIterator<K, V>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <J> the input key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the output key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <U> the input value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the output value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the variables are restricted to non-negative values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the optimization type."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the optimization type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. In addition to those documented in\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\nMultivariateOptimizer}, this method will register the following data:\n<ul>\n <li>{@link LinearObjectiveFunction}</li>\n <li>{@link LinearConstraintSet}</li>\n <li>{@link NonNegativeConstraint}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyIterationsException if the maximal number of\niterations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data.\nThe following data will be looked for:\n<ul>\n <li>{@link LinearObjectiveFunction}</li>\n <li>{@link LinearConstraintSet}</li>\n <li>{@link NonNegativeConstraint}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximize if true, goal is to maximize the objective function"
    },
    {
        "oracle": ";",
        "javadocTag": "@return created tableau"
    },
    {
        "oracle": ";",
        "javadocTag": "@param originalConstraints original (not normalized) constraints"
    },
    {
        "oracle": ";",
        "javadocTag": "@return new versions of the constraints"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint reference constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@return new equation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return 2 for Phase 1.  1 for Phase 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relationship relationship to count"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of constraint with the specified relationship"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients coefficients to sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the -1 times the sum of all coefficients in the given array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param col index of the column to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the row that the variable is basic in.  null if the column is not basic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row the index of the row to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variable that is basic for this row."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn the column to start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param col index of the column"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the row that the variable is basic in, or {@code null} if the variable is not basic."
    },
    {
        "oracle": ";",
        "javadocTag": "@param src the source array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest the destination array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the model has been solved"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pivotCol the pivot column"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pivotRow the pivot row"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dividendRowIndex index of the row"
    },
    {
        "oracle": ";",
        "javadocTag": "@param divisor value of the divisor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minuendRowIndex row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param subtrahendRowIndex row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multiplier multiplication factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return width of the tableau"
    },
    {
        "oracle": ";",
        "javadocTag": "@return height of the tableau"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param column column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return entry at (row, column)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param column column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value for the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the first slack variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the first artificial variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the right hand side"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of decision variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@return original number of decision variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of slack variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of artificial variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row the row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the reference to the underlying row data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return tableau data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param oos stream where object should be written"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be written to stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ois stream from which the object should be read"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if a class in the stream cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be read from the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Linear objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraints Linear constraints."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType Optimization goal: either {@link GoalType#MAXIMIZE}\nor {@link GoalType#MINIMIZE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param restrictToNonNegative Whether to restrict the variables to non-negative values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon Amount of error to accept when checking for optimality."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f linear objective function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraints linear constraints"
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param restrictToNonNegative whether to restrict the variables to non-negative values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon amount of error to accept when checking for optimality"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxUlps amount of error to accept in floating point comparisons"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tableau the simplex tableau containing a feasible solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the best solution found so far by the optimizer, or {@code null} if\nno feasible solution could be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the solution is optimal, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return coefficients of the linear equation being optimized."
    },
    {
        "oracle": ";",
        "javadocTag": "@return constant of the linear equation being optimized."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point at which linear equation must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the linear equation at the current point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point at which linear equation must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the linear equation at the current point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oos stream where object should be written"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be written to stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ois stream from which the object should be read"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if a class in the stream cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be read from the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients Coefficients for the linear equation being optimized."
    },
    {
        "oracle": ";",
        "javadocTag": "@param constantTerm Constant term of the linear equation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients Coefficients for the linear equation being optimized."
    },
    {
        "oracle": ";",
        "javadocTag": "@param constantTerm Constant term of the linear equation."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if all the variables must be positive."
    },
    {
        "oracle": ";",
        "javadocTag": "@param restricted If {@code true}, all the variables must be positive."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the opposite relationship."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stringValue Display string for the relationship."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEvaluations the number of allowed model function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the number of allowed iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker the convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lower bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the upper bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dim Number of parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance suitable for passing to an optimizer that\nrequires bounds specification."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lB Lower bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if collinear points are added as hull vertices, or {@code false}\nif only extreme points are present."
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the set of input points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the convex hull vertices in CCW winding"
    },
    {
        "oracle": ";",
        "javadocTag": "@param includeCollinearPoints indicates if collinear points on the hull shall be\nadded as hull vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param includeCollinearPoints indicates if collinear points on the hull shall be\nadded as hull vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the original point set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reduced point set, useful as input for convex hull algorithms"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the respective points with min/max x/y coordinate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the quadrilateral"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point the point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param quadrilateralPoints the convex quadrilateral, represented by 4 points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the point is inside the quadrilateral, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hullVertices the hull vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the vertices form a convex hull, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the line segments of the convex hull"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of line segments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices the vertices of the convex hull, must be ordered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the vertices do not form a convex hull"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point the current point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hull the partial hull"
    },
    {
        "oracle": ";",
        "javadocTag": "@param includeCollinearPoints whether collinear points shall be added as hull vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param includeCollinearPoints whether collinear points shall be added as hull vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default 2D vector format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale the specific locale used by the format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the 2D vector format specific to the given locale."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for components."
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix prefix to use instead of the default \"{\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix suffix to use instead of the default \"}\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator separator to use instead of the default \"; \""
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix prefix to use instead of the default \"{\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix suffix to use instead of the default \"}\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator separator to use instead of the default \"; \""
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for components."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xMin low bound along the x direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xMax high bound along the x direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yMin low bound along the y direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yMax high bound along the y direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@return boundary of the box"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplaneThickness tolerance below which points are consider to\nbelong to the hyperplane (which is therefore more a slab)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices vertices of the simple loop boundary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the BSP tree of the input vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplaneThickness tolerance below which points are consider to\nbelong to the hyperplane (which is therefore more a slab)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current tree node (it is a leaf node at the beginning\nof the call)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edges list of edges to insert in the cell defined by this node\n(excluding edges not belonging to the cell defined by this node)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param segments segments complete segments list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of connections performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param segments segments complete segments list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of connections performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param segments segments complete segments list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of connections performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param segments segments list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return first segment that has not been processed yet\nor null if all segments have been processed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defining segment used to define the loop"
    },
    {
        "oracle": ";",
        "javadocTag": "@return loop containing the segment (may be null if the loop is a\ndegenerated infinitely thin 2 points loop"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loop segments loop to filter (will be modified in-place)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tree inside/outside BSP tree representing the region"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param boundary collection of boundary elements, as a\ncollection of {@link SubHyperplane SubHyperplane} objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xMin low bound along the x direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xMax high bound along the x direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yMin low bound along the y direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yMax high bound along the y direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplaneThickness tolerance below which points are considered to\nbelong to the hyperplane (which is therefore more a slab)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices vertices of the simple loop boundary"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tree inside/outside BSP tree representing the region"
    },
    {
        "oracle": ";",
        "javadocTag": "@param boundary collection of boundary elements, as a\ncollection of {@link SubHyperplane SubHyperplane} objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xMin low bound along the x direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xMax high bound along the x direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yMin low bound along the y direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yMax high bound along the y direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of segments endpoints"
    },
    {
        "oracle": ";",
        "javadocTag": "@param subLine other sub-line which may intersect instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param includeEndPoints if true, endpoints are considered to belong to\ninstance (i.e. they are closed sets) and may be returned, otherwise endpoints\nare considered to not belong to instance (i.e. they are open sets) and intersection\noccurring on endpoints lead to null being returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the intersection point if there is one, null if the sub-lines don't intersect"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start start point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end end point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an interval set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane underlying hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param remainingRegion remaining region of the hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start start point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end end point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start start point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end end point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param segment single segment forming the sub-line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c1 first column"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c2 second column"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value of the minor computed has an exact fraction"
    },
    {
        "oracle": ";",
        "javadocTag": "@return abscissa of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ordinate of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return vector coordinates"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equationsMapper mapper for ODE equations primary and secondary components"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the method excluding the one being computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if order is 1 or less"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the method excluding the one being computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if order is 1 or less"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator to copy from. The copy is a deep\ncopy: its arrays are separated from the original arrays of the\ninstance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator to copy from. The copy is a deep\ncopy: its arrays are separated from the original arrays of the\ninstance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the multistep method\n(excluding the one being computed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Nordsieck transformer for the specified field and number of steps"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows number of rows of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return P matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param highOrder high order scaled derivatives\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start first order scaled derivatives at step start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end first order scaled derivatives at step end"
    },
    {
        "oracle": ";",
        "javadocTag": "@param highOrder high order scaled derivatives, will be modified\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number of steps of the multistep method\n(excluding the one being computed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equations differential equations to integrate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 initial time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 initial value of the state vector at t0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t target time for the integration\n(can be set to a value smaller than {@code t0} for backward integration)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return state vector at {@code t}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c time steps from Butcher array (without the first zero)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a internal weights from Butcher array (without the first empty row)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b propagation weights for the high order method from Butcher array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param prototype prototype of the step interpolator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previousState state vector at step start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predictedState predicted state vector at step end"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predictedScaled predicted value of the scaled derivatives at step end"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predictedNordsieck predicted value of the Nordsieck vector at step end"
    },
    {
        "oracle": ";",
        "javadocTag": "@return estimated normalized local discretization error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the method excluding the one being computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if order is 1 or less"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the method excluding the one being computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if order is 1 or less"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotK slopes at the intermediate points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialStepSize initial step size to use (must be positive even\nfor backward integration ; providing a negative value or a value\noutside of the min/max step interval will lead the integrator to\nignore the value and compute the initial step size by itself)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward forward integration indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale scaling vector for the state vector (can be shorter than state vector)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param state0 state at integration start time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapper mapper for all the equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return first integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h signed step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward forward integration indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param acceptSmall if true, steps smaller than the minimal value\nare silently increased up to this value, if false such small\nsteps generate an exception"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a bounded integration step (h if no bound is reach, or a bounded value)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the step is too small and acceptSmall is false"
    },
    {
        "oracle": ";",
        "javadocTag": "@return minimal step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximal step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object read from the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if the object's class cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r the Reader to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entire contents of the reader, as a string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entire contents of the reader, as a string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to write to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param contents the text to put in the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash of the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash of the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash of the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash of the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash of the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash of the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash of the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash of the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash of the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash of the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash of the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash of the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash of the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to be hashed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash of the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> type of the iterator elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param itor elements to be randomly selected from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param num_elts number of elements to select"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of num_elts elements from itor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> type of the iterator elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param itor elements to be randomly selected from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param num_elts number of elements to select"
    },
    {
        "oracle": ";",
        "javadocTag": "@param random the Random instance to use to make selections"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of num_elts elements from itor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> type of keys in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m map to have one of its values incremented"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key for the element whose value will be incremented"
    },
    {
        "oracle": ";",
        "javadocTag": "@param count how much to increment the value by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the old value, before it was incremented"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws Error if the key is in the Map but maps to a non-Integer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> type of map keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> type of map values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m map to be converted to a string"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a multi-line string representation of m"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> type of map keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> type of map values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m map to be converted to a string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param linePrefix prefix to write at the beginning of each line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> type of the map keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> type of the map values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m a map whose keyset will be sorted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a sorted version of m.keySet()"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> type of the map keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> type of the map values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m a map whose keyset will be sorted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the Comparator to use for sorting"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a sorted version of m.keySet()"
    },
    {
        "oracle": ";",
        "javadocTag": "@param method a method signature"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the method corresponding to the given signature"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if the class is not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchMethodException if the method is not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param classname class in which to find the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param methodname the method name"
    },
    {
        "oracle": ";",
        "javadocTag": "@param params the parameters of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the method named classname.methodname with parameters params"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if the class is not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchMethodException if the method is not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param command a command to execute on the command line"
    },
    {
        "oracle": ";",
        "javadocTag": "@return all the output of the command"
    },
    {
        "oracle": ";",
        "javadocTag": "@param command a command to execute on the command line, as a list of\nstrings (the command, then its arguments)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return all the output of the command"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p a Properties object in which to look up the property"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key name of the property to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the property has value \"true\", \"yes\", or \"1\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param p a Properties object in which to look up the property"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key name of the property to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param aV List of spline coefficients."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x abscissa of the sample point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value and derivatives of the sample point\n(if only one row is passed, it is the value, if two rows are\npassed the first one is the value and the second the derivative\nand so on)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if the abscissa difference between added point\nand a previous point is zero (i.e. the two points are at same abscissa)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the number of derivatives is larger\nthan 20, which prevents computation of a factorial"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if derivative structures are inconsistent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x interpolation abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@return interpolated value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if sample is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x interpolation abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order maximum derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return interpolated value and derivatives (value in row 0,\n1<sup>st</sup> derivative in row 1, ... n<sup>th</sup> derivative in row n)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if sample is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of this instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of space dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of surface elements of the microspshere."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Interpolation point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param samplePoints Sampling data points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleValues Sampling data values at the corresponding\n{@code samplePoints}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param exponent Exponent used in the power law that computes\nthe weights (distance dimming factor) of the sample data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param noInterpolationTolerance When the distance between the\n{@code point} and one of the {@code samplePoints} is less than\nthis value, no interpolation will be performed, and the value\nof the sample will just be returned."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the estimated value at the given {@code point}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param normal Facet's normal vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param copy Whether to copy the given array."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of {@code n}\ndoes not match the space dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the method has been called\nmore times than the size of the sphere."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value estimated from the current illumination of the\nmicrosphere."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleDirection Vector whose origin is at the interpolation\npoint and tail is at the sample location."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleValue Data value of the sample."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight Weight."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension Dimension of the data space."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Number of surface elements of the sphere."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxDarkFraction Maximum fraction of the facets that can be dark.\nIf the fraction of \"non-illuminated\" facets is larger, no estimation\nof the value will be performed, and the {@code background} value will\nbe returned instead."
    },
    {
        "oracle": ";",
        "javadocTag": "@param darkThreshold Value of the illumination below which a facet is\nconsidered dark."
    },
    {
        "oracle": ";",
        "javadocTag": "@param background Value returned when the {@code maxDarkFraction}\nthreshold is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code maxDarkFraction} does not\nbelong to the interval {@code [0, 1]}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension Dimension of the data space."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Number of surface elements of the sphere."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rand Unit vector generator for creating the microsphere."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxDarkFraction Maximum fraction of the facets that can be dark.\nIf the fraction of \"non-illuminated\" facets is larger, no estimation\nof the value will be performed, and the {@code background} value will\nbe returned instead."
    },
    {
        "oracle": ";",
        "javadocTag": "@param darkThreshold Value of the illumination below which a facet\nis considered dark."
    },
    {
        "oracle": ";",
        "javadocTag": "@param background Value returned when the {@code maxDarkFraction}\nthreshold is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the size of the generated\nvectors does not match the dimension set in the constructor."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code maxDarkFraction} does not\nbelong to the interval {@code [0, 1]}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Instance to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the arguments for the interpolation points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y the values for the interpolation points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function which interpolates the data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code x} and {@code y}\nhave different sizes."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code x} is not sorted in\nstrict increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xval All the x-coordinates of the interpolation points, sorted\nin increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param yval All the y-coordinates of the interpolation points, sorted\nin increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fval The values of the interpolation points on all the grid knots:\n{@code fval[i][j] = f(xval[i], yval[j])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function which interpolates the dataset."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths are inconsistent."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if the array is not sorted."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of points is too small for\nthe order of the interpolation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of extension points\nis larger than the size of {@code xval}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator Interpolator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param period Period."
    },
    {
        "oracle": ";",
        "javadocTag": "@param extend Number of points to be appended at the beginning and\nend of the sample arrays in order to avoid interpolation failure at\nthe (periodic) boundaries of the orginal interval. The value is the\nnumber of sample points which the original {@code interpolator} needs\non each side of the interpolated point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator Interpolator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param period Period."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xval Arguments for the interpolation points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param yval Values for the interpolation points."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function which interpolates the dataset."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the arguments violate assumptions made by the interpolation\nalgorithm."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays lengthes do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param degree Degree of the polynomial fitting functions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xDegree Degree of the polynomial fitting functions along the\nx-dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDegree Degree of the polynomial fitting functions along the\ny-dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x First coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Second coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if (x, y) is a valid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Coordinate samples."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index in {@code val} corresponding to the interval\ncontaining {@code c}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code c} is out of the\nrange defined by the boundary values of {@code val}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param beta List of function values and function partial derivatives\nvalues."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the spline coefficients."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Sample values of the x-coordinate, in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Sample values of the y-coordinate, in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Values of the function on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dFdX Values of the partial derivative of function with respect\nto x on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dFdY Values of the partial derivative of function with respect\nto y on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d2FdXdY Values of the cross partial derivative of function on\nevery grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the various arrays do not contain\nthe expected number of elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code x} or {@code y} are\nnot strictly increasing."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pX Powers of the x-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pY Powers of the y-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param coeff Spline coefficients."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the interpolated value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param coeff Spline coefficients."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the arguments for the interpolation points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y the values for the interpolation points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function which interpolates the data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code x} and {@code y}\nhave different sizes."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code x} is not sorted in\nstrict increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i Index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper limit of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws X if {@link #get()} throws an {@link InterruptedException},\n        {@link CancellationException}, or {@link ExecutionException}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TimeoutException {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExecutionException if the computation threw an exception"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CancellationException if the computation was cancelled"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExecutionException if the computation threw an exception"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CancellationException if the computation was cancelled"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TimeoutException if the wait timed out"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the class of the specified element prevents\n    it from being added to the given queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if some property of the specified element\n    prevents it from being added to the given queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InterruptedException if the current thread was interrupted before\n    or during the call (optional but recommended)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CancellationException {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InterruptedException if the current thread was interrupted before\n    or during the call (optional but recommended)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CancellationException {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to be used as the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the attempt was accepted, completing the {@code Future}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param throwable the exception to be used as the failed result"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the attempt was accepted, completing the {@code Future}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param future the future to delegate to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the attempt was accepted, indicating that the {@code Future} was not previously\n    cancelled or set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param future the done future to complete this future with."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected the expected value of the {@link #value} field."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws RuntimeException if the {@code Future} has not failed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param callable the callable task"
    },
    {
        "oracle": ";",
        "javadocTag": "@param runnable the runnable task"
    },
    {
        "oracle": ";",
        "javadocTag": "@param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in\n       how many permits become available per second"
    },
    {
        "oracle": ";",
        "javadocTag": "@param warmupPeriod the duration of the period where the {@code RateLimiter} ramps up its\n       rate, before reaching its stable (maximum) rate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the time unit of the warmupPeriod argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param permitsPerSecond the new stable rate of this {@code RateLimiter}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param permits the number of permits to acquire"
    },
    {
        "oracle": ";",
        "javadocTag": "@return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited"
    },
    {
        "oracle": ";",
        "javadocTag": "@return time in microseconds to wait until the resource can be acquired, never negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeout the maximum time to wait for the permit. Negative values are treated as zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the time unit of the timeout argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the permit was acquired, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the requested number of permits is negative or zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param permits the number of permits to acquire"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the permits were acquired, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the permit was acquired, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param permits the number of permits to acquire"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeout the maximum time to wait for the permits. Negative values are treated as zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the time unit of the timeout argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the permits were acquired, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the required wait time, never negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the time that permits are available, or, if permits are available immediately, an\n    arbitrary past or present time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the time that the permits may be used, or, if the permits may be used immediately, an\n    arbitrary past or present time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nameFormat a {@link String#format(String, Object...)}-compatible\n    format String, to which a unique integer (0, 1, etc.) will be supplied\n    as the single parameter. This integer will be unique to the built\n    instance of the ThreadFactory and will be assigned sequentially. For\n    example, {@code \"rpc-pool-%d\"} will generate thread names like\n    {@code \"rpc-pool-0\"}, {@code \"rpc-pool-1\"}, {@code \"rpc-pool-2\"}, etc."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this for the builder pattern"
    },
    {
        "oracle": ";",
        "javadocTag": "@param daemon whether or not new Threads created with this ThreadFactory\n    will be daemon threads"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this for the builder pattern"
    },
    {
        "oracle": ";",
        "javadocTag": "@param priority the priority for new Threads created with this\n    ThreadFactory"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this for the builder pattern"
    },
    {
        "oracle": ";",
        "javadocTag": "@param uncaughtExceptionHandler the uncaught exception handler for new\n    Threads created with this ThreadFactory"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this for the builder pattern"
    },
    {
        "oracle": ";",
        "javadocTag": "@param backingThreadFactory the backing {@link ThreadFactory} which will\n    be delegated to during thread creation."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this for the builder pattern"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fully constructed {@link ThreadFactory}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the service is not {@link State#STARTING}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the service is neither {@link State#STOPPING} nor\n        {@link State#RUNNING}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the service is not {@link State#NEW}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the service reaches a state from which it is not possible to\n    enter the {@link State#RUNNING} state. e.g. if the {@code state} is \n    {@code State#TERMINATED} when this method is called then this will throw an \n    IllegalStateException."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeout the maximum time to wait"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the time unit of the timeout argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TimeoutException if the service has not reached the given state within the deadline"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the service reaches a state from which it is not possible to\n    enter the {@link State#RUNNING RUNNING} state. e.g. if the {@code state} is \n    {@code State#TERMINATED} when this method is called then this will throw an \n    IllegalStateException."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the service {@linkplain State#FAILED fails}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeout the maximum time to wait"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the time unit of the timeout argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TimeoutException if the service has not reached the given state within the deadline"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the service {@linkplain State#FAILED fails}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if this service's state isn't {@linkplain State#FAILED FAILED}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param listener the listener to run when the service changes state is complete"
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor the executor in which the listeners callback methods will be run. For fast,\n    lightweight listeners that would be safe to execute in any thread, consider \n    {@link MoreExecutors#directExecutor}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param callable The callable to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nameSupplier The supplier of thread names, {@link Supplier#get get} will be called once\n    for each invocation of the wrapped callable."
    },
    {
        "oracle": ";",
        "javadocTag": "@param task The Runnable to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nameSupplier The supplier of thread names, {@link Supplier#get get} will be called once\n    for each invocation of the wrapped callable."
    },
    {
        "oracle": ";",
        "javadocTag": "@param t the exception that made the future fail. If the future's {@link Future#get() get}\n    method throws an {@link ExecutionException}, then the cause is passed to this method. Any\n    other thrown object is passed unaltered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key an arbitrary, non-null key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the stripe that the passed key corresponds to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index of the stripe to return; must be in {@code [0...size())}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the stripe at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keys arbitrary non-null keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the stripes corresponding to the objects (one per each object, derived by delegating\n        to {@link #get(Object)}; may contain duplicates), in an increasing index order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stripes the minimum number of stripes (locks) required"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code Striped<Lock>}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stripes the minimum number of stripes (locks) required"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code Striped<Lock>}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stripes the minimum number of stripes (semaphores) required"
    },
    {
        "oracle": ";",
        "javadocTag": "@param permits the number of permits in each semaphore"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code Striped<Semaphore>}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stripes the minimum number of stripes (semaphores) required"
    },
    {
        "oracle": ";",
        "javadocTag": "@param permits the number of permits in each semaphore"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code Striped<Semaphore>}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stripes the minimum number of stripes (locks) required"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code Striped<ReadWriteLock>}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stripes the minimum number of stripes (locks) required"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code Striped<ReadWriteLock>}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param format new format of the message attached with the event"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type type of the event"
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix new prefix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix new suffix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out stream used to output message"
    },
    {
        "oracle": ";",
        "javadocTag": "@return A singleton instance of the global environment."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the environment is locked."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameter The parameter name."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The parameter value (empty string if not set)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameter The parameter name."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the given paramter name points to a value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameter The parameter name."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the parameter value means \"true\", false for any other\n        value or if the parameter does not exist."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameter The parameter name."
    },
    {
        "oracle": ";",
        "javadocTag": "@return 1 if the parameter value means \"true\", 0 if it has any other\n        value, or -1 if it does not exist."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameter The parameter name."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The numeric value of the parameter. 0 if the parameter does\n        not exist or is not a number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The number of parameters found in the configuration file."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A set of all the names identifying parameters in this\n        environment."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An Environment object identical to this one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameter The parameter name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The new parameter value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param object The object to initialize."
    },
    {
        "oracle": ";",
        "javadocTag": "@param object The object to initialize."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fieldList The name of the fields to initialize in the object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param object The object to initialize."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fieldList The name of the fields to initialize in the object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param out The output stream to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args The command line."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args The command line."
    },
    {
        "oracle": ";",
        "javadocTag": "@param trashcan Will be filled by the set of unparsed strings (can be\n       null if these strings can be ignored)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileName Name of the file to save the config in."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException For any output error on the given file name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileName Name of the parameter file to read."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException For any error with the given parameter file name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph to start listening for changes."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g1 "
    },
    {
        "oracle": ";",
        "javadocTag": "@param g2 "
    },
    {
        "oracle": ";",
        "javadocTag": "@param g1 "
    },
    {
        "oracle": ";",
        "javadocTag": "@param g2 "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ParseException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ParseException "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ParseException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param reader stream to be parsed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a parser"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a regular expression as a string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param format format of the scanner"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of components found in the string format"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ParseException if invalid component found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param format new format of the scanner"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ParseException if an error is found in the new format"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time timestamp in the scanner format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a calendar modeling the time value or null if invalid format"
    },
    {
        "oracle": ";",
        "javadocTag": "@param calendar the calendar to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string modeling the calendar."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ParseException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param format format of the scanner."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ParseException if bad directives found"
    },
    {
        "oracle": ";",
        "javadocTag": "@return directive of the component."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if component is an alias."
    },
    {
        "oracle": ";",
        "javadocTag": "@return replacement value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value matching the replacement string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param calendar calendar we are working on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param calendar the calendar"
    },
    {
        "oracle": ";",
        "javadocTag": "@return string representation of this component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param directive directive name, should start with a leading '%'."
    },
    {
        "oracle": ";",
        "javadocTag": "@param replace replace the directive with the value given here."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The number of elements in the array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i The element index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The element at index <code>i</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i The element index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The element at index <code>i</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The last insertion index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException If a null value is inserted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i Index of the element to remove."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The removed element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e The element to remove."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param path path to the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@return count of step event in the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@return the count of step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId Identifier of the graph where the node was added."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId Identifier of the added node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId Identifier of the graph where the node will be removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId Identifier of the removed node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId Identifier of the graph where the edge was added."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId Identifier of the added edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fromNodeId Identifier of the first node of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toNodeId Identifier of the second node of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param directed If true, the edge is directed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The graph where the edge will be removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId The edge that will be removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The graph cleared."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId Identifier of the graph where the step starts."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId A numerical value that may give a timestamp to track the\n           evolution of the graph over the time."
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the P matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transpose of the P matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the T matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the transformation does not converge"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the L1 norm of matrix T"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startIdx the starting index for the search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param norm the L1 norm of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the first small sub-diagonal element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the index of the small sub-diagonal element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param idx the current eigenvalue index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iteration the current iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shift holder for shift information"
    },
    {
        "oracle": ";",
        "javadocTag": "@param il the index of the small sub-diagonal element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iu the current eigenvalue index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shift shift information holder"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hVec the initial houseHolder vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the start index for the QR step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param il the index of the small sub-diagonal element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param im the start index for the QR step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iu the current eigenvalue index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shift shift information holder"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hVec the initial houseHolder vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension the size of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index of the entry being visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value of the entry being visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new value of the entry being visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by\n{@link RealVector#walkInDefaultOrder(RealVectorChangingVisitor)},\n{@link RealVector#walkInDefaultOrder(RealVectorChangingVisitor, int, int)},\n{@link RealVector#walkInOptimizedOrder(RealVectorChangingVisitor)}\nor\n{@link RealVector#walkInOptimizedOrder(RealVectorChangingVisitor, int, int)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the median for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scale parameter for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@return mean (always Double.NaN)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return variance (always Double.NaN)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (always Double.NEGATIVE_INFINITY)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (always Double.POSITIVE_INFINITY)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param median Median for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale Scale parameter for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param median Median for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale Scale parameter for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Maximum absolute error in inverse\ncumulative probability estimates\n(defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param median Median for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale Scale parameter for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param median Median for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale Scale parameter for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Maximum absolute error in inverse\ncumulative probability estimates\n(defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the location parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scale parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the matrix corresponding to the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constant vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u vector to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector which is the image of u by the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u vector to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector which is the image of u by the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in an array with three items which stores vector to rotate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out an array with three items to put result to (it can be the same\narray as in)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in an array with three items which stores vector to rotate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out an array with three items to put result to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u vector to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector which is the image of u by the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u vector to apply the inverse of the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector which such that u is its image by the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u vector to apply the inverse of the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector which such that u is its image by the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in an array with three items which stores vector to rotate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out an array with three items to put result to (it can be the same\narray as in)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in an array with three items which stores vector to rotate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out an array with three items to put result to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u vector to apply the inverse of the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector which such that u is its image by the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convention convention to use for the semantics of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the instance\nusing vector operator convention"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convention convention to use for the semantics of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the instance\nusing vector operator convention"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r1 rotation to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rInner rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the inverse\nof the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convention convention to use for the semantics of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the inverse\nof the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the inverse\nof the instance using vector operator convention"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the inverse\nof the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convention convention to use for the semantics of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the inverse\nof the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the inverse\nof the instance using vector operator convention"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rOuter rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rInner rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the inverse\nof the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m initial matrix (not exactly orthogonal)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold convergence threshold for the iterative\northogonality correction (convergence is reached when the\ndifference between two steps of the Frobenius norm of the\ncorrection is below this threshold)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an orthogonal matrix close to m"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotARotationMatrixException if the matrix cannot be\northogonalized with the given threshold after 10 iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r1 first rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r2 second rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <i>distance</i> between r1 and r2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q0 scalar part of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q1 first coordinate of the vectorial part of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q2 second coordinate of the vectorial part of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q3 third coordinate of the vectorial part of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param needsNormalization if true, the coordinates are considered\nnot to be normalized, a normalization preprocessing step is performed\nbefore using them"
    },
    {
        "oracle": ";",
        "javadocTag": "@param axis axis around which to rotate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param angle rotation angle."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the axis norm is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param axis axis around which to rotate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param angle rotation angle."
    },
    {
        "oracle": ";",
        "javadocTag": "@param convention convention to use for the semantics of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the axis norm is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m rotation matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold convergence threshold for the iterative\northogonality correction (convergence is reached when the\ndifference between two steps of the Frobenius norm of the\ncorrection is below this threshold)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotARotationMatrixException if the matrix is not a 3X3\nmatrix, or if it cannot be transformed into an orthogonal matrix\nwith the given threshold, or if the determinant of the resulting\northogonal matrix is negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first vector of the origin pair"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second vector of the origin pair"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 desired image of u1 by the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 desired image of u2 by the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the norm of one of the vectors is zero,\nor if one of the pair is degenerated (i.e. the vectors of the pair are collinear)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u origin vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v desired image of u by the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the norm of one of the vectors is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of rotations to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha1 angle of the first elementary rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha2 angle of the second elementary rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha3 angle of the third elementary rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of rotations to compose, from left to right\n(i.e. we will use {@code r1.compose(r2.compose(r3, convention), convention)})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convention convention to use for the semantics of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha1 angle of the first elementary rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p numerator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q denominator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p/q computed in the instance field"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p numerator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q denominator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p/q computed in the instance field"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotK slopes at the intermediate points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return external weights for the high order method from Butcher array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return order of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@return safety factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param safety safety factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return minimal reduction factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minReduction minimal reduction factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximal growth factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxGrowth maximal growth factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotK derivatives computed during the first stages"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 estimate of the step at the start of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y1 estimate of the step at the end of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h current step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return error ratio, greater than 1 if step should be rejected"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fsal index of the pre-computed derivative for <i>fsal</i> methods\nor -1 if method is not <i>fsal</i>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fsal index of the pre-computed derivative for <i>fsal</i> methods\nor -1 if method is not <i>fsal</i>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotK slopes at the intermediate points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param highOrder high order scaled derivatives\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start first order scaled derivatives at step start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end first order scaled derivatives at step end"
    },
    {
        "oracle": ";",
        "javadocTag": "@param highOrder high order scaled derivatives, will be modified\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the method excluding the one being computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the method excluding the one being computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator to copy from. The copy is a deep\ncopy: its arrays are separated from the original arrays of the\ninstance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator to copy from. The copy is a deep\ncopy: its arrays are separated from the original arrays of the\ninstance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator to copy from. The copy is a deep\ncopy: its arrays are separated from the original arrays of the\ninstance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param performStabilityCheck if true, stability check will be performed,\n     if false, the check will be skipped"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxNumIter maximal number of iterations for which checks are\nperformed (the number of iterations is reset to default if negative\nor null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxNumChecks maximal number of checks for each iteration\n(the number of checks is reset to default if negative or null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stepsizeReductionFactor stepsize reduction factor in case of\nfailure (the factor is reset to default if lower than 0.0001 or\ngreater than 0.9999)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge edge reaching the end vertex of the path element created."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight total cost of the created path element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex end vertex of the path element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param admissibleHeuristic admissible heuristic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertex source vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex target vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param admissibleHeuristic admissible heuristic which estimates the\ndistance from a node to the target node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the shortest path from sourceVertex to targetVertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex starting vertex of the path"
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex ending vertex of the path"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pathLength length of the path"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the shortest path from startVertex to endVertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param currentNode node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return List of edges/arcs that constitutes the path"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of expanded nodes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source source vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sink sink vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximum flow value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <i>read-only</i> mapping from edges to doubles - flow values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current source"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current sink"
    },
    {
        "oracle": ";",
        "javadocTag": "@param network network, where maximum flow will be calculated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param network network, where maximum flow will be calculated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon tolerance for comparing doubles"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param candidatePrevPathElement "
    },
    {
        "oracle": ";",
        "javadocTag": "@param candidateEdge "
    },
    {
        "oracle": ";",
        "javadocTag": "@param candidateCost "
    },
    {
        "oracle": ";",
        "javadocTag": "@return ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pathElement "
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge edge reaching the end vertex of the path element created."
    },
    {
        "oracle": ";",
        "javadocTag": "@param cost total cost of the created path element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon tolerance factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@param original source to copy from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex end vertex of the path element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon tolerance factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the graph on which this algorithm operates"
    },
    {
        "oracle": ";",
        "javadocTag": "@return total number of shortest paths"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@return shortest distance between a and b"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the diameter (longest of all the shortest paths) computed for the\ngraph. If the graph is vertexless, return 0.0."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a From vertice"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b To vertice"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the path, or null if none found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the originating vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@return List of paths"
    },
    {
        "oracle": ";",
        "javadocTag": "@return List of paths"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@return map from element to parent element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return map from element to rank"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to find."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The element representing the set the element is in."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element1 The first element to union."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element2 The second element to union."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 the first vertex to be compared."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 the second vertex to be compared."
    },
    {
        "oracle": ";",
        "javadocTag": "@return -1 if <code>v1</code> comes before <code>v2</code>, +1 if <code>\nv1</code> comes after <code>v2</code>, 0 if equal."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g graph with respect to which the degree is calculated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g graph with respect to which the degree is calculated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param ascendingOrder true - compares in ascending order of degrees\n(lowest first), false - compares in descending order of degrees (highest\nfirst)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return new pair"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the graph inspected"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the graph is strongly connected, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>List</code> of <code>Set</code> s containing the strongly\nconnected components"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of subgraphs representing the strongly connected\ncomponents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param directedGraph the graph to inspect"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param u the Integer to be removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param list the list from which all the occurrences of u must be removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the DirectedGraph in which to find cycles."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The list of all simple cycles. Possibly empty but never <code>\nnull</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph - the DirectedGraph in which to find cycles."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph - the DirectedGraph in which to find cycles."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A list of cycles constituting a cycle base for the graph.\nPossibly empty but never <code>null</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph - the DirectedGraph in which to find cycles."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph - the DirectedGraph in which to find cycles."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph - the DirectedGraph in which to find cycles."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex "
    },
    {
        "oracle": ";",
        "javadocTag": "@return set of all biconnected vertex-components containing the vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if and only if inspected graph is connected."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex for which the connected set to be returned."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set of all vertices that are in the maximally connected\ncomponent together with the specified vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Returns a list of <code>Set</code> s, where each set contains all\nvertices that are in the same maximally connected component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertex one end of the path."
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex another end of the path."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if and only if there is a path from the source\nvertex to the target vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph for which a connectivity inspector to be created."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph for which a connectivity inspector to be created."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source "
    },
    {
        "oracle": ";",
        "javadocTag": "@param sink "
    },
    {
        "oracle": ";",
        "javadocTag": "@return Returns the min cut partition containing the source, or null if\nthere was no call to computeMinCut(V source, V sink)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return returns the min cut partition containing the sink"
    },
    {
        "oracle": ";",
        "javadocTag": "@return cut weight"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialGuess Initial guess. If set to {@code null}, the initial guess\nwill be estimated using the {@link ParameterGuesser}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIter Maximum number of iterations of the optimization algorithm."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to fit."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a curve fitter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newStart new start point (initial guess)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newMaxIter maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param function Function to fit."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialGuess Initial guess. Cannot be {@code null}. Its length must\nbe consistent with the number of parameters of the {@code function} to fit."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIter Maximum number of iterations of the optimization algorithm."
    },
    {
        "oracle": ";",
        "javadocTag": "@param guess First guess for the coefficients. They must be sorted in\nincreasing order of the polynomial's degree."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations of the polynomial."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the coefficients of the polynomial that best fits the observed points."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if\nthe number of evaluations exceeds {@code maxEval}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.ConvergenceException if the algorithm failed to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param guess First guess for the coefficients. They must be sorted in\nincreasing order of the polynomial's degree."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the coefficients of the polynomial that best fits the observed points."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.ConvergenceException if the algorithm failed to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Optimizer to use for the fitting."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialGuess First guess values in the following order:\n<ul>\n <li>Amplitude</li>\n <li>Angular frequency</li>\n <li>Phase</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parameters of the harmonic function that best fits the\nobserved points (in the same order as above)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parameters of the harmonic function that best fits the\nobserved points (see the other {@link #fit(double[]) fit} method."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the sample is too short for the\nthe first guess to be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if the first guess cannot be computed because\nthe abscissa range is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Optimizer to use for the fitting."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the weight of the measurement in the fitting process."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the abscissa of the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the observed value of the function at x."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight Weight of the measurement in the fitting process."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Abscissa of the measurement."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Ordinate of the measurement."
    },
    {
        "oracle": ";",
        "javadocTag": "@param params Input parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the validated values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newCostRelativeTolerance Desired relative error in the sum of squares."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newParRelativeTolerance Desired relative error in the approximate solution\nparameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newOrthoTolerance Desired max cosine on the orthogonality between\nthe function vector and the columns of the Jacobian."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newQRRankingThreshold Desired threshold for QR ranking.\nIf the squared norm of a column vector is smaller or equal to this\nthreshold during QR decomposition, it is considered to be a zero vector\nand hence the rank of the matrix is reduced."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parameter's value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parameter's value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parameter's value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parameter's value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parameter's value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param qy Array containing qTy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta Upper bound on the euclidean norm of diagR * lmDir."
    },
    {
        "oracle": ";",
        "javadocTag": "@param diag Diagonal matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param internalData Data (modified in-place in this method)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param solvedCols Number of solved point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param work1 work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param work2 work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param work3 work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lmDir the \"returned\" LM direction will be stored in this array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lmPar the value of the LM parameter from the previous iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new LM parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param qy array containing qTy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param diag diagonal matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lmDiag diagonal elements associated with lmDir"
    },
    {
        "oracle": ";",
        "javadocTag": "@param internalData Data (modified in-place in this method)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param solvedCols Number of sloved point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param work work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lmDir the \"returned\" LM direction is stored in this array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param jacobian Weighted Jacobian matrix at the current point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param solvedCols Number of solved point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return data used in other methods of this class."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the decomposition cannot be performed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y vector to multiply (will be overwritten with the result)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param internalData Data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialStepBoundFactor initial step bound factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param costRelativeTolerance cost relative tolerance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parRelativeTolerance parameters relative tolerance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param orthoTolerance orthogonality tolerance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param qrRankingThreshold threshold in the QR decomposition. Columns with a 2\n                              norm less than this threshold are considered to be\n                              all 0s."
    },
    {
        "oracle": ";",
        "javadocTag": "@param tol the relative and absolute tolerance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relTol the relative tolerance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absTol the absolute tolerance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the function value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param evaluations number of times the function was evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterations number of iterations of the algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point "
    },
    {
        "oracle": ";",
        "javadocTag": "@param problem the delegate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unweighted the evalutation before weights are applied"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weightSqrt the matrix square root of the weight matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param leastSquaresProblem the problem definition, including model function and\n                           convergence criteria."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The optimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param observationSize the number of observation. Needed for {@link\n                       #getRMS()}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the matrix {@link Decomposition} algoritm."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newDecomposition the {@link Decomposition} algorithm to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param jacobian the m by n jacobian matrix, J. Input."
    },
    {
        "oracle": ";",
        "javadocTag": "@param residuals the m by 1 residual vector, r. Input."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the n by n normal matrix and  the n by 1 J<sup>Tr vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param decomposition the {@link Decomposition} algorithm."
    },
    {
        "oracle": ";",
        "javadocTag": "@param model the model function. Produces the computed values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed the observed (target) values"
    },
    {
        "oracle": "true ? methodResultID==0 : true;",
        "javadocTag": "@return the value where the function is zero."
    },
    {
        "oracle": "(((matrix==null)==false) && (matrix.isSquare())) == false;",
        "javadocTag": "@throws NonSquareMatrixException if the matrix is not square."
    },
    {
        "oracle": "maxIter<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code maxIter <= 0}."
    },
    {
        "oracle": "(first instanceof AbstractListChromosome) == false || (second instanceof AbstractListChromosome) == false;",
        "javadocTag": "@throws MathIllegalArgumentException iff one of the chromosomes is\n  not an instance of {@link AbstractListChromosome}"
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotStrictlyPositiveException if the number of sample points is negative"
    },
    {
        "oracle": "minStep>0;",
        "javadocTag": "@param minStep minimal step (must be positive even for backward\nintegration), the last step can be smaller than this"
    },
    {
        "oracle": "maxStep>0;",
        "javadocTag": "@param maxStep maximal step (must be positive even for backward\nintegration)"
    },
    {
        "oracle": "o==null;",
        "javadocTag": "@throws NullArgumentException if Object <code>o</code> is {@code null}."
    },
    {
        "oracle": "(first instanceof AbstractListChromosome) == false || (second instanceof AbstractListChromosome) == false;",
        "javadocTag": "@throws MathIllegalArgumentException iff one of the chromosomes is\n  not an instance of {@link AbstractListChromosome}"
    },
    {
        "oracle": "min>maxEval;",
        "javadocTag": "@throws MathIllegalArgumentException if {@code min > max} or the endpoints do not\nsatisfy the requirements specified by the integrator"
    },
    {
        "oracle": "f==null;",
        "javadocTag": "@throws NullArgumentException if {@code f} is {@code null}."
    },
    {
        "oracle": "maxIter<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code maxIter <= 0}."
    },
    {
        "oracle": "function==null;",
        "javadocTag": "@throws NullArgumentException if {@code function} is {@code null}."
    },
    {
        "oracle": "true ? methodResultID==0 : true;",
        "javadocTag": "@return a value where the function is zero."
    },
    {
        "oracle": "function==null;",
        "javadocTag": "@throws NullArgumentException if {@code function} is {@code null}."
    },
    {
        "oracle": "true ? methodResultID==0 : true;",
        "javadocTag": "@return a value where the function is zero."
    },
    {
        "oracle": "function==null;",
        "javadocTag": "@throws NullArgumentException if {@code function} is {@code null}."
    },
    {
        "oracle": "maximumIterations<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code maximumIterations <= 0}."
    },
    {
        "oracle": "function==null;",
        "javadocTag": "@throws NullArgumentException if {@code function} is {@code null}."
    },
    {
        "oracle": "q>0;",
        "javadocTag": "@param q additive offset used to compute bounds sequence (must be strictly positive)"
    },
    {
        "oracle": "function==null;",
        "javadocTag": "@throws NullArgumentException if {@code function} is {@code null}."
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}."
    },
    {
        "oracle": "lower>=initial || initial>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= initial} or\n{@code initial >= upper}."
    },
    {
        "oracle": "function==null;",
        "javadocTag": "@throws NullArgumentException if {@code function} is {@code null}."
    },
    {
        "oracle": "nans==1;",
        "javadocTag": "@param nans code of the value, must be one of {@link Dfp#INFINITE},\n{@link Dfp#SNAN},  {@link Dfp#QNAN}"
    },
    {
        "oracle": "true ? methodResultID.equals(a) : true;",
        "javadocTag": "@return exp(a)"
    },
    {
        "oracle": "(((matrix==null)==false) && (matrix.isSquare())) == false;",
        "javadocTag": "@throws NonSquareMatrixException if matrix is not square"
    },
    {
        "oracle": "f==null || t==null || w==null || startPoint==null;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NullArgumentException if\nany argument is {@code null}."
    },
    {
        "oracle": "steps.length==0;",
        "javadocTag": "@throws IllegalArgumentException if one of the steps is zero."
    },
    {
        "oracle": "expected.length<2 || observed.length<2;",
        "javadocTag": "@throws DimensionMismatchException if the arrays length is less than 2"
    },
    {
        "oracle": "expected.length<2 || observed.length<2;",
        "javadocTag": "@throws DimensionMismatchException if the arrays length is less than 2"
    },
    {
        "oracle": "expected.length<2 || observed.length<2;",
        "javadocTag": "@throws DimensionMismatchException if the arrays length is less than 2"
    },
    {
        "oracle": "counts==null;",
        "javadocTag": "@throws NullArgumentException if the array is null"
    },
    {
        "oracle": "counts==null;",
        "javadocTag": "@throws NullArgumentException if the array is null"
    },
    {
        "oracle": "counts==null;",
        "javadocTag": "@throws NullArgumentException if the array is null"
    },
    {
        "oracle": "true ? methodResultID.equals(base) : true;",
        "javadocTag": "@return base<sup>a</sup>"
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "f==null;",
        "javadocTag": "@throws NullArgumentException if f is null"
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}."
    },
    {
        "oracle": "lower>=initial || initial>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= initial} or\n{@code initial >= upper}."
    },
    {
        "oracle": "forward==true;",
        "javadocTag": "@param forward true if integration goes forward"
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "length==0 ? methodResultID==1 : true;",
        "javadocTag": "@return the product of the values or 1 if length = 0"
    },
    {
        "oracle": "length==0 ? methodResultID==1 : true;",
        "javadocTag": "@return the product of the values or 1 if length = 0"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "numberOfPoints<1;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code numberOfPoints < 1}."
    },
    {
        "oracle": "den==0;",
        "javadocTag": "@throws MathArithmeticException if the denominator is {@code zero}"
    },
    {
        "oracle": "fraction==null;",
        "javadocTag": "@throws NullArgumentException if the fraction is {@code null}"
    },
    {
        "oracle": "(fraction==null) == false;",
        "javadocTag": "@param fraction the fraction to add, must not be {@code null}"
    },
    {
        "oracle": "fraction==null;",
        "javadocTag": "@throws NullArgumentException if the fraction is {@code null}"
    },
    {
        "oracle": "(fraction==null) == false;",
        "javadocTag": "@param fraction the fraction to subtract, must not be {@code null}"
    },
    {
        "oracle": "fraction==null;",
        "javadocTag": "@throws NullArgumentException if the fraction is {@code null}"
    },
    {
        "oracle": "(fraction==null) == false;",
        "javadocTag": "@param fraction the fraction to multiply by, must not be {@code null}"
    },
    {
        "oracle": "fraction==null;",
        "javadocTag": "@throws IllegalArgumentException if the fraction is {@code null}"
    },
    {
        "oracle": "(fraction==null) == false;",
        "javadocTag": "@param fraction the fraction to divide by, must not be {@code null}"
    },
    {
        "oracle": "denominator==0;",
        "javadocTag": "@throws MathArithmeticException if the denominator is {@code zero}"
    },
    {
        "oracle": "abs<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code abs <= 0}."
    },
    {
        "oracle": "abs<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code abs <= 0}."
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "estimationType==null || nanStrategy==null;",
        "javadocTag": "@throws NullArgumentException if type or NaNStrategy passed is null"
    },
    {
        "oracle": "p>0 && p<=100;",
        "javadocTag": "@throws MathIllegalArgumentException if p is not a valid quantile value\n(p must be greater than 0 and less than or equal to 100)"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if <code>values</code> is null\n    or p is invalid"
    },
    {
        "oracle": "(p>0) == false && p<=100;",
        "javadocTag": "@throws MathIllegalArgumentException if p is not greater than 0 and less\nthan or equal to 100"
    },
    {
        "oracle": "newEstimationType==null;",
        "javadocTag": "@throws NullArgumentException when newEstimationType is null"
    },
    {
        "oracle": "newNaNStrategy==null;",
        "javadocTag": "@throws NullArgumentException when newNaNStrategy is null"
    },
    {
        "oracle": "newKthSelector==null;",
        "javadocTag": "@throws NullArgumentException when newKthSelector is null"
    },
    {
        "oracle": "(((matrix==null)==false) && (matrix.isSquare())) == false;",
        "javadocTag": "@throws NonSquareMatrixException if matrix is not square."
    },
    {
        "oracle": "(((matrix==null)==false) && (matrix.isSquare())) == false;",
        "javadocTag": "@throws NonSquareMatrixException if matrix is not square"
    },
    {
        "oracle": "numRows<2 || numCols<2;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code numRows < 2} or\n{@code numCols < 2}."
    },
    {
        "oracle": "n<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code n <= 0}."
    },
    {
        "oracle": "isLast==true;",
        "javadocTag": "@param isLast true if the step is the last one"
    },
    {
        "oracle": "base>0;",
        "javadocTag": "@param base Base of the logarithm, must be greater than 0."
    },
    {
        "oracle": "x>0;",
        "javadocTag": "@param x Argument, must be greater than 0."
    },
    {
        "oracle": "true ? methodResultID==x : true;",
        "javadocTag": "@return the value of the logarithm, i.e. the number {@code y} such that\n<code>base<sup>y</sup> = x</code>."
    },
    {
        "oracle": "a<=b ? methodResultID == a : methodResultID == b;",
        "javadocTag": "@return a if a is lesser or equal to b, b otherwise"
    },
    {
        "oracle": "a<=b ? methodResultID == a : methodResultID == b;",
        "javadocTag": "@return a if a is lesser or equal to b, b otherwise"
    },
    {
        "oracle": "a<=b ? methodResultID == a : methodResultID == b;",
        "javadocTag": "@return a if a is lesser or equal to b, b otherwise"
    },
    {
        "oracle": "a<=b ? methodResultID == a : methodResultID == b;",
        "javadocTag": "@return a if a is lesser or equal to b, b otherwise"
    },
    {
        "oracle": "a<=b ? methodResultID == b : methodResultID == a;",
        "javadocTag": "@return b if a is lesser or equal to b, a otherwise"
    },
    {
        "oracle": "a<=b ? methodResultID == b : methodResultID == a;",
        "javadocTag": "@return b if a is lesser or equal to b, a otherwise"
    },
    {
        "oracle": "a<=b ? methodResultID == b : methodResultID == a;",
        "javadocTag": "@return b if a is lesser or equal to b, a otherwise"
    },
    {
        "oracle": "a<=b ? methodResultID == b : methodResultID == a;",
        "javadocTag": "@return b if a is lesser or equal to b, a otherwise"
    },
    {
        "oracle": "b==0;",
        "javadocTag": "@throws MathArithmeticException if b == 0"
    },
    {
        "oracle": "b==0;",
        "javadocTag": "@throws MathArithmeticException if b == 0"
    },
    {
        "oracle": "b==0;",
        "javadocTag": "@throws MathArithmeticException if b == 0"
    },
    {
        "oracle": "b==0;",
        "javadocTag": "@throws MathArithmeticException if b == 0"
    },
    {
        "oracle": "(((matrix==null)==false) && (matrix.isSquare())) == false;",
        "javadocTag": "@throws NonSquareMatrixException if the matrix is not square."
    },
    {
        "oracle": "(((matrix==null)==false) && (matrix.isSquare())) == false;",
        "javadocTag": "@throws NonSquareMatrixException if the matrix is not square."
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "length==0 ? methodResultID==0 : true;",
        "javadocTag": "@return the sum of the natural logs of the values or 0 if\nlength = 0"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "biasCorrected==true;",
        "javadocTag": "@param biasCorrected true means covariances are bias-corrected"
    },
    {
        "oracle": "biasCorrected==true;",
        "javadocTag": "@param biasCorrected true means covariances are bias-corrected"
    },
    {
        "oracle": "true ? methodResultID.equals(matrix) : true;",
        "javadocTag": "@return covariance matrix"
    },
    {
        "oracle": "true ? methodResultID.equals(matrix) : true;",
        "javadocTag": "@return covariance matrix"
    },
    {
        "oracle": "min>=max;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if {@code min >= max}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param guess First guess for the coefficients. They must be sorted in\nincreasing order of the polynomial's degree."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the coefficients of the polynomial that best fits the observed points."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.ConvergenceException if the algorithm failed to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param degree Maximal degree of the polynomial."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Optimizer to use for the fitting."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Optimizer to use for the fitting."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialGuess First guess values in the following order:\n<ul>\n <li>Amplitude</li>\n <li>Angular frequency</li>\n <li>Phase</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parameters of the harmonic function that best fits the\nobserved points (in the same order as above)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parameters of the harmonic function that best fits the\nobserved points (see the other {@link #fit(double[]) fit} method."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the sample is too short for the\nthe first guess to be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if the first guess cannot be computed because\nthe abscissa range is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Optimizer to use for the fitting."
    },
    {
        "oracle": ";",
        "javadocTag": "@return weight of the measurement in the fitting process"
    },
    {
        "oracle": ";",
        "javadocTag": "@return abscissa of the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return observed value of the function at x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight weight of the measurement in the fitting process"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x abscissa of the measurement"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y ordinate of the measurement"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialGuess First guess values in the following order:\n<ul>\n <li>Norm</li>\n <li>Mean</li>\n <li>Sigma</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parameters of the Gaussian function that best fits the\nobserved points (in the same order as above)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parameters of the Gaussian function that best fits the\nobserved points (in the same order as above)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Optimizer to use for the fitting."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the relative threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the absolute threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold relative tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold absolute tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the dimension of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param evaluationFunction Evaluation function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator Comparator to use to sort simplex vertices from best\nto worst."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startPoint First point of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the start point does not match\nsimplex dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param evaluationFunction Evaluation function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator Comparator to use to sort simplex vertices from best to worst."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pointValuePair Point to insert."
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator Comparator to use for sorting the simplex vertices\nfrom best to worst."
    },
    {
        "oracle": ";",
        "javadocTag": "@return all the simplex points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Location."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point at location {@code index}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Location."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point New value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param points New Points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the hypercube."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sideLength Length of the sides of the hypercube."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the steps."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sideLength Length of the sides of the hypercube."
    },
    {
        "oracle": ";",
        "javadocTag": "@param steps Steps along the canonical axes representing box edges. They\nmay be negative but not zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param referenceSimplex Reference simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if the reference simplex does not\ncontain at least one point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if there is a dimension mismatch\nin the reference simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if one of its vertices is duplicated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param simplex Simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Allowed number of evaluations of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType Optimization type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link org.apache.commons.math3.optimization.InitialGuess InitialGuess}</li>\n <li>{@link AbstractSimplex}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value for objective\nfunction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link AbstractSimplex}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel Relative threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abs Absolute threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound Lower bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound Upper bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the objective at the optimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound Lower bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound Upper bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the objective at the optimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param knew "
    },
    {
        "oracle": ";",
        "javadocTag": "@param adelt "
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound Lower bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound Upper bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta "
    },
    {
        "oracle": ";",
        "javadocTag": "@param gnew "
    },
    {
        "oracle": ";",
        "javadocTag": "@param xbdi "
    },
    {
        "oracle": ";",
        "javadocTag": "@param s "
    },
    {
        "oracle": ";",
        "javadocTag": "@param hs "
    },
    {
        "oracle": ";",
        "javadocTag": "@param hred "
    },
    {
        "oracle": ";",
        "javadocTag": "@param beta "
    },
    {
        "oracle": ";",
        "javadocTag": "@param denom "
    },
    {
        "oracle": ";",
        "javadocTag": "@param knew "
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound Lower bounds (constraints) of the objective variables."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound Upperer bounds (constraints) of the objective variables."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfInterpolationPoints Number of interpolation conditions.\nFor a problem of dimension {@code n}, its value must be in the interval\n{@code [n+2, (n+1)(n+2)/2]}.\nChoices that exceed {@code 2n+1} are not recommended."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfInterpolationPoints Number of interpolation conditions.\nFor a problem of dimension {@code n}, its value must be in the interval\n{@code [n+2, (n+1)(n+2)/2]}.\nChoices that exceed {@code 2n+1} are not recommended."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialTrustRegionRadius Initial trust region radius."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stoppingTrustRegionRadius Stopping trust region radius."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sideLength Length of the sides of the default (hypercube)\nsimplex. See {@link AbstractSimplex#AbstractSimplex(int,double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex. See\n{@link AbstractSimplex#AbstractSimplex(int,double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sideLength Length of the sides of the default (hypercube)\nsimplex. See {@link AbstractSimplex#AbstractSimplex(int,double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rho Reflection coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sigma Shrinkage coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex. See\n{@link AbstractSimplex#AbstractSimplex(int)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to remove from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the mapping was removed, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to store against"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to add to the collection at the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value added if the map changed and null if the map did not change"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to copy (either a normal or multi map)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a collection view of the values contained in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the collection mapped to the key, null if no mapping"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to get size for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size of the collection at the key, zero if key not in map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to store against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this map changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to get an iterator for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the iterator of the collection at the key, empty iterator if key not in map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the iterator of all mappings in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the total size of the map counting all values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the collection size that is about to be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the collection class type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collectionFactory the collection factory which must return a Collection instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mapped value, null if no match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param updateToMRU whether the key shall be updated to the\n  most recently used position"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mapped value, null if no match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to update"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to update"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue the new value to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashIndex the index into the data array to store at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashCode the hash code of the key to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to reuse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashIndex the index into the data array to store at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashCode the hash code of the key to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the map is full"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum number of elements the map can hold"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this map scans"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a shallow clone"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an error occurs while writing to the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an error occurs while reading from the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if an object read from the stream can not be loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize the maximum size of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize the maximum size of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialSize the initial size of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize the maximum size of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scanUntilRemovable scan until a removeable entry is found, default false"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize the maximum size of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize the maximum size of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialSize the initial size of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize the maximum size of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scanUntilRemovable scan until a removeable entry is found, default false"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize the maximum size of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialSize the initial size of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scanUntilRemovable scan until a removeable entry is found, default false"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scanUntilRemovable scan until a removeable entry is found, default false"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyType the type of reference to use for keys;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueType the type of reference to use for values;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyType the type of reference to use for keys;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueType the type of reference to use for values;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param purgeValues should the value be automatically purged when the\n  key is garbage collected"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyType the type of reference to use for keys;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueType the type of reference to use for values;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param capacity the initial capacity for the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor for the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyType the type of reference to use for keys;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueType the type of reference to use for values;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param capacity the initial capacity for the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor for the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param purgeValues should the value be automatically purged when the\n  key is garbage collected"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector containing {@code this[i] * v[i]} for all {@code i}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as {@code this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector by which instance elements must be divided"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector containing {@code this[i] / v[i]} for all {@code i}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as {@code this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if one entry of {@code v} is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@return T array of entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector with which dot product should be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scalar dot product of {@code this} and {@code v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as {@code this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector onto which {@code this} must be projected"
    },
    {
        "oracle": ";",
        "javadocTag": "@return projection of {@code this} onto {@code v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as {@code this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if {@code v} is the null vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector with which outer product should be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the matrix outer product between instance and v"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index location of entry to be fetched."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the vector entry at {@code index}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index element index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value new value for the element."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to append to this one."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d T to append."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of first element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number of elements to be retrieved."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector containing n elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if the number of elements if not positive."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of first element to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector containing the values to set."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value single value to set for all elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return array containing a copy of vector elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the matrix is square (rowDimension = columnDimension)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return rowDimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@return columnDimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Row dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected Column dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the U matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the U matrix (or null if decomposed matrix is singular)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the &Sigma; matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the diagonal elements of the &Sigma; matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the V matrix (or null if decomposed matrix is singular)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the V matrix (or null if decomposed matrix is singular)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minSingularValue value below which singular values are ignored\n(a 0 or negative value implies all singular value will be used)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if minSingularValue is larger than\nthe largest singular value, meaning all singular values are ignored"
    },
    {
        "oracle": ";",
        "javadocTag": "@return norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@return condition number of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse of the condition number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return effective numerical matrix rank"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a solver"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Matrix to decompose."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the V matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the D matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transpose of the V matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the eigen values are complex, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the real parts of the eigenvalues of the original matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i index of the eigenvalue (counting from 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return real part of the i<sup>th</sup> eigenvalue of the original\nmatrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the imaginary parts of the eigenvalues of the original\nmatrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i Index of the eigenvalue (counting from 0)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the imaginary part of the i<sup>th</sup> eigenvalue of the original\nmatrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i Index of the eigenvector (counting from 0)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the i<sup>th</sup> eigenvector of the original matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the determinant of the matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square-root of the matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathUnsupportedOperationException if the matrix is not\nsymmetric or not positive definite."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a solver"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathUnsupportedOperationException if the decomposition resulted in\ncomplex eigenvalues"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Matrix to transform."
    },
    {
        "oracle": ";",
        "javadocTag": "@param householderMatrix Householder matrix of the transformation\nto tridiagonal form."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Matrix to transform."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@link SchurTransformer Shur transform} for this matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xr real part of the first number"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xi imaginary part of the first number"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yr real part of the second number"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yi imaginary part of the second number"
    },
    {
        "oracle": ";",
        "javadocTag": "@return result of the complex division"
    },
    {
        "oracle": ";",
        "javadocTag": "@param schur the schur transformation of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the Schur form has a norm of zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Matrix to decompose."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the decomposition of a general matrix\nresults in a matrix with zero norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Matrix to decompose."
    },
    {
        "oracle": ";",
        "javadocTag": "@param splitTolerance Dummy parameter (present for backward\ncompatibility only)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the decomposition of a general matrix\nresults in a matrix with zero norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param main Main diagonal of the symmetric tridiagonal form."
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondary Secondary of the tridiagonal form."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param main Main diagonal of the symmetric tridiagonal form."
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondary Secondary of the tridiagonal form."
    },
    {
        "oracle": ";",
        "javadocTag": "@param splitTolerance Dummy parameter (present for backward\ncompatibility only)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows number of rows of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff a does not contain duplicate elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array, representing a function"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff all elements of a are in [0..a.length) and a\ncontains no duplicates."
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the length of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@return fresh array that is the identity function of the given length"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the input permutation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return fresh array which is the inverse of the given permutation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array representing a function from [0..a.length) to [0..arange);\n each element of a is between 0 and arange inclusive"
    },
    {
        "oracle": ";",
        "javadocTag": "@return function from [0..arange) to [0..a.length) that is the inverse of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if a value of a is outside of arange"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException when the function is not invertible"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a function from [0..a.length) to [0..b.length)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b function from [0..b.length) to range R"
    },
    {
        "oracle": ";",
        "javadocTag": "@return function from [0..a.length) to range R that is the\ncomposition of a and b"
    },
    {
        "oracle": ";",
        "javadocTag": "@param smaller first set to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bigger second set to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff smaller is a subset of bigger"
    },
    {
        "oracle": ";",
        "javadocTag": "@param smaller first set to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bigger second set to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff smaller is a subset of bigger"
    },
    {
        "oracle": ";",
        "javadocTag": "@param smaller first set to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bigger second set to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff smaller is a subset of bigger"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next token"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current token"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ch the comment character"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ch the quoting character"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the type of the current token"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tok string to check next token against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return next token, if if it a word; otherwise calls the error handling routine"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string to tokenize"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string to tokenize"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e error handler"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArgException if there is an illegal argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArgException if there is an illegal argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArgException if there is an illegal argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximum capacity of the set representation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> (super)type of elements of the sets"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max_values the maximum size for the returned LimitedSizeSet"
    },
    {
        "oracle": ";",
        "javadocTag": "@param slist a list of LimitedSizeSet, whose elements will be merged"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a LimitedSizeSet that merges the elements of slist"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max_values the maximum number of values this set will be able to hold"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the string that was read, or null at end of file"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a line-by-line iterator for this file"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether there is another line to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next line in the multi-file\nThrows NoSuchElementException at end of file"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next entry (paragraph) in the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is a problem reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@return next line from the reader, or null if there is no more input"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current filename"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current line number"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lineNumber new line number for the current file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry_start_re regular expression that starts a long entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry_stop_re regular expression that ends a long entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry_start_re regular expression that starts a long entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry_stop_re regular expression that ends a long entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args command-line arguments: filename [comment_re [include_re]]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is a problem reading a file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedEncodingException if the charset encoding is not supported"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in source from which to read entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charsetName the character set to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comment_re_string regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored."
    },
    {
        "oracle": ";",
        "javadocTag": "@param include_re_string regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the InputStream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charsetName the character set to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename the file name"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedEncodingException if the charset encoding is not supported"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in source from which to read entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename non-null file name for stream being read"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comment_re_string regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored."
    },
    {
        "oracle": ";",
        "javadocTag": "@param include_re_string regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the InputStream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename the file name"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the InputStream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reader source from which to read entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename file name corresponding to reader, for use in error messages"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comment_re_string regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored"
    },
    {
        "oracle": ";",
        "javadocTag": "@param include_re_string regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reader source from which to read entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file initial file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comment_re regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored."
    },
    {
        "oracle": ";",
        "javadocTag": "@param include_re regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is a problem reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is a problem reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charsetName the character set to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is a problem reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename initial file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comment_re regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored."
    },
    {
        "oracle": ";",
        "javadocTag": "@param include_re regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is a problem reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename source from which to read entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is a problem reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename source from which to read entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charsetName the character set to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is a problem reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o the object to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the object satisfies the filter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel_diff the new relative diff to use"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "string==null;",
        "javadocTag": "@throws NullPointerException if {@code string} is null"
    },
    {
        "oracle": "s==null;",
        "javadocTag": "@throws NullPointerException if {@code string} is null"
    },
    {
        "oracle": "expression==false;",
        "javadocTag": "@throws VerifyException if {@code expression} is {@code false}"
    },
    {
        "oracle": "expression==false;",
        "javadocTag": "@throws VerifyException if {@code expression} is {@code false}"
    },
    {
        "oracle": "reference==null;",
        "javadocTag": "@throws VerifyException if {@code reference} is {@code null}"
    },
    {
        "oracle": "true ? methodResultID!=null : true;",
        "javadocTag": "@return {@code reference}, guaranteed to be non-null, for convenience"
    },
    {
        "oracle": "reference==null;",
        "javadocTag": "@throws VerifyException if {@code reference} is {@code null}"
    },
    {
        "oracle": "true ? methodResultID!=null : true;",
        "javadocTag": "@return {@code reference}, guaranteed to be non-null, for convenience"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "maxSize<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the literal string to be escaped"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the escaped form of {@code string}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the literal string to be escaped"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to start escaping from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the escaped form of {@code string}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the character to escape if necessary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the replacement characters, or {@code null} if no escaping was needed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param replacements a map of characters to their escaped representations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cp the Unicode code point to escape"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the replacement characters, or {@code null} if no escaping was\n        required"
    },
    {
        "oracle": ";",
        "javadocTag": "@param replacementMap a map of characters to their escaped representations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param safeMin the lowest character value in the safe range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param safeMax the highest character value in the safe range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unsafeReplacement the default replacement for unsafe characters or\n    null if no default replacement is required"
    },
    {
        "oracle": ";",
        "javadocTag": "@param escaperMap the map of replacements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param safeMin the lowest character value in the safe range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param safeMax the highest character value in the safe range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unsafeReplacement the default replacement for unsafe characters or\n    null if no default replacement is required"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a \"sparse\" array that holds the replacement mappings."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an escaper that escapes based on the underlying array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param escaper the instance to be wrapped"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a UnicodeEscaper with the same behavior as the given instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if escaper is not a UnicodeEscaper or a\n        CharEscaper"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the character to escape if necessary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the replacement string, or {@code null} if no escaping was needed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cp the Unicode code point to escape if necessary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the replacement string, or {@code null} if no escaping was needed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the literal string to be escaped"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the escaped form of {@code string}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code string} contains badly formed UTF-16 or cannot be\n        escaped for any other reason"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cp the Unicode code point to escape if necessary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the replacement characters, or {@code null} if no escaping was\n    needed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param csq a sequence of characters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first character to be scanned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index immediately after the last character to be scanned"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the scanned sub-sequence of {@code csq}\n    contains invalid surrogate pairs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the literal string to be escaped"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the escaped form of {@code string}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if invalid surrogate characters are\n        encountered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the literal string to be escaped"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to start escaping from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the escaped form of {@code string}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if invalid surrogate characters are\n        encountered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seq the sequence of characters from which to decode the code point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index of the first character to decode"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index beyond the last valid character to decode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Unicode code point for the given index or the negated value of\n        the trailing high surrogate character at the end of the sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param replacementMap a map of characters to their escaped representations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param safeMin the lowest character value in the safe range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param safeMax the highest character value in the safe range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param escaperMap the mapping of characters to be escaped"
    },
    {
        "oracle": ";",
        "javadocTag": "@param safeMin the lowest character value in the safe range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param safeMax the highest character value in the safe range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value any value of type {@code C}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the least value greater than {@code value}, or {@code null} if\n    {@code value} is {@code maxValue()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value any value of type {@code C}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the greatest value less than {@code value}, or {@code null} if\n    {@code value} is {@code minValue()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance as described above, or {@link Long#MIN_VALUE} or\n    {@link Long#MAX_VALUE} if the distance is too small or too large,\n    respectively."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the minimum value of type {@code C}; never null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the type has no (practical) minimum\n    value; for example, {@link java.math.BigInteger}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum value of type {@code C}; never null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the type has no (practical) maximum\n    value; for example, {@link java.math.BigInteger}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the two keys are equal according to\n    their natural ordering"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if any two keys are equal according to\n    their natural ordering"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if any two keys are equal according to\n    their natural ordering"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if any two keys are equal according to\n    their natural ordering"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the keys in {@code map} are not mutually\n        comparable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key or value in {@code map} is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if any two keys are equal according to\n        their natural ordering"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key or value in {@code map} is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if any two keys are equal according to the\n        comparator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key or value in {@code map} is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if any two keys are equal according to the\n        comparator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key or value in {@code map} is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if any two keys are equal according to the\n        comparator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key or value in {@code map} is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to count occurrences of"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of occurrences of the element in this multiset; possibly\n    zero but never negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to add occurrences of; may be null only if\n    explicitly allowed by the implementation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the count of the element before the operation; possibly zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the count of the element before the operation; possibly zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to add or remove occurrences of; may be null\n    only if explicitly allowed by the implementation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param count the desired count of the element in this multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the count of the element before the operation; possibly zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to conditionally set the count of; may be null\n    only if explicitly allowed by the implementation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldCount the expected present count of the element in this multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newCount the desired count of the element in this multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalMap the normal direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reverseMap the reverse direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseBidiMap the inverse BidiMap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return new bidi map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose mappings are to be placed in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalMap the normal direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reverseMap the reverse direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseBidiMap the inverse BidiMap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable SortedBidiMap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalMap the normal direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reverseMap the reverse direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseBidiMap the inverse BidiMap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return new bidi map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose mappings are to be placed in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalMap the normal direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reverseMap the reverse direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseBidiMap the inverse BidiMap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalMap the normal direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reverseMap the reverse direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseMap the inverse BidiMap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return new bidi map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new ordered map iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose mappings are to be placed in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyComparator the comparator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueComparator the values comparator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalMap the normal direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reverseMap the reverse direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseBidiMap the inverse BidiMap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of key-value mappings in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key whose presence in this map is to be tested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this map contains a mapping for the specified key"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the key is of an inappropriate type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value whose presence in this map is to be tested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this map contains a mapping for the specified value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the value is of an inappropriate type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key whose associated value is to be returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the key is of an inappropriate type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key with which the specified value is to be  associated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to be associated with the specified key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value for the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the key is of an inappropriate type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to copy from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key whose mapping is to be removed from the map."
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous value associated with specified key,\n or null if there was no mapping for key."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the key is of an inappropriate type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value whose associated key is to be returned."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the value is of an inappropriate type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value whose mapping is to be removed from the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous key associated with specified value,\n or null if there was no mapping for value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the value is of an inappropriate type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first (lowest) key currently in this sorted map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the last (highest) key currently in this sorted map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to search for next from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next key, null if no match or at end"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to search for previous from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous key, null if no match or at start"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set view of the keys contained in this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set view of the values contained in this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set view of the values contained in this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code value for this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a standard format string version of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key, always the main map key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value, always the main map value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data the key or value to be looked up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the desired Node, or null if there is no mapping of the\n        specified data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node to be searched from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the specified node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node to be searched from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the specified node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o1 the first object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o2 the second object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return negative value if o1 &lt; o2; 0 if o1 == o2; positive\n        value if o1 &gt; o2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node from which we will start searching"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the smallest node, from the specified node, in the\n        specified mapping"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node from which we will start searching"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the greatest node, from the specified node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param from the node whose color we're copying; may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to the node whose color we're changing; may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node (may be null) in question"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node (may be null) in question"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node (may be null) in question"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotANumberException if any of the probabilities are NaN."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException all of the probabilities are 0."
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed (ignored)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the constant value of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mean vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the covariance matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the standard deviations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values Values at which to compute density."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the multiplication factor of density calculations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param means Vector of means."
    },
    {
        "oracle": ";",
        "javadocTag": "@param covariances Covariance matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the arrays length are\ninconsistent."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if the eigenvalue decomposition cannot\nbe performed on the provided covariance matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonPositiveDefiniteMatrixException if any of the eigenvalues is\nnegative."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random Number Generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param means Vector of means."
    },
    {
        "oracle": ";",
        "javadocTag": "@param covariances Covariance matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the arrays length are\ninconsistent."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if the eigenvalue decomposition cannot\nbe performed on the provided covariance matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonPositiveDefiniteMatrixException if any of the eigenvalues is\nnegative."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mean."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (always 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (always Double.POSITIVE_INFINITY)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean mean of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean Mean of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Maximum absolute error in inverse\ncumulative probability estimates (defaults to\n{@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean Mean of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean Mean of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Maximum absolute error in inverse\ncumulative probability estimates (defaults to\n{@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower Lower bound (inclusive) of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper Upper bound (inclusive) of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower Lower bound (inclusive) of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper Upper bound (inclusive) of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scale parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (always 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (always\n{@code Double.POSITIVE_INFINITY})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale the scale parameter of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape the shape parameter of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale the scale parameter of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape the shape parameter of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Inverse cumulative probability accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale Scale parameter of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape Shape parameter of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale Scale parameter of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape Shape parameter of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Inverse cumulative probability accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of successes."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the probability of success."
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (always 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (always {@code Integer.MAX_VALUE}\nfor positive infinity)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r Number of successes."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Probability of success."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param r Number of successes."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Probability of success."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scale parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (always {@code Double.POSITIVE_INFINITY})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale the scale parameter of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape the shape parameter of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale the scale parameter of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape the shape parameter of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Inverse cumulative probability accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale Scale parameter of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape Shape parameter of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale Scale parameter of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape Shape parameter of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Inverse cumulative probability accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the numerator degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the denominator degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (always 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (always Double.POSITIVE_INFINITY)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numeratorDegreesOfFreedom Numerator degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param denominatorDegreesOfFreedom Denominator degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numeratorDegreesOfFreedom Numerator degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param denominatorDegreesOfFreedom Denominator degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy the maximum absolute error in inverse\ncumulative probability estimates."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numeratorDegreesOfFreedom Numerator degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param denominatorDegreesOfFreedom Denominator degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numeratorDegreesOfFreedom Numerator degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param denominatorDegreesOfFreedom Denominator degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy the maximum absolute error in inverse\ncumulative probability estimates."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the probability of success."
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (always 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (always Integer.MAX_VALUE)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a read-only buffer reflecting {@code file}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mode the mode to use when mapping {@code file}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a buffer reflecting {@code file}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mode the mode to use when mapping {@code file}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a buffer reflecting {@code file}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file The name of the file to trim the extension from. This can be either a fully\n    qualified file name (including a path) or just a file name."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The file name without its path or extension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param from the object to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to the object to write to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of characters copied"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r the object to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string containing all the characters"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r the object to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link StringBuilder} containing all the characters"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r the object to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a mutable {@link List} containing all the lines"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reader the reader to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the number of characters to skip"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws EOFException if this stream reaches the end before skipping all\n    the characters"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target the object to which output will be sent"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new Writer object, unless target is a Writer, in which case the\n    target is returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param url the URL to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a byte array containing all the bytes from the URL"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param url the URL to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charset the charset used to decode the input stream; see {@link\n    Charsets} for helpful predefined constants"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string containing all the characters from the URL"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs."
    },
    {
        "oracle": ";",
        "javadocTag": "@param url the URL to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charset the charset used to decode the input stream; see {@link\n    Charsets} for helpful predefined constants"
    },
    {
        "oracle": ";",
        "javadocTag": "@param callback the LineProcessor to use to handle the lines"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the output of processing the lines"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param url the URL to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charset the charset used to decode the input stream; see {@link\n    Charsets} for helpful predefined constants"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a mutable {@link List} containing all the lines"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param from the URL to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the resource is not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the resource is not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param from the input stream to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to the output stream to write to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of bytes copied"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param from the readable channel to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to the writable channel to write to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of bytes copied"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a byte array containing all the bytes from the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream to be wrapped"
    },
    {
        "oracle": ";",
        "javadocTag": "@param limit the maximum number of bytes to be read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a length-limited {@link InputStream}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream to read from."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the buffer into which the data is read."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws EOFException if this stream reaches the end before reading all\n    the bytes."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream to read from."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the buffer into which the data is read."
    },
    {
        "oracle": ";",
        "javadocTag": "@param off an int specifying the offset into the data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param len an int specifying the number of bytes to read."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws EOFException if this stream reaches the end before reading all\n    the bytes."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the number of bytes to skip"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws EOFException if this stream reaches the end before skipping all\n    the bytes"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs, or the stream does not\n    support skipping"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input stream to process"
    },
    {
        "oracle": ";",
        "javadocTag": "@param processor the object to which to pass the bytes of the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the result of the byte processor"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the buffer into which the data is read"
    },
    {
        "oracle": ";",
        "javadocTag": "@param off an int specifying the offset into the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len an int specifying the number of bytes to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of bytes read"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param flushable the {@code Flushable} object to be flushed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param swallowIOException if true, don't propagate IO exceptions\n    thrown by the {@code flush} method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param flushable the {@code Flushable} object to be flushed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream to be wrapped"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream to be wrapped"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of opening the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of opening the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ds2 second base (unscaled) derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters or orders are inconsistent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ds1 first base (unscaled) derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ds2 second base (unscaled) derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ds3 third base (unscaled) derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters or orders are inconsistent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ds1 first base (unscaled) derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ds2 second base (unscaled) derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ds3 third base (unscaled) derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a4 fourth scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ds4 fourth base (unscaled) derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters or orders are inconsistent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters number of free parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param derivatives derivatives sorted according to\n{@link DSCompiler#getPartialDerivativeIndex(int...)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if derivatives array does not match the\n{@link DSCompiler#getSize() size} expected by the compiler"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if order is too large"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ds instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param function function to differentiate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return differential function"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of points to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return step size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t evaluation abscissa value and derivatives"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 first sample point abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y function values sample {@code y[i] = f(t[i]) = f(t0 + i * stepSize)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value and derivatives at {@code t}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the requested derivation order\nis larger or equal to the number of points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nbPoints number of points to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stepSize step size (gap between each point)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nbPoints number of points to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stepSize step size (gap between each point)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tLower lower bound for independent variable (may be {@code Double.NEGATIVE_INFINITY}\nif there are no lower bounds)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tUpper upper bound for independent variable (may be {@code Double.POSITIVE_INFINITY}\nif there are no upper bounds)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point at which the function must be evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return function value for the given point"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if {@code point} does not\nsatisfy the function's constraints (wrong dimension, argument out of bound,\nor unsupported derivative order for example)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t function input value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return function result"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if t is inconsistent with the\nfunction's free parameters or order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point at which the function must be evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return function value for the given point"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if point's dimension is wrong"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the jacobian function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param z Point at which the function value is to be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the function value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the degree of the polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a fresh copy of coefficients in Newton form formula"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a fresh copy of the centers array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a fresh copy of the coefficients array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Coefficients in Newton form formula."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Centers."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z Point at which the function value is to be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the function value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the size difference between\n{@code a} and {@code c} is not equal to 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the coefficients in Newton form formula"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the centers"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the size difference between\n{@code a} and {@code c} is not equal to 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Coefficients in Newton form formula."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Centers."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the size difference between\n{@code a} and {@code c} is not equal to 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z Point at which the function value is to be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the function value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code x} and {@code y} have\ndifferent lengths."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NonMonotonicSequenceException if {@code x} is not sorted in strictly increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the degree of the polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a fresh copy of the interpolating points array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a fresh copy of the interpolating values array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a fresh copy of the coefficients array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Interpolating points array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Interpolating values array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z Point at which the function value is to be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the function value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code x} and {@code y} have\ndifferent lengths."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code x} is not sorted in strictly increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Interpolating points array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Interpolating values array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z Point at which the function value is to be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the function value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code x} and {@code y} have\ndifferent lengths."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NonMonotonicSequenceException if {@code x} is not sorted in strictly increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the size of {@code x} is less\nthan 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Interpolating points array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Interpolating values array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abort Whether to throw an exception if {@code x} is not sorted."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths are different."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NonMonotonicSequenceException if {@code x} is not sorted in strictly increasing order and {@code abort}\nis {@code true}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code false} if the {@code x} is not sorted in increasing order,\n{@code true} otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x interpolating points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y function values at interpolating points"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths are different."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if two abscissae have the same value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Point for which the function value should be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code v} is outside of the domain of the\nspline function (smaller than the smallest knot point or larger than the\nlargest knot point)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value previously mapped to this key, null if none"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the key does not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to add, must be size 0 or 1, and the key must match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the key does not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the mapping to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value mapped to the removed key, null if key not in map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entrySet view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the keySet view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the values view"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the next key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return null always"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the next key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return null always"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a shallow clone"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code defined in the Map interface"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string version of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyValue the key value pair to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapEntry the mapEntry to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to copy, must be size 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the size is not 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new unmodifiable entry set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if set is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current size"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the associated value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous mapping for the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value at this key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the key set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entry set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map of entries to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r the code to execute atomically"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numBuckets the number of buckets for this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map is currently size zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mapped value, null if no match"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value previously mapped to this key, null if none"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the mapping to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value mapped to the removed key, null if key not in map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set view of this map's entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set view of this map's keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set view of this map's values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ref the reference to purge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entry, null if no match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to get a hash code for, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to get a hash code for, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code, as per the MapEntry specification"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key to compare passed in from outside"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key extracted from the entry via <code>entry.key</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param next the next entry in sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashCode the hash code to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the newly created entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entrySet iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the keySet iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the values iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an error occurs while writing to the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an error occurs while reading from the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if an object read from the stream can not be loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type to check against."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if keyType has the specified type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyType the type of reference to use for keys;\n  must be {@link ReferenceStrength#HARD HARD},\n  {@link ReferenceStrength#SOFT SOFT},\n  {@link ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueType the type of reference to use for values;\n  must be {@link ReferenceStrength#HARD},\n  {@link ReferenceStrength#SOFT SOFT},\n  {@link ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param capacity the initial capacity for the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor for the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param purgeValues should the value be automatically purged when the\n  key is garbage collected"
    },
    {
        "oracle": ";",
        "javadocTag": "@param strict Whether the order should be strict."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if sorted, {@code false} otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dir Ordering direction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param strict Whether the order should be strict."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if sorted, {@code false} otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abort Whether to throw an exception if the check fails."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the arrays have the same length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the lengths differ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abort Whether to throw an exception if the check fails."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the arrays have the same length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the lengths differ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dir Ordering direction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param strict Whether the order should be strict."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abort Whether to throw an exception if the check fails."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the array is sorted."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if the array is not sorted\nand {@code abort} is {@code true}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dir Ordering direction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param strict Whether the order should be strict."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if the array is not sorted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Values."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if the array is not sorted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in array to be tested"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if input array is not rectangular"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in Array to be tested"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if any entries of the array are not\nstrictly positive."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in Array to be tested."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotANumberException if an entry is {@code NaN}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in Array to be tested"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in Array to be tested"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector of doubles."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the 2-norm of the vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Array to be sorted and used as a pattern for permutation\nof the other arrays."
    },
    {
        "oracle": ";",
        "javadocTag": "@param yList Set of arrays whose permutations of entries will follow\nthose performed on {@code x}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if any {@code y} is not the same\nsize as {@code x}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Array to be sorted and used as a pattern for permutation\nof the other arrays."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dir Order direction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param yList Set of arrays whose permutations of entries will follow\nthose performed on {@code x}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if any {@code y} is not the same\nsize as {@code x}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Array to be copied."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the copied array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Array to be copied."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the copied array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Array to be copied."
    },
    {
        "oracle": ";",
        "javadocTag": "@param len Number of entries to copy. If smaller then the source\nlength, the copy will be truncated, if larger it will padded with\nzeroes."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the copied array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Array to be copied."
    },
    {
        "oracle": ";",
        "javadocTag": "@param len Number of entries to copy. If smaller then the source\nlength, the copy will be truncated, if larger it will padded with\nzeroes."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the copied array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Array to be copied."
    },
    {
        "oracle": ";",
        "javadocTag": "@param from Initial index of the range to be copied, inclusive."
    },
    {
        "oracle": ";",
        "javadocTag": "@param to Final index of the range to be copied, exclusive. (This index may lie outside the array.)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the copied array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Factors."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Factors."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions don't match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b1 second factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 first factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b2 second factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b1 second factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 first factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b2 second factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 first factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b3 second factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b1 second factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 first factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b2 second factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 first factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b3 second factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a4 first factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b4 second factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the values are both null or have same dimension\nand equal elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the values are both null or have same dimension and\nequal elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x First array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Second array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the values are both {@code null} or have same\ndimension and equal elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x First array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Second array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the values are both {@code null} or have same\ndimension and equal elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values Input array to be normalized"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalizedSum Target sum for the normalized array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the normalized array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map, <code>null</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a String, <code>null</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a Boolean, <code>null</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a Number, <code>null</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a Byte, <code>null</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a Short, <code>null</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a Integer, <code>null</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a Long, <code>null</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a Float, <code>null</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a Double, <code>null</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a Map, <code>null</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose value to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key of the value to look up in that map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the map, or defaultValue if the original value\n  is null or the map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose value to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key of the value to look up in that map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the map as a string, or defaultValue if the\n  original value is null, the map is null or the string conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose value to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key of the value to look up in that map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue what to return if the value is null or if the\n  conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the map as a boolean, or defaultValue if the\n  original value is null, the map is null or the boolean conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose value to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key of the value to look up in that map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the map as a number, or defaultValue if the\n  original value is null, the map is null or the number conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose value to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key of the value to look up in that map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the map as a number, or defaultValue if the\n  original value is null, the map is null or the number conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose value to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key of the value to look up in that map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the map as a number, or defaultValue if the\n  original value is null, the map is null or the number conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose value to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key of the value to look up in that map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the map as a number, or defaultValue if the\n  original value is null, the map is null or the number conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose value to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key of the value to look up in that map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the map as a number, or defaultValue if the\n  original value is null, the map is null or the number conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose value to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key of the value to look up in that map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the map as a number, or defaultValue if the\n  original value is null, the map is null or the number conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose value to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key of the value to look up in that map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the map as a number, or defaultValue if the\n  original value is null, the map is null or the number conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose value to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key of the value to look up in that map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the map as a number, or defaultValue if the\n  original value is null, the map is null or the map conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a Boolean, <code>false</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a byte, <code>0</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param readSteps If true, read several events (usually starting with a step\n           event, but it may be preceded by other events), until another\n           step is encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stop If true stop at the next step encountered (and push it back so\n           that is is readable at the next call to this method)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if it remains things to read."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The attribute name, already read."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key attribute key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute must name the attribute."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute_class must be the complete name of a Java class that will represent\n           the attribute."
    },
    {
        "oracle": ";",
        "javadocTag": "@param file Name of the file used as source for the tokenizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param file File name to be opened."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reader for the tokenizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FileNotFoundException If the given file does not exist or un readable."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stream Input stream to be open as a reader."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reader for the tokenizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param url The URL used as source for the tokenizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stream The stream used as source for the tokenizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stream The stream used as source for the tokenizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param name The name of the input stream."
    },
    {
        "oracle": ";",
        "javadocTag": "@param reader The reader used as source for the tokenizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param reader The reader."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The new tokenizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException For any I/O error."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The token read StreamTokenizer.TT_EOL or StreamTokenizer.TT_EOF."
    },
    {
        "oracle": ";",
        "javadocTag": "@param words The expected words."
    },
    {
        "oracle": ";",
        "javadocTag": "@param word1 The first word to eat."
    },
    {
        "oracle": ";",
        "javadocTag": "@param word2 The alternative word to eat."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A string."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A string."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A string."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A string."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the <code>value</code> is not a truth value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the <code>value</code> is not a double."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the <code>value</code> is not a long."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eol_is_significant If true EOL will be returned as a token, else it is ignored."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eol_is_significant If true EOL will be returned as a token, else it is ignored."
    },
    {
        "oracle": ";",
        "javadocTag": "@param commentChar Character used for one line comments."
    },
    {
        "oracle": ";",
        "javadocTag": "@param quoteChar Character used to enclose quotations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileName Name of the file to read."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@param url The URL of the file to read."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stream The input stream to use for reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@param reader The reader to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileName Name of the file to read."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@param url The URL of the file to read."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stream The input stream to use for reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@param reader The file reader to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if there are still events to read, false as soon as the file\n        is finished."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if there are still events to read, false as soon as the file\n        is finished."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while closing the file."
    },
    {
        "oracle": ";",
        "javadocTag": "@param declareNodes If true (default=true) this reader outputs nodeAdded events."
    },
    {
        "oracle": ";",
        "javadocTag": "@param declareNodes If true (default=true) this reader outputs nodeAdded events."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeout "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InterruptedException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param source "
    },
    {
        "oracle": ";",
        "javadocTag": "@param source "
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new replay controller"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sink The sink to register."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sink The sink to remove, if it does not exist, this is ignored\n           silently."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sink The sink to register."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sink The sink to remove, if it does not exist, this is ignored\n           silently."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sink The sink to register."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sink The sink to remove, if it does not exist, this is ignored\n           silently."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graph to export."
    },
    {
        "oracle": ";",
        "javadocTag": "@param filter The filter to use, it can be null to disable global attribute\n           filtering."
    },
    {
        "oracle": ";",
        "javadocTag": "@param filter The filter to use, it can be null to disable graph attribute\n           filtering."
    },
    {
        "oracle": ";",
        "javadocTag": "@param filter The filter to use, it can be null to disable node attribute\n           filtering."
    },
    {
        "oracle": ";",
        "javadocTag": "@param filter The filter to use, it can be null to disable edge attribute\n           filtering."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The global attribute filter or null if there is no global filter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The graph attribute filter or null if there is no graph filter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The node global attribute filter or null if there is no node\n        filter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The edge attribute filter or null of there is no edge filter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if time has been updated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if event is new for the source"
    },
    {
        "oracle": ";",
        "javadocTag": "@param currentTimeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param currentTimeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param source source of the events"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source source of the events"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input The source of events we listen at."
    },
    {
        "oracle": ";",
        "javadocTag": "@param input "
    },
    {
        "oracle": ";",
        "javadocTag": "@param replay "
    },
    {
        "oracle": ";",
        "javadocTag": "@param input "
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialListener "
    },
    {
        "oracle": ";",
        "javadocTag": "@param replay "
    },
    {
        "oracle": ";",
        "javadocTag": "@param input The source of graph events we listen at."
    },
    {
        "oracle": ";",
        "javadocTag": "@param input The source of events we listen at."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sharedMBox The message box used to send and receive graph messages across\n           the thread boundary."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonPositiveDefiniteOperatorException if {@code m} is not positive\ndefinite"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllConditionedOperatorException if {@code a} is ill-conditioned"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n{@code true}, and {@code a} is not self-adjoint"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllConditionedOperatorException if {@code a} is ill-conditioned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the linear operator A of the system"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the right-hand side vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param goodb usually {@code false}, except if {@code x} is expected to\ncontain a large multiple of {@code b}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shift the amount to be subtracted to all diagonal elements of A"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to {@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareOperatorException if {@code a} is not square"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code b} has dimensions\ninconsistent with {@code a}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException at exhaustion of the iteration count,\nunless a custom\n{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}\nhas been set at construction of the {@link IterationManager}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n{@code true}, and {@code a} is not self-adjoint"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllConditionedOperatorException if {@code a} is ill-conditioned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x not meaningful in this implementation; should not be considered\nas an initial guess (<a href=\"#initguess\">more</a>)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n{@code true}, and {@code a} is not self-adjoint"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllConditionedOperatorException if {@code a} is ill-conditioned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the vector to be updated with the solution; {@code x} should\nnot be considered as an initial guess (<a href=\"#initguess\">more</a>)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n{@code true}, and {@code a} or {@code m} is not self-adjoint"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonPositiveDefiniteOperatorException if {@code m} is not\npositive definite"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllConditionedOperatorException if {@code a} is ill-conditioned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the linear operator A of the system"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m the preconditioner, M (can be {@code null})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the right-hand side vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the vector to be updated with the solution; {@code x} should\nnot be considered as an initial guess (<a href=\"#initguess\">more</a>)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param goodb usually {@code false}, except if {@code x} is expected to\ncontain a large multiple of {@code b}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shift the amount to be subtracted to all diagonal elements of A"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to {@code x} (shallow copy)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareOperatorException if {@code a} or {@code m} is not square"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\nhave dimensions inconsistent with {@code a}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException at exhaustion of the iteration count,\nunless a custom\n{@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}\nhas been set at construction of the {@link IterationManager}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n{@code true}, and {@code a} or {@code m} is not self-adjoint"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonPositiveDefiniteOperatorException if {@code m} is not positive\ndefinite"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllConditionedOperatorException if {@code a} is ill-conditioned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the vector to be updated with the solution; {@code x} should\nnot be considered as an initial guess (<a href=\"#initguess\">more</a>)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n{@code true}, and {@code a} is not self-adjoint"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllConditionedOperatorException if {@code a} is ill-conditioned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta the &delta; parameter for the default stopping criterion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param check {@code true} if self-adjointedness of both matrix and\npreconditioner should be checked"
    },
    {
        "oracle": ";",
        "javadocTag": "@param manager the custom iteration manager"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta the &delta; parameter for the default stopping criterion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param check {@code true} if self-adjointedness of both matrix and\npreconditioner should be checked"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entries of this instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this + v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to append to this one."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector with which outer product should be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the matrix outer product between instance and v"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to be subtracted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this - v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as\n{@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry of the subvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry of the subvector (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code start} of {@code end} are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Expected dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimensions do not match."
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be used to process the entries of this\nvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorPreservingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor to be used to process the entries of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorPreservingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be used to process the entries of this\nvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorPreservingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor to be used to process the entries of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorPreservingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be used to process and modify the entries\nof this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorChangingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor to be used to process the entries of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorChangingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be used to process the entries of this\nvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorChangingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor to be used to process the entries of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldVectorChangingVisitor#end()}\nat the end of the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension Size of the vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Original vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resize Amount to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension Size of the vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedSize Expected number of non-zero entries."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values Set of values to create from."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code int} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code int} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the least index {@code i} for which {@code array[i] == target}, or\n    {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to search for the sequence {@code target}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target the array to search for as a sub-sequence of {@code array}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code int} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code int} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the greatest index {@code i} for which {@code array[i] == target},\n    or {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is less than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is greater than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arrays zero or more {@code int} arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a single array containing all the values from the source arrays, in\n    order"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code bytes} has fewer than 4 elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the source array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minLength the minimum length the returned array must guarantee"
    },
    {
        "oracle": ";",
        "javadocTag": "@param padding an extra amount to \"grow\" the array by if growth is\n    necessary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the values of {@code array}, with guaranteed\n    minimum length {@code minLength}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator the text that should appear between consecutive values in\n    the resulting string (but not at the start or end)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code int} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection a collection of {@code Number} instances"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the same values as {@code collection}, in the\n    same order, converted to primitives"
    },
    {
        "oracle": ";",
        "javadocTag": "@param backingArray the array to back the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list view of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the string representation of an integer value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the integer value represented by {@code string}, or {@code null} if\n    {@code string} has a length of zero or cannot be parsed as an integer\n    value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the string representation of an integer value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param radix the radix to use when parsing"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the integer value represented by {@code string} using\n    {@code radix}, or {@code null} if {@code string} has a length of zero\n    or cannot be parsed as an integer value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code radix < Character.MIN_RADIX} or\n    {@code radix > Character.MAX_RADIX}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value a value between 0 and 255 inclusive"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@code byte} value that, when treated as unsigned, equals\n    {@code value}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value any {@code long} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code (byte) 255} if {@code value >= 255}, {@code (byte) 0} if\n    {@code value <= 0}, and {@code value} cast to {@code byte} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first {@code byte} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second {@code byte} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a negative value if {@code a} is less than {@code b}; a positive\n    value if {@code a} is greater than {@code b}; or zero if they are equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is less than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is greater than or equal\n    to every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value to convert to a string."
    },
    {
        "oracle": ";",
        "javadocTag": "@param radix the radix to use while working with {@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code radix} is not between {@link Character#MIN_RADIX}\n        and {@link Character#MAX_RADIX}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the string does not contain a valid unsigned {@code byte}\n        value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if {@code s} is null\n        (in contrast to {@link Byte#parseByte(String)})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the string containing the unsigned {@code byte} representation to be parsed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param radix the radix to use while parsing {@code string}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the string does not contain a valid unsigned {@code byte}\n        with the given radix, or if {@code radix} is not between {@link Character#MIN_RADIX}\n        and {@link Character#MAX_RADIX}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if {@code s} is null\n        (in contrast to {@link Byte#parseByte(String)})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator the text that should appear between consecutive values in\n    the resulting string (but not at the start or end)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code byte} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value a primitive {@code char} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code for the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value any value in the range of the {@code char} type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@code char} value that equals {@code value}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code value} is greater than {@link\n    Character#MAX_VALUE} or less than {@link Character#MIN_VALUE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value any {@code long} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the same value cast to {@code char} if it is in the range of the\n    {@code char} type, {@link Character#MAX_VALUE} if it is too large,\n    or {@link Character#MIN_VALUE} if it is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first {@code char} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second {@code char} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a negative value if {@code a} is less than {@code b}; a positive\n    value if {@code a} is greater than {@code b}; or zero if they are equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code char} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code char} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code array[i] == target} for some value of {@code\n    i}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code char} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code char} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the least index {@code i} for which {@code array[i] == target}, or\n    {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to search for the sequence {@code target}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target the array to search for as a sub-sequence of {@code array}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code char} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code char} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the greatest index {@code i} for which {@code array[i] == target},\n    or {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is less than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is greater than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arrays zero or more {@code char} arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a single array containing all the values from the source arrays, in\n    order"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code bytes} has fewer than 2\n    elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the source array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minLength the minimum length the returned array must guarantee"
    },
    {
        "oracle": ";",
        "javadocTag": "@param padding an extra amount to \"grow\" the array by if growth is\n    necessary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the values of {@code array}, with guaranteed\n    minimum length {@code minLength}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator the text that should appear between consecutive values in\n    the resulting string (but not at the start or end)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code char} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection a collection of {@code Character} objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the same values as {@code collection}, in the\n    same order, converted to primitives"
    },
    {
        "oracle": ";",
        "javadocTag": "@param backingArray the array to back the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list view of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code value} is negative or {@code value >= 2^32}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the string does not contain a parsable unsigned {@code int}\n        value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the string does not contain a parsable unsigned {@code int}\n        value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code val} is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code val} is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value a primitive {@code long} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code for the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first {@code long} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second {@code long} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a negative value if {@code a} is less than {@code b}; a positive\n    value if {@code a} is greater than {@code b}; or zero if they are equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code long} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code long} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code array[i] == target} for some value of {@code\n    i}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code long} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code long} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param residuals Residuals."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cost."
    },
    {
        "oracle": ";",
        "javadocTag": "@return RMS value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return chi-square value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square-root of the weight matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param cost Cost value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the covariance matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.linear.SingularMatrixException if the covariance matrix cannot be computed (singular problem)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Singularity threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the covariance matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.linear.SingularMatrixException if the covariance matrix cannot be computed (singular problem)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param params Model parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Singularity threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the covariance matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.linear.SingularMatrixException if the covariance matrix cannot be computed (singular problem)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an estimate of the standard deviation of the optimized parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.linear.SingularMatrixException if the covariance matrix cannot be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of degrees of freedom is not\npositive, i.e. the number of measurements is less or equal to the number of\nparameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param params Model parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param covarianceSingularityThreshold Singularity threshold (see\n{@link #computeCovariances(double[],double) computeCovariances})."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an estimate of the standard deviation of the optimized parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.linear.SingularMatrixException if the covariance matrix cannot be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param target Target value for the objective functions at optimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights Weights for the least squares cost computation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startPoint Start point for optimization."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value for objective\nfunction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Allowed number of evaluations of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link Target}</li>\n <li>{@link Weight}</li>\n <li>{@link InitialGuess}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value of the objective\nfunction."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if\nthe maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the target, and weight arguments\nhave inconsistent dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param objectiveValue Value of the the objective function. This is\nthe value returned from a call to\n{@link #computeObjectiveValue(double[]) computeObjectiveValue}\n(whose array argument contains the model parameters)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the residuals."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code params} has a wrong\nlength."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Symmetric, positive-definite (weight) matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square-root of the weight matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param evaluationPoint Point at which the gradient must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the gradient at the specified point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param useLU If {@code true}, the normal equations will be solved\nusing LU decomposition, otherwise they will be solved using QR\ndecomposition."
    },
    {
        "oracle": ";",
        "javadocTag": "@param useLU If {@code true}, the normal equations will be solved\nusing LU decomposition, otherwise they will be solved using QR\ndecomposition."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param evaluationPoint Point at which the gradient must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the gradient at the specified point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the allowed number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType Type of optimization goal: either\n{@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startPoint Start point for optimization."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value for objective\nfunction."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialStep initial step used to bracket the optimum in line search,\nif a non-positive value is used, the initial step is reset to its\ndefault value of 1.0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f function whose root must be bracketed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a lower bound of the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param h initial step to try."
    },
    {
        "oracle": ";",
        "javadocTag": "@return b such that f(a) and f(b) have opposite signs."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if no bracket can be found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param updateFormula formula to use for updating the &beta; parameter,\nmust be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\nConjugateGradientFormula#POLAK_RIBIERE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param updateFormula formula to use for updating the &beta; parameter,\nmust be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\nConjugateGradientFormula#POLAK_RIBIERE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param updateFormula formula to use for updating the &beta; parameter,\nmust be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\nConjugateGradientFormula#POLAK_RIBIERE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lineSearchSolver Solver to use during line search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param updateFormula formula to use for updating the &beta; parameter,\nmust be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\nConjugateGradientFormula#POLAK_RIBIERE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lineSearchSolver Solver to use during line search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param preconditioner Preconditioner."
    },
    {
        "oracle": ";",
        "javadocTag": "@return array containing the optima"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if {@link\n#optimize(int,MultivariateVectorFunction,double[],double[],double[]) optimize} has not been\ncalled."
    },
    {
        "oracle": ";",
        "javadocTag": "@param target Target value for the objective functions at optimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights Weights for the least-squares cost computation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Single-start optimizer to wrap."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator Random vector generator to use for restarts."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the variables are restricted to non-negative values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the optimization type."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the optimization type."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the optimization type."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the maximal number of iterations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value for objective function"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if no solution fulfilling the constraints\ncan be found in the allowed number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return coefficients of the constraint (left hand side)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return relationship between left and right hand sides"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value of the constraint (right hand side)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param oos stream where object should be written"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be written to stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ois stream from which the object should be read"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if a class in the stream cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be read from the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients The coefficients of the constraint (left hand side)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relationship The type of (in)equality used in the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The value of the constraint (right hand side)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest FourthMoment to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code FourthMoment} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the weighted variance of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the weighted variance of the values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean the precomputed mean value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean the precomputed mean value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance of the values or Double.NaN if the array is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean the precomputed weighted mean value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean the precomputed weighted mean value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Returns the isBiasCorrected."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Variance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest Variance to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m2 the SecondMoment (Third or Fourth moments work\nhere as well.)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isBiasCorrected setting for bias correction - true means\nbias will be corrected and is equivalent to using the argumentless\nconstructor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isBiasCorrected setting for bias correction - true means\nbias will be corrected"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m2 the SecondMoment (Third or Fourth moments work\nhere as well.)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code Variance} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the kurtosis of the values or Double.NaN if length is less than 4"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Kurtosis to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest Kurtosis to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m4 external Moment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code Kurtosis} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values input array containing the values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the geometric mean or Double.NaN if length = 0 or\nany of the values are &lt;= 0."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sumLogImpl the StorelessUnivariateStatistic instance to use\nfor computing the log sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added\n (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the log sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source GeometricMean to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest GeometricMean to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has been added to this statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code GeometricMean} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sumOfLogs sum of logs instance to use for computation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the standard deviation of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the standard deviation of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean the precomputed mean value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the standard deviation of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean the precomputed mean value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the standard deviation of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Returns the isBiasCorrected."
    },
    {
        "oracle": ";",
        "javadocTag": "@param isBiasCorrected The isBiasCorrected to set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source StandardDeviation to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest StandardDeviation to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m2 the external moment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code StandardDeviation} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isBiasCorrected whether or not the variance computation will use\nthe bias-corrected formula"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isBiasCorrected whether or not the variance computation will use\nthe bias-corrected formula"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m2 the external moment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the vector does not have the right dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@return covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of vectors in the sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension vectors dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isBiasCorrected if true, computed the unbiased sample covariance,\notherwise computes the biased population covariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source ThirdMoment to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest ThirdMoment to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code ThirdMoment} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source SemiVariance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest SemiVariance to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if this range set does not support the {@code clear}\n        operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if this range set does not support the {@code addAll}\n        operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if this range set does not support the {@code removeAll}\n        operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param self a collection which might contain all elements in {@code c}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c a collection whose elements might be contained by {@code self}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the original iterable whose elements have to be permuted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an immutable {@link Collection} containing all the different\n    permutations of the original iterable."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the original iterable whose elements have to be permuted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator a comparator for the iterable's elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an immutable {@link Collection} containing all the different\n    permutations of the original iterable."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the original collection whose elements have to be permuted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an immutable {@link Collection} containing all the different\n    permutations of the original collection."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the elements that the queue should contain, in order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code LinkedBlockingQueue} containing those elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q the blocking queue to be drained"
    },
    {
        "oracle": ";",
        "javadocTag": "@param buffer where to add the transferred elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numElements the number of elements to be waited for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeout how long to wait before giving up, in units of {@code unit}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit a {@code TimeUnit} determining how to interpret the timeout parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of elements transferred"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InterruptedException if interrupted while waiting"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q the blocking queue to be drained"
    },
    {
        "oracle": ";",
        "javadocTag": "@param buffer where to add the transferred elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numElements the number of elements to be waited for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeout how long to wait before giving up, in units of {@code unit}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit a {@code TimeUnit} determining how to interpret the timeout parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of elements transferred"
    },
    {
        "oracle": ";",
        "javadocTag": "@param queue the queue to be wrapped in a synchronized view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized view of the specified queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@param deque the deque to be wrapped in a synchronized view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized view of the specified deque"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowKey key of row to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnKey key of column to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowKey key of row to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnKey key of column to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowKey key of row to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnKey key of column to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowKey row key that the value should be associated with"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnKey column key that the value should be associated with"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to be associated with the specified keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value previously associated with the keys, or {@code null} if\n    no mapping existed for the keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param table the table to add to this table"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowKey row key of mapping to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnKey column key of mapping to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value previously associated with the keys, or {@code null} if\n    no such value existed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowKey key of row to search for in the table"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the corresponding map from column keys to values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnKey key of column to search for in the table"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the corresponding map from row keys to values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return set of table cells consisting of row key / column key / value\n    triplets"
    },
    {
        "oracle": ";",
        "javadocTag": "@return set of row keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@return set of column keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@return collection of values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map view from each row key to a secondary map from column keys to\n    values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map view from each column key to a secondary map from row keys to\n    values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyType the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueType the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose mappings are to be placed in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if map is not an {@code EnumBiMap}\n    instance and contains no mappings"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the component type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the length of the new array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reference any array of the desired type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the length of the new array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param first the first array of elements to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param second the second array of elements to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the component type of the returned array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to prepend to the front of {@code array}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array of elements to append"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array whose size is one larger than {@code array}, with\n    {@code element} occupying the first position, and the\n    elements of {@code array} occupying the remaining elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array of elements to prepend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to append to the end"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array whose size is one larger than {@code array}, with\n    the same contents as {@code array}, plus {@code element} occupying the\n    last position."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the collection for which to return an array of elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array in which to place the collection elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArrayStoreException if the runtime type of the specified array is\n    not a supertype of the runtime type of every element in the specified\n    collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the collection for which to return an array of elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the iteration has no more elements\n    according to {@link #hasNext()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowKeys row keys that may be stored in the generated table"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnKeys column keys that may be stored in the generated table"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code rowKeys} or {@code columnKeys}\n    contains duplicates or is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if {@code table} has a null key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowIndex position of the row key in {@link #rowKeyList()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnIndex position of the row key in {@link #columnKeyList()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value with the specified row and column"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if either index is negative, {@code\n    rowIndex} is greater then or equal to the number of allowed row keys,\n    or {@code columnIndex} is greater then or equal to the number of\n    allowed column keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowIndex position of the row key in {@link #rowKeyList()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnIndex position of the row key in {@link #columnKeyList()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to store in the table"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value with the specified row and column"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if either index is negative, {@code\n    rowIndex} is greater then or equal to the number of allowed row keys,\n    or {@code columnIndex} is greater then or equal to the number of\n    allowed column keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueClass class of values stored in the returned array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code rowKey} is not in {@link\n    #rowKeySet()} or {@code columnKey} is not in {@link #columnKeySet()}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if {@code table} has a null key"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if any of the provided table's row keys or\n    column keys is not in {@link #rowKeySet()} or {@link #columnKeySet()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowKey row key of mapping to be erased"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnKey column key of mapping to be erased"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value previously associated with the keys, or {@code null} if\n    no mapping existed for the keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@return set of table cells consisting of row key / column key / value\n    triplets"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnKey key of column to search for in the table"
    },
    {
        "oracle": "set==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if set or predicate is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "set==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if set or predicate is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "enumeration==null;",
        "javadocTag": "@throws NullPointerException if the enumeration parameter is <code>null</code>."
    },
    {
        "oracle": "(enumeration==null) == false;",
        "javadocTag": "@param enumeration the enumeration to traverse, which should not be <code>null</code>."
    },
    {
        "oracle": "multipleUse==true;",
        "javadocTag": "@param multipleUse <code>true</code> if the new iterable can be used in multiple iterations"
    },
    {
        "oracle": "closures==null;",
        "javadocTag": "@throws NullPointerException if the closures array is null"
    },
    {
        "oracle": "Arrays.stream(closures).anyMatch(jdVar -> jdVar==null);",
        "javadocTag": "@throws NullPointerException if any closure in the array is null"
    },
    {
        "oracle": "closures==null;",
        "javadocTag": "@throws NullPointerException if the closures collection is null"
    },
    {
        "oracle": "value1==null;",
        "javadocTag": "@param value1 the first value to compare, may be null"
    },
    {
        "oracle": "value2==null;",
        "javadocTag": "@param value2 the second value to compare, may be null"
    },
    {
        "oracle": "index<0;",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is less than 0; equal to\nthe size of the list and endMakerAllowed is false; or greater than the\nsize of the list"
    },
    {
        "oracle": "coll==null;",
        "javadocTag": "@throws NullPointerException if {@code coll} is {@code null}"
    },
    {
        "oracle": "(coll==null) == false;",
        "javadocTag": "@param coll the <code>BoundedCollection</code> to decorate, must not be null"
    },
    {
        "oracle": "coll==null;",
        "javadocTag": "@throws NullPointerException if coll is null"
    },
    {
        "oracle": "(coll==null) == false;",
        "javadocTag": "@param coll the <code>BoundedCollection</code> to decorate, must not be null"
    },
    {
        "oracle": "(predicate1==null) == false;",
        "javadocTag": "@param predicate1 the first predicate to check, not null"
    },
    {
        "oracle": "(predicate2==null) == false;",
        "javadocTag": "@param predicate2 the second predicate to check, not null"
    },
    {
        "oracle": "predicate1==null || predicate2==null;",
        "javadocTag": "@throws NullPointerException if either predicate is null"
    },
    {
        "oracle": "(predicate1==null) == false;",
        "javadocTag": "@param predicate1 the first predicate to check, not null"
    },
    {
        "oracle": "(predicate2==null) == false;",
        "javadocTag": "@param predicate2 the second predicate to check, not null"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return the predicates"
    },
    {
        "oracle": "coll==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if collection or transformer is null"
    },
    {
        "oracle": "(coll==null) == false;",
        "javadocTag": "@param coll the collection to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "coll==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if collection or transformer is null"
    },
    {
        "oracle": "(coll==null) == false;",
        "javadocTag": "@param coll the collection to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "collection==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if collection or transformer is null"
    },
    {
        "oracle": "(collection==null) == false;",
        "javadocTag": "@param collection the collection to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "true ? methodResultID.equals(coll) : true;",
        "javadocTag": "@return a transformed object"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return the key"
    },
    {
        "oracle": "true ? methodResultID.equals(this.values()) : true;",
        "javadocTag": "@return the value"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return true always"
    },
    {
        "oracle": "true ? methodResultID==false : true;",
        "javadocTag": "@return false always"
    },
    {
        "oracle": "this.containsKey(value) ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return true if the map contains the key"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true ? methodResultID.equals(this.getKey()) : true;",
        "javadocTag": "@return the key"
    },
    {
        "oracle": "true ? methodResultID.equals(this.getKey()) : true;",
        "javadocTag": "@return the key"
    },
    {
        "oracle": "multiset==null;",
        "javadocTag": "@throws NullPointerException if multiset is null"
    },
    {
        "oracle": "(multiset==null) == false;",
        "javadocTag": "@param multiset the multiset to decorate, must not be null"
    },
    {
        "oracle": "multiset==null || lock==null;",
        "javadocTag": "@throws NullPointerException if multiset or lock is null"
    },
    {
        "oracle": "(multiset==null) == false;",
        "javadocTag": "@param multiset the multiset to decorate, must not be null"
    },
    {
        "oracle": "(lock==null) == false;",
        "javadocTag": "@param lock the lock to use, must not be null"
    },
    {
        "oracle": "multiset==null;",
        "javadocTag": "@throws NullPointerException if multiset is null"
    },
    {
        "oracle": "(multiset==null) == false;",
        "javadocTag": "@param multiset the multiset to decorate, must not be null"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return the predicates being decorated"
    },
    {
        "oracle": "a==null || b==null;",
        "javadocTag": "@throws NullPointerException if either iterator is null"
    },
    {
        "oracle": "a==null || b==null || c==null;",
        "javadocTag": "@throws NullPointerException if either iterator is null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to decorate, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "keyPredicate==null;",
        "javadocTag": "@param keyPredicate the predicate to validate the keys, null means no check"
    },
    {
        "oracle": "valuePredicate==null;",
        "javadocTag": "@param valuePredicate the predicate to validate to values, null means no check"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "keyPredicate==null;",
        "javadocTag": "@param keyPredicate the predicate to validate the keys, null means no check"
    },
    {
        "oracle": "valuePredicate==null;",
        "javadocTag": "@param valuePredicate the predicate to validate to values, null means no check"
    },
    {
        "oracle": "true ? methodResultID.equals(value) : true;",
        "javadocTag": "@return the value itself"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if the specified array is null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "bag==null || lock==null;",
        "javadocTag": "@throws NullPointerException if bag or lock is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "(lock==null) == false;",
        "javadocTag": "@param lock the lock to use, must not be null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "coll==null;",
        "javadocTag": "@throws NullPointerException if collection is null"
    },
    {
        "oracle": "(coll==null) == false;",
        "javadocTag": "@param coll the collection to decorate, must not be null"
    },
    {
        "oracle": "transformer==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if the transformer or the predicate is null"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return the value"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if list is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if list is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "type==null;",
        "javadocTag": "@throws NullPointerException if the class is null"
    },
    {
        "oracle": "(type==null) == false;",
        "javadocTag": "@param type the type to check for, may not be null"
    },
    {
        "oracle": "methodName==null;",
        "javadocTag": "@throws NullPointerException if the methodName is null."
    },
    {
        "oracle": "(methodName==null) == false;",
        "javadocTag": "@param methodName the method name to call on the input object, may not be null"
    },
    {
        "oracle": "methodName==null;",
        "javadocTag": "@throws NullPointerException if the method name is null"
    },
    {
        "oracle": "(methodName==null) == false;",
        "javadocTag": "@param methodName the method name to call on the input object, may not be null"
    },
    {
        "oracle": "predicate1==null || predicate2==null;",
        "javadocTag": "@throws NullPointerException if either predicate is null"
    },
    {
        "oracle": "(predicate1==null) == false;",
        "javadocTag": "@param predicate1 the first predicate, may not be null"
    },
    {
        "oracle": "(predicate2==null) == false;",
        "javadocTag": "@param predicate2 the second predicate, may not be null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates array is null"
    },
    {
        "oracle": "Arrays.stream(predicates).anyMatch(jdVar -> jdVar==null);",
        "javadocTag": "@throws NullPointerException if any predicate in the array is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates an array of predicates to check, may not be null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates collection is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates a collection of predicates to check, may not be null"
    },
    {
        "oracle": "predicate1==null || predicate2==null;",
        "javadocTag": "@throws NullPointerException if either predicate is null"
    },
    {
        "oracle": "(predicate1==null) == false;",
        "javadocTag": "@param predicate1 the first predicate, may not be null"
    },
    {
        "oracle": "(predicate2==null) == false;",
        "javadocTag": "@param predicate2 the second predicate, may not be null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the slope of the regression line"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sum of squared errors associated with the regression model"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sum of squared deviations of y values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sum of squared deviations of x values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sum of cross products"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sum of squared deviations of predicted y values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sum of squared deviations of y values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Pearson's r"
    },
    {
        "oracle": ";",
        "javadocTag": "@return r-square"
    },
    {
        "oracle": ";",
        "javadocTag": "@return standard error associated with intercept estimate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return standard error associated with slope estimate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return half-width of 95% confidence interval for the slope estimate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the confidence interval can not be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha the desired significance level"
    },
    {
        "oracle": ";",
        "javadocTag": "@return half-width of 95% confidence interval for the slope estimate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the confidence interval can not be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return significance level for slope/correlation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.MaxCountExceededException if the significance level can not be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param slope current slope"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the intercept of the regression line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param slope regression slope estimate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sum of squared deviations of predicted y values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return RegressionResults acts as a container of regression output"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException if the model is not correctly specified"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if there is not sufficient data in the model to\nestimate the regression parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param variablesToInclude an array of indices of regressors to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return RegressionResults acts as a container of regression output"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if a requested variable is not present in model"
    },
    {
        "oracle": ";",
        "javadocTag": "@param includeIntercept whether or not to include an intercept term in\nthe regression model"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if constant exists, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Number of observations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the independent variables which form the design matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y the dependent or response variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException if the length of {@code x} does not equal\nthe number of independent variables in the model"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x a series of observations on the independent variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y a series of observations on the dependent variable\nThe length of x and y must be the same"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException if {@code x} is not rectangular, does not match\nthe length of {@code y} or does not contain sufficient data to estimate the model"
    },
    {
        "oracle": ";",
        "javadocTag": "@return RegressionResults acts as a container of regression output"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException if the model is not correctly specified"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if there is not sufficient data in the model to\nestimate the regression parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param variablesToInclude an array of indices of regressors to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return RegressionResults acts as a container of regression output"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException if the model is not correctly specified"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the X sample data."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Y sample data."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the model has no intercept term; false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data input data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nobs number of observations (rows)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nvars number of independent variables (columns, not counting y)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the data array is not equal\nto <code>nobs * (nvars + 1)</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y the array representing the y sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the rectangular array representing the x sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if x is not rectangular"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the [n,k] array representing the x data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y the [n,1] array representing the y data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code x} and {@code y} do not\nhave the same length"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the number of rows of {@code x}\nis not larger than the number of columns + 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the [n,k] array representing the x sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param covariance the [n,n] array representing the covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the number of rows in x is not equal\nto the number of rows in covariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareMatrixException if the covariance matrix is not square"
    },
    {
        "oracle": ";",
        "javadocTag": "@return estimate of the error variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return regression standard error"
    },
    {
        "oracle": ";",
        "javadocTag": "@return beta"
    },
    {
        "oracle": ";",
        "javadocTag": "@return beta variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Y variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return error variance estimate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The residuals [n,1] matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y y values of the sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x x values of the sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param covariance array representing the covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param omega the [n,n] array representing the covariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return inverse of the covariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return beta"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The beta variance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return error variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern message pattern describing the specification error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parameters estimated for regressor at index."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code index} is not in the interval\n{@code [0, number of parameters)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return array of parameter estimates, null if no estimation occurred"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the standard errors associated with parameters estimated at index."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code index} is not in the interval\n{@code [0, number of parameters)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array standard errors associated with parameters estimates,\n null if no estimation occurred"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i {@code i}th regression parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param j {@code j}th regression parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the covariance of the parameter estimates."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code i} or {@code j} is not in the\ninterval {@code [0, number of parameters)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of regressors, -1 if not estimated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Number of observations, -1 if an error condition prevents estimation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sum of squared deviations of y values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sum of squared deviations of predicted y values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sum of squared errors associated with the regression model"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sum of squared deviations of y values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return r-square, a double in the interval [0, 1]"
    },
    {
        "oracle": ";",
        "javadocTag": "@return adjusted R-Squared statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the model has an intercept term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i first variable index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f the function to be sampled and transformed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param min the (inclusive) lower bound for the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max the (exclusive) upper bound for the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the number of sample points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of transform (forward, inverse) to be performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the real transformed array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if the lower bound is greater than, or equal to the upper bound"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the sample cannot be transformed\n  with the given type (this may be for example due to sample size, which is\n  constrained in some transforms)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the length of the data array is\n  not a power of two, or the first element of the data array is not zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NonMonotonicSequenceException if the lower bound is greater than, or equal to the upper bound"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if the number of sample points is negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the number of sample points is not a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f the real data array to be transformed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the real transformed array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the length of the data array is\n  not a power of two, or the first element of the data array is not zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalization the type of normalization to be applied to the transformed data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first array to be shuffled"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second array to be shuffled"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dataRI the unscaled transformed data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalization the normalization to be applied"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of transform (forward, inverse) which resulted in the specified data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dataRI the two dimensional array of real and imaginary parts of the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalization the normalization to be applied to the transformed data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of transform (forward, inverse) to be performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the number of rows of the specified\n  array is not two, or the array is not rectangular"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the number of data points is not\n  a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f the real data array to be transformed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of transform (forward, inverse) to be performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the complex transformed array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the length of the data array is not a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f the function to be sampled and transformed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param min the (inclusive) lower bound for the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max the (exclusive) upper bound for the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the number of sample points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of transform (forward, inverse) to be performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the complex transformed array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if the lower bound is greater than, or equal to the upper bound"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if the number of sample points {@code n} is negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the number of sample points\n  {@code n} is not a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f the complex data array to be transformed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of transform (forward, inverse) to be performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the length of the data array is not a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mdca Multi-Dimensional Complex Array, i.e. {@code Complex[][][][]}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of transform (forward, inverse) to be performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return transform of {@code mdca} as a Multi-Dimensional Complex Array, i.e. {@code Complex[][][][]}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if any dimension is not a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mdcm input matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of transform (forward, inverse) to be performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d index of the dimension to process"
    },
    {
        "oracle": ";",
        "javadocTag": "@param subVector recursion subvector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if any dimension is not a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalization the type of normalization to be applied to the\ntransformed data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the length of the data array is\nnot a power of two plus one"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NonMonotonicSequenceException if the lower bound is greater than, or equal to the upper bound"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if the number of sample points is negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the number of sample points is\nnot a power of two plus one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f the real data array to be transformed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the real transformed array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the length of the data array is\nnot a power of two plus one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalization the type of normalization to be applied to the\ntransformed data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f the real array to be scaled"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d the real scaling coefficient"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to the scaled array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f the complex array to be scaled"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d the real scaling coefficient"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to the scaled array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dataC the array of {@link Complex} data to be transformed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a two dimensional array filled with the real and imaginary parts\n  of the specified complex input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dataRI the array of real and imaginary parts to be transformed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of {@link Complex} with specified real and imaginary parts."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the number of rows of the specified\n  array is not two, or the array is not rectangular"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the {@code int} whose base-2 logarithm is to be evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the base-2 logarithm of {@code n}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if {@code n} is not a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the length of the data array is\nnot a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NonMonotonicSequenceException if the lower bound is greater than, or equal to the upper bound"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if the number of sample points is negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the number of sample points is not a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f the integer data array to be transformed (signal)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the integer transformed array (spectrum)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the length of the data array is not a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the real data array to be transformed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the real transformed array, {@code y}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the length of the data array is not a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the integer data array to be transformed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the integer transformed array, {@code y}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the length of the data array is not a power of two"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to call, not null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws IllegalArgumentException if the predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to call, not null"
    },
    {
        "oracle": "predicate==null || closure==null;",
        "javadocTag": "@throws NullPointerException if either argument is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use as an end of loop test, not null"
    },
    {
        "oracle": "(closure==null) == false;",
        "javadocTag": "@param closure the closure to call repeatedly, not null"
    },
    {
        "oracle": "closure==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if either argument is null"
    },
    {
        "oracle": "(closure==null) == false;",
        "javadocTag": "@param closure the closure to call repeatedly, not null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use as an end of loop test, not null"
    },
    {
        "oracle": "methodName==null;",
        "javadocTag": "@throws NullPointerException if the method name is null"
    },
    {
        "oracle": "methodName==null;",
        "javadocTag": "@throws NullPointerException if the method name is null"
    },
    {
        "oracle": "closures==null;",
        "javadocTag": "@throws NullPointerException if the closures array is null"
    },
    {
        "oracle": "Arrays.stream(closures).anyMatch(jdVar -> jdVar==null);",
        "javadocTag": "@throws NullPointerException if any closure in the array is null"
    },
    {
        "oracle": "closures==null;",
        "javadocTag": "@throws NullPointerException if the closures collection is null"
    },
    {
        "oracle": "((closures==null)==false) && (closures.isEmpty());",
        "javadocTag": "@throws IllegalArgumentException if the closures collection is empty"
    },
    {
        "oracle": "predicate==null || trueClosure==null;",
        "javadocTag": "@throws NullPointerException if the predicate or closure is null"
    },
    {
        "oracle": "predicate==null || trueClosure==null || falseClosure==null;",
        "javadocTag": "@throws NullPointerException if the predicate or either closure is null"
    },
    {
        "oracle": "predicates==null || closures==null;",
        "javadocTag": "@throws NullPointerException if any element in the arrays is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates an array of predicates to check, not null"
    },
    {
        "oracle": "(closures==null) == false;",
        "javadocTag": "@param closures an array of closures to call, not null"
    },
    {
        "oracle": "predicates==null || closures==null;",
        "javadocTag": "@throws NullPointerException if any element in the arrays is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates an array of predicates to check, not null"
    },
    {
        "oracle": "(closures==null) == false;",
        "javadocTag": "@param closures an array of closures to call, not null"
    },
    {
        "oracle": "predicatesAndClosures==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "((predicatesAndClosures==null)==false) && (predicatesAndClosures.isEmpty());",
        "javadocTag": "@throws IllegalArgumentException if the map is empty"
    },
    {
        "oracle": "objectsAndClosures==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "((objectsAndClosures==null)==false) && (objectsAndClosures.isEmpty());",
        "javadocTag": "@throws IllegalArgumentException if the map is empty"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "loadFactor>0.0 && loadFactor<1.0;",
        "javadocTag": "@param loadFactor the load factor, must be > 0.0f and generally < 1.0f"
    },
    {
        "oracle": "initialCapacity<0;",
        "javadocTag": "@throws IllegalArgumentException if the initial capacity is negative"
    },
    {
        "oracle": "initialCapacity<0;",
        "javadocTag": "@throws IllegalArgumentException if the initial capacity is negative"
    },
    {
        "oracle": "loadFactor<0;",
        "javadocTag": "@throws IllegalArgumentException if the load factor is less than zero"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if iterator is null"
    },
    {
        "oracle": "offset<0;",
        "javadocTag": "@throws IllegalArgumentException if offset is negative"
    },
    {
        "oracle": "(closure==null) == false;",
        "javadocTag": "@param closure the closure to call, not null"
    },
    {
        "oracle": "closure==null;",
        "javadocTag": "@throws NullPointerException if the closure is null"
    },
    {
        "oracle": "(closure==null) == false;",
        "javadocTag": "@param closure the closure to call, not null"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return the transformed result"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the sorted bag to decorate, must not be null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the sorted bag to decorate, must not be null"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if <code>array</code> is <code>null</code>"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if <code>array</code> is <code>null</code>"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if <code>array</code> is <code>null</code>"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate used to evaluate when the loop terminates, not null"
    },
    {
        "oracle": "(closure==null) == false;",
        "javadocTag": "@param closure the closure the execute, not null"
    },
    {
        "oracle": "doLoop==true;",
        "javadocTag": "@param doLoop true to act as a do-while loop, always executing the closure once"
    },
    {
        "oracle": "predicate==null || closure==null;",
        "javadocTag": "@throws NullPointerException if the predicate or closure is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate used to evaluate when the loop terminates, not null"
    },
    {
        "oracle": "(closure==null) == false;",
        "javadocTag": "@param closure the closure the execute, not null"
    },
    {
        "oracle": "doLoop==true;",
        "javadocTag": "@param doLoop true to act as a do-while loop, always executing the closure once"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws IllegalArgumentException if set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "set==null || list==null;",
        "javadocTag": "@throws NullPointerException if set or list is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "set==null || list==null;",
        "javadocTag": "@throws NullPointerException if set or list is null"
    },
    {
        "oracle": "(set.isEmpty()) == false || (list.isEmpty()) == false;",
        "javadocTag": "@throws IllegalArgumentException if either the set or list is not empty"
    },
    {
        "oracle": "(set==null) == false && set.isEmpty();",
        "javadocTag": "@param set the set to decorate, must be empty and not null"
    },
    {
        "oracle": "(list==null) == false && list.isEmpty();",
        "javadocTag": "@param list the list to decorate, must be empty and not null"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if list is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return the transformed result"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if the predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to decorate, not null"
    },
    {
        "oracle": "object==null;",
        "javadocTag": "@throws FunctorException if input is null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map.isEmpty()) == false;",
        "javadocTag": "@throws IllegalArgumentException if the map is not empty"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, not null"
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException if the key is null"
    },
    {
        "oracle": "key!=null;",
        "javadocTag": "@param key the non-null MultiKey object"
    },
    {
        "oracle": "mapToCopy==null;",
        "javadocTag": "@throws NullPointerException if the mapToCopy or any key within is null"
    },
    {
        "oracle": "removeAllowed==true;",
        "javadocTag": "@param removeAllowed true if remove is allowed"
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException if the key is null and null keys are invalid"
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException if the key is null and null keys are invalid"
    },
    {
        "oracle": "map==null || keyTransformer==null || valueTransformer==null;",
        "javadocTag": "@throws NullPointerException if map or either of the transformers is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "(keyTransformer==null) == false;",
        "javadocTag": "@param keyTransformer the transformer to use for key conversion, must not be null"
    },
    {
        "oracle": "(valueTransformer==null) == false;",
        "javadocTag": "@param valueTransformer the transformer to use for value conversion, must not be null"
    },
    {
        "oracle": "map==null || keyTransformer==null || valueTransformer==null;",
        "javadocTag": "@throws NullPointerException if map or either of the transformers is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "(keyTransformer==null) == false;",
        "javadocTag": "@param keyTransformer the transformer to use for key conversion, must not be null"
    },
    {
        "oracle": "(valueTransformer==null) == false;",
        "javadocTag": "@param valueTransformer the transformer to use for value conversion, must not be null"
    },
    {
        "oracle": "true ? methodResultID.equals(map) : true;",
        "javadocTag": "@return the transformed object"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to wrap, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "transformer==null;",
        "javadocTag": "@throws NullPointerException if the transformer is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param j second variable index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the requested variance-covariance matrix entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters a double array with the regression slope estimates"
    },
    {
        "oracle": ";",
        "javadocTag": "@param varcov the variance covariance matrix, stored either in a square matrix\nor as a compressed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isSymmetricCompressed a flag which denotes that the variance covariance\nmatrix is in symmetric compressed format"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nobs the number of observations of the regression estimation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rank the number of independent variables in the regression"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sumy the sum of the independent variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sumysq the sum of the squared independent variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sse sum of squared errors"
    },
    {
        "oracle": ";",
        "javadocTag": "@param containsConstant true model has constant,  false model does not have constant"
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyData if true a deep copy of all input data is made, if false only references\nare copied and the RegressionResults become mutable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true regression has an intercept, false no intercept"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of observations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the array with regressor values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y the value of dependent variable given these regressors"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException if the length of {@code x} does not equal\nthe number of independent variables in the model"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x observations on the regressors"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y observations on the regressand"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException if {@code x} is not rectangular, does not match\nthe length of {@code y} or does not contain sufficient data to estimate the model"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x observations on the regressors"
    },
    {
        "oracle": ";",
        "javadocTag": "@param wi weight of the this observation (-1,1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yi observation on the regressand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a - an addend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b - an addend"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of the a and b"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nreq how many of the regressors to include (either in canonical\norder, or in the current reordered state)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array with the estimated slope coefficients"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException if {@code nreq} is less than 1\nor greater than the number of independent variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nreq how many of the regressors to include (either in canonical\norder, or in the current reordered state)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array with the variance covariance of the included\nregressors in lower triangular form"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rinv the storage for the inverse of r"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nreq how many of the regressors to include (either in canonical\norder, or in the current reordered state)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in how many of the regressors to include (either in canonical\norder, or in the current reordered state)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array with the partial correlations of the remainder of\nregressors with each other and the regressand, in lower triangular form"
    },
    {
        "oracle": ";",
        "javadocTag": "@param from initial position"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to destination"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list the regressors to move"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos1 where the list will be placed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return -1 error, 0 everything ok"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row_data returns the diagonal of the hat matrix for this observation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the diagonal element of the hatmatrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return int[] with the current order of the regressors"
    },
    {
        "oracle": ";",
        "javadocTag": "@return RegressionResults the structure holding all regression results"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException - thrown if number of observations is\nless than the number of variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfRegressors many of the regressors to include (either in canonical\norder, or in the current reordered state)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return RegressionResults the structure holding all regression results"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException - thrown if number of observations is\nless than the number of variables or number of regressors requested\nis greater than the regressors in the model"
    },
    {
        "oracle": ";",
        "javadocTag": "@param variablesToInclude array of variables to include in regression"
    },
    {
        "oracle": ";",
        "javadocTag": "@return RegressionResults the structure holding all regression results"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException - thrown if number of observations is\nless than the number of variables, the number of regressors requested\nis greater than the regressors in the model or a regressor index in\nregressor array does not exist"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfVariables number of regressors to expect, not including constant"
    },
    {
        "oracle": ";",
        "javadocTag": "@param includeConstant include a constant automatically"
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorTolerance zero tolerance, how machine zero is determined"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException if {@code numberOfVariables is less than 1}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfVariables maximum number of potential regressors"
    },
    {
        "oracle": ";",
        "javadocTag": "@param includeConstant include a constant automatically"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException if {@code numberOfVariables is less than 1}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y the [n,1] array representing the y sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the [n,k] array representing the x sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the x and y array data are not\n            compatible for the regression"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hat matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException unless method {@code newSampleData} has been\ncalled beforehand."
    },
    {
        "oracle": ";",
        "javadocTag": "@return SSTO - the total sum of squares"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the sample has not been set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return residual sum of squares"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.linear.SingularMatrixException if the design matrix is singular"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the data for the model have not been loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@return R-square statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the sample has not been set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.linear.SingularMatrixException if the design matrix is singular"
    },
    {
        "oracle": ";",
        "javadocTag": "@return adjusted R-Squared statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the sample has not been set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.linear.SingularMatrixException if the design matrix is singular"
    },
    {
        "oracle": ";",
        "javadocTag": "@return beta"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.linear.SingularMatrixException if the design matrix is singular"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the data for the model have not been loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The beta variance-covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.linear.SingularMatrixException if the design matrix is singular"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the data for the model have not been loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold the singularity threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The [k,1] array representing b"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The [k,k] array representing the variance of b"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The [n,1] array representing the residuals"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The double representing the variance of y"
    },
    {
        "oracle": ";",
        "javadocTag": "@return standard errors of estimated regression parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if <code>v</code> is not comparable with previous entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the table contains entries not\ncomparable to Long"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the table contains entries not\ncomparable to Long"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the table contains entries not\ncomparable to Char"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@param increment the amount by which the value should be incremented"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if <code>v</code> is not comparable with previous entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@param increment the amount by which the value should be incremented"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the corresponding map from row keys to values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return immutable set of column keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowKey key of row to search for in the table"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the corresponding map from column keys to values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return immutable set of row keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@return collection of values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if neither this range nor the domain has a lower bound, or if\n        neither has an upper bound"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedKeys the expected number of distinct keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multimap the multimap whose contents are copied to this multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to store in the multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to store in the multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialArraySize the exact size of the initial backing array for\n    the returned array list ({@code ArrayList} documentation calls this\n    value the \"capacity\")"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code ArrayList} which is guaranteed not to resize\n    itself unless its size reaches {@code initialArraySize + 1}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param estimatedSize an estimate of the eventual {@link List#size()} of\n    the new list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code ArrayList}, sized appropriately to hold the\n    estimated number of elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code CopyOnWriteArrayList}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the elements that the list should contain, in order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code CopyOnWriteArrayList} containing those elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param first the first element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rest an array of additional elements, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable list containing the specified elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param first the first element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param second the second element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rest an array of additional elements, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable list containing the specified elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lists the lists to choose elements from, in the order that\n    the elements chosen from those lists should appear in the resulting\n    lists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <B> any common base class shared by all axes (often just {@link\n    Object})"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Cartesian product, as an immutable list containing immutable\n    lists"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the size of the cartesian product would\n    be greater than {@link Integer#MAX_VALUE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lists the lists to choose elements from, in the order that\n    the elements chosen from those lists should appear in the resulting\n    lists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <B> any common base class shared by all axes (often just {@link\n    Object})"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Cartesian product, as an immutable list containing immutable\n    lists"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the size of the cartesian product would\n    be greater than {@link Integer#MAX_VALUE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list the list to return consecutive sublists of"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the desired size of each sublist (the last may be\n    smaller)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of consecutive sublists"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code partitionSize} is nonpositive"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence the character sequence to view as a {@code List} of\n       characters"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an {@code List<Character>} view of the character sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowComparator the comparator that orders the row keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnComparator the comparator that orders the column keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hash the hash code for the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the segment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedSize the expected number of entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multiset the multiset for which an unmodifiable view is to be\n    generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sortedMultiset the sorted multiset for which an unmodifiable view is\n    to be generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the element to be associated with the returned entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the count to be associated with the returned entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code multisetToModify} was changed as a result\n        of this operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code multisetToModify} was changed as a result of\n        this operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code multisetToModify} was changed as a result of\n        this operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowKey the row key to be associated with the returned cell"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnKey the column key to be associated with the returned cell"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to be associated with the returned cell"
    },
    {
        "oracle": ";",
        "javadocTag": "@param backingMap place to store the mapping from each row key to its\n    corresponding column key / value map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factory supplier of new, empty maps that will each hold all column\n    key / value mappings for a given row key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param table the table for which an unmodifiable view is to be returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the specified table"
    },
    {
        "oracle": ";",
        "javadocTag": "@param table the row-sorted table for which an unmodifiable view is to be returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the specified table"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reference any array of the desired type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the length of the new array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyType the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map whose mappings are to be placed in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if map is not an {@code EnumBiMap} or an\n    {@code EnumHashBiMap} instance and contains no mappings"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map place to store the mapping from each key to its corresponding\n    values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factory supplier of new, empty collections that will each hold all\n    values for a given key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map place to store the mapping from each key to its corresponding\n    values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factory supplier of new, empty lists that will each hold all values\n    for a given key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map place to store the mapping from each key to its corresponding\n    values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factory supplier of new, empty sets that will each hold all values\n    for a given key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map place to store the mapping from each key to its corresponding\n    values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factory supplier of new, empty sorted sets that will each hold\n    all values for a given key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source any multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest the multimap to copy into; usually empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multimap the multimap to be wrapped in a synchronized view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized view of the specified multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delegate the multimap for which an unmodifiable view is to be\n    returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the specified multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multimap the multimap to be wrapped"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized view of the specified multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delegate the multimap for which an unmodifiable view is to be\n    returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the specified multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multimap the multimap to be wrapped"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized view of the specified multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delegate the multimap for which an unmodifiable view is to be\n    returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the specified multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multimap the multimap to be wrapped"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized view of the specified multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delegate the multimap for which an unmodifiable view is to be\n    returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the specified multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection for which to return an unmodifiable view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entries the entries for which to return an unmodifiable view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the backing map for the returned multimap view"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients The coefficients of the constraint (left hand side)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relationship The type of (in)equality used in the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The value of the constraint (right hand side)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhsCoefficients The coefficients of the linear expression on the left hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhsConstant The constant term of the linear expression on the left hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relationship The type of (in)equality used in the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhsCoefficients The coefficients of the linear expression on the right hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhsConstant The constant term of the linear expression on the right hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhsCoefficients The coefficients of the linear expression on the left hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lhsConstant The constant term of the linear expression on the left hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relationship The type of (in)equality used in the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhsCoefficients The coefficients of the linear expression on the right hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rhsConstant The constant term of the linear expression on the right hand side of the constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tableau simple tableau for the problem"
    },
    {
        "oracle": ";",
        "javadocTag": "@return column with the most negative coefficient"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tableau simple tableau for the problem"
    },
    {
        "oracle": ";",
        "javadocTag": "@param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return row with the minimum ratio"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tableau simple tableau for the problem"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the maximal iteration count has been exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnboundedSolutionException if the model is found not to have a bounded solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tableau simple tableau for the problem"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the maximal iteration count has been exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnboundedSolutionException if the model is found not to have a bounded solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoFeasibleSolutionException if there is no feasible solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon the amount of error to accept for algorithm convergence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxUlps amount of error to accept in floating point comparisons"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations maximal number of function calls"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximal number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f linear objective function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraints linear constraints"
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param restrictToNonNegative whether to restrict the variables to non-negative values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return point/value pair giving the optimal value for objective function"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if no solution fulfilling the constraints\n  can be found in the allowed number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximize if true, goal is to maximize the objective function"
    },
    {
        "oracle": ";",
        "javadocTag": "@return created tableau"
    },
    {
        "oracle": ";",
        "javadocTag": "@param originalConstraints original (not normalized) constraints"
    },
    {
        "oracle": ";",
        "javadocTag": "@return new versions of the constraints"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint reference constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@return new equation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return 2 for Phase 1.  1 for Phase 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relationship relationship to count"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of constraint with the specified relationship"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients coefficients to sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the -1 times the sum of all coefficients in the given array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param col index of the column to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the row that the variable is basic in.  null if the column is not basic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param src the source array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest the destination array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the model has been solved"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dividendRow index of the row"
    },
    {
        "oracle": ";",
        "javadocTag": "@param divisor value of the divisor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minuendRow row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param subtrahendRow row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multiple multiplication factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return width of the tableau"
    },
    {
        "oracle": ";",
        "javadocTag": "@return height of the tableau"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param column column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return entry at (row, column)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param column column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value for the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the first slack variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the first artificial variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the right hand side"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of decision variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@return original number of decision variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of slack variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of artificial variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@return tableau data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param oos stream where object should be written"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be written to stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ois stream from which the object should be read"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if a class in the stream cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be read from the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f linear objective function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraints linear constraints"
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param restrictToNonNegative whether to restrict the variables to non-negative values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon amount of error to accept when checking for optimality"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f linear objective function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraints linear constraints"
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param restrictToNonNegative whether to restrict the variables to non-negative values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon amount of error to accept when checking for optimality"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxUlps amount of error to accept in floating point comparisons"
    },
    {
        "oracle": ";",
        "javadocTag": "@return coefficients of the linear equation being optimized"
    },
    {
        "oracle": ";",
        "javadocTag": "@return constant of the linear equation being optimized"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point at which linear equation must be evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value of the linear equation at the current point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point at which linear equation must be evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value of the linear equation at the current point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param oos stream where object should be written"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be written to stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ois stream from which the object should be read"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if a class in the stream cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the SemiVariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param direction the {@link Direction} of the semivariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the SemiVariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cutoff the reference point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the SemiVariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cutoff the reference point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param direction the {@link Direction} of the semivariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the SemiVariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cutoff the reference point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param direction the {@link Direction} of the semivariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param corrected the BiasCorrection flag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the SemiVariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of biasCorrected."
    },
    {
        "oracle": ";",
        "javadocTag": "@param biasCorrected new biasCorrected property value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the varianceDirection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param varianceDirection the direction of the semivariance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param biasCorrected setting for bias correction - true means\nbias will be corrected and is equivalent to using the argumentless\nconstructor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param direction setting for the direction of the SemiVariance\nto calculate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param corrected setting for bias correction - true means\nbias will be corrected and is equivalent to using the argumentless\nconstructor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param direction setting for the direction of the SemiVariance\nto calculate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code SemiVariance} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source FirstMoment to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest FirstMoment to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code FirstMoment} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the skewness of the available values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin the index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the skewness of the values or Double.NaN if length is less than\n3"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Skewness to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest Skewness to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m3 external moment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code Skewness} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the vector does not have the right dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@return mean vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of vectors in the sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension vectors dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Returns the max."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Returns the mean."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Returns the min."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Returns the number of values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Returns the sum."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Returns the standard deviation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Returns the variance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to test equality against."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if object equals this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@return String with line feeds displaying statistics"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean the sample mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param variance the sample variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the number of observations in the sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max the maximum value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param min the minimum value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sum the sum of the values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The mean or Double.NaN if no values have been added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The variance, Double.NaN if no values have been added\nor 0.0 for a single value set."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The standard deviation, Double.NaN if no values have been added\nor 0.0 for a single value set."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The max or Double.NaN if no values have been added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The min or Double.NaN if no values have been added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The number of available values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The sum or Double.NaN if no values have been added"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d the new value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values array holding the new values to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values array holding the new values to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the array index of the first value to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value of the statistic, <code>Double.NaN</code> if it\nhas been cleared or just instantiated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The dimension of the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component means"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The covariance, null if no multivariate sample\nhave been added or a zeroed matrix for a single value set."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component standard deviations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component maxima"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component minima"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The number of available values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component geometric means"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component sums"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component sums of squares"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component log sums"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of logs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the geometric mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The sum of squares"
    },
    {
        "oracle": ";",
        "javadocTag": "@return second central moment statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Current values of aggregate statistics"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code SummaryStatistics} whose data will be aggregated with\n     those of this {@code AggregateSummaryStatistics}.  The initial state\n     is a copy of the configured prototype statistics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param statistics collection of SummaryStatistics to aggregate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return summary statistics for the combined dataset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value any value in the range of the {@code byte} type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@code byte} value that equals {@code value}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code value} is greater than {@link\n    Byte#MAX_VALUE} or less than {@link Byte#MIN_VALUE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value any {@code long} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the same value cast to {@code byte} if it is in the range of the\n    {@code byte} type, {@link Byte#MAX_VALUE} if it is too large,\n    or {@link Byte#MIN_VALUE} if it is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is less than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is greater than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator the text that should appear between consecutive values in\n    the resulting string (but not at the start or end)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code byte} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value a primitive {@code double} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code for the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first {@code double} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second {@code double} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a negative value if {@code a} is less than {@code b}; a positive\n    value if {@code a} is greater than {@code b}; or zero if they are equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code double} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code double} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code array[i] == target} for some value of {@code\n    i}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code double} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code double} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the least index {@code i} for which {@code array[i] == target}, or\n    {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to search for the sequence {@code target}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target the array to search for as a sub-sequence of {@code array}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code double} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code double} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the greatest index {@code i} for which {@code array[i] == target},\n    or {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is less than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is greater than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arrays zero or more {@code double} arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a single array containing all the values from the source arrays, in\n    order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the source array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minLength the minimum length the returned array must guarantee"
    },
    {
        "oracle": ";",
        "javadocTag": "@param padding an extra amount to \"grow\" the array by if growth is\n    necessary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the values of {@code array}, with guaranteed\n    minimum length {@code minLength}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator the text that should appear between consecutive values in\n    the resulting string (but not at the start or end)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code double} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection a collection of {@code Number} instances"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the same values as {@code collection}, in the\n    same order, converted to primitives"
    },
    {
        "oracle": ";",
        "javadocTag": "@param backingArray the array to back the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list view of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the string representation of a {@code double} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the floating point value represented by {@code string}, or\n    {@code null} if {@code string} has a length of zero or cannot be\n    parsed as a {@code double} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value a primitive {@code byte} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code for the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code byte} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code byte} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code array[i] == target} for some value of {@code\n    i}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code byte} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code byte} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the least index {@code i} for which {@code array[i] == target}, or\n    {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to search for the sequence {@code target}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target the array to search for as a sub-sequence of {@code array}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code byte} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code byte} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the greatest index {@code i} for which {@code array[i] == target},\n    or {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param arrays zero or more {@code byte} arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a single array containing all the values from the source arrays, in\n    order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the source array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minLength the minimum length the returned array must guarantee"
    },
    {
        "oracle": ";",
        "javadocTag": "@param padding an extra amount to \"grow\" the array by if growth is\n    necessary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the values of {@code array}, with guaranteed\n    minimum length {@code minLength}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection a collection of {@code Number} instances"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the same values as {@code collection}, in the\n    same order, converted to primitives"
    },
    {
        "oracle": ";",
        "javadocTag": "@param backingArray the array to back the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list view of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first unsigned {@code int} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second unsigned {@code int} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is\n        greater than {@code b}; or zero if they are equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is less than or equal to every other value in\n        the array according to {@link #compare}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is greater than or equal to every other value\n        in the array according to {@link #compare}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator the text that should appear between consecutive values in the resulting\n       string (but not at the start or end)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of unsigned {@code int} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dividend the dividend (numerator)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param divisor the divisor (denominator)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dividend the dividend (numerator)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param divisor the divisor (denominator)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the string does not contain a valid unsigned {@code int} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the string does not contain a valid unsigned {@code int} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the string containing the unsigned integer representation to be parsed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param radix the radix to use while parsing {@code s}; must be between\n       {@link Character#MIN_RADIX} and {@link Character#MAX_RADIX}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the string does not contain a valid unsigned {@code int}, or\n        if supplied radix is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if {@code s} is null\n        (in contrast to {@link Integer#parseInt(String)})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value to convert to a string."
    },
    {
        "oracle": ";",
        "javadocTag": "@param radix the radix to use while working with {@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code radix} is not between {@link Character#MIN_RADIX}\n        and {@link Character#MAX_RADIX}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code value} is negative or {@code value >= 2^64}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the string does not contain a parsable unsigned {@code long}\n    value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the string does not contain a parsable unsigned {@code long}\n    value, or {@code radix} is not between {@link Character#MIN_RADIX} and\n    {@link Character#MAX_RADIX}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value a primitive {@code int} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code for the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value any value in the range of the {@code int} type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@code int} value that equals {@code value}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code value} is greater than {@link\n    Integer#MAX_VALUE} or less than {@link Integer#MIN_VALUE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value any {@code long} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the same value cast to {@code int} if it is in the range of the\n    {@code int} type, {@link Integer#MAX_VALUE} if it is too large,\n    or {@link Integer#MIN_VALUE} if it is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first {@code int} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second {@code int} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a negative value if {@code a} is less than {@code b}; a positive\n    value if {@code a} is greater than {@code b}; or zero if they are equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code int} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code int} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code array[i] == target} for some value of {@code\n    i}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputGraph The graph we listen at."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputGraph The graph we listen at."
    },
    {
        "oracle": ";",
        "javadocTag": "@param replayGraph If false, and if the input graph already contains element they\n           are not replayed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputGraph The graph we listen at."
    },
    {
        "oracle": ";",
        "javadocTag": "@param firstListener The initial listener to register."
    },
    {
        "oracle": ";",
        "javadocTag": "@param replayGraph If false, and if the input graph already contains element they\n           are not replayed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputGraph The graph we listen at."
    },
    {
        "oracle": ";",
        "javadocTag": "@param replayGraph If false, and if the input graph already contains element they\n           are not replayed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sharedMBox The message box used to send and receive graph messages across\n           the thread boundary."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The graph identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param step The step time stamp."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The graph identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param step The step time stamp."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The graph identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The graph identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId The edge identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fromNodeId The edge start node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toNodeId The edge end node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param directed Is the edge directed?."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId The edge identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fromNodeId The edge start node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toNodeId The edge end node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param directed Is the edge directed?."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId The edge identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId The edge identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId The edge identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The attribute value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId The edge identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The attribute value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId The edge identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldValue The old attribute value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue The new attribute value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId The edge identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldValue The old attribute value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue The new attribute value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId The edge identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId The edge identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The attribute value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The attribute value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldValue The attribute old value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue The attribute new value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldValue The attribute old value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue The attribute new value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The attribute value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The attribute value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Instance to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return available real vector format locales."
    },
    {
        "oracle": ";",
        "javadocTag": "@return format prefix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return format suffix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return format separator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return components format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default real vector format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale the specific locale used by the format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the real vector format specific to the given locale."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v RealVector object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a formatted vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector the object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source String to parse."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link RealVector} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathParseException if the beginning of the specified string\ncannot be parsed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source String to parse."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/ouput parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link RealVector} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for components."
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix prefix to use instead of the default \"{\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix suffix to use instead of the default \"}\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator separator to use instead of the default \"; \""
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix prefix to use instead of the default \"{\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix suffix to use instead of the default \"}\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator separator to use instead of the default \"; \""
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for components."
    },
    {
        "oracle": ";",
        "javadocTag": "@param cond An estimate of the condition number of the offending linear\noperator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code r != null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the iterative solver which fired this event"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterations the number of iterations performed at the time\n{@code this} event is created"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the current estimate of the solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the right-hand side vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r the current estimate of the residual (can be {@code null})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rnorm the norm of the current estimate of the residual"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the iterative solver which fired this event"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterations the number of iterations performed at the time\n{@code this} event is created"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the current estimate of the solution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the right-hand side vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rnorm the norm of the current estimate of the residual"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the right-hand side vector, b"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the norm of the residual, ||r||"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the updated residual, r"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the solution, x"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code false} if {@link #getResidual()} throws a\n{@link MathUnsupportedOperationException}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the iterative algorithm on which the event initially\noccurred"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterations the number of iterations performed at the time\n{@code this} event is created"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the requested dimensions are not equal."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this + m}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to be subtracted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this - m}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m matrix to postmultiply by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this * m}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if\n{@code columnDimension(this) != rowDimension(m)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m matrix to postmultiply by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this * m}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if\n{@code columnDimension(this) != rowDimension(m)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return 1-dimensional array of entries."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if {@code row != column} and value is non-zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if {@code row != column} and increment is non-zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if value is not zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse of {@code m}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if the matrix is singular"
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Singularity threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse of {@code m}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Singularity threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the matrix is singular, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension Number of rows and columns in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Data for the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Data for new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyArray if {@code true}, the input array will be copied,\notherwise it will be referenced."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the P matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transpose of the P matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the H matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the main diagonal elements of the B matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return root of the square matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return r of the square matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Symmetric positive semidefinite matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonPositiveDefiniteMatrixException if the matrix is not\npositive semidefinite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Symmetric positive semidefinite matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param small Diagonal elements threshold under which columns are\nconsidered to be dependent on previous ones and are discarded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonPositiveDefiniteMatrixException if the matrix is not\npositive semidefinite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows number of rows of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columns number of columns of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row row index of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param column column index of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value current value of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new value to be set for the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value that the <code>walkInXxxOrder</code> must return"
    },
    {
        "oracle": ";",
        "javadocTag": "@return capacity to use for the specified size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i input value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return smallest power of two greater than the input value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key associated with the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return data associated with the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if a value is associated with key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return iterator over the map elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hash initial hash"
    },
    {
        "oracle": ";",
        "javadocTag": "@return perturbed hash"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@return index at which key should be inserted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keys keys table"
    },
    {
        "oracle": ";",
        "javadocTag": "@param states states table"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mask bit mask for hash values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return index at which key should be inserted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param perturb perturbed hash"
    },
    {
        "oracle": ";",
        "javadocTag": "@param j previous probe"
    },
    {
        "oracle": ";",
        "javadocTag": "@return next probe"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index initial index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return changed index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of elements stored in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to which the value is associated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return removed value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if an element is associated with key at index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the element to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return removed value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to which value is associated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to put in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous value associated with the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if  tables should grow"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to hash"
    },
    {
        "oracle": ";",
        "javadocTag": "@return hash value of the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stream input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be read"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if the class corresponding\nto the serialized object cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length size of the array to build"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param missingEntries value to return when a missing entry is fetched"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedSize expected number of elements in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedSize expected number of elements in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param missingEntries value to return when a missing entry is fetched"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source map to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arr Array to scale."
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Scalar."
    },
    {
        "oracle": ";",
        "javadocTag": "@return scaled copy of array with each entry multiplied by val."
    },
    {
        "oracle": ";",
        "javadocTag": "@param arr Array to scale"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Scalar"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a First term of the addition."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Second term of the addition."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new array {@code r} where {@code r[i] = a[i] + b[i]}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths differ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a First term."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Element to be subtracted."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths differ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a First factor of the multiplication."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Second factor of the multiplication."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new array {@code r} where {@code r[i] = a[i] * b[i]}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths differ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Numerator of the division."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Denominator of the division."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new array {@code r} where {@code r[i] = a[i] / b[i]}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths differ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 the first point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 the second point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the L<sub>1</sub> distance between the two points"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths differ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 the first point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 the second point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the L<sub>1</sub> distance between the two points"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths differ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 the first point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 the second point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the L<sub>2</sub> distance between the two points"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths differ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 Cartesian coordinates of the first vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 Cartesian coordinates of the second vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cosine of the angle between the vectors."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 the first point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 the second point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the L<sub>2</sub> distance between the two points"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths differ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 the first point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 the second point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the L<sub>&infin;</sub> distance between the two points"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths differ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 the first point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 the second point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the L<sub>&infin;</sub> distance between the two points"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths differ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the elements in the specified array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dir Ordering direction."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an inverted bidirectional map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the factory creates"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the \"type\" of null object the factory should return."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the factory creates"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constantToReturn the constant object to return each time in the factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>constant</code> factory."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the factory creates"
    },
    {
        "oracle": ";",
        "javadocTag": "@param prototype the object to clone each time in the factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\nthe {@code prototype} is {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the prototype cannot be cloned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the factory creates"
    },
    {
        "oracle": ";",
        "javadocTag": "@param classToInstantiate the Class to instantiate each time in the factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>reflection</code> factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the factory creates"
    },
    {
        "oracle": ";",
        "javadocTag": "@param classToInstantiate the Class to instantiate each time in the factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@param paramTypes parameter types for the constructor, can be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the arguments to pass to the constructor, can be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>reflection</code> factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the paramTypes and args don't match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the constructor doesn't exist"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list the list, possibly <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an empty list if the argument is <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list the list, possibly {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an empty list if the argument is <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list1 the first list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list2 the second list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the intersection of those two lists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list1 the list to subtract from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list2 the list to subtract"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new list containing the results"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list1 the first list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list2 the second list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new list containing the sum of those lists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list1 the first list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list2 the second list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new list containing the union of those lists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the elements matching the predicate (new list)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the elements <b>not</b> matching the predicate (new list)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list1 the first list, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list2 the second list, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list the list to generate the hashCode for, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection whose contents are the target of the #retailAll operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param retain the collection containing the elements to be retained in the returned collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a <code>List</code> containing all the elements of <code>c</code>\nthat occur at least once in <code>retain</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection from which items are removed (in the returned collection)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param remove the items to be removed from the returned <code>collection</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a <code>List</code> containing all the elements of <code>c</code> except\nany elements that also occur in <code>remove</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized list backed by the given list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable list backed by the given list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a predicated list backed by the given list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a transformed list backed by the given list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a lazy list backed by the given list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a fixed-size list backed by that list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list the List to search, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first index of an Object in the List which matches the predicate or -1 if none could be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the longest common subsequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equator the equator used to test object equality"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the longest common subsequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the longest common subsequence as {@link String}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list the list to return consecutive sublists of"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the desired size of each sublist (the last may be smaller)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of consecutive sublists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input to execute on"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException (runtime) if the input is the wrong class"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException (runtime) if the input is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FunctorException (runtime) if any other error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a instance to multiply"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x a value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y a value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number to exponentiate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x power to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a<sup>x</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return base 10 logarithm of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y first argument of the arc tangent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x second argument of the arc tangent"
    },
    {
        "oracle": ";",
        "javadocTag": "@return atan2(y, x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return instance converted into degrees"
    },
    {
        "oracle": ";",
        "javadocTag": "@return instance converted into radians"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta parameters offsets (&Delta;x, &Delta;y, ...)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value of the Taylor expansion at x + &Delta;x, y + &Delta;y, ..."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f0 value of the function at (i.e. f({@link #getValue()}))"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f1 first derivative of the function at\nthe current point (i.e. f'({@link #getValue()}))"
    },
    {
        "oracle": ";",
        "javadocTag": "@return f(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Object to test for equality to this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if two sparse gradients are equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code value for this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value of the function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param derivatives derivatives map, a deep copy will be performed,\nso the map given here will remain safe from changes in the new instance,\nmay be null to create an empty derivatives map, i.e. a constant value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value of the function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale scaling factor to apply to all derivatives"
    },
    {
        "oracle": ";",
        "javadocTag": "@param derivatives derivatives map, a deep copy will be performed,\nso the map given here will remain safe from changes in the new instance,\nmay be null to create an empty derivatives map, i.e. a constant value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param function function to differentiate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return differential function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param function function to differentiate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return differential function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point at which the function must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the function value for the given point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if {@code point} does not\nsatisfy the function's constraints (wrong dimension, argument out of bound,\nor unsupported derivative order for example)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f underlying vector-valued function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f underlying real-valued function"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of free parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@return derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c value of the constant"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constant compatible with instance order and number of parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value part of the derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param orders derivation orders with respect to each variable (if all orders are 0,\nthe value is returned)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return partial derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the numbers of variables does not\nmatch the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if sum of derivation orders is larger\nthan the instance limits"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a fresh copy of partial derivatives, in an array sorted according to\n{@link DSCompiler#getPartialDerivativeIndex(int...)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@return exponent for instance in IEEE754 representation, without bias"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x a value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y a value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f array of value and derivatives of the function at\nthe current point (i.e. [f({@link #getValue()}),\nf'({@link #getValue()}), f''({@link #getValue()})...])."
    },
    {
        "oracle": ";",
        "javadocTag": "@return f(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the number of derivatives\nin the array is not equal to {@link #getOrder() order} + 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number to exponentiate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x power to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a<sup>x</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@return base 10 logarithm of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y first argument of the arc tangent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x second argument of the arc tangent"
    },
    {
        "oracle": ";",
        "javadocTag": "@return atan2(y, x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@return instance converted into degrees"
    },
    {
        "oracle": ";",
        "javadocTag": "@return instance converted into radians"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta parameters offsets (&Delta;x, &Delta;y, ...)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value of the Taylor expansion at x + &Delta;x, y + &Delta;y, ..."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if factorials becomes too large"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters\nor orders do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Object to test for equality to this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if two derivative structures are equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code value for this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return data transfer object that will be serialized"
    },
    {
        "oracle": ";",
        "javadocTag": "@param compiler compiler to use for computation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters number of free parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if order is too large"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters number of free parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value of the constant"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if order is too large"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters number of free parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the variable (from 0 to {@code parameters - 1})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value of the variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ds1 first base (unscaled) derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an error occurs while writing tothe stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an error occurs while reading from the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if an object read from the stream can not be loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a shallow clone"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InternalError if {@link AbstractMap#clone()} failed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code defined in the Map interface"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string version of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity, must be a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold the threshold, must be sensible"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new unmodifiable map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Map.Entry<K, V>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entrySet the entrySet to adapt"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new list ordered map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first key currently in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the last key currently in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to find previous for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next key, null if no match or at start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to find previous for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous key, null if no match or at start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index in the Map to start at."
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the Map containing the entries to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is out of range [0, size]"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fully modifiable collection view over the keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unmodifiable list view over the keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fully modifiable collection view over the values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the partially modifiable list view over the values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fully modifiable set view over the entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Map as a String"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the key at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the key at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to find the index of"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index, or -1 if not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index of the value to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the new value to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value at that index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index at which the mapping should be inserted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is out of range [0, size]"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index of the object to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the removed value, or <code>null</code> if none existed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The ordered list of keys."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a shallow clone"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the key at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to find the index of"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index, or -1 if not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index of the object to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value corresponding the <code>key</code>,\n or <code>null</code> if none existed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The ordered list of keys."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the new value to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the old value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return 1 always"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mapped value, null if no match"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size of 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to set, must be the key of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException when the given throwable is an IOException"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this method does not return; it always throws"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException when the given throwable is an IOException"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws X when the given throwable is of the declared type X"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this method does not return; it always throws"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException when the given throwable is an IOException"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws X1 when the given throwable is of the declared type X1"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws X2 when the given throwable is of the declared type X2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param patternStr the pattern string on which to filter file names"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws PatternSyntaxException if pattern compilation fails (runtime)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern the pattern on which to filter file names"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closeable the {@code Closeable} object to be closed, or null, in which case this method\n    does nothing"
    },
    {
        "oracle": ";",
        "javadocTag": "@param swallowIOException if true, don't propagate IO exceptions thrown by the {@code close}\n    methods"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputStream the input stream to be closed, or {@code null} in which case this method\n    does nothing"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reader the reader to be closed, or {@code null} in which case this method does nothing"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the input is not a valid encoded string according to this\n        encoding."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DecodingException if the input is not a valid encoded string according to this\n        encoding."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if this padding character is already used in the alphabet or a\n        separator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if this encoding already uses a separator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the alphabet used by this encoding contains mixed upper- and\n        lower-case characters"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the alphabet used by this encoding contains mixed upper- and\n        lower-case characters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cbuf the character buffer to process"
    },
    {
        "oracle": ";",
        "javadocTag": "@param off the offset into the buffer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len the number of characters to process"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line a line of text (possibly empty), without any line separators"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the line separator; one of {@code \"\\r\"}, {@code \"\\n\"},\n    {@code \"\\r\\n\"}, or {@code \"\"}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charset the charset used to decode the input stream; see {@link\n    Charsets} for helpful predefined constants"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the buffered reader"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to write to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charset the charset used to encode the output stream; see {@link\n    Charsets} for helpful predefined constants"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the buffered writer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a byte array containing all the bytes from file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the file is bigger than the largest\n    possible byte array (2^31 - 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charset the charset used to decode the input stream; see {@link\n    Charsets} for helpful predefined constants"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string containing all the characters from the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param from the bytes to write"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to the destination file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param from the source file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param from the source file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to the destination file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code from.equals(to)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param from the character sequence to write"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to the destination file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charset the charset used to encode the output stream; see {@link\n    Charsets} for helpful predefined constants"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param from the character sequence to append"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to the destination file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charset the charset used to encode the output stream; see {@link\n    Charsets} for helpful predefined constants"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param from the character sequence to append"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to the destination file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charset the charset used to encode the output stream; see {@link\n    Charsets} for helpful predefined constants"
    },
    {
        "oracle": ";",
        "javadocTag": "@param append true to append, false to overwrite"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param from the source file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charset the charset used to decode the input stream; see {@link\n    Charsets} for helpful predefined constants"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to the appendable object"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the newly-created directory"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the directory could not be created"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to create or update"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs, or if any necessary but\n    nonexistent parent directories of the specified file could not be\n    created."
    },
    {
        "oracle": ";",
        "javadocTag": "@param from the source file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to the destination file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code from.equals(to)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charset the charset used to decode the input stream; see {@link\n    Charsets} for helpful predefined constants"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first line, or null if the file is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charset the charset used to decode the input stream; see {@link\n    Charsets} for helpful predefined constants"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a mutable {@link List} containing all the lines"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to read from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charset the charset used to decode the input stream; see {@link\n    Charsets} for helpful predefined constants"
    },
    {
        "oracle": ";",
        "javadocTag": "@param callback the {@link LineProcessor} to use to handle the lines"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the output of processing the lines"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@param processor the object to which the bytes of the file are passed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the result of the byte processor"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashFunction the hash function to use to hash the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@link HashCode} of all of the bytes in the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p probability of success."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Probability of success."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the cumulative probability"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper a value satisfying {@code p <= cumulativeProbability(upper)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the smallest {@code p}-quantile of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param argument input value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cumulative probability"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathInternalError if the cumulative probability is {@code NaN}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the point at which the PMF is evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the logarithm of the value of the probability mass function at {@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mean for the distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Upper bound, inclusive."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distribution function value calculated using a normal\napproximation."
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (always 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (always {@code Integer.MAX_VALUE} for\npositive infinity)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param meanPoisson Mean of the Poisson distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next sample."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the Poisson mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Poisson mean."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon Convergence criterion for cumulative probabilities."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations for cumulative\nprobabilities."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Poisson mean."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon Convergence criterion for cumulative probabilities."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations for cumulative\nprobabilities."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Poisson mean."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon Convergence criterion for cumulative probabilities."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Poisson mean."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations Maximum number of iterations for cumulative\nprobabilities."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the two-sided probability of {@code P(D_n < d)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if algorithm fails to convert {@code h}\nto a {@link org.apache.commons.math3.fraction.BigFraction} in expressing\n{@code d} as {@code (k - h) / m} for integer {@code k, m} and\n{@code 0 <= h < 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the two-sided probability of {@code P(D_n < d)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if algorithm fails to convert {@code h}\nto a {@link org.apache.commons.math3.fraction.BigFraction} in expressing\n{@code d} as {@code (k - h) / m} for integer {@code k, m} and\n{@code 0 <= h < 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param exact whether the probability should be calculated exact using\n{@link org.apache.commons.math3.fraction.BigFraction} everywhere at the\nexpense of very slow execution time, or if {@code double} should be used\nconvenient places to gain speed. Almost never choose {@code true} in real\napplications unless you are very sure; {@code true} is almost solely for\nverification purposes."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the two-sided probability of {@code P(D_n < d)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if algorithm fails to convert {@code h}\nto a {@link org.apache.commons.math3.fraction.BigFraction} in expressing\n{@code d} as {@code (k - h) / m} for integer {@code k, m} and\n{@code 0 <= h < 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the two-sided probability of {@code P(D_n < d)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if algorithm fails to convert {@code h}\nto a {@link org.apache.commons.math3.fraction.BigFraction} in expressing\n{@code d} as {@code (k - h) / m} for integer {@code k, m} and\n{@code 0 <= h < 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the two-sided probability of {@code P(D_n < d)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if algorithm fails to convert {@code h}\nto a {@link org.apache.commons.math3.fraction.BigFraction} in expressing\n{@code d} as {@code (k - h) / m} for integer {@code k, m} and\n{@code 0 <= h < 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@return H matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if fractional part is greater than 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FractionConversionException if algorithm fails to convert\n{@code h} to a {@link org.apache.commons.math3.fraction.BigFraction} in\nexpressing {@code d} as {@code (k - h) / m} for integer {@code k, m} and\n{@code 0 <= h < 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of observations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the component distributions and associated weights."
    },
    {
        "oracle": ";",
        "javadocTag": "@param components List of (weight, distribution) pairs from which to sample."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param components Distributions from which to sample."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if any of the weights is negative."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if not all components have the same\nnumber of variables."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scale parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scale parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (always 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (always Double.POSITIVE_INFINITY)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Gamma(shape, scale) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape the shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale the scale parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape the shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale the scale parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy the maximum absolute error in inverse\ncumulative probability estimates (defaults to\n{@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape the shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale the scale parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape the shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale the scale parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy the maximum absolute error in inverse\ncumulative probability estimates (defaults to\n{@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param singletons values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param probabilities probabilities"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of value/probability pairs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the point at which the PMF is evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the probability mass function at point {@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code sum(singletons[i] * probabilities[i])}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code sum((singletons[i] - mean) ^ 2 * probabilities[i])}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lowest value with non-zero probability."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the highest value with non-zero probability."
    },
    {
        "oracle": ";",
        "javadocTag": "@param singletons array of random variable values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param probabilities array of probabilities."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if\n{@code singletons.length != probabilities.length}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if any of the probabilities are negative."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if any of the probabilities are infinite."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotANumberException if any of the probabilities are NaN."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException all of the probabilities are 0."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param singletons array of random variable values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param probabilities array of probabilities."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object the {@link Iterator} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the {@link Iterator} to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if every element of the collection matches the predicate or if the\n  collection is empty, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the {@link Iterator} to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the iterator is exhausted or null, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object the {@link Iterator} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to check, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the object is contained in the iterator, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object in the {@link Iterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to get a value from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to get"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to check, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of elements contained in the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to convert to a string, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of {@code iterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to convert to a string, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer used to get a string representation of an element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of {@code iterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to convert to a string, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer used to get a string representation of an element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delimiter the string to delimit elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix the prefix, prepended to the string representation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix the suffix, appended to the string representation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of {@code iterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the object type to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a comparator which uses natural order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the object type to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link ComparatorChain} formed from the input comparators"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the object type to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link ComparatorChain} formed from the input comparators"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the comparators collection contains the wrong object type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the object type to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator to reverse"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a comparator that reverses the order of the input comparator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param trueFirst when <code>true</code>, sort\n       <code>true</code> {@link Boolean}s before\n       <code>false</code> {@link Boolean}s."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a comparator that sorts booleans"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the object type to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator that wants to allow nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a version of that comparator that allows nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the object type to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator that wants to allow nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a version of that comparator that allows nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input object type of the transformed comparator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the object type of the decorated comparator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the sort order to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a comparator that transforms its input objects before comparing them"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the object type to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o1 the first object to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o2 the second object to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the sort order to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the smaller of the two objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the object type to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o1 the first object to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o2 the second object to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the sort order to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the larger of the two objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@param msg the error message."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rootCause the exception or error that caused this exception\n                  to be thrown."
    },
    {
        "oracle": ";",
        "javadocTag": "@param msg the error message."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rootCause the exception or error that caused this exception\n                  to be thrown."
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalMap the normal direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reverseMap the reverse direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseMap this map, which is the inverse in the new map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the keySet view"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the keySet iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the values view"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the values iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entrySet view"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entrySet iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalMap the normal direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reverseMap the reverse direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalMap the normal direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reverseMap the reverse direction map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseBidiMap the inverse BidiMap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable BidiMap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable OrderedBidiMap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an inverted unmodifiable bidirectional map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 the first value to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 the first value to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if a1 and a2 are set equivalent, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param smaller the possibly-smaller subset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bigger the possibly-larger set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if smaller is a subset (each element of smaller is\nalso a element of bigger) of bigger, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel_diff the relative diff to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the condition for modification was met. This\n    implies that the multiset was indeed modified, unless\n    {@code oldCount == newCount}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a view of the set of distinct elements in this multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set of entries representing the data of this multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to check for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if this multiset contains at least one occurrence of\n    the element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the collection of elements to be checked for containment in\n    this multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if this multiset contains at least one occurrence of\n    each element contained in {@code elements}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to add one occurrence of; may be null only if\n    explicitly allowed by the implementation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} always, since this call is required to modify the\n    multiset, unlike other {@link Collection} types"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@link Integer#MAX_VALUE} occurrences\n    of {@code element} are already contained in this multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to remove one occurrence of"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if an occurrence was found and removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value previously associated with this class (possibly {@code\n    null}), or {@code null} if there was no previous entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the call would result in more than\n    {@link Integer#MAX_VALUE} occurrences of {@code element} in this\n    multiset."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to store in the multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to store in the multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the method increased the size of the multimap, or\n    {@code false} if the multimap already contained the key-value pair"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map place to store the mapping from each key to its corresponding\n    values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedSize the number of elements you expect to add to the\n       returned set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code HashSet} with enough capacity to hold {@code\n        expectedSize} elements without resizing"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty thread-safe {@code Set}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the elements that the set should contain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new thread-safe set containing those elements (minus duplicates)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code LinkedHashSet}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedSize the number of elements you expect to add to the\n       returned set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code LinkedHashSet} with enough capacity to hold\n        {@code expectedSize} elements without resizing"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the elements that the set should contain, in order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code LinkedHashSet} containing those elements (minus\n    duplicates)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code TreeSet}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the elements that the set should contain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code TreeSet} containing those elements (minus duplicates)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator to use to sort the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code TreeSet}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code CopyOnWriteArraySet}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the elements that the set should contain, in order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code CopyOnWriteArraySet} containing those elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection whose complement should be stored in the\n    enum set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, modifiable {@code EnumSet} containing all values of the enum\n    that aren't present in the given collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code collection} is not an\n    {@code EnumSet} instance and contains no elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection whose complement should be stored in the\n    {@code EnumSet}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of the elements in the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, modifiable {@code EnumSet} initially containing all the\n    values of the enum not present in the given collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the backing map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the set backed by the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sets the sets to choose elements from, in the order that\n    the elements chosen from those sets should appear in the resulting\n    lists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <B> any common base class shared by all axes (often just {@link\n    Object})"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Cartesian product, as an immutable set containing immutable\n    lists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sets the sets to choose elements from, in the order that\n    the elements chosen from those sets should appear in the resulting\n    lists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <B> any common base class shared by all axes (often just {@link\n    Object})"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Cartesian product, as an immutable set containing immutable\n    lists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set the set of elements to construct a power set from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the power set, as an immutable set of immutable sets"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code set} has more than 30 unique\n    elements (causing the power set size to exceed the {@code int} range)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set the navigable set for which an unmodifiable view is to be\n       returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the specified navigable set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param navigableSet the navigable set to be \"wrapped\" in a synchronized\n   navigable set."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized view of the specified navigable set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint that validates added entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the specified map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multimap the multimap to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint that validates added entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multimap the multimap to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint that validates added entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the specified multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multimap the multimap to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint that validates added entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the specified multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multimap the multimap to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint that validates added entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the specified multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint for the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the specified entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the {@code asMap} entry to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint for the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the specified entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entries the entries to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint for the entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entries the entries to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint for the entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the specified entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entries the entries to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint for the entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the specified entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the bimap to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint that validates added entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the specified bimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedRows the expected number of distinct row keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedCellsPerRow the expected number of column key / value\n    mappings in each row"
    },
    {
        "oracle": ";",
        "javadocTag": "@param table the table to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any of the row keys, column keys, or values\n    in {@code table} is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param removeFrom the iterable to (potentially) remove elements from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elementsToRemove the elements to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if any element was removed from {@code iterable}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param removeFrom the iterable to (potentially) remove elements from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elementsToRetain the elements to retain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if any element was removed from {@code iterable}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if a value transformer is in use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mutator the MapMutator to be used for mutation delegation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the Map to be added to the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if there is a key collision and there is no\n        MapMutator set to handle it."
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the Map to be removed from the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The removed Map or <code>null</code> if map is not in the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if any of the composited Maps do not support clear()"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key whose presence in this map is to be tested."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if this map contains a mapping for the specified\n        key."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the key is of an inappropriate type for\n        this map (optional)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value whose presence in this map is to be tested."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if this map maps one or more keys to the\n        specified value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the value is of an inappropriate type for\n        this map (optional)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set view of the mappings contained in this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key whose associated value is to be returned."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the key is of an inappropriate type for\n        this map (optional)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if this map contains no key-value mappings."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set view of the keys contained in this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key with which the specified value is to be associated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to be associated with the specified key."
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous value associated with specified key, or {@code null}\n        if there was no mapping for key.  A {@code null} return can\n        also indicate that the map previously associated {@code null}\n        with the specified key, if the implementation supports\n        {@code null} values."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if no MapMutator has been specified"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the class of the specified key or value\n           prevents it from being stored in this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if some aspect of this key or value\n           prevents it from being stored in this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException this map does not permit {@code null}\n           keys or values, and the specified key or value is\n           {@code null}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param map Mappings to be stored in this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the {@code putAll} method is\n        not supported by this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the class of a key or value in the\n        specified map prevents it from being stored in this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException some aspect of a key or value in the\n        specified map prevents it from being stored in this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key whose mapping is to be removed from the map."
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous value associated with specified key, or {@code null}\n        if there was no mapping for key."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the key is of an inappropriate type for\n        the composited map (optional)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the {@code remove} method is\n        not supported by the composited map containing the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of key-value mappings in this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a collection view of the values contained in this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the maps are equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param one the first Map to be composited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param two the second Map to be composited"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if there is a key collision"
    },
    {
        "oracle": ";",
        "javadocTag": "@param one the first Map to be composited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param two the second Map to be composited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mutator MapMutator to be used for mutation operations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param composite the Maps to be composited"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if there is a key collision"
    },
    {
        "oracle": ";",
        "javadocTag": "@param composite Maps to be composited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mutator MapMutator to be used for mutation operations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key for the entry, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value for the entry, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the entry is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the individual keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the key at the index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size of the list of keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other the other object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a debugging string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keys the keys to calculate the hash code for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the instance with recalculated hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key5 the fifth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key for the entry, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value for the entry, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the entry is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the new key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the old key"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if key is this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the old value of the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if value is this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a MapEntry instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal key and value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a suitable hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key for the entry, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value for the entry, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the entry is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columns number of columns of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row row index of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param column column index of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value current value of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new value to be set for the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value that the <code>walkInXxxOrder</code> must return"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the L matrix (or null if decomposed matrix is singular)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the U matrix (or null if decomposed matrix is singular)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the P rows permutation matrix (or null if decomposed matrix is singular)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the pivot permutation vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return determinant of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a solver"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix The matrix to decompose."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the row index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the column index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the absolute positivity threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Value that fails the positivity check."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Row (and column) index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Absolute positivity threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@return available real vector format locales."
    },
    {
        "oracle": ";",
        "javadocTag": "@return format prefix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return format suffix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return format prefix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return format suffix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return format separator for rows."
    },
    {
        "oracle": ";",
        "javadocTag": "@return format separator between components."
    },
    {
        "oracle": ";",
        "javadocTag": "@return components format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default real vector format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale the specific locale used by the format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the real vector format specific to the given locale."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m RealMatrix object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a formatted matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix the object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source String to parse."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link RealMatrix} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathParseException if the beginning of the specified string\ncannot be parsed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source String to parse."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/ouput parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link RealMatrix} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for components."
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix prefix to use instead of the default \"{\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix suffix to use instead of the default \"}\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowPrefix row prefix to use instead of the default \"{\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowSuffix row suffix to use instead of the default \"}\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowSeparator tow separator to use instead of the default \";\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnSeparator column separator to use instead of the default \", \""
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix prefix to use instead of the default \"{\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix suffix to use instead of the default \"}\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowPrefix row prefix to use instead of the default \"{\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowSuffix row suffix to use instead of the default \"}\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowSeparator tow separator to use instead of the default \";\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnSeparator column separator to use instead of the default \", \""
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for components."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows number of rows of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columns number of columns of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return RealMatrix with specified dimensions"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the matrix elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows number of rows of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columns number of columns of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return FieldMatrix with specified dimensions"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return RealMatrix containing the values of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if {@code data} is not rectangular (not all rows have the same length)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if a row or column is empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code data} is not rectangular."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a matrix containing the values of the array."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if {@code data} is not rectangular (not all rows have the same length)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if a row or column is empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension dimension of identity matrix to generate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return identity matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension dimension of identity matrix to generate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return identity matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param diagonal diagonal elements of the matrix (the array elements\nwill be copied)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return diagonal matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param diagonal diagonal elements of the matrix (the array elements\nwill be copied)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return diagonal matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data the input data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a data.length RealVector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data the input data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a data.length FieldVector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if {@code data} has 0 elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowData the input row data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a 1 x rowData.length RealMatrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowData the input row data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a 1 x rowData.length FieldMatrix"
    },
    {
        "oracle": "min>=max;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if {@code min >= max}."
    },
    {
        "oracle": "chromosomes==null;",
        "javadocTag": "@throws NullArgumentException if the list of chromosomes is {@code null}"
    },
    {
        "oracle": "chromosomes==null;",
        "javadocTag": "@throws NullArgumentException if the list of chromosomes is {@code null}"
    },
    {
        "oracle": "this.getNorm()==0;",
        "javadocTag": "@throws MathArithmeticException if the norm is zero"
    },
    {
        "oracle": "pivotingStrategy==null;",
        "javadocTag": "@throws NullArgumentException when pivotingStrategy is null"
    },
    {
        "oracle": "xval.length==0;",
        "javadocTag": "@throws NoDataException if there an array has zero-length."
    },
    {
        "oracle": "xval==null;",
        "javadocTag": "@throws NullArgumentException if an argument is {@code null}."
    },
    {
        "oracle": "abs<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code abs <= 0}."
    },
    {
        "oracle": "abs<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code abs <= 0}."
    },
    {
        "oracle": "xval.length==0 || yval.length==0 || zval.length==0 || fval.length==0;",
        "javadocTag": "@throws NoDataException if any of the arrays has zero length."
    },
    {
        "oracle": "eps<0.0 || minPts<0;",
        "javadocTag": "@throws NotPositiveException if {@code eps < 0.0} or {@code minPts < 0}"
    },
    {
        "oracle": "points==null;",
        "javadocTag": "@throws NullArgumentException if the data points are null"
    },
    {
        "oracle": "maxTime<0;",
        "javadocTag": "@throws NumberIsTooSmallException if the provided time is &lt; 0"
    },
    {
        "oracle": "maxTime<0;",
        "javadocTag": "@throws NumberIsTooSmallException if the provided time is &lt; 0"
    },
    {
        "oracle": "n<2 ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return true if n is prime. (All numbers &lt; 2 return false)."
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws MathIllegalArgumentException if n &lt; 0."
    },
    {
        "oracle": "n>0;",
        "javadocTag": "@param n a positive number."
    },
    {
        "oracle": "true ? methodResultID>=n : true;",
        "javadocTag": "@return the smallest prime greater than or equal to n."
    },
    {
        "oracle": "n<2;",
        "javadocTag": "@throws MathIllegalArgumentException if n &lt; 2."
    },
    {
        "oracle": "n>=2;",
        "javadocTag": "@param n number to factorize: must be &ge; 2"
    },
    {
        "oracle": "x.length<3;",
        "javadocTag": "@throws NumberIsTooSmallException if the size of {@code x} is smaller\nthan 3."
    },
    {
        "oracle": "isLast==true;",
        "javadocTag": "@param isLast true if the step is the last one"
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "isLast==true;",
        "javadocTag": "@param isLast true if the step is the last one"
    },
    {
        "oracle": "scale<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code scale <= 0}."
    },
    {
        "oracle": "scale<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code scale <= 0}."
    },
    {
        "oracle": "scale<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code scale <= 0}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "numberOfSuccesses<0;",
        "javadocTag": "@throws NotPositiveException if {@code numberOfSuccesses < 0}."
    },
    {
        "oracle": "populationSize<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code populationSize <= 0}."
    },
    {
        "oracle": "numberOfSuccesses>populationSize || sampleSize>populationSize;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code numberOfSuccesses > populationSize},\nor {@code sampleSize > populationSize}."
    },
    {
        "oracle": "numberOfSuccesses<0;",
        "javadocTag": "@throws NotPositiveException if {@code numberOfSuccesses < 0}."
    },
    {
        "oracle": "populationSize<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code populationSize <= 0}."
    },
    {
        "oracle": "numberOfSuccesses>populationSize || sampleSize>populationSize;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code numberOfSuccesses > populationSize},\nor {@code sampleSize > populationSize}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "numberOfTrials<0 || numberOfSuccesses<0;",
        "javadocTag": "@throws NotPositiveException if {@code numberOfTrials} or {@code numberOfSuccesses} is negative"
    },
    {
        "oracle": "(probability==0) == false;",
        "javadocTag": "@throws OutOfRangeException if {@code probability} is not between 0 and 1"
    },
    {
        "oracle": "numberOfTrials<numberOfSuccesses || alternativeHypothesis==null;",
        "javadocTag": "@throws MathIllegalArgumentException if {@code numberOfTrials} &lt; {@code numberOfSuccesses} or\nif {@code alternateHypothesis} is null."
    },
    {
        "oracle": "numberOfTrials<0 || numberOfSuccesses<0;",
        "javadocTag": "@throws NotPositiveException if {@code numberOfTrials} or {@code numberOfSuccesses} is negative"
    },
    {
        "oracle": "(probability==0) == false;",
        "javadocTag": "@throws OutOfRangeException if {@code probability} is not between 0 and 1"
    },
    {
        "oracle": "numberOfTrials<numberOfSuccesses || alternativeHypothesis==null;",
        "javadocTag": "@throws MathIllegalArgumentException if {@code numberOfTrials} &lt; {@code numberOfSuccesses} or\nif {@code alternateHypothesis} is null."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "v==null;",
        "javadocTag": "@throws NullArgumentException if {@code v} is {@code null}."
    },
    {
        "oracle": "v==null;",
        "javadocTag": "@throws NullArgumentException if {@code v} is {@code null}."
    },
    {
        "oracle": "isLast==true;",
        "javadocTag": "@param isLast true if the step is the last one"
    },
    {
        "oracle": "imaginaryFormat==null;",
        "javadocTag": "@throws NullArgumentException if {@code imaginaryFormat} is {@code null}."
    },
    {
        "oracle": "realFormat==null;",
        "javadocTag": "@throws NullArgumentException if {@code realFormat} is {@code null}."
    },
    {
        "oracle": "imaginaryCharacter==null;",
        "javadocTag": "@throws NullArgumentException if {@code imaginaryCharacter} is\n{@code null}."
    },
    {
        "oracle": "imaginaryCharacter==null;",
        "javadocTag": "@throws NullArgumentException if {@code imaginaryCharacter} is\n{@code null}."
    },
    {
        "oracle": "format==null;",
        "javadocTag": "@throws NullArgumentException if {@code format} is {@code null}."
    },
    {
        "oracle": "imaginaryCharacter==null;",
        "javadocTag": "@throws NullArgumentException if {@code imaginaryCharacter} is\n{@code null}."
    },
    {
        "oracle": "imaginaryFormat==null;",
        "javadocTag": "@throws NullArgumentException if {@code imaginaryFormat} is {@code null}."
    },
    {
        "oracle": "realFormat==null;",
        "javadocTag": "@throws NullArgumentException if {@code realFormat} is {@code null}."
    },
    {
        "oracle": "imaginaryCharacter==null;",
        "javadocTag": "@throws NullArgumentException if {@code imaginaryCharacter} is\n{@code null}."
    },
    {
        "oracle": "numeratorDegreesOfFreedom<=0 || denominatorDegreesOfFreedom<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if\n{@code numeratorDegreesOfFreedom <= 0} or\n{@code denominatorDegreesOfFreedom <= 0}."
    },
    {
        "oracle": "numeratorDegreesOfFreedom<=0 || denominatorDegreesOfFreedom<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if\n{@code numeratorDegreesOfFreedom <= 0} or\n{@code denominatorDegreesOfFreedom <= 0}."
    },
    {
        "oracle": "numeratorDegreesOfFreedom<=0 || denominatorDegreesOfFreedom<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code numeratorDegreesOfFreedom <= 0} or\n{@code denominatorDegreesOfFreedom <= 0}."
    },
    {
        "oracle": "numeratorDegreesOfFreedom<=0 || denominatorDegreesOfFreedom<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code numeratorDegreesOfFreedom <= 0} or\n{@code denominatorDegreesOfFreedom <= 0}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "(rowDimension>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if the row or column dimension is\nnot positive."
    },
    {
        "oracle": "d.length==0;",
        "javadocTag": "@throws NoDataException if {@code d} row or column dimension is zero."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "d.length==0;",
        "javadocTag": "@throws NoDataException if {@code d} row or column dimension is zero."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the index"
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "length==0 ? methodResultID==0 : true;",
        "javadocTag": "@return the sum of the values or 0 if length = 0"
    },
    {
        "oracle": "length==0 ? methodResultID==0 : true;",
        "javadocTag": "@return the sum of the values or 0 if length = 0"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "xval.length==0 || yval.length==0 || fval.length==0;",
        "javadocTag": "@throws NoDataException if any of the arrays has zero length."
    },
    {
        "oracle": "theta==0;",
        "javadocTag": "@param theta normalized interpolation abscissa within the step\n(theta is zero at the previous time step and one at the current time step)"
    },
    {
        "oracle": "true ? methodResultID==x+y : true;",
        "javadocTag": "@return the sum {@code x+y}"
    },
    {
        "oracle": "true ? methodResultID==a+b : true;",
        "javadocTag": "@return the sum {@code a+b}"
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "k>n;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code k > n}."
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "k>n;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code k > n}."
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "k>n;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code k > n}."
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "n>20;",
        "javadocTag": "@throws MathArithmeticException if {@code n > 20}: The factorial value is too\nlarge to fit in a {@code long}."
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "true ? methodResultID==x*y : true;",
        "javadocTag": "@return the product {@code x * y}."
    },
    {
        "oracle": "true ? methodResultID==a*b : true;",
        "javadocTag": "@return the product {@code a * b}."
    },
    {
        "oracle": "true ? methodResultID==x-y : true;",
        "javadocTag": "@return the difference {@code x - y}."
    },
    {
        "oracle": "true ? methodResultID==a-b : true;",
        "javadocTag": "@return the difference {@code a - b}."
    },
    {
        "oracle": "e<0;",
        "javadocTag": "@throws NotPositiveException if {@code e < 0}."
    },
    {
        "oracle": "e>0 || e==0;",
        "javadocTag": "@param e Exponent (must be positive or zero)."
    },
    {
        "oracle": "e<0;",
        "javadocTag": "@throws NotPositiveException if {@code e < 0}."
    },
    {
        "oracle": "e>0 || e==0;",
        "javadocTag": "@param e Exponent (must be positive or zero)."
    },
    {
        "oracle": "e<0;",
        "javadocTag": "@throws NotPositiveException if {@code e < 0}."
    },
    {
        "oracle": "e>0 || e==0;",
        "javadocTag": "@param e Exponent (must be positive or zero)."
    },
    {
        "oracle": "e<0;",
        "javadocTag": "@throws NotPositiveException if {@code e < 0}."
    },
    {
        "oracle": "e>0 || e==0;",
        "javadocTag": "@param e Exponent (must be positive or zero)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rho Reflection coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sigma Shrinkage coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param steps Steps along the canonical axes representing box edges.\nThey may be negative but not zero. See"
    },
    {
        "oracle": ";",
        "javadocTag": "@param steps Steps along the canonical axes representing box edges.\nThey may be negative but not zero. See\n{@link AbstractSimplex#AbstractSimplex(double[])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rho Reflection coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sigma Shrinkage coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param referenceSimplex Reference simplex. See\n{@link AbstractSimplex#AbstractSimplex(double[][])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param referenceSimplex Reference simplex. See\n{@link AbstractSimplex#AbstractSimplex(double[][])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rho Reflection coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sigma Shrinkage coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if the reference simplex does not contain at least one point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if there is a dimension mismatch in the reference simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point unbounded value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return bounded value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point bounded value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return unbounded value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point unbounded value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return underlying function value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bounded bounded function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower lower bounds for each element of the input parameters array\n(some elements may be set to {@code Double.NEGATIVE_INFINITY} for\nunbounded values)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper upper bounds for each element of the input parameters array\n(some elements may be set to {@code Double.POSITIVE_INFINITY} for\nunbounded values)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if lower and upper bounds are not\nconsistent, either according to dimension or to values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point at which the objective function must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective function value at the specified point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of evaluations is\nexceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Allowed number of evaluations of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link Target}</li>\n <li>{@link Weight}</li>\n <li>{@link InitialGuess}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value of the objective\nfunction."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the initial guess, target, and weight\narguments have inconsistent dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param t Target value for the objective functions at optimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param w Weights for the least squares cost computation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startPoint Start point for optimization."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value for objective\nfunction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Allowed number of evaluations of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link Target}</li>\n <li>{@link Weight}</li>\n <li>{@link InitialGuess}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value of the objective\nfunction."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the initial guess, target, and weight\narguments have inconsistent dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the weight matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the target values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective vector function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value for the\nobjective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to the {@link #target array}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to the {@link #weight array}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link Target}</li>\n <li>{@link Weight}</li>\n <li>{@link InitialGuess}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@link #target} and\n{@link #weightMatrix} have inconsistent dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@return History of sigma values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return History of mean matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return History of fitness values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return History of D matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Allowed number of evaluations of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType Optimization type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link org.apache.commons.math3.optimization.InitialGuess InitialGuess}</li>\n <li>{@link Sigma}</li>\n <li>{@link PopulationSize}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value for objective\nfunction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link Sigma}</li>\n <li>{@link PopulationSize}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param guess Initial guess for the arguments of the fitness function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param zmean Weighted row matrix of the gaussian random numbers generating\nthe current offspring."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xold xmean matrix of the previous generation."
    },
    {
        "oracle": ";",
        "javadocTag": "@return hsig flag indicating a small correction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hsig Flag indicating a small correction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param bestArz Fitness-sorted matrix of the gaussian random values of the\ncurrent offspring."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hsig Flag indicating a small correction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param bestArx Fitness-sorted matrix of the argument vectors producing the\ncurrent offspring."
    },
    {
        "oracle": ";",
        "javadocTag": "@param arz Unsorted matrix containing the gaussian random values of the\ncurrent offspring."
    },
    {
        "oracle": ";",
        "javadocTag": "@param arindex Indices indicating the fitness-order of the current offspring."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xold xmean matrix of the previous generation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param negccov Negative covariance factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vals History queue."
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Current best fitness value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param doubles Array of values to be sorted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a sorted array of indices pointing into doubles."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Matrix representing the element-wise logarithm of m."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Matrix representing the element-wise square root of m."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Matrix representing the element-wise square of m."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Input matrix 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the matrix where the elements of m and n are element-wise multiplied."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Input matrix 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Matrix where the elements of m and n are element-wise divided."
    },
    {
        "oracle": ";",
        "javadocTag": "@return sin(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return tan(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return acos(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return asin(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return atan(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x second argument of the arc tangent"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters or orders are inconsistent"
    },
    {
        "oracle": ";",
        "javadocTag": "@return cosh(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sinh(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return tanh(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return acosh(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return asin(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return atanh(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Factors."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Factors."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions don't match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Factors."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Factors."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions don't match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b1 second factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 first factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b2 second factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a<sub>1</sub>&times;b<sub>1</sub> +\na<sub>2</sub>&times;b<sub>2</sub>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b1 second factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 first factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b2 second factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a<sub>1</sub>&times;b<sub>1</sub> +\na<sub>2</sub>&times;b<sub>2</sub>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b1 second factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 first factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b2 second factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 first factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b3 second factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a<sub>1</sub>&times;b<sub>1</sub> +\na<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b1 second factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 first factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b2 second factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 first factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b3 second factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a<sub>1</sub>&times;b<sub>1</sub> +\na<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b1 second factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 first factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b2 second factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 first factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b3 second factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a4 first factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b4 second factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a<sub>1</sub>&times;b<sub>1</sub> +\na<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\na<sub>4</sub>&times;b<sub>4</sub>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b1 second factor of the first term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 first factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b2 second factor of the second term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 first factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b3 second factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a4 first factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b4 second factor of the third term"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a<sub>1</sub>&times;b<sub>1</sub> +\na<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\na<sub>4</sub>&times;b<sub>4</sub>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number to test."
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of prime factors of n"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factors the list where to add the factors."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the part of n which remains to be factored, it is either a prime or a semi-prime"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxFactor the upper bound of trial division: if it is reached, the method gives up and returns n."
    },
    {
        "oracle": ";",
        "javadocTag": "@param factors the list where to add the factors."
    },
    {
        "oracle": ";",
        "javadocTag": "@return n or 1 if factorization is completed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the number to factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of prime factors of n"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number to test: an odd integer &ge; 3"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if n is prime. false if n is definitely composite."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of prime factors of n."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number to factor, must be semi-prime."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a prime factor of n."
    },
    {
        "oracle": ";",
        "javadocTag": "@return gcd(a,b)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x abscissa of the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y observed value of the point at x, after fitting we should\nhave f(x) as close as possible to this value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight weight of the observed point in the fit"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x abscissa of the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y observed value of the point at x, after fitting we should\nhave f(x) as close as possible to this value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed observed point to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return observed points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f parametric function to fit."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialGuess first guess of the function parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fitted parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f parametric function to fit."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialGuess first guess of the function parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fitted parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the number of allowed evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Optimizer to use for the fitting."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a curve fitter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newStart new start point (initial guess)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newMaxIter maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param method "
    },
    {
        "oracle": ";",
        "javadocTag": "@param str "
    },
    {
        "oracle": ";",
        "javadocTag": "@param g1 GraphOrdering on first graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g2 GraphOrdering on second graph (possible subgraph)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexComparator comparator for semantic equality of vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeComparator comparator for semantic equality of edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are graph isomorphic to the already matched vertices\nof graph2 and the second one vertex of nextPair."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph1 the first graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph2 the second graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexComparator comparator for semantic equivalence of vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeComparator comparator for semantic equivalence of edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cacheEdges if true, edges get cached for faster access"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are subgraph isomorphic to the already matched\nvertices of graph2 and the second one vertex of nextPair."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph1 the first graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph2 the second graph (possible subgraph of graph1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexComparator comparator for semantic equivalence of vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeComparator comparator for semantic equivalence of edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cacheEdges if true, edges get cached for faster access"
    },
    {
        "oracle": ";",
        "javadocTag": "@return returns the number of vertices in the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexNumber the number which identifies the vertex v in this\norder."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the identifying numbers of all vertices which are connected to v\nby an edge outgoing from v."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexNumber the number which identifies the vertex v in this\norder."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the identifying numbers of all vertices which are connected to v\nby an edge incoming to v."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1Number the number of the first vertex v1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2Number the number of the second vertex v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return exists the edge from v1 to v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexNumber the number identifying the vertex v"
    },
    {
        "oracle": ";",
        "javadocTag": "@return v"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1Number the number identifying the vertex v1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2Number the number identifying the vertex v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the edge from v1 to v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the graph to be ordered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param orderByDegree should the vertices be ordered by their degree. This\nspeeds up the VF2 algorithm."
    },
    {
        "oracle": ";",
        "javadocTag": "@param cacheEdges if true, the class creates a adjacency matrix and two\narrays for incoming and outgoing edges for fast access."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the graph to be ordered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ordering1 "
    },
    {
        "oracle": ";",
        "javadocTag": "@param ordering2 "
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexComparator "
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeComparator "
    },
    {
        "oracle": ";",
        "javadocTag": "@return is there a corresponding vertex to v in the subgraph"
    },
    {
        "oracle": ";",
        "javadocTag": "@return is there a corresponding edge to e in the subgraph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel the corresponding mapping"
    },
    {
        "oracle": ";",
        "javadocTag": "@return do both relations map to the same vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g1 the first graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g2 the second graph which is a possible subgraph of g1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param core1 the mapping as array (forwards)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param core2 the mapping as array (backwards)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph1 the first graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph2 the second graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexComparator comparator for semantic equivalence of vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeComparator comparator for semantic equivalence of edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cacheEdges if true, edges get cached for faster access"
    },
    {
        "oracle": ";",
        "javadocTag": "@return null or one matching between graph1 and graph2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Collection of cliques (each of which is represented as a Set of\nvertices)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Collection of cliques (each of which is represented as a Set of\nvertices)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the graph in which cliques are to be found; graph must be\nsimple"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g an undirected graph to find the chromatic number of"
    },
    {
        "oracle": ";",
        "javadocTag": "@return integer the approximate chromatic number from the greedy\nalgorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g an undirected graph for which to find the coloring"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the graph inspected by this StrongConnectivityAlgorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the graph is strongly connected, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>List</code> of <code>Set</code> s containing the strongly\nconnected components"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of subgraphs representing the strongly connected\ncomponents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param directedGraph the graph to inspect"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param endVertex end vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cost of the shortest path between the start vertex and the\nend vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param endVertex end vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of <code>Edge</code>, or null if no path exists between the\nstart vertex and the end vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the graph to be searched"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex the vertex at which the path should start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endVertex the vertex at which the path should end"
    },
    {
        "oracle": ";",
        "javadocTag": "@return List of Edges, or null if no path exists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph "
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex "
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph "
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex "
    },
    {
        "oracle": ";",
        "javadocTag": "@param nMaxHops maximum number of edges of the calculated paths."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph "
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex "
    },
    {
        "oracle": ";",
        "javadocTag": "@param nMaxHops maximum number of edges of the calculated paths."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon tolerance factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@return List of Edges, or null if no path exists"
    },
    {
        "oracle": ";",
        "javadocTag": "@return path representation, or null if no path exists"
    },
    {
        "oracle": ";",
        "javadocTag": "@return path length, or Double.POSITIVE_INFINITY if no path exists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the graph to be searched"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex the vertex at which the path should start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endVertex the vertex at which the path should end"
    },
    {
        "oracle": ";",
        "javadocTag": "@return List of Edges, or null if no path exists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the graph to be searched"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex the vertex at which the path should start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endVertex the vertex at which the path should end"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the graph to be searched"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex the vertex at which the path should start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endVertex the vertex at which the path should end"
    },
    {
        "oracle": ";",
        "javadocTag": "@param radius limit on weighted path length, or Double.POSITIVE_INFINITY\nfor unbounded search"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>null</code> is the path is empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pathElement "
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu location parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu location parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x0 Lower bound (excluded)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x1 Upper bound (included)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the probability that a random variable with this distribution\ntakes a value between {@code x0} and {@code x1}, excluding the lower\nand including the upper endpoint."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum absolute error in inverse cumulative probability estimates"
    },
    {
        "oracle": ";",
        "javadocTag": "@return zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the point at which the PDF is evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the logarithm of the value of the probability density function at point {@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Number of successes in the population."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Sample size."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a two element array containing the lower and upper bounds of the\nhypergeometric distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Number of successes in the population."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Sample size."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lowest domain value of the hypergeometric distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of successes."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sample size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Number of successes in the population."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Sample size."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the highest domain value of the hypergeometric distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Value at which the CDF is evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the upper tail CDF for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x0 Inclusive lower bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x1 Inclusive upper bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dx Direction of summation (1 indicates summing from x0 to x1, and\n0 indicates summing from x1 to x0)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code P(x0 <= X <= x1)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support"
    },
    {
        "oracle": ";",
        "javadocTag": "@param populationSize Population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfSuccesses Number of successes in the population."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleSize Sample size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param populationSize Population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfSuccesses Number of successes in the population."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleSize Sample size."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (always\n{@code Double.NEGATIVE_INFINITY})"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (always\n{@code Double.POSITIVE_INFINITY})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param degreesOfFreedom Degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param degreesOfFreedom Degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy the maximum absolute error in inverse\ncumulative probability estimates\n(defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param degreesOfFreedom Degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param degreesOfFreedom Degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy the maximum absolute error in inverse\ncumulative probability estimates\n(defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code 2 * k}, where {@code k} is the number of degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@return zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code Double.POSITIVE_INFINITY}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param degreesOfFreedom Degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param degreesOfFreedom Degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy the maximum absolute error in inverse\ncumulative probability estimates (defaults to\n{@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param degreesOfFreedom Degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param degreesOfFreedom Degrees of freedom."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy the maximum absolute error in inverse\ncumulative probability estimates (defaults to\n{@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mode {@code c} of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Lower limit of this distribution (inclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Upper limit of this distribution (inclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Mode of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Lower limit of this distribution (inclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Upper limit of this distribution (inclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Mode of this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialMixture Model containing initial values of weights and\n           multivariate normals"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations Maximum iterations allowed for fit"
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Convergence threshold computed as difference in\n            logLikelihoods between successive iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if any component's covariance matrix is\n            singular during fitting"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if numComponents is less than one\n            or threshold is less than Double.MIN_VALUE"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if initialMixture mean vector and data\n            number of columns are not equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialMixture Model containing initial values of weights and\n           multivariate normals"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if any component's covariance matrix is\n            singular during fitting"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if numComponents is less than one or\n            threshold is less than Double.MIN_VALUE"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data Data to estimate distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numComponents Number of components for estimated mixture"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Multivariate normal mixture model estimated from the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if {@code numComponents} is greater\nthan the number of data rows."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if data has less than 2 rows"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if rows of data have different numbers\n            of columns"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Log likelihood of data or zero of no data has been fit"
    },
    {
        "oracle": ";",
        "javadocTag": "@return fitted model or {@code null} if no fit has been performed yet."
    },
    {
        "oracle": ";",
        "javadocTag": "@param data Data to use in fitting procedure"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if data has no rows"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if rows of data have different numbers\n            of columns"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of columns in the data is\n            less than 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first shape parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the second shape parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the solver absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (always 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (always 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha2 angle of the second elementary rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha3 angle of the third elementary rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return abscissa of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ordinate of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return height of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return vector coordinates"
    },
    {
        "oracle": ";",
        "javadocTag": "@return azimuth (&alpha;) of the vector, between -&pi; and +&pi;"
    },
    {
        "oracle": ";",
        "javadocTag": "@return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new normalized vector orthogonal to the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the norm of the instance is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return angular separation between v1 and v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if either vector has a null norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Object to test for equality to this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if two 3D vector objects are equal, false if\n        object is null, not an instance of Vector3D, or\n        not equal to this Vector3D instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code value for this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v other vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cross product this ^ v as a new Vector3D"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the dot product v1.v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cross product v1 ^ v2 as a new Vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between v1 and v2 according to the L<sub>1</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between v1 and v2 according to the L<sub>2</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square of the distance between v1 and v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y ordinate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param z height"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v coordinates array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if array does not have 3 elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha azimuth (&alpha;) around Z\n             (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u3 third base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u3 third base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a4 fourth scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u4 fourth base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new hyperplane, copy of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p point belonging to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normal normal direction to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the normal norm is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original plane to reset from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normal normal direction to the plane (will be copied)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the normal norm is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the origin point of the plane frame (point closest to the\n3D-space origin)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return normalized normal vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return normalized first canonical vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return normalized second canonical vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector n-dimension point of the space"
    },
    {
        "oracle": ";",
        "javadocTag": "@return (n-1)-dimension point of the sub-space corresponding to\nthe specified space point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector (n-1)-dimension point of the sub-space"
    },
    {
        "oracle": ";",
        "javadocTag": "@return n-dimension point of the space corresponding to the\nspecified sub-space point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point of the space (must be a {@link Vector3D\nVector3D} instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return in-plane point (really a {@link\norg.apache.commons.math3.geometry.euclidean.twod.Vector2D Vector2D} instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point in-plane point (must be a {@link\norg.apache.commons.math3.geometry.euclidean.twod.Vector2D Vector2D} instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return 3D space point (really a {@link Vector3D Vector3D} instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inPlane desired in-plane coordinates for the point in the\nplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset desired offset for the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return one point in the 3D-space, with given coordinates and offset\nrelative to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param plane plane to which the instance is compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the planes are similar"
    },
    {
        "oracle": ";",
        "javadocTag": "@param center rotation center"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rotation vectorial rotation operator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param translation translation to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line line intersecting the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return intersection point between between the line and the\ninstance (null if the line is parallel to the instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other other plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return line at the intersection of the instance and the\nother plane (really a {@link Line Line} instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param plane1 first plane1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param plane2 second plane2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equationsMapper mapper for ODE equations primary and secondary components"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialState initial time, state vector and derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param finalTime target time for the integration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param state current value of the independent <i>time</i> variable,\nstate vector and derivative\nFor efficiency purposes, the {@link FieldStepNormalizer} class reuses\nthe same array on each call, so if\nthe instance wants to keep it across all calls (for example to\nprovide at the end of the integration a complete array of all\nsteps), it should build a local copy store this copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension total dimension (negative if arrays should be set to null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y reference to the integrator array holding the state at the end of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isForward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param primary equations mapper for the primary equations set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondary equations mappers for the secondary equations sets"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the finalized instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softPreviousTime start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softCurrentTime end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous global grid point time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current global grid point time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous soft grid point time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current soft grid point time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param oneMinusThetaH time gap between the interpolated time and\nthe current time"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out stream where to save the state"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException in case of write error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in stream where to read the state from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return interpolated time to be set later by the caller"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException in case of read error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if an equation mapper class\ncannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y reference to the integrator array holding the state at\nthe end of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param primaryMapper equations mapper for the primary equations set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondaryMappers equations mappers for the secondary equations sets"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator to copy from."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialState initial time, state vector and derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param finalTime target time for the integration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator for the last accepted step. For\nefficiency purposes, the various integrators reuse the same\nobject on each call, so if the instance wants to keep it across\nall calls (for example to provide at the end of the integration a\ncontinuous model valid throughout the integration range, as the\n{@link org.apache.commons.math3.ode.ContinuousOutputModel\nContinuousOutputModel} class does), it should build a local copy\nusing the clone method of the interpolator and store this copy.\nKeeping only a reference to the interpolator and reusing it will\nresult in unpredictable behavior (potentially crashing the application)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the interpolator throws one because\nthe number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value indicating whether the first point should be passed\nto the underlying fixed step size step handler."
    },
    {
        "oracle": ";",
        "javadocTag": "@return value indicating whether the last point should be passed\nto the underlying fixed step size step handler."
    },
    {
        "oracle": ";",
        "javadocTag": "@param first Whether the first point should be passed to the\nunderlying fixed step size step handler."
    },
    {
        "oracle": ";",
        "javadocTag": "@param last Whether the last point should be passed to the\nunderlying fixed step size step handler."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y reference to the integrator array holding the state at\nthe end of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param primaryMapper equations mapper for the primary equations set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondaryMappers equations mappers for the secondary equations sets"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time time at which all arrays are defined"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stepSize step size used in the scaled and Nordsieck arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scaledDerivative reference to the integrator array holding the first\nscaled derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nordsieckVector reference to the integrator matrix holding the\nNordsieck vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stepSize new step size to use in the scaled and Nordsieck arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@return state vector at time {@link #getInterpolatedTime}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator to copy from. The copy is a deep\ncopy: its arrays are separated from the original arrays of the\ninstance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator for the last accepted step. For\nefficiency purposes, the various integrators reuse the same\nobject on each call, so if the instance wants to keep it across\nall calls (for example to provide at the end of the integration a\ncontinuous model valid throughout the integration range), it\nshould build a local copy using the clone method and store this\ncopy."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the interpolator throws one because\nthe number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nextTime the next normalized time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator for the last accepted step, to use to\nget the end time of the current step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value indicating whether the next normalized time is in the\ncurrent step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isLast true if the step is the last one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h fixed time step (sign is not used)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler fixed time step handler to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h fixed time step (sign is not used)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler fixed time step handler to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mode step normalizer mode to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h fixed time step (sign is not used)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler fixed time step handler to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bounds step normalizer bounds setting to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h fixed time step (sign is not used)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler fixed time step handler to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mode step normalizer mode to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bounds step normalizer bounds setting to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newField field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newForward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newYDotK slopes at the intermediate points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newGlobalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newGlobalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newSoftPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newSoftCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newMapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients coefficients to apply to the method staged derivatives"
    },
    {
        "oracle": ";",
        "javadocTag": "@return combined state"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients coefficients to apply to the method staged derivatives"
    },
    {
        "oracle": ";",
        "javadocTag": "@return combined state"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients coefficients to apply to the method staged derivatives"
    },
    {
        "oracle": ";",
        "javadocTag": "@return combined state"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a array to add to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients coefficients to apply to the method staged derivatives"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a itself, as a convenience for fluent API"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotK slopes at the intermediate points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The control points coordinates or null if this edge is a straight\n        line."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if control points are available."
    },
    {
        "oracle": ";",
        "javadocTag": "@param points The new set of points. See the {@link #getControlPoints()}\n           method for an explanation on the organisation of this array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The edge index between the two nodes if there are several such\n        edges."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeList The actual set of edges between two nodes (see the\n           connectivity in the graphic graph)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The group of edges between two same nodes, null if the edge is\n        alone between the two nodes."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The edge unique identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param from The source node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param to The target node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dir True if the edge is directed in the direction from-to."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attributes A set of initial attributes."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the graph was changed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A style sheet."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A style group."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The style groups."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The maximum node or sprite position."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The minimum node or sprite position."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The number of groups."
    },
    {
        "oracle": ";",
        "javadocTag": "@param groupId The group identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The corresponding group or null if not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An iterator on the group set."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An iterable on the set of groups."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The z index iterator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The z levels."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The shadow groups iterator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return All the groups that cast a shadow."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the node is in this set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The edge identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the edge is in this set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The sprite identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the sprite is in this set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The graph identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the graph is in this set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The element id."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elt2grp The kind of element."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The element or null if not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The node if it is in this set, else null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The edge identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The edge if it is in this set, else null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The sprite identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The sprite if it is in this set, else null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The graph identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The graph if it is in this set, else null."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The node count."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The edge count."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The sprite count."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An iterator on all node elements contained in style groups."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An iterator on all graph elements contained in style groups."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The set of all nodes."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The set of all graphs."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An iterator on all edge elements contained in style groups."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The set of all edges."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An iterator on all sprite elements contained in style groups."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The set of all sprites."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to search for."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Identifier of the group containing the element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to search for."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The style group of the element (which is also a style)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node The node to search for."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The node style."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge The edge to search for."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The edge style."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sprite The node to search for."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The sprite style."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The node to search for."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The graph style."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the groups are removed when empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The Z index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The set of shadowed style groups."
    },
    {
        "oracle": ";",
        "javadocTag": "@param on If true the groups will be removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The style group where the element was added."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to remove."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to move."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event The event to push."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element considered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event The event to push."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event The event to remove."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element considered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event The event to pop."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to add to the dynamic subset."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to remove from the dynamic subset."
    },
    {
        "oracle": ";",
        "javadocTag": "@param listener The listener to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@param listener The listener to remove."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldRule The old rule that changed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newRule The new rule that participated in the change."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newRule The new style rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elt2grp The name space."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newRule The new style rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elt2grp The name space."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stylesheet The style sheet to use to create groups."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The style group corresponding to this element."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The new X."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The new Y."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z the new Z."
    },
    {
        "oracle": ";",
        "javadocTag": "@param component The component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param type type of the event"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expect the expected value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param update the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if successful. False return indicates that\nthe actual value was not equal to the expected value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expect the expected value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param update the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if successful"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta the value to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta the value to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the updated value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the String representation of the current values of array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the length of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to copy elements from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor the ExecutorService that will execute the method calls on\n    the target objects; for example, a {@link\n    Executors#newCachedThreadPool()}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor the executor to modify to make sure it exits when the\n       application is finished"
    },
    {
        "oracle": ";",
        "javadocTag": "@param terminationTimeout how long to wait for the executor to\n       finish before terminating the JVM"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeUnit unit of time for the time parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable version of the input which will not hang the JVM"
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor the executor to modify to make sure it exits when the\n       application is finished"
    },
    {
        "oracle": ";",
        "javadocTag": "@param terminationTimeout how long to wait for the executor to\n       finish before terminating the JVM"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeUnit unit of time for the time parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable version of the input which will not hang the JVM"
    },
    {
        "oracle": ";",
        "javadocTag": "@param service ExecutorService which uses daemon threads"
    },
    {
        "oracle": ";",
        "javadocTag": "@param terminationTimeout how long to wait for the executor to finish\n       before terminating the JVM"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeUnit unit of time for the time parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor the executor to modify to make sure it exits when the\n       application is finished"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable version of the input which will not hang the JVM"
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor the executor to modify to make sure it exits when the\n       application is finished"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable version of the input which will not hang the JVM"
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor The executor to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nameSupplier The source of names for each task"
    },
    {
        "oracle": ";",
        "javadocTag": "@param service The executor to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nameSupplier The source of names for each task"
    },
    {
        "oracle": ";",
        "javadocTag": "@param service The executor to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nameSupplier The source of names for each task"
    },
    {
        "oracle": ";",
        "javadocTag": "@param service the {@code ExecutorService} to shut down"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeout the maximum time to wait for the {@code ExecutorService} to terminate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the time unit of the timeout argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}\n    the call timed out or was interrupted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param listener the listener to run when the manager changes state"
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor the executor in which the listeners callback methods will be run."
    },
    {
        "oracle": ";",
        "javadocTag": "@param listener the listener to run when the manager changes state"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if any of the Services are not {@link State#NEW new} when the\n    method is called."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the service manager reaches a state from which it cannot\n    become {@linkplain #isHealthy() healthy}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeout the maximum time to wait"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the time unit of the timeout argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TimeoutException if not all of the services have finished starting within the deadline"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the service manager reaches a state from which it cannot\n    become {@linkplain #isHealthy() healthy}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeout the maximum time to wait"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the time unit of the timeout argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TimeoutException if not all of the services have stopped within the deadline"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Map of services and their corresponding startup time in millis, the map entries will be\n    ordered by startup time."
    },
    {
        "oracle": ";",
        "javadocTag": "@param services The services to manage"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there\nare any duplicate services."
    },
    {
        "oracle": ";",
        "javadocTag": "@param target the object to proxy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interfaceType the interface you wish the returned proxy to\n    implement"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeoutDuration with timeoutUnit, the maximum length of time that\n    callers are willing to wait on each method call to the proxy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeoutUnit with timeoutDuration, the maximum length of time that\n    callers are willing to wait on each method call to the proxy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a time-limiting proxy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param callable the Callable to execute"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeoutDuration with timeoutUnit, the maximum length of time to wait"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeoutUnit with timeoutDuration, the maximum length of time to wait"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interruptible whether to respond to thread interruption by aborting\n    the operation and throwing InterruptedException; if false, the\n    operation is allowed to complete or time out, and the current thread's\n    interrupt status is re-asserted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the result returned by the Callable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UncheckedTimeoutException if the time limit is reached"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws Exception "
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expect the expected value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param update the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if successful. False return indicates that\nthe actual value was not bitwise equal to the expected value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expect the expected value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param update the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if successful"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta the value to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta the value to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the updated value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the String representation of the current value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialValue the initial value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code AtomicReference} with no initial value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialValue the initial value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code AtomicReference} with the given initial value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the length of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code AtomicReferenceArray} with the given length"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to copy elements from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code AtomicReferenceArray} copied from the given array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element of {@code tasks} is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.lang.IllegalStateException if this executor is not suspended."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws X if {@link #get()} throws an {@link InterruptedException},\n        {@link CancellationException}, or {@link ExecutionException}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Sample values of the x-coordinate, in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Sample values of the y-coordinate, in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z Sample values of the y-coordinate, in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Values of the function on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dFdX Values of the partial derivative of function with respect to x on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dFdY Values of the partial derivative of function with respect to y on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dFdZ Values of the partial derivative of function with respect to z on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d2FdXdY Values of the cross partial derivative of function on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d2FdXdZ Values of the cross partial derivative of function on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d2FdYdZ Values of the cross partial derivative of function on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d3FdXdYdZ Values of the cross partial derivative of function on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if any of the arrays has zero length."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the various arrays do not contain the expected number of elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code x}, {@code y} or {@code z} are not strictly increasing."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x x-coordinate of the interpolation point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y y-coordinate of the interpolation point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z z-coordinate of the interpolation point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the interpolated value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code x}, {@code y} or\n{@code z} are not in the interval {@code [0, 1]}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param aV List of spline coefficients."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xval All the x-coordinates of the interpolation points, sorted\nin increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param yval All the y-coordinates of the interpolation points, sorted\nin increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param zval All the z-coordinates of the interpolation points, sorted\nin increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fval the values of the interpolation points on all the grid knots:\n{@code fval[i][j][k] = f(xval[i], yval[j], zval[k])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function that interpolates the data set."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths are inconsistent."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if arrays are not sorted"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of points is too small for\nthe order of the interpolation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Interpolating points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Interpolating values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function which interpolates the data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths are different."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of points is less than 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if two abscissae have the same\nvalue."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the space dimension of the\ngiven samples does not match the space dimension of the microsphere."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension Space dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements Number of surface elements of the microsphere."
    },
    {
        "oracle": ";",
        "javadocTag": "@param exponent Exponent used in the power law that computes the"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxDarkFraction Maximum fraction of the facets that can be dark.\nIf the fraction of \"non-illuminated\" facets is larger, no estimation\nof the value will be performed, and the {@code background} value will\nbe returned instead."
    },
    {
        "oracle": ";",
        "javadocTag": "@param darkThreshold Value of the illumination below which a facet is\nconsidered dark."
    },
    {
        "oracle": ";",
        "javadocTag": "@param background Value returned when the {@code maxDarkFraction}\nthreshold is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sharedSphere Whether the sphere can be shared among the\ninterpolating function instances.  If {@code true}, the instances\nwill share the same data, and thus will <em>not</em> be thread-safe."
    },
    {
        "oracle": ";",
        "javadocTag": "@param noInterpolationTolerance When the distance between an\ninterpolated point and one of the sample points is less than this\nvalue, no interpolation will be performed (the value of the sample\nwill be returned)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.OutOfRangeException if\n{@code maxDarkFraction} does not belong to the interval {@code [0, 1]}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param microsphere Microsphere."
    },
    {
        "oracle": ";",
        "javadocTag": "@param exponent Exponent used in the power law that computes the\nweights (distance dimming factor) of the sample data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sharedSphere Whether the sphere can be shared among the\ninterpolating function instances.  If {@code true}, the instances\nwill share the same data, and thus will <em>not</em> be thread-safe."
    },
    {
        "oracle": ";",
        "javadocTag": "@param noInterpolationTolerance When the distance between an\ninterpolated point and one of the sample points is less than this\nvalue, no interpolation will be performed (the value of the sample\nwill be returned)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xvals the arguments for the interpolation points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yvals the values for the interpolation points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function which interpolates the data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code xvals} and {@code yvals} have\n        different sizes."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code xvals} is not sorted in\n        strict increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xvals x values to calculate the numerical derivative with"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yvals y values to calculate the numerical derivative with"
    },
    {
        "oracle": ";",
        "javadocTag": "@param indexOfDifferentiation index of the elemnt we are calculating the derivative around"
    },
    {
        "oracle": ";",
        "javadocTag": "@param indexOfFirstSample index of the first element to sample for the three point method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param indexOfSecondsample index of the second element to sample for the three point method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param indexOfThirdSample index of the third element to sample for the three point method"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xvals x values for interpolation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yvals y values for interpolation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param firstDerivatives first derivative values of the function"
    },
    {
        "oracle": ";",
        "javadocTag": "@return polynomial that fits the function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xval the arguments for the interpolation points.\n{@code xval[i][0]} is the first component of interpolation point\n{@code i}, {@code xval[i][1]} is the second component, and so on\nuntil {@code xval[i][d-1]}, the last component of that interpolation\npoint (where {@code d} is thus the dimension of the space)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param yval the values for the interpolation points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function which interpolates the data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the arguments violate assumptions\nmade by the interpolation algorithm."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException when the array dimensions are not consistent."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i Index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper limit of the array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i Index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initializeDerivatives Whether to initialize the internal data\nneeded for calling any of the methods that compute the partial derivatives\nof the {@link BicubicSplineInterpolatingFunction function} returned from\nthe call to {@link #interpolate(double[],double[],double[][]) interpolate}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if any of the variables is outside its interpolation range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Coordinate samples."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index in {@code val} corresponding to the interval containing {@code c}, or {@code -1}\n  if {@code c} is out of the range defined by the end values of {@code val}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param beta List of function values and function partial derivatives values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the spline coefficients."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Sample values of the x-coordinate, in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Sample values of the y-coordinate, in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z Sample values of the y-coordinate, in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Values of the function on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dFdX Values of the partial derivative of function with respect to x on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dFdY Values of the partial derivative of function with respect to y on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dFdZ Values of the partial derivative of function with respect to z on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d2FdXdY Values of the cross partial derivative of function on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d2FdXdZ Values of the cross partial derivative of function on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d2FdYdZ Values of the cross partial derivative of function on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d3FdXdYdZ Values of the cross partial derivative of function on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if any of the arrays has zero length."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the various arrays do not contain the expected number of elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code x}, {@code y} or {@code z} are not strictly increasing."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x x-coordinate of the interpolation point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y y-coordinate of the interpolation point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z z-coordinate of the interpolation point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the interpolated value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code x}, {@code y} or\n{@code z} are not in the interval {@code [0, 1]}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to concatenate to the previous value of the property"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value of the property"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p a Properties object in which to look up the property"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key name of the property to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to set the property to, if it is not already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value of the property"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o object in which to set the field"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fieldName name of field to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value new value of field"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchFieldException if the field does not exist in the object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o object in which to set the field"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fieldName name of field to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return new value of field"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchFieldException if the field does not exist in the object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set a set in which to look up the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the value to look up in the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param from input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param is input stream to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a String containing all the characters from the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target the string to do replacement in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldStr the substring to replace"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newStr the replacement"
    },
    {
        "oracle": ";",
        "javadocTag": "@return target with all instances of oldStr replaced by newStr"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the string to split"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delim delimiter to split the string on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return array of length at least 1, containing s split on delimiter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the string to split"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delim delimiter to split the string on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return array of length at least 1, containing s split on delimiter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the string to split"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of Strings, one for each line in the argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a array of values to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delim delimiter to place between printed representations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the concatenation of the string representations of the values, with the delimiter between"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a array of values to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the concatenation of the string representations of the values, each on its own line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v list of values to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delim delimiter to place between printed representations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the concatenation of the string representations of the values, with the delimiter between"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v list of values to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the concatenation of the string representations of the values, each on its own line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param orig string to quote"
    },
    {
        "oracle": ";",
        "javadocTag": "@return quoted version of orig"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ch character to quote"
    },
    {
        "oracle": ";",
        "javadocTag": "@return quoted version och ch"
    },
    {
        "oracle": ";",
        "javadocTag": "@param orig string to quote"
    },
    {
        "oracle": ";",
        "javadocTag": "@return quoted version of orig"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c character to quote"
    },
    {
        "oracle": ";",
        "javadocTag": "@return quoted version of c"
    },
    {
        "oracle": ";",
        "javadocTag": "@param orig string to quoto"
    },
    {
        "oracle": ";",
        "javadocTag": "@return quoted version of orig"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arg string to remove whitespace in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delimiter string to remove whitespace abutting"
    },
    {
        "oracle": ";",
        "javadocTag": "@return version of arg, with whitespace abutting delimiter removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arg string to remove whitespace in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delimiter string to remove whitespace after"
    },
    {
        "oracle": ";",
        "javadocTag": "@return version of arg, with whitespace after delimiter removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arg string to remove whitespace in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delimiter string to remove whitespace before"
    },
    {
        "oracle": ";",
        "javadocTag": "@return version of arg, with whitespace before delimiter removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n count of nouns"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noun word being counted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string to truncate or pad"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length goal length"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string to truncate or pad"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length goal length"
    },
    {
        "oracle": ";",
        "javadocTag": "@param num int whose string representation to truncate or pad"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length goal length"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of num truncated or padded to length characters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param num double whose string representation to truncate or pad"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length goal length"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of num truncated or padded to length characters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string to search in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ch character to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of times the character appears in the string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string to search in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sub string to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of times the substring appears in the string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param str a string to be parsed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delim the delimiters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param returnDelims flag indicating whether to return the delimiters as tokens"
    },
    {
        "oracle": ";",
        "javadocTag": "@return vector of strings resulting from tokenization"
    },
    {
        "oracle": ";",
        "javadocTag": "@param str a string to be parsed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delim the delimiters"
    },
    {
        "oracle": ";",
        "javadocTag": "@return vector of strings resulting from tokenization"
    },
    {
        "oracle": ";",
        "javadocTag": "@param str a string to be parsed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return vector of strings resulting from tokenization"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t the Throwable to obtain a backtrace of"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a String representation of the backtrace of the given Throwable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a sorted version of the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> type of elements of the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l a list to sort"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c a sorted version of the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> type of elements of the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l a list to remove duplicates from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the list with duplicates removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o1 first value to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o2 second value to comare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff o1 and o2 are deeply equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return angular separation between v1 and v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if either vector has a null norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first point of the line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second point of the line"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cross-product"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between p1 and p2 according to the L<sub>2</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square of the distance between p1 and p2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Object to test for equality to this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if two 2D vector objects are equal, false if\n        object is null, not an instance of Vector2D, or\n        not equal to this Vector2D instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code value for this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y ordinate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v coordinates array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if array does not have 2 elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u3 third base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u3 third base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a4 fourth scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u4 fourth base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bLoop boundary loop (will be reversed in place if needed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if an outline has crossing\nboundary loops or open boundary loops"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node boundary loop (will be reversed in place if needed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if an outline has boundary\nloops that cross each other"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clockwise if true, the loop should be set to clockwise\norientation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loop boundary loop (will be reversed in place if needed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if an outline has an open boundary loop"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unique instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p point belonging to the line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha angle of the line with respect to abscissa axis"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new line, with orientation opposite to the instance orientation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector n-dimension point of the space"
    },
    {
        "oracle": ";",
        "javadocTag": "@return (n-1)-dimension point of the sub-space corresponding to\nthe specified space point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector (n-1)-dimension point of the sub-space"
    },
    {
        "oracle": ";",
        "javadocTag": "@return n-dimension point of the space corresponding to the\nspecified sub-space point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other other line"
    },
    {
        "oracle": ";",
        "javadocTag": "@return intersection point of the instance and the other line\nor null if there are no intersection points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a region containing the instance (really a {@link\nPolygonsSet PolygonsSet} instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line line to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector vector to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param abscissa desired abscissa for the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset desired offset for the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return one point in the plane, with given abscissa and offset\nrelative to the line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if p belongs to the line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return distance between the instance and the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line other line to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the instance is parallel to the other line\n(they can have either the same or opposite orientations)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p point by which the line should pass"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the angle of the line with respect to the abscissa axis"
    },
    {
        "oracle": ";",
        "javadocTag": "@param angle new angle of the line with respect to the abscissa axis"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the offset of the origin"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset offset of the origin"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transform affine transform to embed (must be inversible\notherwise the {@link\norg.apache.commons.math3.geometry.partitioning.Transform#apply(Hyperplane)\napply(Hyperplane)} method would work only for some lines, and\nfail for other ones)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transform that can be applied to either {@link\nVector2D Vector2D}, {@link Line Line} or {@link\norg.apache.commons.math3.geometry.partitioning.SubHyperplane\nSubHyperplane} instances"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the transform is non invertible"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cXX transform factor between input abscissa and output abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cYX transform factor between input abscissa and output ordinate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cXY transform factor between input ordinate and output abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cYY transform factor between input ordinate and output ordinate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cX1 transform addendum for output abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cY1 transform addendum for output ordinate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transform that can be applied to either {@link\nVector2D Vector2D}, {@link Line Line} or {@link\norg.apache.commons.math3.geometry.partitioning.SubHyperplane\nSubHyperplane} instances"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the transform is non invertible"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p point belonging to the line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p numerator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q denominator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p/q computed in the instance field"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotK slopes at the intermediate points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return time steps from Butcher array (without the first zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@return internal weights from Butcher array (without the first empty row)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return external weights for the high order method from Butcher array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the method excluding the one being computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if order is 1 or less"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the method excluding the one being computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if order is 1 or less"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p numerator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q denominator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p/q computed in the instance field"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotK slopes at the intermediate points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return external weights for the high order method from Butcher array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equations differential equations to integrate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 initial time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 initial value of the state vector at t0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t target time for the integration\n(can be set to a value smaller than {@code t0} for backward integration)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return state vector at {@code t}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator to copy from. The copy is a deep\ncopy: its arrays are separated from the original arrays of the\ninstance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotK slopes at the intermediate points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newForward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newGlobalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newGlobalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newSoftPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newSoftCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newMapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reference reference state"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time time at which state must be estimated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stepSize step size used in the scaled and Nordsieck arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scaled first scaled derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nordsieck Nordsieck vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return estimated state"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <S> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stepSize step size used in the scaled and Nordsieck arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reference reference state from which Taylor expansion are estimated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scaled first scaled derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nordsieck Nordsieck vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isForward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equationsMapper mapper for ODE equations primary and secondary components"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stepSize step size used in the scaled and Nordsieck arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reference reference state from which Taylor expansion are estimated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scaled first scaled derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nordsieck Nordsieck vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isForward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max the maximum number of elements returned by this iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new bounded iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to make immutable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an immutable version of the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param listIterator the iterator to make immutable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an immutable version of the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapIterator the iterator to make immutable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an immutable version of the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a combination iterator over the iterators"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a combination iterator over the iterators"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a combination iterator over the iterators"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the iterators collection contains the wrong object type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator to use, may be null for natural order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a combination iterator over the iterators"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator to use, may be null for natural order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a combination iterator over the iterators"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator to use, may be null for natural order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a combination iterator over the iterators"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the iterators collection contains the wrong object type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param root the root object to start iterating from, null results in an empty iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new object graph iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transforming iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new filtered iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new filtered iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new looping iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new looping iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, single use {@link Iterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, single use {@link Iterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a peeking iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a pushback iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset the first number of elements to skip"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new skipping iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first iterator to interleave"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second iterator to interleave"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first iterator to interleave"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second iterator to interleave"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the third iterator to interleave"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterators the array of iterators to interleave"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator, interleaving the decorated iterators"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new enumeration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, single use {@link Iterable}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, multiple use iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of the iterator contents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arrayClass the class of array to create"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of the iterator contents"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArrayStoreException if the arrayClass is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of the iterator contents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param estimatedSize the initial size of the ArrayList"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of the iterator contents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to convert to an iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a suitable iterator, never null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object the {@link Iterator} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to search, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first element of the iterator which matches the predicate or null if none could be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to search, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the first element which matches the predicate or -1 if none matches"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object the {@link Iterator} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the {@link Iterator} to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if any element of the collection matches the predicate, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param removeFrom the iterable to (potentially) remove elements from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate a predicate that determines whether an element should\n    be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if any elements were removed from the iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the iterable does not support\n    {@code remove()}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the iterable is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the iterable contains multiple\n    elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the iterator contains multiple\n    elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of the elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a newly-allocated array into which all the elements of the iterable\n    have been copied"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a newly-allocated array into which all the elements of the iterable\n    have been copied"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code collection} was modified as a result of this\n    operation."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any of the provided iterables is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to return a partitioned view of"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the desired size of each partition (the last may be smaller)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterable of unmodifiable lists containing the elements of {@code\n    iterable} divided into partitions"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to return a partitioned view of"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the desired size of each partition"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterable of unmodifiable lists containing the elements of {@code\n    iterable} divided into partitions (the final iterable may have\n    trailing null elements)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unfiltered an iterable containing objects of any type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of elements desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable iterable containing all elements of the original\n    iterable that were of the requested type"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if no element in {@code iterable} matches\n    the given predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param position position of the element to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the element at the specified position in {@code iterable}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param position position of the element to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue the default value to return if {@code position} is\n    greater than or equal to the size of the iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the element at the specified position in {@code iterable} or\n    {@code defaultValue} if {@code iterable} contains fewer than\n    {@code position + 1} elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue the default value to return if the iterable is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first element of {@code iterable} or the default value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the last element of {@code iterable}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the iterable is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue the value to return if {@code iterable} is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the last element of {@code iterable} or the default value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to limit"
    },
    {
        "oracle": ";",
        "javadocTag": "@param limitSize the maximum number of elements in the returned iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a view of the supplied iterable that wraps each generated iterator\n    through {@link Iterators#consumingIterator(Iterator)}; for queues,\n    an iterable that generates iterators that return and consume the\n    queue's elements in queue order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the iterable contains no elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param removeFrom the iterator to (potentially) remove elements from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elementsToRemove the elements to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if any element was removed from {@code iterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param removeFrom the iterator to (potentially) remove elements from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate a predicate that determines whether an element should\n    be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if any elements were removed from the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param removeFrom the iterator to (potentially) remove elements from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elementsToRetain the elements to retain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if any element was removed from {@code iterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the iterator is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the iterator contains multiple\n    elements.  The state of the iterator is unspecified."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the iterator contains multiple\n    elements.  The state of the iterator is unspecified."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of the elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a newly-allocated array into which all the elements of the iterator\n        have been copied"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code collection} was modified as a result of this\n        operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any of the provided iterators is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to return a partitioned view of"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the desired size of each partition (the last may be smaller)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator of immutable lists containing the elements of {@code\n    iterator} divided into partitions"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to return a partitioned view of"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the desired size of each partition"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator of immutable lists containing the elements of {@code\n    iterator} divided into partitions (the final iterable may have\n    trailing null elements)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unfiltered an iterator containing objects of any type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of elements desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable iterator containing all elements of the original\n    iterator that were of the requested type"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if no element in {@code iterator} matches\n    the given predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param position position of the element to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the element at the specified position in {@code iterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param position position of the element to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue the default value to return if the iterator is empty\n    or if {@code position} is greater than the number of elements\n    remaining in {@code iterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the element at the specified position in {@code iterator} or\n    {@code defaultValue} if {@code iterator} produces fewer than\n    {@code position + 1} elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue the default value to return if the iterator is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next element of {@code iterator} or the default value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the last element of {@code iterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the iterator is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue the default value to return if the iterator is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the last element of {@code iterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of elements the iterator was advanced"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to limit"
    },
    {
        "oracle": ";",
        "javadocTag": "@param limitSize the maximum number of elements in the returned iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to remove and return elements from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator that removes and returns elements from the\n    supplied iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the backing iterator. The {@link PeekingIterator} assumes\n    ownership of this iterator, so users should cease making direct calls\n    to it after calling this method."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a peeking iterator backed by that iterator. Apart from the\n    additional {@link PeekingIterator#peek()} method, this iterator behaves\n    exactly the same as {@code iterator}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint that validates added elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set the set to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint that validates added elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sortedSet the sorted set to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint that validates added elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the sorted set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list the list to constrain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint that validates added elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param listIterator the iterator for which to return a constrained view"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constraint the constraint for elements in the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constrained view of the specified iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be read from the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients The coefficients for the linear equation being optimized"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constantTerm The constant term of the linear equation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients The coefficients for the linear equation being optimized"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constantTerm The constant term of the linear equation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return relationship obtained when multiplying all coefficients by -1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stringValue display string for the relationship"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lB Lower bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param uB Upper bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the stored point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to the internal array storing the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the stored value of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to the internal array storing the value of\nthe objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return data transfer object that will be serialized"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point coordinates. This instance will store\na copy of the array, not the array passed as argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Value of the objective function at the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point coordinates."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Value of the objective function at the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyArray if {@code true}, the input arrays will be copied,\notherwise they will be referenced."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Single-start optimizer to wrap."
    },
    {
        "oracle": ";",
        "javadocTag": "@param starts Number of starts to perform (including the\nfirst one), multi-start is disabled if value is less than or\nequal to 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator Random vector generator to use for restarts."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Single-start optimizer to wrap."
    },
    {
        "oracle": ";",
        "javadocTag": "@param starts Number of starts to perform (including the\nfirst one), multi-start is disabled if value is less than or\nequal to 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator Random vector generator to use for restarts."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iteration Index of current iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous Best point in the previous iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@param current Best point in the current iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the arguments satify the convergence criterion."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold relative tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold absolute tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold Relative tolerance threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold Absolute tolerance threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIter Maximum iteration count."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iteration Index of current iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous Best point in the previous iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@param current Best point in the current iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the arguments satify the convergence criterion."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold relative tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold absolute tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold Relative tolerance threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold Absolute tolerance threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIter Maximum iteration count."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximal number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of evaluations of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object used to check for convergence."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Point and value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Point and value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param isMinim {@code true} if the selected point must be the one with\nthe lowest value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the best point, or {@code null} if {@code a} and {@code b} are\nboth {@code null}. When {@code a} and {@code b} have the same function\nvalue, {@code a} is returned."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel Relative threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abs Absolute threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Additional, user-defined, convergence checking\nprocedure."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel Relative threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abs Absolute threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the optima."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if {@link\n#optimize(int,UnivariateFunction,GoalType,double,double) optimize}\nhas not been called."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goal Goal type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Single-start optimizer to wrap."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator Random generator to use for restarts."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to optimize."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType Type of optimization goal: either\n{@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a (point, value) pair where the function is optimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximum evaluation count is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.ConvergenceException if the optimizer detects a convergence problem."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to optimize."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType Type of optimization goal: either\n{@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startValue Start value to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a (point, value) pair where the function is optimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximum evaluation count is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.ConvergenceException if the\noptimizer detects a convergence problem."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the optimization type."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lower end of the search interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the higher end of the search interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point at which the objective function must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective function value at specified point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of evaluations\nis exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the optimum and its corresponding function value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of evaluations\nis exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checking procedure."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iteration Index of current iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous Best point in the previous iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@param current Best point in the current iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the algorithm has converged."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold relative tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold absolute tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold relative tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold absolute tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIter Maximum iteration count."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a String view of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key for the entry, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value for the entry, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the old value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the value is set to this map entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal key and value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a suitable hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@return entry as a string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal key and value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a suitable hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key for the entry, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value for the entry, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized multiset backed by that multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of that multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a predicated multiset backed by the given multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the iterator has more elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next key in the iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.util.NoSuchElementException if the iteration is finished"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current key"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if <code>next()</code> has not yet been called"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if <code>next()</code> has not yet been called"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if remove is not supported by the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if <code>next()</code> has not yet been called"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if <code>remove()</code> has already been called\n since the last call to <code>next()</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if setValue is not supported by the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if <code>next()</code> has not yet been called"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if <code>remove()</code> has been called since the\n last call to <code>next()</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the wrapped map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@code Collection} of values, will return an empty {@code Collection} for no mapping"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to remove values from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>Collection</code> of values removed, will return an\n  empty, unmodifiable collection for no mapping found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to remove from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the mapping was removed, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a collection view of the values contained in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to store against"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to add to the collection at the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value added if the map changed and null if the map did not change"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map changed as a result of this operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map changed as a result of this operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a bag view of the key mapping contained in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to store against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this map changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException any of the usual I/O related exceptions"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException any of the usual I/O related exceptions"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if the stream contains an object which class can not be loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the stream does not contain the correct objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the type of key elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the type of value elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable MultiValuedMap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the MultiValuedMap to decorate, may not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialSetCapacity the initial capacity used for value collections"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialMapCapacity the initial hashmap capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialSetCapacity the initial capacity used for value collections"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map a <code>MultiValuedMap</code> to copy into this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map a <code>Map</code> to copy into this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed MultiValuedMap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed MultiValuedMap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>Set</code> of values, will return an empty\n  <code>Set</code> for no mapping"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to remove values from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>Set</code> of values removed, will return an empty,\n  unmodifiable set for no mapping found."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@code List} of values, will return an empty {@link List} for no mapping"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to remove values from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>List</code> of values removed, will return an empty,\n  unmodifiable list for no mapping found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param prototypeStatistics a {@code SummaryStatistics} serving as a\n     prototype both for the internal aggregate statistics and for\n     contributing statistics obtained via the\n     {@code createContributingStatistics()} method.  Being a prototype\n     means that other objects are initialized by copying this object's state.\n     If {@code null}, a new, default statistics object is used.  Any statistic\n     values in the prototype are propagated to contributing statistics\n     objects and (once) into these aggregate statistics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param prototypeStatistics a {@code SummaryStatistics} serving as a\n     prototype both for the internal aggregate statistics and for\n     contributing statistics obtained via the\n     {@code createContributingStatistics()} method.  Being a prototype\n     means that other objects are initialized by copying this object's state.\n     If {@code null}, a new, default statistics object is used.  Any statistic\n     values in the prototype are propagated to contributing statistics\n     objects, but not into these aggregate statistics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialStatistics a {@code SummaryStatistics} to serve as the\n     internal aggregate statistics object.  If {@code null}, a new, default\n     statistics object is used."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights array of weights"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the weighted statistic applied to the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if either array is null, lengths\ndo not match, weights contain NaN, negative or infinite values, or\nweights does not include at least on positive value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights array of weights"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin the index of the first element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the weighted statistic applied to the included array entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if either array is null, lengths\ndo not match, indices are invalid, weights contain NaN, negative or\ninfinite values, or weights does not include at least on positive value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source SynchronizedSummaryStatistics to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest SynchronizedSummaryStatistics to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code SynchronizedSummaryStatistics} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the statistic applied to the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin the index of the first element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the statistic applied to the included array entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the percentile value to compute"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the statistic applied to the stored data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values input array of values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the percentile value to compute"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the percentile value or Double.NaN if the array is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the percentile value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values array of input values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the percentile to compute"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin the first (0-based) element to include in the computation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of array elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the percentile value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid or the\ninput array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param work data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first element of the slice"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end index after the last element of the slice"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the median element chosen between the\nfirst, the middle and the last element of the array slice"
    },
    {
        "oracle": ";",
        "javadocTag": "@return quantile set while construction or {@link #setQuantile(double)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p a value between 0 < p <= 100"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Percentile to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest Percentile to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathUnsupportedOperationException always thrown since 3.4"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the array of numbers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index to start reading the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the length of array to be read from the begin index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return work array sliced from values in the range [begin,begin+length)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if values or indices are invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin start index of the array to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length number of elements to include from begin"
    },
    {
        "oracle": ";",
        "javadocTag": "@return copy of a slice of the original array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin start index of the array to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length number of elements to include from begin"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the value to be replaced with"
    },
    {
        "oracle": ";",
        "javadocTag": "@param replacement the value to be used for replacement"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the copy of sliced array with replaced values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin start index of the array to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length number of elements to include from begin"
    },
    {
        "oracle": ";",
        "javadocTag": "@param removedValue the value to be removed from the sliced array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the copy of the sliced array after removing the removedValue"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values array containing the input numbers"
    },
    {
        "oracle": ";",
        "javadocTag": "@return cached pivots or a newly created one"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@code estimationType} set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newEstimationType estimation type for the new instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance, with changed estimation type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code NaN Handling} strategy set during construction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newNaNStrategy NaN strategy for the new instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance, with changed NaN handling strategy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@code kthSelector} set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the pivoting strategy set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newKthSelector KthSelector for the new instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance, with changed KthSelector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param quantile the quantile"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if p is not greater than 0 and less\nthan or equal to 100"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code Percentile} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param quantile the quantile to be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param estimationType one of the percentile {@link EstimationType  estimation types}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nanStrategy one of {@link NaNStrategy} to handle with NaNs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param kthSelector a {@link KthSelector} to use for pivoting during search"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if p is not within (0,100]"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Max to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest Max to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code Max} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o object to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if {@code o} is a {@code PSquarePercentile} with\nequivalent internal state"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observation the observation currently being added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return string representation of state data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param cols Columns to select."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Matrix representing the selected columns."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Diagonal position."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Upper triangular part of matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Row matrix representing the sums of the rows."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the diagonal n-by-n matrix if m is a column matrix or the column\nmatrix representing the diagonal if m is a n-by-n matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m1 Source matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param col1 Source column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m2 Target matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param col2 Target column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of rows."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Number of columns."
    },
    {
        "oracle": ";",
        "javadocTag": "@return n-by-m matrix filled with 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of rows."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Number of columns."
    },
    {
        "oracle": ";",
        "javadocTag": "@return n-by-m matrix of 0 values out of diagonal, and 1 values on\nthe diagonal."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of rows."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Number of columns."
    },
    {
        "oracle": ";",
        "javadocTag": "@return n-by-m matrix of zero values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mat Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Number of row replicates."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Number of column replicates."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a matrix which replicates the input matrix in both directions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start Start value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param end End value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param step Step size."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a sequence as column matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum of the matrix element values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the minimum of the matrix element values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum of the array values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Input array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the minimum of the array values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param indices Input index array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse of the mapping defined by indices."
    },
    {
        "oracle": ";",
        "javadocTag": "@param indices Input index array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the indices in inverse order (last is first)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Length of random array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of Gaussian random numbers."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Number of rows."
    },
    {
        "oracle": ";",
        "javadocTag": "@param popSize Population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a 2-dimensional matrix of Gaussian random numbers."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lambda Population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lambda Population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputSigma Initial standard deviations to sample new points\naround the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lambda Population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputSigma Initial standard deviations to sample new points\naround the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations Maximal number of iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stopFitness Whether to stop if objective function value is smaller than\n{@code stopFitness}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param isActiveCMA Chooses the covariance matrix update method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param diagonalOnly Number of initial iterations, where the covariance matrix\nremains diagonal."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checkFeasableCount Determines how often new random objective variables are\ngenerated in case they are out of bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param random Random generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generateStatistics Whether statistic data is collected."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lambda Population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputSigma Initial standard deviations to sample new points\naround the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations Maximal number of iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stopFitness Whether to stop if objective function value is smaller than\n{@code stopFitness}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param isActiveCMA Chooses the covariance matrix update method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param diagonalOnly Number of initial iterations, where the covariance matrix\nremains diagonal."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checkFeasableCount Determines how often new random objective variables are\ngenerated in case they are out of bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param random Random generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generateStatistics Whether statistic data is collected."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations Maximal number of iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stopFitness Whether to stop if objective function value is smaller than\n{@code stopFitness}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param isActiveCMA Chooses the covariance matrix update method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param diagonalOnly Number of initial iterations, where the covariance matrix\nremains diagonal."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checkFeasableCount Determines how often new random objective variables are\ngenerated in case they are out of bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param random Random generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generateStatistics Whether statistic data is collected."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point unbounded point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return either underlying function value or penalty function value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bounded bounded function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower lower bounds for each element of the input parameters array\n(some elements may be set to {@code Double.NEGATIVE_INFINITY} for\nunbounded values)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper upper bounds for each element of the input parameters array\n(some elements may be set to {@code Double.POSITIVE_INFINITY} for\nunbounded values)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset base offset of the penalty function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale scale of the penalty function"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if lower bounds, upper bounds and\nscales are not consistent, either according to dimension or to bounadary\nvalues"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point at which the objective function must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective function value at the specified point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Allowed number of evaluations of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType Optimization type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link InitialGuess}</li>\n <li>{@link SimpleBounds}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value of the objective\nfunction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType Type of optimization goal: either\n{@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startPoint Start point for optimization."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value for objective\nfunction."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if all the elements in the array\n have already been returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array this iterator iterates over."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the start index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the end index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to iterate over."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if <code>array</code> is not an array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to iterate over."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startIndex the index to start iterating at."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if <code>array</code> is not an array."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to iterate over."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startIndex the index to start iterating at."
    },
    {
        "oracle": ";",
        "javadocTag": "@param endIndex the index to finish iterating at."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if <code>array</code> is not an array."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if either index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if there are more permutations, otherwise false"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of the permutator's elements representing a permutation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if there are no more permutations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to generate permutations for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the single object hasn't been returned yet"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the single object has been returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return 0 or 1 depending on current state."
    },
    {
        "oracle": ";",
        "javadocTag": "@return 0 or -1 depending on current state."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the single object"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the single object has already\n   been returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the single object"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the single object has not already\n   been returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the {@code next} or {@code previous}\n       method has not yet been called, or the {@code remove} method\n       has already been called after the last call to {@code next}\n       or {@code previous}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if {@code next} has not been called\n         or the object has been removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the single object to return from the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link MapIterator}<K, V>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if there is a next element to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next element in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if all the elements in the array\n   have already been returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array this iterator iterates over"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the start index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the end index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to iterate over"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to iterate over"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index to start iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the start index is out of bounds"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to iterate over"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index to start iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index (exclusive) to finish iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the start or end index is out of bounds"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if end index is before the start"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the underlying enumeration has more elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next object from the enumeration"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException <code>next()</code> not called."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if no associated collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the underlying enumeration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param enumeration the new underlying enumeration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param enumeration the enumeration to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param enumeration the enumeration to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection to remove elements from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if there are more elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next object"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if there are no elements\n        at all.  Use {@link #hasNext} to avoid this error."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current collection size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the underlying iterator has more elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next element from the underlying iterator."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.util.NoSuchElementException if the underlying iterator has\nno more elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the underlying iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the new underlying iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the single object hasn't been returned yet"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the single object"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the single object has already\n   been returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the {@code next} method has not\n       yet been called, or the {@code remove} method has already\n       been called after the last call to the {@code next}\n       method."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if remove is not supported"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the single object to return from the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the single object to return from the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the underlying iterator is not of\ntype {@link ListIterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if there are more elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if there are previous elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next element from the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if there are no more elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the next element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous element"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if there are no previous elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the previous element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the underlying iterator is not of\ntype {@link ListIterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to be decorated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset the index of the first element of the decorated iterator to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return OrderedIterator<E>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if there is a previous element to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous element"
    },
    {
        "oracle": "((start==null)==false) && (start.equals(end));",
        "javadocTag": "@throws MathIllegalArgumentException if the points are equal"
    },
    {
        "oracle": "((start==null)==false) && (start.equals(end));",
        "javadocTag": "@throws MathIllegalArgumentException if the points are equal"
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the input array is null or the array\nindex parameters are not valid"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "x==null || y==null;",
        "javadocTag": "@throws NullArgumentException if {@code x} or {@code y} are {@code null}."
    },
    {
        "oracle": "x.length==0 || y.length==0;",
        "javadocTag": "@throws NoDataException if {@code x} or {@code y} are zero-length."
    },
    {
        "oracle": "x==null || y==null;",
        "javadocTag": "@throws NullArgumentException if {@code x} or {@code y} are {@code null}."
    },
    {
        "oracle": "x.length==0 || y.length==0;",
        "javadocTag": "@throws NoDataException if {@code x} or {@code y} are zero-length."
    },
    {
        "oracle": "exactPValue==true;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code exactPValue} is {@code true}\nand {@code x.length} > 30"
    },
    {
        "oracle": "points==null;",
        "javadocTag": "@throws NullArgumentException if the input collection is {@code null}"
    },
    {
        "oracle": "x.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the size of {@code x} is smaller\nthan 2."
    },
    {
        "oracle": "maxIter<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code maxIter <= 0}."
    },
    {
        "oracle": "maxIter<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code maxIter <= 0}."
    },
    {
        "oracle": "a==null || c==null;",
        "javadocTag": "@throws NullArgumentException if any argument is {@code null}."
    },
    {
        "oracle": "a.length==0 || c.length==0;",
        "javadocTag": "@throws NoDataException if any array has zero length."
    },
    {
        "oracle": "a==null || c==null;",
        "javadocTag": "@throws NullArgumentException if any argument is {@code null}."
    },
    {
        "oracle": "a.length==0 || c.length==0;",
        "javadocTag": "@throws NoDataException if any array has zero length."
    },
    {
        "oracle": "a==null || c==null;",
        "javadocTag": "@throws NullArgumentException if any argument is {@code null}."
    },
    {
        "oracle": "a.length==0 || c.length==0;",
        "javadocTag": "@throws NoDataException if any array has zero length."
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "c==null;",
        "javadocTag": "@throws NullArgumentException if {@code c} is {@code null}."
    },
    {
        "oracle": "c.length==0;",
        "javadocTag": "@throws NoDataException if {@code c} is empty."
    },
    {
        "oracle": "coefficients.length==0;",
        "javadocTag": "@throws NoDataException if {@code coefficients} is empty."
    },
    {
        "oracle": "coefficients==null;",
        "javadocTag": "@throws NullArgumentException if {@code coefficients} is {@code null}."
    },
    {
        "oracle": "this.getCoefficients().length==0;",
        "javadocTag": "@throws NoDataException if {@code coefficients} is empty."
    },
    {
        "oracle": "this.getCoefficients()==null;",
        "javadocTag": "@throws NullArgumentException if {@code coefficients} is {@code null}."
    },
    {
        "oracle": "coefficients.length==0;",
        "javadocTag": "@throws NoDataException if {@code coefficients} is empty."
    },
    {
        "oracle": "coefficients==null;",
        "javadocTag": "@throws NullArgumentException if {@code coefficients} is {@code null}."
    },
    {
        "oracle": "coefficients.length==1 ? methodResultID==null : true;",
        "javadocTag": "@return the coefficients of the derivative or {@code null} if coefficients has length 1."
    },
    {
        "oracle": "true ? methodResultID!=null : true;",
        "javadocTag": "@return vertices of the polygon, organized as oriented boundary\nloops with the open loops first (the returned value is guaranteed\nto be non-null)"
    },
    {
        "oracle": "true ? methodResultID==false : true;",
        "javadocTag": "@return {@code false}"
    },
    {
        "oracle": "chromosomes==null;",
        "javadocTag": "@throws NullArgumentException if the list of chromosomes is {@code null}"
    },
    {
        "oracle": "fuzziness<=1.0;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code fuzziness <= 1.0}"
    },
    {
        "oracle": "fuzziness>1.0;",
        "javadocTag": "@param fuzziness the fuzziness factor, must be &gt; 1.0"
    },
    {
        "oracle": "fuzziness<=1.0;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code fuzziness <= 1.0}"
    },
    {
        "oracle": "fuzziness>1.0;",
        "javadocTag": "@param fuzziness the fuzziness factor, must be &gt; 1.0"
    },
    {
        "oracle": "fuzziness<=1.0;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code fuzziness <= 1.0}"
    },
    {
        "oracle": "fuzziness>1.0;",
        "javadocTag": "@param fuzziness the fuzziness factor, must be &gt; 1.0"
    },
    {
        "oracle": "dataPoints==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the data points are null or the number\n    of clusters is larger than the number of data points"
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "bytes!=null;",
        "javadocTag": "@param bytes the non-null byte array in which to put the\nrandom bytes"
    },
    {
        "oracle": "n<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code n <= 0}."
    },
    {
        "oracle": "n>0;",
        "javadocTag": "@param n the bound on the random number to be returned.  Must be\npositive."
    },
    {
        "oracle": "x0>x1;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code x0 > x1}.\n\nThe default implementation uses the identity\n{@code P(x0 < X <= x1) = P(X <= x1) - P(X <= x0)}"
    },
    {
        "oracle": "initValue<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code initValue <= 0}."
    },
    {
        "oracle": "slope>=0;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code slope >= 0}."
    },
    {
        "oracle": "numCall<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code numCall <= 0}."
    },
    {
        "oracle": "(this.getValuesFileURL()!=null) == false;",
        "javadocTag": "@throws NullArgumentException if the {@code valuesFileURL} has not been set"
    },
    {
        "oracle": "(this.getValuesFileURL()!=null) == false;",
        "javadocTag": "@throws NullArgumentException if the {@code valuesFileURL} has not been set"
    },
    {
        "oracle": "(this.getValuesFileURL()!=null) == false;",
        "javadocTag": "@throws NullPointerException if the {@code valuesFileURL} has not been set."
    },
    {
        "oracle": "stepSize<=0;",
        "javadocTag": "@throws NotPositiveException if {@code stepsize <= 0} (note that\n{@link NotPositiveException} extends {@link NumberIsTooSmallException})"
    },
    {
        "oracle": "nbPoints<=1;",
        "javadocTag": "@throws NumberIsTooSmallException {@code nbPoint <= 1}"
    },
    {
        "oracle": "stepSize<=0;",
        "javadocTag": "@throws NotPositiveException if {@code stepsize <= 0} (note that\n{@link NotPositiveException} extends {@link NumberIsTooSmallException})"
    },
    {
        "oracle": "nbPoints<=1;",
        "javadocTag": "@throws NumberIsTooSmallException {@code nbPoint <= 1}"
    },
    {
        "oracle": "stepSize>=tUpper;",
        "javadocTag": "@throws NumberIsTooLargeException {@code stepSize * (nbPoints - 1) >= tUpper - tLower}"
    },
    {
        "oracle": "format==null;",
        "javadocTag": "@throws NullArgumentException if {@code format} is {@code null}."
    },
    {
        "oracle": "(((matrix==null)==false) && (matrix.isSquare())) == false;",
        "javadocTag": "@throws NonSquareMatrixException if the matrix is not square"
    },
    {
        "oracle": "eps<0.0 || minPts<0;",
        "javadocTag": "@throws NotPositiveException if {@code eps < 0.0} or {@code minPts < 0}"
    },
    {
        "oracle": "eps<0.0 || minPts<0;",
        "javadocTag": "@throws NotPositiveException if {@code eps < 0.0} or {@code minPts < 0}"
    },
    {
        "oracle": "points==null;",
        "javadocTag": "@throws NullArgumentException if the data points are null"
    },
    {
        "oracle": "n==0;",
        "javadocTag": "@throws ZeroException if {@code n = 0}"
    },
    {
        "oracle": "max<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code max <= 0}."
    },
    {
        "oracle": "upper<p;",
        "javadocTag": "@param lower a value satisfying {@code cumulativeProbability(lower) < p}"
    },
    {
        "oracle": "true ? methodResultID.equals(this.atanh()) : true;",
        "javadocTag": "@return atan2(this, x)"
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "d.length==0;",
        "javadocTag": "@throws ZeroException if {@code d} is empty."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "d.length==0;",
        "javadocTag": "@throws ZeroException if {@code d} is empty."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "v==null;",
        "javadocTag": "@throws NullArgumentException if {@code v} is {@code null}."
    },
    {
        "oracle": "v==null;",
        "javadocTag": "@throws NullArgumentException if {@code v} is {@code null}."
    },
    {
        "oracle": "v==null;",
        "javadocTag": "@throws NullArgumentException if {@code v} is {@code null}."
    },
    {
        "oracle": "v1==null || v2==null;",
        "javadocTag": "@throws NullArgumentException if {@code v1} or {@code v2} is\n{@code null}."
    },
    {
        "oracle": "v1==null || v2==null;",
        "javadocTag": "@throws NullArgumentException if {@code v1} or {@code v2} is\n{@code null}."
    },
    {
        "oracle": "v1==null || v2==null;",
        "javadocTag": "@throws NullArgumentException if {@code v1} or {@code v2} is\n{@code null}."
    },
    {
        "oracle": "v1==null || v2==null;",
        "javadocTag": "@throws NullArgumentException if {@code v1} or {@code v2} is\n{@code null}."
    },
    {
        "oracle": "v1==null || v2==null;",
        "javadocTag": "@throws NullArgumentException if {@code v1} or {@code v2} is\n{@code null}."
    },
    {
        "oracle": "v1==null || v2==null;",
        "javadocTag": "@throws NullArgumentException if {@code v1} or {@code v2} is\n{@code null}."
    },
    {
        "oracle": "v1==null || v2==null;",
        "javadocTag": "@throws NullArgumentException if {@code v1} or {@code v2} is\n{@code null}."
    },
    {
        "oracle": "v1==null || v2==null;",
        "javadocTag": "@throws NullArgumentException if {@code v1} or {@code v2} is\n{@code null}."
    },
    {
        "oracle": "end<start;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}."
    },
    {
        "oracle": "end<start;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}."
    },
    {
        "oracle": "end<start;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}."
    },
    {
        "oracle": "end<start;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}."
    },
    {
        "oracle": "(rowDimension>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if row or column dimension is not\npositive."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if the array is {@code null}."
    },
    {
        "oracle": "d.length==0;",
        "javadocTag": "@throws NoDataException if the array is empty."
    },
    {
        "oracle": "d.length==0;",
        "javadocTag": "@throws NoDataException if array is empty."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "selectedRows==null || selectedColumns==null;",
        "javadocTag": "@throws NullArgumentException if the arrays are {@code null}."
    },
    {
        "oracle": "(this.isSupported(name)) == false;",
        "javadocTag": "@throws UnknownParameterException if the parameter is not supported"
    },
    {
        "oracle": "true ? methodResultID.equals(highOrder) : true;",
        "javadocTag": "@return updated high order derivatives"
    },
    {
        "oracle": "initialStepSize>0;",
        "javadocTag": "@param initialStepSize initial step size to use (must be positive even\nfor backward integration ; providing a negative value or a value\noutside of the min/max step interval will lead the integrator to\nignore the value and compute the initial step size by itself)"
    },
    {
        "oracle": "newInitialStepBoundFactor==100.0;",
        "javadocTag": "@param newInitialStepBoundFactor Positive input variable used in\ndetermining the initial step bound. This bound is set to the\nproduct of initialStepBoundFactor and the euclidean norm of\n{@code diag * x} if non-zero, or else to {@code newInitialStepBoundFactor}\nitself. In most cases factor should lie in the interval\n{@code (0.1, 100.0)}. {@code 100} is a generally recommended value.\nof the matrix is reduced."
    },
    {
        "oracle": "f==null || startPoint==null;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NullArgumentException if\n{@code f}, {@code goalType} or {@code startPoint} is {@code null}."
    },
    {
        "oracle": "numComponents<2;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code numComponents < 2}."
    },
    {
        "oracle": "abs<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code abs <= 0}."
    },
    {
        "oracle": "abs<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code abs <= 0}."
    },
    {
        "oracle": "abs<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code abs <= 0}."
    },
    {
        "oracle": "abs<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code abs <= 0}."
    },
    {
        "oracle": "dimension<1 || dimension>1000;",
        "javadocTag": "@throws OutOfRangeException if the space dimension is outside the allowed range of [1, 1000]"
    },
    {
        "oracle": "index<0;",
        "javadocTag": "@throws NotPositiveException if index &lt; 0"
    },
    {
        "oracle": "lo>=hi;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lo >= hi}."
    },
    {
        "oracle": "init<lo;",
        "javadocTag": "@throws OutOfRangeException if {@code init < lo} or {@code init > hi}."
    },
    {
        "oracle": "lo>=hi;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lo >= hi}."
    },
    {
        "oracle": "sigma<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code sigma <= 0}."
    },
    {
        "oracle": "sigma<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code sigma <= 0}."
    },
    {
        "oracle": "format==null;",
        "javadocTag": "@throws NullArgumentException if {@code format} is {@code null}."
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "length==0 ? methodResultID==0 : true;",
        "javadocTag": "@return the sum of the squares of the values or 0 if length = 0"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "f==null || goalType==null || startPoint==null;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NullArgumentException if\nany argument is {@code null}."
    },
    {
        "oracle": "(n>0) == false;",
        "javadocTag": "@throws NotPositiveException if the number of elements is not positive."
    },
    {
        "oracle": "end<start;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}"
    },
    {
        "oracle": "this.getNorm()==0;",
        "javadocTag": "@throws MathArithmeticException if the norm is zero."
    },
    {
        "oracle": "this.getNorm()==0;",
        "javadocTag": "@throws MathArithmeticException if the norm is zero."
    },
    {
        "oracle": "end<start;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}."
    },
    {
        "oracle": "end<start;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}."
    },
    {
        "oracle": "end<start;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}."
    },
    {
        "oracle": "end<start;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}."
    },
    {
        "oracle": "initialStepBoundFactor==100.0;",
        "javadocTag": "@param initialStepBoundFactor Positive input variable used in\ndetermining the initial step bound. This bound is set to the\nproduct of initialStepBoundFactor and the euclidean norm of\n{@code diag * x} if non-zero, or else to {@code initialStepBoundFactor}\nitself. In most cases factor should lie in the interval\n{@code (0.1, 100.0)}. {@code 100} is a generally recommended value."
    },
    {
        "oracle": "initialStepBoundFactor==100.0;",
        "javadocTag": "@param initialStepBoundFactor Positive input variable used in\ndetermining the initial step bound. This bound is set to the\nproduct of initialStepBoundFactor and the euclidean norm of\n{@code diag * x} if non-zero, or else to {@code initialStepBoundFactor}\nitself. In most cases factor should lie in the interval\n{@code (0.1, 100.0)}. {@code 100} is a generally recommended value."
    },
    {
        "oracle": "minimalStep>0;",
        "javadocTag": "@param minimalStep minimal step (must be positive even for backward\nintegration), the last step can be smaller than this"
    },
    {
        "oracle": "maximalStep>0;",
        "javadocTag": "@param maximalStep maximal step (must be positive even for backward\nintegration)"
    },
    {
        "oracle": "minimalStep>0;",
        "javadocTag": "@param minimalStep minimal step (must be positive even for backward\nintegration), the last step can be smaller than this"
    },
    {
        "oracle": "maximalStep>0;",
        "javadocTag": "@param maximalStep maximal step (must be positive even for backward\nintegration)"
    },
    {
        "oracle": "optimizer==null || generator==null;",
        "javadocTag": "@throws NullArgumentException if {@code optimizer} or {@code generator}\nis {@code null}."
    },
    {
        "oracle": "starts<1;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code starts < 1}."
    },
    {
        "oracle": "starts==1;",
        "javadocTag": "@param starts Number of starts to perform. If {@code starts == 1},\nthe {@link #optimize(int,MultivariateFunction,GoalType,double[])\noptimize} will return the same solution as {@code optimizer} would."
    },
    {
        "oracle": "this.isEmpty() ? methodResultID==null : true;",
        "javadocTag": "@return the tree node containing the smallest element in the tree\nor null if the tree is empty"
    },
    {
        "oracle": "this.isEmpty() ? methodResultID==null : true;",
        "javadocTag": "@return the tree node containing the largest element in the tree\nor null if the tree is empty"
    },
    {
        "oracle": "this.isEmpty() ? methodResultID==null : true;",
        "javadocTag": "@return the tree node containing the smallest element not smaller\nthan the reference object or null if either the tree is empty or\nall its elements are smaller than the reference object"
    },
    {
        "oracle": "this.isEmpty() ? methodResultID==null : true;",
        "javadocTag": "@return the tree node containing the largest element not larger\nthan the reference object (in which case the node is guaranteed\nnot to be empty) or null if either the tree is empty or all its\nelements are larger than the reference object"
    },
    {
        "oracle": "f==null || goalType==null || startPoint==null;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NullArgumentException if\nany argument is {@code null}."
    },
    {
        "oracle": "degreesOfFreedom<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code degreesOfFreedom <= 0}"
    },
    {
        "oracle": "degreesOfFreedom<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code degreesOfFreedom <= 0}"
    },
    {
        "oracle": "degreesOfFreedom<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code degreesOfFreedom <= 0}"
    },
    {
        "oracle": "degreesOfFreedom<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code degreesOfFreedom <= 0}"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "true ? methodResultID.equals(checker) : true;",
        "javadocTag": "@return a convergence checker that delegates to {@code checker}."
    },
    {
        "oracle": "(r>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if the number of successes is not positive"
    },
    {
        "oracle": "p<0 || p>1;",
        "javadocTag": "@throws OutOfRangeException if the probability of success is not in the\nrange {@code [0, 1]}."
    },
    {
        "oracle": "(r>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if the number of successes is not positive"
    },
    {
        "oracle": "p<0 || p>1;",
        "javadocTag": "@throws OutOfRangeException if the probability of success is not in the\nrange {@code [0, 1]}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "true ? methodResultID.equals(point) : true;",
        "javadocTag": "@return projected point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return real value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a right hand side parameter of the operator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this+a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a right hand side parameter of the operator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this-a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a right hand side parameter of the operator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this&times;a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a right hand side parameter of the operator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this&divide;a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a right hand side parameter of the operator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this - n &times; a where n is the closest integer to this/a\n(the even integer is chosen for n if this/a is halfway between two integers)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a right hand side parameter of the operator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this - n &times; a where n is the closest integer to this/a\n(the even integer is chosen for n if this/a is halfway between two integers)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters or orders are inconsistent"
    },
    {
        "oracle": ";",
        "javadocTag": "@return abs(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ceil(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return floor(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a double number r such that r is an integer r - 0.5 &le; this &le; r + 0.5"
    },
    {
        "oracle": ";",
        "javadocTag": "@return closest long to {@link #getReal()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sign the sign for the returned value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the instance with the same sign as the {@code sign} argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sign the sign for the returned value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the instance with the same sign as the {@code sign} argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n power of 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this &times; 2<sup>n</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y a value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sqrt(<i>this</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters or orders are inconsistent"
    },
    {
        "oracle": ";",
        "javadocTag": "@return square root of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return cubic root of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n order of the root"
    },
    {
        "oracle": ";",
        "javadocTag": "@return n<sup>th</sup> root of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p power to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this<sup>p</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n power to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this<sup>n</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e exponent"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this<sup>e</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if number of free parameters or orders are inconsistent"
    },
    {
        "oracle": ";",
        "javadocTag": "@return exponential of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return exponential minus one of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return logarithm of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return logarithm of one plus the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return cos(this)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex vertex in one of the graphs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward if true, uses mapping from graph1 to graph2; if false, use\nmapping from graph2 to graph1"
    },
    {
        "oracle": ";",
        "javadocTag": "@return corresponding vertex in other graph, or null if none"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge edge in one of the graphs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward if true, uses mapping from graph1 to graph2; if false, use\nmapping from graph2 to graph1"
    },
    {
        "oracle": ";",
        "javadocTag": "@return corresponding edge in other graph, or null if none"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the vertex event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the vertex event."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the traversed edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eventSource the source of the event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the traversed edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the traversal event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the traversal event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the edge traversal event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the vertex traversal event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the vertex traversal event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eventSource the source of this event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the event type of this event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge that this event is related to."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eventSource the source of this event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the event type of this event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge that this event is related to."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeSource edge source vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeTarget edge target vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the traversed vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eventSource the source of the event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the traversed vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the event type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eventSource the source of the event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the edge event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the edge event."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the event type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eventSource the source of the event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of event."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the vertex that this event is related to."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eventSource the source of the event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of the event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex that the event is related to."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex vertex in the initial graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex vertex in the initial graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex vertex in the initial graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertex the source vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex the target vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param simplePathsOnly if true, only search simple\n(non-self-intersecting) paths"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxPathLength maximum number of edges to allow in a path (if null,\nall paths are considered, which may be very slow due to potentially huge\noutput)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertices the source vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertices the target vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param simplePathsOnly if true, only search simple\n(non-self-intersecting) paths"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxPathLength maximum number of edges to allow in a path (if null,\nall paths are considered, which may be very slow due to potentially huge\noutput)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of all paths from the sources to the targets containing no\nmore than maxPathLength edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertices the target vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxPathLength maximum number of edges to allow in a path (if null,\nall edges will be considered, which may be expensive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the minimum number of edges in a path from each edge to the\ntargets, encoded in a Map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertices the source vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertices the target vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxPathLength maximum number of edges to allow in a path"
    },
    {
        "oracle": ";",
        "javadocTag": "@param simplePathsOnly if true, only search simple\n(non-self-intersecting) paths (if null, all edges will be considered,\nwhich may be expensive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeMinDistancesFromTargets the minimum number of edges in a path\nto a target through each edge, as computed by {@code\nedgeMinDistancesBackwards}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a List of all GraphPaths from the sources to the targets\nsatisfying the given constraints"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edges the edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the corresponding GraphPath"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if at least one path has been improved during\nthe previous pass, <code>false</code> otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param endVertex end vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of <code>RankingPathElement</code>, or <code>null</code> of\nno path exists between the start vertex and the end vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex a vertex which has just been encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge via which the vertex was encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex "
    },
    {
        "oracle": ";",
        "javadocTag": "@return ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex vertex reached by a path."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge edge reaching the vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex a vertex which has just been encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge via which the vertex was encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex "
    },
    {
        "oracle": ";",
        "javadocTag": "@param improvedVertices "
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph graph on which shortest paths are searched."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex start vertex of the calculated paths."
    },
    {
        "oracle": ";",
        "javadocTag": "@param endVertex end vertex of the calculated paths."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize number of paths stored at end vertex of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@return minimum spanning-tree edges set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return minimum spanning-tree total weight"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the graph to be searched"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the graph inspected by this StrongConnectivityAlgorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the graph is strongly connected, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>List</code> of <code>Set</code> s containing the strongly\nconnected components"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of subgraphs representing the strongly connected\ncomponents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param directedGraph the graph to inspect"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException "
    },
    {
        "oracle": ";",
        "javadocTag": "@return false, if there are no more pairs left"
    },
    {
        "oracle": ";",
        "javadocTag": "@return is the matching already complete?"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are isomorphic to the already matched vertices of\ngraph2 and the second one vertex of nextPair."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 "
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 "
    },
    {
        "oracle": ";",
        "javadocTag": "@return v1 and v2 are equivalent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 "
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 "
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 "
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 "
    },
    {
        "oracle": ";",
        "javadocTag": "@return edges are equivalent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hP step for Jacobian finite difference computation w.r.t. the specified parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnknownParameterException if the parameter is not supported"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dYdY0 initial Jacobian matrix w.r.t. state"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if matrix dimensions are incorrect"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pName parameter name"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dYdP initial Jacobian column vector with respect to the parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnknownParameterException if a parameter is not supported"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the column vector does not match state dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dYdY0 current Jacobian matrix with respect to state."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pName name of the parameter for the computed Jacobian matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dYdP current Jacobian matrix with respect to the named parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected expected dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array (may be null if expected is 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array dimension does not match the expected one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fode the primary first order differential equations set to extend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hY step used for finite difference computation with respect to state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters parameters to consider for Jacobian matrices processing\n(may be null if parameters Jacobians is not desired)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if there is a dimension mismatch between\nthe steps array {@code hY} and the equation dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param jode the primary first order differential equations set to extend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters parameters to consider for Jacobian matrices processing\n(may be null if parameters Jacobians is not desired)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator for the last accepted step. For\nefficiency purposes, the various integrators reuse the same\nobject on each call, so if the instance wants to keep it across\nall calls (for example to provide at the end of the integration a\ncontinuous model valid throughout the integration range), it\nshould build a local copy using the clone method and store this\ncopy."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the interpolator throws one because\nthe number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nextTime the next normalized time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator for the last accepted step, to use to\nget the end time of the current step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value indicating whether the next normalized time is in the\ncurrent step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isLast true if the step is the last one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator for the last accepted step, to use to\nget the interpolated information"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t the time for which to store the interpolated information"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the interpolator throws one because\nthe number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h fixed time step (sign is not used)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler fixed time step handler to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h fixed time step (sign is not used)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler fixed time step handler to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mode step normalizer mode to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h fixed time step (sign is not used)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler fixed time step handler to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bounds step normalizer bounds setting to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h fixed time step (sign is not used)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler fixed time step handler to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mode step normalizer mode to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bounds step normalizer bounds setting to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 start value of the independent <i>time</i> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 array containing the start value of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t target time for the integration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t time of the current step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y state vector at t. For efficiency purposes, the {@link\nStepNormalizer} class reuses the same array on each call, so if\nthe instance wants to keep it across all calls (for example to\nprovide at the end of the integration a complete array of all\nsteps), it should build a local copy store this copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot derivatives of the state vector state vector at t.\nFor efficiency purposes, the {@link StepNormalizer} class reuses\nthe same array on each call, so if\nthe instance wants to keep it across all calls (for example to\nprovide at the end of the integration a complete array of all\nsteps), it should build a local copy store this copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 start value of the independent <i>time</i> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 array containing the start value of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t target time for the integration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator for the last accepted step. For\nefficiency purposes, the various integrators reuse the same\nobject on each call, so if the instance wants to keep it across\nall calls (for example to provide at the end of the integration a\ncontinuous model valid throughout the integration range, as the\n{@link org.apache.commons.math3.ode.ContinuousOutputModel\nContinuousOutputModel} class does), it should build a local copy\nusing the clone method of the interpolator and store this copy.\nKeeping only a reference to the interpolator and reusing it will\nresult in unpredictable behavior (potentially crashing the application)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the interpolator throws one because\nthe number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the only instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator for the last accepted step. For\nefficiency purposes, the various integrators reuse the same\nobject on each call, so if the instance wants to keep it across\nall calls (for example to provide at the end of the integration a\ncontinuous model valid throughout the integration range), it\nshould build a local copy using the clone method and store this\ncopy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return state at previous grid point time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return state at current grid point time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time time of the interpolated point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return state at interpolated time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the integration variable (time) increases during\nintegration"
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous grid point time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current grid point time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return interpolation point time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time time of the interpolated point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return state vector at time {@link #getInterpolatedTime}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@return derivatives of the state vector at time {@link #getInterpolatedTime}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the secondary set, as returned by {@link\norg.apache.commons.math3.ode.ExpandableStatefulODE#addSecondaryEquations(\norg.apache.commons.math3.ode.SecondaryEquations)\nExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return interpolated secondary state at the current interpolation date"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the secondary set, as returned by {@link\norg.apache.commons.math3.ode.ExpandableStatefulODE#addSecondaryEquations(\norg.apache.commons.math3.ode.SecondaryEquations)\nExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return interpolated secondary derivatives at the current interpolation date"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the integration variable (time) increases during\nintegration"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a deep copy of the instance, which can be used independently."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded\nduring step finalization"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param currentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return restricted version of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newForward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newGlobalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newGlobalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newSoftPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newSoftCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newMapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous global grid point state"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current global grid point state"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equationsMapper mapper for ODE equations primary and secondary components"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time interpolation time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param theta normalized interpolation abscissa within the step\n(theta is zero at the previous time step and one at the current time step)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param thetaH time gap between the previous time and the interpolated time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param oneMinusThetaH time gap between the interpolated time and\nthe current time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return interpolated state and derivatives"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isForward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u3 third base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u3 third base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u3 third base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u3 third base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a4 fourth scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u4 fourth base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u3 third base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a4 fourth scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u4 fourth base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u3 third base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a4 fourth scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u4 fourth base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ort orthogonal rotation matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return quaternion corresponding to the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation whose effect is the reverse of the effect\nof the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return scalar coordinate of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@return first coordinate of the vectorial part of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@return second coordinate of the vectorial part of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@return third coordinate of the vectorial part of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@return normalized axis of the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convention convention to use for the semantics of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return normalized axis of the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return angle of the rotation (between 0 and &pi;)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order rotation order to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of three angles, in the order specified by the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CardanEulerSingularityException if the rotation is\nsingular with respect to the angles set specified"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order rotation order to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convention convention to use for the semantics of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of three angles, in the order specified by the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CardanEulerSingularityException if the rotation is\nsingular with respect to the angles set specified"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the matrix corresponding to the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u vector to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector which is the image of u by the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in an array with three items which stores vector to rotate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out an array with three items to put result to (it can be the same\narray as in)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u vector to apply the inverse of the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector which such that u is its image by the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in an array with three items which stores vector to rotate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out an array with three items to put result to (it can be the same\narray as in)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convention convention to use for the semantics of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the instance\nusing vector operator convention"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the inverse\nof the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convention convention to use for the semantics of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the inverse\nof the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r rotation to apply the rotation to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation which is the composition of r by the inverse\nof the instance using vector operator convention"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m initial matrix (not exactly orthogonal)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold convergence threshold for the iterative\northogonality correction (convergence is reached when the\ndifference between two steps of the Frobenius norm of the\ncorrection is below this threshold)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The input to convert."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The value or -1 if the conversion failed. TODO should be named\n        convertNumber"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value A Number or a CharSequence."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id A string that identifies an element of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param clazz A string that matches all elements of a given class."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pseudoClass A string that matches all elements of a given pseudo-class."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An element type."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The identifier or null if the selector is general."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A class name or null if the selector is general."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A pseudo-class name or null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param type The element type of this selector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param type The element type of this selector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier The element name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param clazz The element class."
    },
    {
        "oracle": ";",
        "javadocTag": "@param type Either \"node\", \"edge\", \"graph\" or \"sprite\"."
    },
    {
        "oracle": ";",
        "javadocTag": "@param other The other selector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param units The value units."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param other The other value to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The rule style."
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier The identifier to test for the match."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if matching."
    },
    {
        "oracle": ";",
        "javadocTag": "@param style A style specification."
    },
    {
        "oracle": ";",
        "javadocTag": "@param groupId The group unique identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param groupId The group unique identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param selector The rule selector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The object to convert."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attributes The node attribute set (can be null)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A style group identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The type of the style group elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if one property is dynamic."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the group contains some elements changed by an event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to test."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the element has actually active events."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to test."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the element has actually specific style attributes."
    },
    {
        "oracle": ";",
        "javadocTag": "@param property The style property the value is searched for."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the group is empty of elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elementId The element to search."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the element is in the group."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to search."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the element is in the group."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The searched element identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The element corresponding to the identifier or null if not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The element count."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The elements iterator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return All the elements in no particular order."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The iterable set of bulk elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The subset of elements modified by one or more events."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The subset of dynamic elements of the group."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A renderer or null if not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A set of events or null if none occurring at that time."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The new graph element to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to remove."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The removed element, or null if the element was not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to modify with an event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event The event to push."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event The event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to push events for."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The renderer identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param renderer The renderer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The renderer identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The removed renderer or null if not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier The unique group identifier (see\n           {@link org.graphstream.ui.graphicGraph.stylesheet.StyleSheet#getStyleGroupIdFor(Element, ArrayList)}\n           )."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rules The set of style rules for the style group (see\n           {@link org.graphstream.ui.graphicGraph.stylesheet.StyleSheet#getRulesFor(Element)}\n           )."
    },
    {
        "oracle": ";",
        "javadocTag": "@param firstElement The first element to construct the group."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A newly allocated array of three floats containing the (x,y,z)\n        position of the node, or null if the node is not part of the\n        graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A newly allocated point containing the (x,y,z)\n        position of the node, or null if the node is not part of the\n        graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node The node to consider."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A newly allocated array of three floats containing the (x,y,z)\n        position of the node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node The node to consider."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A newly allocated point containing the (x,y,z)\n        position of the node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xyz An array of at least three cells."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws RuntimeException If the node with the given identifier does not exist."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos A point that will receive the node position."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws RuntimeException If the node with the given identifier does not exist."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node The node to consider."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xyz An array of at least three cells."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node The node to consider."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos A point that will receive the node position."
    },
    {
        "oracle": ";",
        "javadocTag": "@param o The object to try to convert."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xyz The result."
    },
    {
        "oracle": ";",
        "javadocTag": "@param o The object to try to convert."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos The result."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The identifier of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The edge length or -1 if the nodes of the edge have no positions."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws RuntimeException If the edge cannot be found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge "
    },
    {
        "oracle": ";",
        "javadocTag": "@return The edge length or -1 if the nodes of the edge have no positions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n One of the node of this edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The other node of this edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InterruptedException if interrupted while waiting"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the monitor was entered, which guarantees that the guard is now satisfied"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the monitor was entered, which guarantees that the guard is now satisfied"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the monitor was entered, which guarantees that the guard is now satisfied"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InterruptedException if interrupted while waiting"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InterruptedException if interrupted while waiting"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fair whether this monitor should use a fair ordering policy rather than a non-fair (but\n       fast) one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param callable the callable task"
    },
    {
        "oracle": ";",
        "javadocTag": "@param runnable the runnable task"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code ListenableFuture} representing pending completion of the task"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws RejectedExecutionException {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code ListenableFuture} representing pending completion of the task"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws RejectedExecutionException {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code ListenableFuture} representing pending completion of the task"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws RejectedExecutionException {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return A list of {@code ListenableFuture} instances representing the tasks, in the same\n        sequential order as produced by the iterator for the given task list, each of which has\n        completed."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws RejectedExecutionException {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of {@code ListenableFuture} instances representing the tasks, in the same\n        sequential order as produced by the iterator for the given task list. If the operation\n        did not time out, each task will have completed. If it did time out, some of these\n        tasks will not have completed."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws RejectedExecutionException {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the result of executing the future."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws X on interruption, cancellation or execution exceptions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the result of executing the future."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TimeoutException if retrieving the result timed out."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws X on interruption, cancellation or execution exceptions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k0 the first half of the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k1 the second half of the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimumBits a positive integer (can be arbitrarily large)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash function, described above, that produces hash codes of length {@code\n    minimumBits} or greater"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code hashCodes} is empty, or the hash codes\n    do not all have the same bit length"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code hashCodes} is empty, or the hash codes\n    do not all have the same bit length"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest the byte array into which the hash code will be written"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset the start offset in the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxLength the maximum number of bytes to write"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of bytes written to {@code dest}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if there is not enough room in {@code dest}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b a byte"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bytes a byte array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bytes a byte array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param off the start offset in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len the number of bytes to write"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the bloom filter's bits changed as a result of this operation. If the bits\n    changed, this is <i>definitely</i> the first time {@code object} has been added to the\n    filter. If the bits haven't changed, this <i>might</i> be the first time {@code object}\n    has been added to the filter. Note that {@code put(t)} always returns the\n    <i>opposite</i> result to what {@code mightContain(t)} would have returned at the time\n    it is called.\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param that The bloom filter to check for compatibility."
    },
    {
        "oracle": ";",
        "javadocTag": "@param that The bloom filter to combine this bloom filter with. It is not mutated."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code isCompatible(that) == false}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param funnel the funnel of T's that the constructed {@code BloomFilter<T>} will use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code BloomFilter}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param funnel the funnel of T's that the constructed {@code BloomFilter<T>} will use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code BloomFilter}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param funnel the funnel of T's that the constructed {@code BloomFilter<T>} will use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code BloomFilter}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param funnel the funnel of T's that the constructed {@code BloomFilter<T>} will use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code BloomFilter}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p false positive rate (must be 0 < p < 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if the InputStream throws an {@code IOException}, or if its data does\n    not appear to be a BloomFilter serialized using the\n    {@linkplain #writeTo(OutputStream)} method."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException this operation is not supported"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if the attempt to read class path resources (jar files or directories)\n        failed."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExceptionInInitializerError if an exception is thrown during\n  initialization of a class"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code interfaceType} does not specify\n    the type of a Java interface"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <X> The parameter type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param typeParam the parameter type variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param typeArg the actual type to substitute"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <X> The parameter type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param typeParam the parameter type variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param typeArg the actual type to substitute"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value previously associated with this class (possibly {@code null}),\n        or {@code null} if there was no previous entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value previously associated with this type (possibly {@code null}),\n        or {@code null} if there was no previous entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@param formal The type whose type variables or itself is mapped to other type(s). It's almost\n       always a bug if {@code formal} isn't a type variable and contains no type variable. Make\n       sure you are passing the two parameters in the right order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param actual The type that the formal type variable(s) are mapped to. It can be or contain yet\n       other type variables, in which case these type variables will be further resolved if\n       corresponding mappings exist in the current {@code TypeResolver} instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of opening the reader"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of opening the reader"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading the length of this source"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading from this source or\n    writing to {@code appendable}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading from this source or\n    writing to {@code sink}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading from this source"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading from this source"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading from this source"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading from this source or if\n    {@code processor} throws an {@code IOException}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sources the sources to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code CharSource} containing the concatenated data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sources the sources to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code CharSource} containing the concatenated data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sources the sources to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code CharSource} containing the concatenated data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of opening the writer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of opening the writer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error in the process of writing to this sink"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of writing to this sink"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of writing to this sink"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading from {@code readable} or\n    writing to this sink"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target target to which to append output"
    },
    {
        "oracle": ";",
        "javadocTag": "@param it an iterator of I/O suppliers that will provide each substream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of opening the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of opening the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O occurs in the process of writing to this sink"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O occurs in the process of reading from {@code input} or writing to\n    this sink"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this method does not return; it always throws"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key5 the fifth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value mapped to the removed key, null if key not in map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key5 the fifth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key5 the fifth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the key matches"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if any elements were removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if any elements were removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if any elements were removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if any elements were removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a shallow clone"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value for the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the key is not a MultiKey"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapToCopy to this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if any key in mapToCopy is not a MultiKey"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a shallow clone"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new lazy map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new lazy map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeToLive the constant amount of time an entry is available\n       before it expires. A negative value results in entries that NEVER\n       expire. A zero value results in entries that ALWAYS expire."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeUnit the unit of time for the <code>timeToLive</code>\n       parameter, must not be null."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the time unit is null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param now the time in milliseconds used to compare against the\n       expiration time."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expirationTimeObject the expiration time value retrieved from\n       {@link #expirationMap}, can be null."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if <code>expirationTimeObject</code> is &ge; 0\n        and <code>expirationTimeObject</code> &lt; <code>now</code>.\n        <code>false</code> otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param expiringPolicy the policy used to determine expiration times of\n       entries as they are added."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expiringPolicy the policy used to determine expiration times of\n       entries as they are added."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeToLiveMillis the constant amount of time (in milliseconds) an\n       entry is available before it expires. A negative value results in\n       entries that NEVER expire. A zero value results in entries that\n       ALWAYS expire."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeToLiveMillis the constant amount of time (in milliseconds) an\n       entry is available before it expires. A negative value results in\n       entries that NEVER expire. A zero value results in entries that\n       ALWAYS expire."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeToLive the constant amount of time an entry is available\n       before it expires. A negative value results in entries that NEVER\n       expire. A zero value results in entries that ALWAYS expire."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeToLive the constant amount of time an entry is available\n       before it expires. A negative value results in entries that NEVER\n       expire. A zero value results in entries that ALWAYS expire."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new multi-value map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the collection class type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collectionClass the type of the collection class"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new multi-value map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the collection class type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collectionFactory the collection factory (must return a Collection object)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new multi-value map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the start of the subsequence to be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the end of the subsequence to be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a subsequence of seq from start to end that is interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seq the sequence whose subsequence should be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the start of the subsequence to be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the end of the subsequence to be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a subsequence of seq from start to end that is interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> type of the graph nodes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predecessors a graph, represented as a predecessor map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map from each node to a list of its pre-dominators"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of nodes of the graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the graph to print"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ps the PrintStream to which to print the graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param indent the number of spaces by which to indent the printed representation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args command-line arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the merged DateTime"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Date read from the given string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param next value to be added to this selector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current_values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param num_elts the number of elements intended to be selected\nfrom the input elements\n\nSets 'number_to_take' = num_elts"
    },
    {
        "oracle": ";",
        "javadocTag": "@param num_elts the number of elements intended to be selected\nfrom the input elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r the seed to give for random number generation.\n\nSets 'number_to_take' = num_elts"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keep_probability the probability that each element is\nselected from the oncoming Iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r the seed to give for random number generation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param gen class whose methods to print"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string describing the method declaration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m the method whose access flags to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the access flags of method m"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the attribute"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the attribute name for the specified attribute"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pool the constant pool"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index in the constant pool"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the constant string at the specified offset in the constant pool"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mg the method to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the method is a constructor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m the method to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the method is a constructor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mg the method to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the method is a class initializer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m the method to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the method is a class initializer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param gen the class to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the class is part of the JDK (rt.jar)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param classname the class to test, in the format of Class.getName();\n  the class should not be an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the class is part of the JDK (rt.jar)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param classname the class to test, in internal form"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the class is part of the JDK (rt.jar)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param gen the class whose methods to print"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mgen the class to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param gen the class to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mg method to be augmented"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nl instructions to prepend to the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param jc javaclass to dump"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dump_dir directory in which to write the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param jc javaclass to dump"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dump_dir directory in which to write the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mg the method whose local variables to describe"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a description of the local variables (one per line)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mg the method whose line numbers to extract"
    },
    {
        "oracle": ";",
        "javadocTag": "@param il the instruction list to augment with line numbers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mg the method whose locals to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mg the method to clear out"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mg the method to clear out"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the attribute"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pool the constant pool"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the attribute is a local variable type table"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the attribute"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pool the constant pool"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the attribute name for the specified attribute"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mg the method to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the method is a main method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Java classname that corresponds to type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Java class that corresponds to type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param types the array to extend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param new_type the element to add to the end of the types array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array (or a new one), with new_type at the end"
    },
    {
        "oracle": ";",
        "javadocTag": "@param types the array to extend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param new_type the element to add to the beginning of the types array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array (or a new one), with new_type at the beginning"
    },
    {
        "oracle": ";",
        "javadocTag": "@param classname the class to convert to a type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the type corresponding to the given class name"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first BitSet to intersect"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second BitSet to intersect"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the cardinality bound"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff size(a intersect b) &ge; i"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first BitSet to intersect"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second BitSet to intersect"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the third BitSet to intersect"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the cardinality bound"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff size(a intersect b intersect c) &ge; i"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first BitSet to intersect"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second BitSet to intersect"
    },
    {
        "oracle": ";",
        "javadocTag": "@return size(a intersect b)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first BitSet to intersect"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second BitSet to intersect"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the third BitSet to intersect"
    },
    {
        "oracle": ";",
        "javadocTag": "@return size(a intersect b intersect c)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equationData equation data to be inserted into the complete array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param complete placeholder where to put equation data (only the\npart corresponding to the equation will be overwritten)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if either array has not enough elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the equation, must be between 0 included and\n{@link #getNumberOfEquations()} (excluded)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if index is out of range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapper former mapper, with one equation less (null for first equation)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension dimension of the equation state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return mapper for the set of equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondary secondary equations set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return index of the secondary equation in the expanded state, to be used\nas the parameter to {@link FieldODEState#getSecondaryState(int)} and\n{@link FieldODEStateAndDerivative#getSecondaryDerivative(int)} (beware index\n0 corresponds to main state, additional states start at 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 value of the independent <I>time</I> variable at integration start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 array containing the value of the state vector at integration start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param finalTime target time for the integration"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <I>time</I> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the complete state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return time derivative of the complete state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@param primary the primary set of differential equations to be integrated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return dimension of the underlying FODE"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <I>time</I> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot placeholder array where to put the time derivative of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ode original first order differential equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 start value of the independent <i>time</i> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 array containing the start value of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t target time for the integration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equations equations to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return differential equations to integrate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return evaluations counter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return evaluations counter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equations complete set of differential equations to integrate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t target time for the integration\n(can be set to a value smaller than <code>t0</code> for backward integration)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if integration step is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of the complete state does not\nmatch the complete equations sets dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the location of an event cannot be bracketed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <I>time</I> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot placeholder array where to put the time derivative of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the ODE equations have not been set (i.e. if this method\nis called outside of a call to {@link #integrate(ExpandableStatefulODE, double)} or {@link\n#integrate(FirstOrderDifferentialEquations, double, double[], double, double[])})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stateInitialized new value for the flag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator step interpolator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y state vector at step end time, must be reset if an event\nasks for resetting or if an events stops integration during the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot placeholder array where to put the time derivative of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tEnd final integration time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return time at end of step"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the interpolator throws one because\nthe number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the location of an event cannot be bracketed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equations set of differential equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t target time for the integration"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if integration span is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if adaptive step size integrators\ntolerance arrays dimensions are not compatible with equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@return dimension of the problem"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <I>time</I> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot array containing the current value of the first derivative\nof the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDDot placeholder array where to put the second time derivative\nof the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the parameter to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param names names of the supported parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param names names of the supported parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the name of the unknown parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param name parameter name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param model model to add at the end of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the model to append is not\ncompatible with the instance (dimension of the state vector,\npropagation direction, hole between the dates)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded\nduring step finalization"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator for the last accepted step."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded\nduring step finalization"
    },
    {
        "oracle": ";",
        "javadocTag": "@return initial integration time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return final integration time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return interpolation point time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time time of the interpolated point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return state vector at time {@link #getInterpolatedTime}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@return derivatives of the state vector at time {@link #getInterpolatedTime}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondaryStateIndex index of the secondary set, as returned by {@link\norg.apache.commons.math3.ode.ExpandableStatefulODE#addSecondaryEquations(\norg.apache.commons.math3.ode.SecondaryEquations)\nExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return interpolated secondary state at the current interpolation date"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondaryStateIndex index of the secondary set, as returned by {@link\norg.apache.commons.math3.ode.ExpandableStatefulODE#addSecondaryEquations(\norg.apache.commons.math3.ode.SecondaryEquations)\nExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return interpolated secondary derivatives at the current interpolation date"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time point to locate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interval step interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return -1 if the double is before the interval, 0 if it is in\nthe interval, and +1 if it is after the interval, according to\nthe interval direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@return dimension of the problem"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <I>time</I> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot placeholder array where to put the time derivative of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@return index of the first equation element in complete state arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@param angle angle of the line with respect to abscissa axis"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param angle angle of the line with respect to abscissa axis"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cos cosine of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sin sine of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param originOffset offset of the origin"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p point belonging to the line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param angle angle of the line with respect to abscissa axis"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line line to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the set of input points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the convex hull"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if generator fails to generate a convex hull for\nthe given set of input points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return vertices of the convex hull"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the region enclosed by the convex hull"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InsufficientDataException if the number of vertices is not enough to\nbuild a region in the respective space"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower lower angular bound of the arc"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper upper angular bound of the arc"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which close sub-arcs are merged together"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the built tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if lower is greater than upper"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InconsistentStateAt2PiWrapping if the tree leaf nodes are not\nconsistent across the \\( 0, 2 \\pi \\) crossing"
    },
    {
        "oracle": ";",
        "javadocTag": "@param root tree root"
    },
    {
        "oracle": ";",
        "javadocTag": "@return first leaf node (i.e. node corresponding to the region just after 0.0 radians)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param root tree root"
    },
    {
        "oracle": ";",
        "javadocTag": "@return last leaf node (i.e. node corresponding to the region just before \\( 2 \\pi \\) radians)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return smallest internal node (i.e. first after 0.0 radians, in trigonometric direction),\nor null if there are no internal nodes (i.e. the set is either empty or covers the full circle)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the node corresponds to the start angle of an arc"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the node corresponds to the end angle of an arc"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return next internal node in trigonometric order, or null\nif this is the last internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous internal node in trigonometric order, or null\nif this is the first internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node at which the sub-tree starts"
    },
    {
        "oracle": ";",
        "javadocTag": "@return leaf node just before the internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node at which the sub-tree starts"
    },
    {
        "oracle": ";",
        "javadocTag": "@return leaf node just after the internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node child node considered"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true is the node has a parent end is before it in trigonometric order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node child node considered"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true is the node has a parent end is after it in trigonometric order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node at which the sub-tree starts"
    },
    {
        "oracle": ";",
        "javadocTag": "@return child node just before the internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node at which the sub-tree starts"
    },
    {
        "oracle": ";",
        "javadocTag": "@return child node just after the internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the limit angle is direct"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return limit angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new ordered list containing {@link Arc Arc} elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arc arc to check instance against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH}\nor {@link Side#HYPER}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arc splitting arc"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an object containing both the part of the instance\non the plus side of the arc and the part of the\ninstance on the minus side of the arc"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tree BSP tree under construction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha arc limit"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isStart if true, the limit is the start of an arc"
    },
    {
        "oracle": ";",
        "javadocTag": "@param limits limit angles of the split part"
    },
    {
        "oracle": ";",
        "javadocTag": "@return split part (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which close sub-arcs are merged together"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower lower bound of the arc"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper upper bound of the arc"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which close sub-arcs are merged together"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tree inside/outside BSP tree representing the arcs set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which close sub-arcs are merged together"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InconsistentStateAt2PiWrapping if the tree leaf nodes are not\nconsistent across the \\( 0, 2 \\pi \\) crossing"
    },
    {
        "oracle": ";",
        "javadocTag": "@param boundary collection of boundary elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which close sub-arcs are merged together"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InconsistentStateAt2PiWrapping if the tree leaf nodes are not\nconsistent across the \\( 0, 2 \\pi \\) crossing"
    },
    {
        "oracle": ";",
        "javadocTag": "@return azimuthal angle \\( \\alpha \\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return normalized vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the angular separation between p1 and p2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Object to test for equality to this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if two points on the 2-sphere objects are equal, false if\n        object is null, not an instance of S2Point, or\n        not equal to this S2Point instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code value for this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha azimuthal angle \\( \\alpha \\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha azimuthal angle \\( \\alpha \\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector corresponding vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unique instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return nothing"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSubSpaceException in all cases"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower angular bound of the arc,\nalways between 0 and \\( 2 \\pi \\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper angular bound of the arc,\nalways between {@link #getInf()} and {@link #getInf()} \\( + 2 \\pi \\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return angular size of the arc"
    },
    {
        "oracle": ";",
        "javadocTag": "@return barycenter of the arc"
    },
    {
        "oracle": ";",
        "javadocTag": "@return tolerance below which angles are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a code representing the point status: either {@link\nLocation#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower lower angular bound of the arc"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper upper angular bound of the arc"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which angles are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the instance itself"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the plus side of the hyperplane is towards\nangles greater than hyperplane location"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Dimension index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the wrong dimension stored at {@code index}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Dimension index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the expected dimension stored at {@code index}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Wrong dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected Expected dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param specific Message pattern providing the specific context of\nthe error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Wrong dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected Expected dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lower bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the higher bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Requested value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lo Lower bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hi Higher bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@param specific Context information."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Requested value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lo Lower bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hi Higher bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Message pattern providing the specific context of\nthe error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param arguments Values for replacing the placeholders in {@code pattern}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the maximum is included in the allowed range."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Value that is larger than the maximum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Maximum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param boundIsAllowed if true the maximum is included in the allowed range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param specific Specific context pattern."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Value that is larger than the maximum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Maximum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param boundIsAllowed if true the maximum is included in the allowed range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Message pattern explaining the cause of the error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args Arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@param cause Root cause."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Message pattern explaining the cause of the error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args Arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Message pattern providing the specific context of\nthe error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args Arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@param specific Specific context where the error occurred."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the order direction."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} is the sequence should be strictly monotonic."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Value that did not match the requirements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous Previous value in the sequence."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index of the value that did not match the requirements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Value that did not match the requirements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous Previous value in the sequence."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index of the value that did not match the requirements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param direction Strictly positive for a sequence required to be\nincreasing, negative (or zero) for a decreasing sequence."
    },
    {
        "oracle": ";",
        "javadocTag": "@param strict Whether the sequence must be strictly increasing or\ndecreasing."
    },
    {
        "oracle": ";",
        "javadocTag": "@param specific Specific context pattern."
    },
    {
        "oracle": ";",
        "javadocTag": "@param arguments Arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Message pattern explaining the cause of the error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args Arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the expected dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param specific Specific context information pattern."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Wrong dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected Expected dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Wrong dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected Expected dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Message pattern explaining the cause of the error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args Arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Bad string representation of the object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param position Index, in the {@code wrong} string, that caused the\nparsing to fail."
    },
    {
        "oracle": ";",
        "javadocTag": "@param type Class of the object supposedly represented by the\n{@code wrong} string."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Bad string representation of the object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param position Index, in the {@code wrong} string, that caused the\nparsing to fail."
    },
    {
        "oracle": ";",
        "javadocTag": "@param specific Contextual information on what caused the exception."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the requested value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Localizable pattern."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Wrong number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param arguments Arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@param specific Specific context where the error occurred."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Maximum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param specific Specific context pattern."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Maximum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args Additional arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the minimum is included in the allowed range."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the minimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Value that is smaller than the minimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Minimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param boundIsAllowed Whether {@code min} is included in the allowed range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param specific Specific context pattern."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Value that is smaller than the minimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Minimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param boundIsAllowed Whether {@code min} is included in the allowed range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Message pattern providing the specific context of\nthe error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args Arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@param cause root cause"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Message pattern explaining the cause of the error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args Arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f the real data array to be transformed (signal)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of transform (forward, inverse) to be performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the real transformed array (spectrum)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the array cannot be transformed\n  with the given type (this may be for example due to array size, which is\n  constrained in some transforms)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to use, populating if possible"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of all the elements in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the collection was modified"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if CollectionMutator hasn't been set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if add is unsupported"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the object cannot be added due to its type"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the object cannot be added because its null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the object cannot be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object being removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the collection is changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if removed is unsupported"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the object cannot be removed due to its type"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the object cannot be removed because its null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the object cannot be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to check for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if all elements contained"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the collection was modified"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if CollectionMutator hasn't been set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if add is unsupported"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the object cannot be added due to its type"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the object cannot be added because its null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the object cannot be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the collection was modified"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if removeAll is unsupported"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the collection was modified"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if retainAll is unsupported"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if clear is unsupported"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mutator the mutator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param compositeCollection the Collection to be appended to the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param compositeCollection1 the Collection to be appended to the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param compositeCollection2 the Collection to be appended to the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param compositeCollections the Collections to be appended to the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll collection to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return A new ArrayList containing all of the elements in this composite.\n        The new collection is <i>not</i> backed by this composite."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Unmodifiable list of all collections in this composite."
    },
    {
        "oracle": ";",
        "javadocTag": "@return CollectionMutator<E>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param compositeCollection the Collection to be appended to the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param compositeCollection1 the Collection to be appended to the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param compositeCollection2 the Collection to be appended to the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param compositeCollections the collections to composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed Collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a transformed object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new Builder for predicated collections"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new Builder for predicated collections that ignores null values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the elements in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new predicated collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the collection contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object being added"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the add is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object being added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the result of adding to the underlying collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the add is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection being added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the result of adding to the underlying collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the add is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the collection contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the index object type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the collection type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the decorated {@link Collection}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyTransformer the {@link Transformer} for generating index keys."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the created {@link IndexedCollection}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the index object type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the collection type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the decorated {@link Collection}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyTransformer the {@link Transformer} for generating index keys."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the created {@link IndexedCollection}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the object maps to an existing key and the index\n  enforces a uniqueness constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return element found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a collection of elements found, or null if {@code contains(key) == false}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the object maps to an existing key and the index\n  enforces a uniqueness constraint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll decorated {@link Collection}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyTransformer {@link Transformer} for generating index keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map map to use as index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param uniqueIndex if the index shall enforce uniqueness of index keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the elements in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new synchronized collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator that must be manually synchronized on the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the elements in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if collection is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the decorated collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the table contains entries not\ncomparable to Long"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@param increment the amount by which the value should be incremented"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the table contains entries not\ncomparable to Long"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@param increment the amount by which the value should be incremented"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the table contains entries not\ncomparable to Char"
    },
    {
        "oracle": ";",
        "javadocTag": "@return values Iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return entry set Iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the total frequency count."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the frequency of v."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the frequency of v."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the frequency of v."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the frequency of v."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of unique values that have been added to the frequency table."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the proportion of values equal to v"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the proportion of values equal to v"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the proportion of values less than or equal to v"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list containing the value(s) which appear most often."
    },
    {
        "oracle": ";",
        "javadocTag": "@param other the other {@link Frequency} object to be merged"
    },
    {
        "oracle": ";",
        "javadocTag": "@param others the other {@link Frequency} objects to be merged"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator Comparator used to order values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between the two vectors"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths differ."
    },
    {
        "oracle": ";",
        "javadocTag": "@return chosen cluster center"
    },
    {
        "oracle": ";",
        "javadocTag": "@param center the point which is to be the center of this cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximum radius of the neighborhood"
    },
    {
        "oracle": ";",
        "javadocTag": "@return minimum number of points needed for a cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the points to cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of clusters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cluster Cluster to expand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point to add to cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@param neighbors List of neighbors"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visited the set of already visited points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the expanded cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point the point to look for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points possible neighbors"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the List of neighbors"
    },
    {
        "oracle": ";",
        "javadocTag": "@param one first list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param two second list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return merged lists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps maximum radius of the neighborhood to be considered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minPts minimum number of points needed for a cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps maximum radius of the neighborhood to be considered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minPts minimum number of points needed for a cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@param measure the distance measure to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return points contained in the cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the embedded clusterer"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of trials"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the used {@link ClusterEvaluator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the points to cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of clusters containing the points"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if an empty cluster is encountered and the\n  underlying {@link KMeansPlusPlusClusterer} has its\n  {@link KMeansPlusPlusClusterer.EmptyClusterStrategy} is set to {@code ERROR}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param clusterer the k-means clusterer to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numTrials number of trial runs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clusterer the k-means clusterer to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numTrials number of trial runs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param evaluator the cluster evaluator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of clusters"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fuzziness factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum number of iterations, or -1 if no maximum is set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the convergence criteria"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the random generator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the membership matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if {@link #cluster(Collection)} has not been called before"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of data points, or {@code null} if {@link #cluster(Collection)} has\n  not been called before."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of clusters, or {@code null} if {@link #cluster(Collection)} has\n  not been called before."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective function evaluation as double value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if {@link #cluster(Collection)} has not been called before"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dataPoints the points to cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of clusters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix the membership matrix of the previous iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum membership matrix change"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix the place to store the membership matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the number of clusters to split the data into"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the number of clusters to split the data into"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations to run the algorithm for.\n  If negative, no maximum will be used."
    },
    {
        "oracle": ";",
        "javadocTag": "@param measure the distance measure to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the number of clusters to split the data into"
    },
    {
        "oracle": "iterable==null;",
        "javadocTag": "@throws NullPointerException if iterable is null"
    },
    {
        "oracle": "(iterable==null) == false;",
        "javadocTag": "@param iterable the iterable to use, may not be null"
    },
    {
        "oracle": "elementsToSkip<0;",
        "javadocTag": "@throws IllegalArgumentException if elementsToSkip is negative"
    },
    {
        "oracle": "iterable==null;",
        "javadocTag": "@throws NullPointerException if iterable is null"
    },
    {
        "oracle": "(iterable==null) == false;",
        "javadocTag": "@param iterable the iterable to use, may not be null"
    },
    {
        "oracle": "(elementsToSkip<0) == false;",
        "javadocTag": "@param elementsToSkip the number of elements to skip from the start, must not be negative"
    },
    {
        "oracle": "iterable==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if either iterable or transformer is null"
    },
    {
        "oracle": "(iterable==null) == false;",
        "javadocTag": "@param iterable the iterable to transform, may not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer, must not be null"
    },
    {
        "oracle": "iterable==null;",
        "javadocTag": "@throws NullPointerException if iterable is null"
    },
    {
        "oracle": "(iterable==null) == false;",
        "javadocTag": "@param iterable the iterable to use, may not be null"
    },
    {
        "oracle": "iterable==null;",
        "javadocTag": "@throws NullPointerException if iterable is null"
    },
    {
        "oracle": "(iterable==null) == false;",
        "javadocTag": "@param iterable the iterable to use, may not be null"
    },
    {
        "oracle": "a==null || b==null;",
        "javadocTag": "@throws NullPointerException if either a or b is null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first iterable, may not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second iterable, may not be null"
    },
    {
        "oracle": "first==null;",
        "javadocTag": "@throws NullPointerException if either of the provided iterables is null"
    },
    {
        "oracle": "(first==null) == false;",
        "javadocTag": "@param first the first iterable, may not be null"
    },
    {
        "oracle": "(others==null) == false;",
        "javadocTag": "@param others the array of iterables to interleave, may not be null"
    },
    {
        "oracle": "closure==null;",
        "javadocTag": "@throws NullPointerException if closure is null"
    },
    {
        "oracle": "(closure==null) == false;",
        "javadocTag": "@param closure the closure to apply to each element, may not be null"
    },
    {
        "oracle": "(closure==null) == false;",
        "javadocTag": "@param closure the closure to perform, may not be null"
    },
    {
        "oracle": "iterable==null ? methodResultID==null : true;",
        "javadocTag": "@return the last element in the iterable, or null if iterable is null or empty"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use, may not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use, may not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use, may not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use, may not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use, may not be null"
    },
    {
        "oracle": "iterable==null ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return true if the iterable is null or empty, false otherwise"
    },
    {
        "oracle": "equator==null;",
        "javadocTag": "@throws NullPointerException if equator is null"
    },
    {
        "oracle": "(equator==null) == false;",
        "javadocTag": "@param equator the equator to use to check, may not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use, may not be null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if any predicate is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to use, may not be null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if any predicate is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to use, may not be null"
    },
    {
        "oracle": "transformer==null;",
        "javadocTag": "@throws NullPointerException if {@code transformer} is null"
    },
    {
        "oracle": "transformer==null || delimiter==null || prefix==null || suffix==null;",
        "javadocTag": "@throws NullPointerException if either transformer, delimiter, prefix or suffix is null"
    },
    {
        "oracle": "iterable==null;",
        "javadocTag": "@throws NullPointerException if iterable is null"
    },
    {
        "oracle": "iterables==null;",
        "javadocTag": "@throws NullPointerException if the argument or any of its contents is null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws FunctorException always"
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException if the specified key is null and this map\n  does not permit null keys (optional)"
    },
    {
        "oracle": "value==null;",
        "javadocTag": "@throws NullPointerException if the value is null and null values are not supported\n  by the used collection types (optional)"
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException if the key is null and null keys are invalid (optional)"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws NullPointerException if the specified iterable is null, or if this map\n  does not permit null keys or values, and the specified key or values contain\n  null (optional)"
    },
    {
        "oracle": "(values==null) == false;",
        "javadocTag": "@param values the values to add to the collection at the key, may not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the specified map is null, or if this map\n  does not permit null keys or values, and the specified map\n  contains null keys or values (optional)"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map mappings to be stored in this map, may not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the specified map is null, or if this map\n  does not permit null keys or values, and the specified map\n  contains null keys or values (optional)"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map mappings to be stored in this map, may not be null"
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException if the key is null and null keys are invalid (optional)"
    },
    {
        "oracle": "true ? methodResultID.equals(key) : true;",
        "javadocTag": "@return the values that were removed"
    },
    {
        "oracle": "count<0;",
        "javadocTag": "@throws IllegalArgumentException if count is negative"
    },
    {
        "oracle": "occurrences<0;",
        "javadocTag": "@throws IllegalArgumentException if occurrences is negative"
    },
    {
        "oracle": "occurrences<0;",
        "javadocTag": "@throws IllegalArgumentException if occurrences is negative"
    },
    {
        "oracle": "items==null;",
        "javadocTag": "@throws NullPointerException if the array is null"
    },
    {
        "oracle": "items==null;",
        "javadocTag": "@throws NullPointerException if the list is null"
    },
    {
        "oracle": "this.isLocked();",
        "javadocTag": "@throws UnsupportedOperationException if the comparator is locked"
    },
    {
        "oracle": "unknownObjectBehavior==null;",
        "javadocTag": "@throws NullPointerException if unknownObjectBehavior is null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "keyTransformer==null;",
        "javadocTag": "@param keyTransformer the predicate to validate the keys, null means no transformation"
    },
    {
        "oracle": "valueTransformer==null;",
        "javadocTag": "@param valueTransformer the predicate to validate to values, null means no transformation"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "keyTransformer==null;",
        "javadocTag": "@param keyTransformer the predicate to validate the keys, null means no transformation"
    },
    {
        "oracle": "valueTransformer==null;",
        "javadocTag": "@param valueTransformer the predicate to validate to values, null means no transformation"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "keyTransformer==null;",
        "javadocTag": "@param keyTransformer the transformer to use for key conversion, null means no transformation"
    },
    {
        "oracle": "valueTransformer==null;",
        "javadocTag": "@param valueTransformer the transformer to use for value conversion, null means no transformation"
    },
    {
        "oracle": "(entry==null) == false;",
        "javadocTag": "@param entry the <code>Map.Entry</code> to decorate, must not be null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to decorate, must not be null"
    },
    {
        "oracle": "(predicate1==null) == false;",
        "javadocTag": "@param predicate1 the first predicate to check, not null"
    },
    {
        "oracle": "(predicate2==null) == false;",
        "javadocTag": "@param predicate2 the second predicate to check, not null"
    },
    {
        "oracle": "predicate1==null || predicate2==null;",
        "javadocTag": "@throws NullPointerException if either predicate is null"
    },
    {
        "oracle": "(predicate1==null) == false;",
        "javadocTag": "@param predicate1 the first predicate to check, not null"
    },
    {
        "oracle": "(predicate2==null) == false;",
        "javadocTag": "@param predicate2 the second predicate to check, not null"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return the predicates"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the MultiValuedMap to decorate, may not be null"
    },
    {
        "oracle": "keyTransformer==null;",
        "javadocTag": "@param keyTransformer the transformer to use for key conversion, null means no conversion"
    },
    {
        "oracle": "valueTransformer==null;",
        "javadocTag": "@param valueTransformer the transformer to use for value conversion, null means no conversion"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the MultiValuedMap to decorate, may not be null"
    },
    {
        "oracle": "keyTransformer==null;",
        "javadocTag": "@param keyTransformer the transformer to use for key conversion, null means no conversion"
    },
    {
        "oracle": "valueTransformer==null;",
        "javadocTag": "@param valueTransformer the transformer to use for value conversion, null means no conversion"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the MultiValuedMap to decorate, may not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the parameters are valid and designate a subarray of positive length"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the indices are invalid or the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include."
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include."
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowEmpty if {@code true} than allow zero length arrays to pass."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the parameters are valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if either of the arrays are null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the array indices are not valid,\nthe weights array contains NaN, infinite or negative elements, or there\nare no positive weights."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Current values of statistics"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The number of available values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The sum or <code>Double.NaN</code> if no values have been added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The sum of squares"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the standard deviation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The quadratic mean or {@code Double.NaN} if no values\nhave been added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the population variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the minimum"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the geometric mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of logs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return second central moment statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@return String with line feeds displaying statistics"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to test equality against."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if object equals this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sumImpl the StorelessUnivariateStatistic instance to use for\n       computing the Sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added (i.e if n >0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the sum of squares"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sumsqImpl the StorelessUnivariateStatistic instance to use for\n       computing the sum of squares"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the minimum"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minImpl the StorelessUnivariateStatistic instance to use for\n       computing the minimum"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the maximum"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxImpl the StorelessUnivariateStatistic instance to use for\n       computing the maximum"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the log sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sumLogImpl the StorelessUnivariateStatistic instance to use for\n       computing the log sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the geometric mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param geoMeanImpl the StorelessUnivariateStatistic instance to use for\n       computing the geometric mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param meanImpl the StorelessUnivariateStatistic instance to use for\n       computing the mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param varianceImpl the StorelessUnivariateStatistic instance to use for\n       computing the variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has been added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source SummaryStatistics to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest SummaryStatistics to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code SummaryStatistics} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if there are no elements stored"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the value to replace the most recent stored value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return replaced value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if there are no elements stored"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The mean or Double.NaN if no values have been added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The geometricMean, Double.NaN if no values have been added,\nor if any negative values have been added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The variance, Double.NaN if no values have been added\nor 0.0 for a single value set."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The population variance, Double.NaN if no values have been added,\nor 0.0 for a single value set."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The standard deviation, Double.NaN if no values have been added\nor 0.0 for a single value set."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The quadratic mean or {@code Double.NaN} if no values\nhave been added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The skewness, Double.NaN if less than 3 values have been added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The kurtosis, Double.NaN if less than 4 values have been added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The max or Double.NaN if no values have been added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The min or Double.NaN if no values have been added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The number of available values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The sum or Double.NaN if no values have been added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The sum of the squares or Double.NaN if no\nvalues have been added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The current window size or -1 if its Infinite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param windowSize sets the size of the window."
    },
    {
        "oracle": ";",
        "javadocTag": "@return returns the current set of numbers in the order in which they\n        were added to this set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return returns the current set of\nnumbers sorted in ascending order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index The Index of the element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return return the element at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the requested percentile (scaled from 0 - 100)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return An estimate for the pth percentile of the stored data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if percentile implementation has been\n overridden and the supplied implementation does not support setQuantile"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if p is not a valid quantile"
    },
    {
        "oracle": ";",
        "javadocTag": "@return String with line feeds displaying statistics"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stat the statistic to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the computed value of the statistic."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the UnivariateStatistic implementing the mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param meanImpl the UnivariateStatistic instance to use\nfor computing the mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the UnivariateStatistic implementing the geometric mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param geometricMeanImpl the UnivariateStatistic instance to use\nfor computing the geometric mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the UnivariateStatistic implementing the kurtosis"
    },
    {
        "oracle": ";",
        "javadocTag": "@param kurtosisImpl the UnivariateStatistic instance to use\nfor computing the kurtosis"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the UnivariateStatistic implementing the maximum"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxImpl the UnivariateStatistic instance to use\nfor computing the maximum"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the UnivariateStatistic implementing the minimum"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minImpl the UnivariateStatistic instance to use\nfor computing the minimum"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the greatest index {@code i} for which {@code array[i] == target},\n    or {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is less than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is greater than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arrays zero or more {@code float} arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a single array containing all the values from the source arrays, in\n    order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the source array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minLength the minimum length the returned array must guarantee"
    },
    {
        "oracle": ";",
        "javadocTag": "@param padding an extra amount to \"grow\" the array by if growth is\n    necessary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the values of {@code array}, with guaranteed\n    minimum length {@code minLength}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator the text that should appear between consecutive values in\n    the resulting string (but not at the start or end)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code float} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection a collection of {@code Number} instances"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the same values as {@code collection}, in the\n    same order, converted to primitives"
    },
    {
        "oracle": ";",
        "javadocTag": "@param backingArray the array to back the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list view of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param string the string representation of a {@code float} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the floating point value represented by {@code string}, or\n    {@code null} if {@code string} has a length of zero or cannot be\n    parsed as a {@code float} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value a primitive {@code boolean} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code for the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first {@code boolean} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second {@code boolean} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a positive number if only {@code a} is {@code true}, a negative\n    number if only {@code b} is true, or zero if {@code a == b}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code boolean} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code boolean} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code array[i] == target} for some value of {@code\n    i}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code boolean} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code boolean} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the least index {@code i} for which {@code array[i] == target}, or\n    {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to search for the sequence {@code target}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target the array to search for as a sub-sequence of {@code array}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code boolean} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code boolean} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the greatest index {@code i} for which {@code array[i] == target},\n    or {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param arrays zero or more {@code boolean} arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a single array containing all the values from the source arrays, in\n    order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the source array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minLength the minimum length the returned array must guarantee"
    },
    {
        "oracle": ";",
        "javadocTag": "@param padding an extra amount to \"grow\" the array by if growth is\n    necessary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the values of {@code array}, with guaranteed\n    minimum length {@code minLength}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator the text that should appear between consecutive values in\n    the resulting string (but not at the start or end)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code boolean} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection a collection of {@code Boolean} objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the same values as {@code collection}, in the\n    same order, converted to primitives"
    },
    {
        "oracle": ";",
        "javadocTag": "@param backingArray the array to back the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list view of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first unsigned {@code long} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second unsigned {@code long} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is\n        greater than {@code b}; or zero if they are equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is less than or equal to every other value in\n        the array according to {@link #compare}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is greater than or equal to every other value\n        in the array according to {@link #compare}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator the text that should appear between consecutive values in the resulting\n       string (but not at the start or end)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of unsigned {@code long} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dividend the dividend (numerator)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param divisor the divisor (denominator)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dividend the dividend (numerator)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param divisor the divisor (denominator)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the string does not contain a valid unsigned {@code long}\n        value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the string does not contain a valid unsigned {@code long}\n        value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the string containing the unsigned {@code long} representation to be parsed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param radix the radix to use while parsing {@code s}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if the string does not contain a valid unsigned {@code long}\n        with the given radix, or if {@code radix} is not between {@link Character#MIN_RADIX}\n        and {@link Character#MAX_RADIX}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value to convert to a string."
    },
    {
        "oracle": ";",
        "javadocTag": "@param radix the radix to use while working with {@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code radix} is not between {@link Character#MIN_RADIX}\n        and {@link Character#MAX_RADIX}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value a primitive {@code short} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code for the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value any value in the range of the {@code short} type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@code short} value that equals {@code value}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code value} is greater than {@link\n    Short#MAX_VALUE} or less than {@link Short#MIN_VALUE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value any {@code long} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the same value cast to {@code short} if it is in the range of the\n    {@code short} type, {@link Short#MAX_VALUE} if it is too large,\n    or {@link Short#MIN_VALUE} if it is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first {@code short} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second {@code short} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a negative value if {@code a} is less than {@code b}; a positive\n    value if {@code a} is greater than {@code b}; or zero if they are equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code short} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code short} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code array[i] == target} for some value of {@code\n    i}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code short} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code short} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the least index {@code i} for which {@code array[i] == target}, or\n    {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to search for the sequence {@code target}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target the array to search for as a sub-sequence of {@code array}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code short} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code short} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the greatest index {@code i} for which {@code array[i] == target},\n    or {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is less than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value present in {@code array} that is greater than or equal to\n    every other value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arrays zero or more {@code short} arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a single array containing all the values from the source arrays, in\n    order"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code bytes} has fewer than 2\n    elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the source array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minLength the minimum length the returned array must guarantee"
    },
    {
        "oracle": ";",
        "javadocTag": "@param padding an extra amount to \"grow\" the array by if growth is\n    necessary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the values of {@code array}, with guaranteed\n    minimum length {@code minLength}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator the text that should appear between consecutive values in\n    the resulting string (but not at the start or end)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code short} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection a collection of {@code Number} instances"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the same values as {@code collection}, in the\n    same order, converted to primitives"
    },
    {
        "oracle": ";",
        "javadocTag": "@param backingArray the array to back the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list view of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param highOrder high order scaled derivatives\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start first order scaled derivatives at step start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end first order scaled derivatives at step end"
    },
    {
        "oracle": ";",
        "javadocTag": "@param highOrder high order scaled derivatives, will be modified\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number of steps of the multistep method\n(excluding the one being computed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotK slopes at the intermediate points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rkIntegrator integrator being used"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y reference to the integrator array holding the state at\nthe end of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotArray reference to the integrator array holding all the\nintermediate slopes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param primaryMapper equations mapper for the primary equations set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondaryMappers equations mappers for the secondary equations sets"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator to copy from."
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator to copy from. The copy is a deep\ncopy: its arrays are separated from the original arrays of the\ninstance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotK slopes at the intermediate points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param highOrder high order scaled derivatives\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start first order scaled derivatives at step start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end first order scaled derivatives at step end"
    },
    {
        "oracle": ";",
        "javadocTag": "@param highOrder high order scaled derivatives, will be modified\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the method excluding the one being computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the method excluding the one being computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxDegree maximal degree to handle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu degree of the interpolation polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h current step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale scaling array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return estimate of the interpolation error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y reference to the integrator array holding the current state"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0Dot reference to the integrator array holding the slope\nat the beginning of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y1 reference to the integrator array holding the state at\nthe end of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y1Dot reference to the integrator array holding the slope\nat the end of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yMidDots reference to the integrator array holding the\nderivatives at the middle point of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param primaryMapper equations mapper for the primary equations set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondaryMappers equations mappers for the secondary equations sets"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator to copy from. The copy is a deep\ncopy: its arrays are separated from the original arrays of the\ninstance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator to copy from. The copy is a deep\ncopy: its arrays are separated from the original arrays of the\ninstance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward forward integration indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale scaling vector for the state vector (can be shorter than state vector)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 start time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 state vector at t0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot0 first time derivative of y0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y1 work array for a state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot1 work array for the first time derivative of y1"
    },
    {
        "oracle": ";",
        "javadocTag": "@return first integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h signed step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward forward integration indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param acceptSmall if true, steps smaller than the minimal value\nare silently increased up to this value, if false such small\nsteps generate an exception"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a bounded integration step (h if no bound is reach, or a bounded value)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the step is too small and acceptSmall is false"
    },
    {
        "oracle": ";",
        "javadocTag": "@return minimal step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximal step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param plane3 third plane2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return intersection point of three planes, null if some planes are parallel"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a region covering the whole hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a region containing the instance (really a {@link\nPolyhedronsSet PolyhedronsSet} instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if p belongs to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param plane plane to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector vector to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other other hyperplane to check against the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the instance and the other hyperplane have\nthe same orientation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normal normal direction to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the normal norm is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p point belonging to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normal normal direction to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the normal norm is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first point belonging to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second point belonging to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p3 third point belonging to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the points do not constitute a plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normal normal direction to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the normal norm is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p point belonging to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param normal normal direction to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the normal norm is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first point belonging to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second point belonging to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p3 third point belonging to the plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the points do not constitute a plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param plane plane to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c1 first column"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c2 second column"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c3 third column"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value of the minor computed has an exact fraction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first point belonging to the line (this can be any point)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second point belonging to the line (this can be any point, different from p1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance, with reversed direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@return normalized direction vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return line point closest to the origin"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return abscissa of the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param abscissa desired abscissa for the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return one point belonging to the line, at specified abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector n-dimension point of the space"
    },
    {
        "oracle": ";",
        "javadocTag": "@return (n-1)-dimension point of the sub-space corresponding to\nthe specified space point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector (n-1)-dimension point of the sub-space"
    },
    {
        "oracle": ";",
        "javadocTag": "@return n-dimension point of the space corresponding to the\nspecified sub-space point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line line to which instance should be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the lines are similar"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if p belongs to the line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return distance between the instance and the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line line to check against the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return shortest distance between the instance and the line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line line to check against the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return point of the instance closest to another line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line other line"
    },
    {
        "oracle": ";",
        "javadocTag": "@return intersection point of the instance and the other line\nor null if there are no intersection points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a sub-line covering the whole line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first point belonging to the line (this can be any point)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second point belonging to the line (this can be any point, different from p1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line line to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first point belonging to the line (this can be any point)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second point belonging to the line (this can be any point, different from p1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower lower bound of the interval, must be lesser or equal\nto {@code upper} (may be {@code Double.NEGATIVE_INFINITY})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper upper bound of the interval, must be greater or equal\nto {@code lower} (may be {@code Double.POSITIVE_INFINITY})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the built tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lowest value belonging to the instance\n({@code Double.NEGATIVE_INFINITY} if the instance doesn't\nhave any low bound, {@code Double.POSITIVE_INFINITY} if the\ninstance is empty)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return highest value belonging to the instance\n({@code Double.POSITIVE_INFINITY} if the instance doesn't\nhave any high bound, {@code Double.NEGATIVE_INFINITY} if the\ninstance is empty)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x abscissa of the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new point for finite abscissa, null otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new ordered list containing {@link Interval Interval}\nelements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param root tree root"
    },
    {
        "oracle": ";",
        "javadocTag": "@return first leaf node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return smallest internal node,\nor null if there are no internal nodes (i.e. the set is either empty or covers the real line)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the node corresponds to the start abscissa of an interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the node corresponds to the end abscissa of an interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return next internal node in ascending order, or null\nif this is the last internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous internal node in ascending order, or null\nif this is the first internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node at which the sub-tree starts"
    },
    {
        "oracle": ";",
        "javadocTag": "@return leaf node just before the internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node at which the sub-tree starts"
    },
    {
        "oracle": ";",
        "javadocTag": "@return leaf node just after the internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node child node considered"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true is the node has a parent end is before it in ascending order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node child node considered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldValue The attribute old value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue The attribute new value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldValue The attribute old value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue The attribute new value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeId "
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId The source identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eltId The changed element identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eltType The changed element type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The changed attribute."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event The add/change/remove action."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldValue The old attribute value (null if the attribute is removed or\n           added)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue The new attribute value (null if removed)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param name Identifier of the stream."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the identified pipe"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name Filter only message with this name to the given message box."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stream The ThreadProxyPipe to push the events to."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws Exception If another Pipe is already registered at the given name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param unpaker "
    },
    {
        "oracle": ";",
        "javadocTag": "@param hostname The host name to listen at messages."
    },
    {
        "oracle": ";",
        "javadocTag": "@param port The port to listen at messages."
    },
    {
        "oracle": ";",
        "javadocTag": "@param port The port to listen at messages."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hostname The host name to listen at messages."
    },
    {
        "oracle": ";",
        "javadocTag": "@param port The port to listen at messages."
    },
    {
        "oracle": ";",
        "javadocTag": "@param debug If true informations are output for each message received."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stream2 "
    },
    {
        "oracle": ";",
        "javadocTag": "@param paker The packer object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in The double to encode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ByteBuffer with encoded double in it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in The float array to encode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ByteBuffer with encoded float array in it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in The float to encode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ByteBuffer with encoded float in it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in The long array to encode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ByteBuffer with encoded long array in it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in The long to encode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ByteBuffer with encoded long in it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in The integer array to encode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ByteBuffer with encoded integer array in it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in The integer to encode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ByteBuffer with encoded integer in it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param b "
    },
    {
        "oracle": ";",
        "javadocTag": "@param sumsizes "
    },
    {
        "oracle": ";",
        "javadocTag": "@param ssize "
    },
    {
        "oracle": ";",
        "javadocTag": "@param buff "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param b4 A reusable byte array to reduce array instantiation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param threeBytes the array to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numSigBytes the number of significant bytes in your array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return four byte array in Base64 notation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the array to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcOffset the index where conversion begins"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numSigBytes the number of significant bytes in your array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param destination the array to hold the conversion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param destOffset the index where output will be put"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <var>destination</var> array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param zero additive identity of the field"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the linear operator for which the preconditioner should be built"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the diagonal preconditioner made of the inverse of the diagonal\ncoefficients of the specified linear operator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareOperatorException if {@code a} is not square"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square root of {@code this} preconditioner"
    },
    {
        "oracle": ";",
        "javadocTag": "@param diag the diagonal coefficients of the linear operator to be\npreconditioned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param deep {@code true} if a deep copy of the above array should be\nperformed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of rows of the underlying matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of columns of the underlying matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the vector to operate on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the product of {@code this} instance with {@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the column dimension does not match\nthe size of {@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the vector to operate on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the product of the transpose of {@code this} instance with\n{@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the row dimension does not match the size of {@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if this operation is not supported\nby {@code this} operator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param qrt transposed matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minor minor index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param qrt transposed matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a permutation matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dropThreshold threshold triggering rank computation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return effective numerical matrix rank"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a solver"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix The matrix to decompose."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix The matrix to decompose."
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Singularity threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> Type of the field elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Data array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the field to which the array elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> Type of the field elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Data array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the field to which the array elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> Type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which array elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows number of rows"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columns number of columns (may be negative to build partial\narrays in the same way <code>new Field[rows][]</code> works)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which array elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation for this matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to test equality against."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if object equals this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return hashcode for matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row index to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code index} is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column index to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code index} is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param selectedRows Array of row indices."
    },
    {
        "oracle": ";",
        "javadocTag": "@param selectedColumns Array of column indices."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if the arrays have zero length."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if row or column selections are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the matrix is not\naddition-compatible with instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the matrix is not\nsubtraction-compatible with instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to check."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the matrix is not\nmultiplication-compatible with instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowDimension Number of rows in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnDimension Number of columns in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowDimension the number of rows in the new matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnDimension the number of columns in the new matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new matrix of the same type as the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return matrix copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m matrix to be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this + m}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m matrix to be subtracted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this - m}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d value to be added to each entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code d + this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d value to multiply all entries by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code d * this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m matrix to postmultiply by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this * m}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if\n{@code columnDimension(this) != rowDimension(m)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m matrix to premultiply by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code m * this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if\n{@code rowDimension(this) != columnDimension(m)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p raise {@code this} to power {@code p}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this^p}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return 2-dimensional array of entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@return norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The subMatrix containing the data of the\nspecified rows and columns."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param selectedRows Array of row indices."
    },
    {
        "oracle": ";",
        "javadocTag": "@return minimum spanning-tree edges set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return minimum spanning-tree total weight"
    },
    {
        "oracle": ";",
        "javadocTag": "@return weight of a matching found"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the graph inspected by this StrongConnectivityAlgorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the graph is strongly connected, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>List</code> of <code>Set</code> s containing the strongly\nconnected components"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of subgraphs representing the strongly connected\ncomponents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source source of the flow inside the network"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sink sink of the flow inside the network"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximum flow"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexLabels Map that gives a label for each vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Vertex with the maximal label."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k vertex' label"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r the reach structure."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices the vertices to induce the subgraph from."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the induced subgraph is a clique."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the graph to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A copy of the graph projected to a SimpleGraph."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the graph is chordal, false otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Set of fill edges."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Triangulated graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@return List of generators."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The minimal elimination ordering."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A map from separators to integers (component count)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Set of atoms, where each atom is described as the set of its\nvertices."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Set of separators, where each separator is described as the set\nof its vertices."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Original graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g The graph to decompose."
    },
    {
        "oracle": ";",
        "javadocTag": "@param endVertex end vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return ."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if at least one path has been improved during\nthe previous pass, <code>false</code> otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the graph is undirected and the\nedge-weight is negative."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex a vertex which has just been encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge via which the vertex was encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cost obtained by concatenation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex "
    },
    {
        "oracle": ";",
        "javadocTag": "@return ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex a vertex which has already been seen."
    },
    {
        "oracle": ";",
        "javadocTag": "@return data associated with the seen vertex or <code>null</code> if no\ndata was associated with the vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex a vertex which has already been seen."
    },
    {
        "oracle": ";",
        "javadocTag": "@return data associated with the seen vertex or <code>null</code> if no\ndata was associated with the vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex vertex in question."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>true</tt> if vertex has already been seen."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex "
    },
    {
        "oracle": ";",
        "javadocTag": "@param data "
    },
    {
        "oracle": ";",
        "javadocTag": "@return ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex a vertex which has been seen."
    },
    {
        "oracle": ";",
        "javadocTag": "@param data data to be associated with the seen vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous value associated with specified vertex or <code>\nnull</code> if no data was associated with the vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex a vertex which has just been encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge via which the vertex was encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param cost cost of the created path element."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex a vertex which has just been encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge via which the vertex was encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex a vertex which has just been encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge via which the vertex was encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the cost has been improved, <code>\nfalse</code> otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph "
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex start vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon tolerance factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of <code>Edge</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@return ."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>null</code> if the path is empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>null</code> is the path is empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@return ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pathElement "
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge edge reaching the end vertex of the path element created."
    },
    {
        "oracle": ";",
        "javadocTag": "@param original source to copy from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex end vertex of the path element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source source vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sink sink vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current source"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current sink"
    },
    {
        "oracle": ";",
        "javadocTag": "@param network network, where maximum flow will be calculated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param network network, where maximum flow will be calculated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon tolerance for comparing doubles"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a transformed map backed by the given map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a fixed-size map backed by that map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a lazy map backed by the given map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a lazy map backed by the given map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an ordered map backed by the given map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a multi-value map backed by the given map which returns ArrayLists of values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the collection class type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collectionClass the type of collections to return from the map\n  (must contain public no-arg constructor and extend Collection)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a multi-value map backed by the given map which returns collections of the specified type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the collection class type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collectionFactory a factor which creates collection objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a multi-value map backed by the given map which returns collections\n  created by the specified collection factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized map backed by the given map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable map backed by the given map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a predicated map backed by the given map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a transformed map backed by the given map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a fixed-size map backed by that map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a lazy map backed by the given map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a lazy map backed by the given map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the <code>Map</code> to populate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the <code>Iterable</code> containing the input values for the map."
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyTransformer the <code>Transformer</code> used to transform the element into a key value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object contained in the {@link Iterable}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the <code>Map</code> to populate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the <code>Iterable</code> containing the input values for the map."
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyTransformer the <code>Transformer</code> used to transform the element into a key value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueTransformer the <code>Transformer</code> used to transform the element into a value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the <code>MultiMap</code> to populate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the <code>Iterable</code> to use as input values for the map."
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyTransformer the <code>Transformer</code> used to transform the element into a key value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of object contained in the {@link Iterable}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the <code>MultiMap</code> to populate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the <code>Iterable</code> containing the input values for the map."
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyTransformer the <code>Transformer</code> used to transform the element into a key value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueTransformer the <code>Transformer</code> used to transform the element into a value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map to wrap if necessary."
    },
    {
        "oracle": ";",
        "javadocTag": "@return IterableMap<K, V>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sortedMap to wrap if necessary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link IterableSortedMap}<K, V>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the object to be transformed, should be left unchanged"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException (runtime) if the input is the wrong class"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException (runtime) if the input is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FunctorException (runtime) if the transform cannot be completed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the object type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>o.hashCode()</code> if <code>o</code> is non-\n        <code>null</code>, else {@link #HASHCODE_NULL}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> input type for the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> output type for the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate predicate to switch on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param trueTransformer transformer used if true"
    },
    {
        "oracle": ";",
        "javadocTag": "@param falseTransformer transformer used if false"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>if</code> transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param a "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param value "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of every node attributes filtered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graphAttributesFiltered the new list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param attr the filtered attribute"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the attribute has been added, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param attr the no more filtered attribute"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the attribute has been removed, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of every node attributes filtered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeAttributesFiltered the new list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param attr the filtered attribute"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the attribute has been added, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param attr the no more filtered attribute"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the attribute has been removed, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of every edge attributes filtered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeAttributesFiltered the new list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param attr the filtered attribute"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the attribute has been added, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param attr the filtered attribute"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the attribute has been removed, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterGraphAttributeAdded "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterGraphAttributeChanged "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterGraphAttributeRemoved "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterNodeAttributeAdded "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterNodeAttributeChanged "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterNodeAttributeRemoved "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterNodeAdded "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterNodeRemoved "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterEdgeAttributeAdded "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterEdgeAttributeChanged "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterEdgeAttributeRemoved "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterEdgeAdded "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterEdgeRemoved "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterGraphCleared "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this filter is disable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param noFilterStepBegins "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if exported graph is directed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a parser factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgedefault "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileName Name of the graph file."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A graph reader suitable for the fileName graph format."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If the file is not readable or accessible."
    },
    {
        "oracle": ";",
        "javadocTag": "@param styleSheet the style sheet"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r resolution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param width "
    },
    {
        "oracle": ";",
        "javadocTag": "@param height "
    },
    {
        "oracle": ";",
        "javadocTag": "@param rendererType "
    },
    {
        "oracle": ";",
        "javadocTag": "@param policy policy defining when images are produced"
    },
    {
        "oracle": ";",
        "javadocTag": "@param policy policy defining how the layout is computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param spf step per frame"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sas step after stabilization."
    },
    {
        "oracle": ";",
        "javadocTag": "@param limit "
    },
    {
        "oracle": ";",
        "javadocTag": "@param logoFile path to the logo picture-file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x x position of the logo (top-left corner is (0;0))"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y y position of the logo"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the rounded value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}\nand the specified scaling operation would require rounding."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code roundingMethod} does not\nrepresent a valid rounding mode."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Value to round."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale Number of digits to the right of the decimal point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the rounded value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Value to round."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale Number of digits to the right of the decimal point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param roundingMethod Rounding method as defined in {@link BigDecimal}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the rounded value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if an exact operation is required but result is not exact"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param unscaled Value to round."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sign Sign of the original, scaled value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param roundingMethod Rounding method, as defined in {@link BigDecimal}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the rounded value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if an exact operation is required but result is not exact"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param originalDelta Offset value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the iterator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index in unidimensional counter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the multidimensional counts."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Indices in multidimensional counter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index within the unidimensionl counter."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the size of {@code c}\ndoes not match the size of the array given in the constructor."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if a value of {@code c} is not in\nthe range of the corresponding dimension, as defined in the\n{@link MultidimensionalCounter#MultidimensionalCounter(int...) constructor}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the total size of the unidimensional counter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sizes of the multidimensional counter in each dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Counter sizes (number of slots in each dimension)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if one of the sizes is\nnegative or zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index to fetch a value from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value stored at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index to store a value in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to store at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value to be added to end of array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values to be added to end of array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to be added to the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value which has been discarded or \"pushed\" out of the array\n        by this rolling insert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return all elements added to the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper limit of the counter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the counter upper limit."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current count."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code false} if the next call to {@link #incrementCount(int)\nincrementCount} will trigger a {@code MaxCountExceededException},\n{@code true} otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Number of increments."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException at counter exhaustion."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException at counter exhaustion, unless a\ncustom {@link MaxCountExceededCallback callback} has been set at\nconstruction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param incrementor wrapped {@link IntegerSequence.Incrementor}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an incrementor wrapping an {@link IntegerSequence.Incrementor}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Maximal count."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Maximal count."
    },
    {
        "oracle": ";",
        "javadocTag": "@param cb Function to be called when the maximal count has been reached."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedSize expected size of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return capacity to use for the specified size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i input value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return smallest power of two greater than the input value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key associated with the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return data associated with the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if a value is associated with key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return iterator over the map elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hash initial hash"
    },
    {
        "oracle": ";",
        "javadocTag": "@return perturbed hash"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@return index at which key should be inserted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keys keys table"
    },
    {
        "oracle": ";",
        "javadocTag": "@param states states table"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to lookup"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mask bit mask for hash values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return index at which key should be inserted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param perturb perturbed hash"
    },
    {
        "oracle": ";",
        "javadocTag": "@param j previous probe"
    },
    {
        "oracle": ";",
        "javadocTag": "@return next probe"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index initial index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return changed index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of elements stored in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to which the value is associated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return removed value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if an element is associated with key at index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the element to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return removed value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to which value is associated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to put in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous value associated with the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if  tables should grow"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to hash"
    },
    {
        "oracle": ";",
        "javadocTag": "@return hash value of the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stream input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if object cannot be read"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if the class corresponding\nto the serialized object cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param missingEntries value to return when a missing entry is fetched"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedSize expected number of elements in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedSize expected number of elements in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param missingEntries value to return when a missing entry is fetched"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source map to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedSize expected size of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new ordered map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the converted key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a shallow clone"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mapped value, null if no match"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map is currently size zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value previously mapped to this key, null if none"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the mapping to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value mapped to the removed key, null if key not in map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the converted key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to get a hash code for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key to compare passed in from outside"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key extracted from the entry via <code>entry.key</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value1 the first value to compare passed in from outside"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value2 the second value extracted from the entry via <code>getValue()</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashCode the hash code to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dataSize the size of the data to pick a bucket from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the bucket index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entry, null if no match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to update"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue the new value to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to update, not null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashIndex the index in the data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashCode the hash code of the key to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashIndex the index into the data array to store at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashCode the hash code of the key to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param next the next entry in sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashCode the hash code to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the newly created entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashIndex the index into the data array to store at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashIndex the index into the data structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous the previous entry in the chain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashIndex the index into the data structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous the previous entry in the chain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to destroy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newCapacity the new capacity of the array (a power of two, less or equal to max)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param proposedCapacity the proposed capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the normalized new capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newCapacity the new capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor the load factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new resize threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to query, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>next</code> field of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the entry is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to query, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>hashCode</code> field of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the entry is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to query, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>key</code> field of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the entry is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to query, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>value</code> field of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the entry is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the map iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entrySet view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entrySet iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the keySet view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the keySet iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the values view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the values iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Sample values of the y-coordinate, in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Values of the function on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dFdX Values of the partial derivative of function with respect\nto x on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dFdY Values of the partial derivative of function with respect\nto y on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d2FdXdY Values of the cross partial derivative of function on\nevery grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the various arrays do not contain\nthe expected number of elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code x} or {@code y} are\nnot strictly increasing."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Sample values of the x-coordinate, in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Sample values of the y-coordinate, in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Values of the function on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dFdX Values of the partial derivative of function with respect\nto x on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dFdY Values of the partial derivative of function with respect\nto y on every grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d2FdXdY Values of the cross partial derivative of function on\nevery grid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initializeDerivatives Whether to initialize the internal data\nneeded for calling any of the methods that compute the partial derivatives\nthis function."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the various arrays do not contain\nthe expected number of elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code x} or {@code y} are\nnot strictly increasing."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pX Powers of the x-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pY Powers of the y-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param coeff Spline coefficients."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the interpolated value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the partial derivative wrt {@code x}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the partial derivative wrt {@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the second partial derivative wrt {@code x}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the second partial derivative wrt {@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the second partial cross-derivative."
    },
    {
        "oracle": ";",
        "javadocTag": "@param coeff Spline coefficients."
    },
    {
        "oracle": ";",
        "javadocTag": "@param coeff Spline coefficients."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initializeDerivatives Whether to initialize the internal data\nneeded for calling any of the methods that compute the partial derivatives\nthis function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xval the arguments for the interpolation points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yval the values for the interpolation points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return A cubic spline built upon a loess fit to the data at the original abscissae"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code xval} not sorted in\nstrictly increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code xval} and {@code yval} have\ndifferent sizes."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if {@code xval} or {@code yval} has zero size."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if any of the arguments and values are\nnot finite real numbers."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the bandwidth is too small to\naccomodate the size of the input data (i.e. the bandwidth must be\nlarger than 2/n)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xval Arguments for the interpolation points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param yval Values for the interpolation points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights point weights: coefficients by which the robustness weight\nof a point is multiplied."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the values of the loess fit at corresponding original abscissae."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code xval} not sorted in\nstrictly increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code xval} and {@code yval} have\ndifferent sizes."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if {@code xval} or {@code yval} has zero size."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if any of the arguments and values are\n     not finite real numbers."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the bandwidth is too small to\naccomodate the size of the input data (i.e. the bandwidth must be\nlarger than 2/n)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xval the arguments for the interpolation points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yval the values for the interpolation points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return values of the loess fit at corresponding original abscissae"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code xval} not sorted in\nstrictly increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code xval} and {@code yval} have\ndifferent sizes."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if {@code xval} or {@code yval} has zero size."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if any of the arguments and values are\nnot finite real numbers."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the bandwidth is too small to\naccomodate the size of the input data (i.e. the bandwidth must be\nlarger than 2/n)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xval Arguments array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights Weights array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i Index around which the new interval should be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param bandwidthInterval a two-element array {left, right} such that:\n{@code (left==0 or xval[i] - xval[left-1] > xval[right] - xval[i])}\nand\n{@code (right==xval.length-1 or xval[right+1] - xval[i] > xval[i] - xval[left])}.\nThe array will be updated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights Weights array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i Index from which to start search."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the smallest compliant index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>(1 - |x|<sup>3</sup>)<sup>3</sup></code> for |x| &lt; 1, 0 otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values Values array."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotFiniteNumberException if one of the values is not a finite real number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param accuracy If the median residual at a certain robustness iteration\nis less than this amount, no more iterations are done."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Interpolating points array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Interpolating values array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a function which interpolates the dataset."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths are different."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code x} is not sorted in\nstrictly increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Interpolating points array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Interpolating values array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a fresh copy of the divided difference array."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array lengths are different."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code x} is not sorted in strictly increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x abscissa of the sample point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value and derivatives of the sample point\n(if only one row is passed, it is the value, if two rows are\npassed the first one is the value and the second the derivative\nand so on)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if the abscissa difference between added point\nand a previous point is zero (i.e. the two points are at same abscissa)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the number of derivatives is larger\nthan 20, which prevents computation of a factorial"
    },
    {
        "oracle": ";",
        "javadocTag": "@return interpolation polynomials array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if sample is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x interpolation abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@return interpolated value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if sample is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x interpolation abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@return interpolated value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if sample is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if interpolation cannot be performed\nbecause sample is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c polynomials coefficients"
    },
    {
        "oracle": ";",
        "javadocTag": "@return polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if any of the variables is outside its interpolation range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x First coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Second coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z Third coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if (x, y, z) is a valid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Coordinate samples."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index in {@code val} corresponding to the interval containing {@code c}, or {@code -1}\n  if {@code c} is out of the range defined by the end values of {@code val}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param beta List of function values and function partial derivatives values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the spline coefficients."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Maximum absolute error in inverse\ncumulative probability estimates (defaults to\n{@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Maximum absolute error in inverse\ncumulative probability estimates (defaults to\n{@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the point at which the PMF is evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the probability mass function at point {@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the point at which the PDF is evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the probability density function at point {@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the point at which the CDF is evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x0 the exclusive lower bound"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x1 the inclusive upper bound"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the probability that a random variable with this distribution\ntakes a value between {@code x0} and {@code x1},\nexcluding the lower and including the upper endpoint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the cumulative probability"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the smallest {@code p}-quantile of this distribution\n(largest 0-quantile for {@code p = 0})"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mean or {@code Double.NaN} if it is not defined"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance (possibly {@code Double.POSITIVE_INFINITY} as\nfor certain cases in {@link TDistribution}) or {@code Double.NaN} if it\nis not defined"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (might be\n{@code Double.NEGATIVE_INFINITY})"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (might be\n{@code Double.POSITIVE_INFINITY})"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the lower bound of support is finite and the density\nfunction returns a non-NaN, non-infinite value there"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the upper bound of support is finite and the density\nfunction returns a non-NaN, non-infinite value there"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the support is connected or not"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the new seed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleSize the number of random values to generate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array representing the random sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mean for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the standard deviation for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (always\n{@code Double.NEGATIVE_INFINITY})"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (always\n{@code Double.POSITIVE_INFINITY})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean Mean for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sd Standard deviation for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean Mean for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sd Standard deviation for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Inverse cumulative probability accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean Mean for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sd Standard deviation for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean Mean for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sd Standard deviation for this distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Inverse cumulative probability accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z the value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Striling's series error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the x value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu the average."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a part of the deviance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value at which the probability is evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the number of trials."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the probability of success."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q the probability of failure (1 - p)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return log(p(x))."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights Weights of each component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param means Mean vector for each component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param covariances Covariance matrix for each component."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of components."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights Weights of each component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param means Mean vector for each component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param covariances Covariance matrix for each component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param components List of (weight, distribution) pairs from which to sample."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param components Distributions from which to sample."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if any of the weights is negative."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if not all components have the same\nnumber of variables."
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower Lower bound of this distribution (inclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper Upper bound of this distribution (exclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower Lower bound of this distribution (inclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper Upper bound of this distribution (exclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Inverse cumulative probability accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower Lower bound of this distribution (inclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper Upper bound of this distribution (exclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Inverse cumulative probability accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower Lower bound of this distribution (inclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper Upper bound of this distribution (exclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the location parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scale parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu location parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu location parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the exponent"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mean of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Term in the series to calculate (must be larger than 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Exponent (special case {@code m = 1} is the harmonic series)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the n<sup>th</sup> generalized harmonic number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (always 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfElements Number of elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param exponent Exponent."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfElements Number of elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param exponent Exponent."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of trials."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the probability of success."
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (0 or the number of trials)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (number of trials or 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> type of the enumeration and vector elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e an enumeration to convert to a Vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector containing the elements of the enumeration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> type of the input list elements, and type of the innermost output list elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dims number of dimensions:  that is, size of each innermost list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start initial index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param objs list of elements to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of lists of length dims, each of which combines elements from objs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arity size of each innermost list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start initial value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cnt maximum element value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of lists of length arity, each of which combines integers from start to cnt"
    },
    {
        "oracle": ";",
        "javadocTag": "@param qualified_name the fully-qualified name of a class"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the simple unqualified name of the class"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cls a class"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the simple unqualified name of the class"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val a numeric value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an abbreviated string representation of the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o object whose hash code to compute"
    },
    {
        "oracle": ";",
        "javadocTag": "@return o's hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o1 the first value to test for equality"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o2 the second value to test for equality"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether o1 equals o2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args command-line arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximum capacity of the set representation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max_values the maximum size for the returned LimitedSizeIntSet"
    },
    {
        "oracle": ";",
        "javadocTag": "@param slist a list of LimitedSizeIntSet, whose elements will be merged"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a LimitedSizeIntSet that merges the elements of slist"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max_values the maximum number of values this set will be able to hold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the Object to be assigned to a bucket"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a key representing the bucket containing obj"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <A> type of first argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <B> type of second argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> type of third argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c third argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a triple of the values (a, b, c)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param enabled whether to enable or disable logging"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val whether to parse arguments after a non-option command-line argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val whether to parse long options with a single dash, as in -longOption"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the commandline to be parsed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return all non-option arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArgException if the command line contains unknown option or\nmisused options."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the command line to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@return all non-option arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArgException if the command line contains misused options or an unknown option."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the command line to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@return all non-option arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the command line to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@return all non-option arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ps where to print usage information"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ps where to print usage information"
    },
    {
        "oracle": ";",
        "javadocTag": "@param msg message to print before usage information"
    },
    {
        "oracle": ";",
        "javadocTag": "@param msg messag. to print before usage information"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ps where to print usage information"
    },
    {
        "oracle": ";",
        "javadocTag": "@param format message to print before usage information"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args objects to put in formatted message"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the command-line usage message"
    },
    {
        "oracle": ";",
        "javadocTag": "@param group_names the list of option groups to include in the usage\nmessage.  If empty and option groups are being used, will return usage\nfor all option groups that are not unpublicized.  If empty and option\ngroups are not being used, will return usage for all options that are\nnot unpublicized."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the command-line usage message"
    },
    {
        "oracle": ";",
        "javadocTag": "@param include_unpublicized if true, treat all unpublicized options\nand option groups as publicized"
    },
    {
        "oracle": ";",
        "javadocTag": "@param group_names the list of option groups to include in the usage\nmessage.  If empty and option groups are being used, will return usage\nfor all option groups that are not unpublicized.  If empty and option\ngroups are not being used, will return usage for all options that are\nnot unpublicized."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the length of the longest synopsis message in a list of options"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the enum type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a short name for the specified type for use in messages"
    },
    {
        "oracle": ";",
        "javadocTag": "@return options, similarly to supplied on the command line"
    },
    {
        "oracle": ";",
        "javadocTag": "@return options, similarly to supplied on the command line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param include_unpublicized if true, treat all unpublicized options\nand option groups as publicized"
    },
    {
        "oracle": ";",
        "javadocTag": "@return options, similarly to supplied on the command line"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a description of all of the known options"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the classes whose options to process"
    },
    {
        "oracle": ";",
        "javadocTag": "@param usage_synopsis a synopsis of how to call your program"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the classes whose options to process"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the smallest value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the smallest value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the smallest value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the smallest value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the smallest value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the smallest value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the largest value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the largest value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the largest value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the largest value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the largest value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the largest value in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a two-element array containing the smallest and largest values in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a two-element array containing the smallest and largest values in the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the difference between the smallest and largest array elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the difference between the smallest and largest array elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of an array of integers"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of all the elements of a 2d array of integers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of an array of doubles"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of all the elements of a 2d array of doubles"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the base type of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lst the list to convert to an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the result of lst.toArray, casted to a more precise type than Object[]"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the sequence elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array that concatenates the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the sequence elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array that concatenates the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the sequence elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array that concatenates the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the sequence elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array that concatenates the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first array to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second array to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array that concatenates the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array that concatenates the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array that concatenates the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array that concatenates the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array that concatenates the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array that concatenates the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array that concatenates the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array that concatenates the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second sequence to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array that concatenates the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param quoted whether to quote the array elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a a collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param quoted whether to quote the collection elements that are Java strings"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj a list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff a does not contain duplicate elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff a does not contain duplicate elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff a does not contain duplicate elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff a does not contain duplicate elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff a does not contain duplicate elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff a does not contain duplicate elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff a does not contain duplicate elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff a does not contain duplicate elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff a does not contain duplicate elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff a does not contain duplicate elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a a list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param trials Number of trials."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Probability of success."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param trials Number of trials."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Probability of success."
    },
    {
        "oracle": ";",
        "javadocTag": "@param singletons values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param probabilities probabilities"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of value/probability pairs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code sum(singletons[i] * probabilities[i])}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code sum((singletons[i] - mean) ^ 2 * probabilities[i])}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lowest value with non-zero probability."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the highest value with non-zero probability."
    },
    {
        "oracle": ";",
        "javadocTag": "@param singletons array of random variable values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param probabilities array of probabilities."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if\n{@code singletons.length != probabilities.length}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if any of the probabilities are negative."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if any of the probabilities are infinite."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotANumberException if any of the probabilities are NaN."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException all of the probabilities are 0."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param singletons array of random variable values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param probabilities array of probabilities."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if\n{@code singletons.length != probabilities.length}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if any of the probabilities are negative."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if any of the probabilities are infinite."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotANumberException if any of the probabilities are NaN."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException all of the probabilities are 0."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng random number generator used for sampling"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data input dataset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data input dataset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the point at which the PMF is evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the probability mass function at {@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the point at which the CDF is evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x0 the exclusive lower bound"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x1 the inclusive upper bound"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the probability that a random variable with this distribution\nwill take a value between {@code x0} and {@code x1},\nexcluding the lower and including the upper endpoint"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the cumulative probability"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the smallest {@code p}-quantile of this distribution\n(largest 0-quantile for {@code p = 0})"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mean or {@code Double.NaN} if it is not defined"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance (possibly {@code Double.POSITIVE_INFINITY} or\n{@code Double.NaN} if it is not defined)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support ({@code Integer.MIN_VALUE}\nfor negative infinity)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support ({@code Integer.MAX_VALUE}\nfor positive infinity)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the support is connected or not"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the new seed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleSize the number of random values to generate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array representing the random sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the shape parameter, {@code alpha}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scale parameter, {@code beta}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the solver absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mean of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance of this distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the support (always 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the support (always\n{@code Double.POSITIVE_INFINITY})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha Shape parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param beta Scale parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha Shape parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param beta Scale parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Maximum absolute error in inverse\ncumulative probability estimates\n(defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha Shape parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param beta Scale parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha Shape parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param beta Scale parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseCumAccuracy Maximum absolute error in inverse\ncumulative probability estimates\n(defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Point at which the PDF is evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the probability density function at point {@code x}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed Seed with which to initialize the random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of variables."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random value vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleSize the number of random vectors to generate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array representing the random samples."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the shape parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scale parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseAbsoluteAccuracy the maximum absolute error in inverse\ncumulative probability estimates (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inverseAbsoluteAccuracy the maximum absolute error in inverse\ncumulative probability estimates (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the new seed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the point at which the PMF is evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the probability mass function at {@code x}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the probability mass function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleSize the number of random values to generate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array representing the random sample."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleSize the number of random values to generate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to populate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array representing the random sample."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pmf probability mass function enumerated as a list of <T, probability>\npairs."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if any of the probabilities are negative."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if any of the probabilities are infinite."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotANumberException if any of the probabilities are NaN."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException all of the probabilities are 0."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng random number generator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pmf probability mass function enumerated as a list of <T, probability>\npairs."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if any of the probabilities are negative."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if any of the probabilities are infinite."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a shallow clone"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code defined in the Map interface"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string version of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new predicated map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to validate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to validate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to validate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if a value predicate is in use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new fixed size sorted map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new unmodifiable sorted map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new predicated sorted map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue the default value to return when the key is not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new defaulting map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new defaulting map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new defaulting map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue the default value to return when the key is not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValueTransformer transformer to use to generate missing values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValueTransformer the value transformer to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to get a hash code for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to get a hash code for, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to get a hash code for, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code, as per the MapEntry specification"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key to compare passed in from outside"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key extracted from the entry via <code>entry.key</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal by identity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value1 the first value to compare passed in from outside"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value2 the second value extracted from the entry via <code>getValue()</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal by identity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyType the type of reference to use for keys;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueType the type of reference to use for values;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyType the type of reference to use for keys;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueType the type of reference to use for values;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param purgeValues should the value be automatically purged when the\n  key is garbage collected"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyType the type of reference to use for keys;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueType the type of reference to use for values;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param capacity the initial capacity for the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor for the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyType the type of reference to use for keys;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueType the type of reference to use for values;\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param capacity the initial capacity for the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor for the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param purgeValues should the value be automatically purged when the\n  key is garbage collected"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the map may not be changed by setValue"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the specified value is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the class of the specified value is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new fixed size map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new lazy sorted map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new lazy sorted map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the derivative function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the derivative function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of spline segments."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the interpolating polynomials."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the knot points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code x} is a valid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param knots Spline segment interval delimiters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param polynomials Polynomial functions that make up the spline."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if knots has length less than 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code polynomials.length != knots.length - 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if the {@code knots} array is not strictly increasing."
    },
    {
        "oracle": ";",
        "javadocTag": "@param degree degree of the polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Chebyshev polynomial of specified degree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param degree degree of the polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Hermite polynomial of specified degree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param degree degree of the polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Laguerre polynomial of specified degree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param degree degree of the polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Legendre polynomial of specified degree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param degree degree of the polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v first exponent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param w second exponent"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Jacobi polynomial of specified degree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients Coefficients of the original polynomial."
    },
    {
        "oracle": ";",
        "javadocTag": "@param shift Shift value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the coefficients \\(b_i\\) of the shifted\npolynomial."
    },
    {
        "oracle": ";",
        "javadocTag": "@param degree degree of the polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients list where the computed coefficients are stored"
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator recurrence coefficients generator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return coefficients array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param degree maximal degree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxDegree current maximal degree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator recurrence coefficients generator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients list where the computed coefficients should be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument for which the function value should be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the polynomial at the given point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the degree of the polynomial."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a fresh copy of the coefficients array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients Coefficients of the polynomial to evaluate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param argument Input value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the polynomial."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Polynomial to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new polynomial which is the sum of the instance and {@code p}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Polynomial to subtract."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new polynomial which is the instance minus {@code p}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new polynomial with all coefficients negated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Polynomial to multiply by."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new polynomial equal to this times {@code p}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coefficients Coefficients of the polynomial to differentiate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the derivative polynomial."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the derivative function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the polynomial."
    },
    {
        "oracle": ";",
        "javadocTag": "@param coeff Coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of {@code coeff}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Polynomial coefficients."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Point at which the function value should be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the function."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException when the activated method itself can\nascertain that a precondition, specified in the API expressed at the\nlevel of the activated method, has been violated.\nWhen Commons Math throws an {@code IllegalArgumentException}, it is\nusually the consequence of checking the actual parameters passed to\nthe method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x First coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Second coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if (x, y) is a valid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x x-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y y-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value at point (x, y) of the first partial derivative with\nrespect to x."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code x} (resp. {@code y}) is outside\nthe range defined by the boundary values of {@code xval} (resp.\n{@code yval})."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the internal data were not initialized\n(cf. {@link #BicubicSplineInterpolatingFunction(double[],double[],double[][],\n            double[][],double[][],double[][],boolean) constructor})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x x-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y y-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value at point (x, y) of the first partial derivative with\nrespect to y."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code x} (resp. {@code y}) is outside\nthe range defined by the boundary values of {@code xval} (resp.\n{@code yval})."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the internal data were not initialized\n(cf. {@link #BicubicSplineInterpolatingFunction(double[],double[],double[][],\n            double[][],double[][],double[][],boolean) constructor})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x x-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y y-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value at point (x, y) of the second partial derivative with\nrespect to x."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code x} (resp. {@code y}) is outside\nthe range defined by the boundary values of {@code xval} (resp.\n{@code yval})."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the internal data were not initialized\n(cf. {@link #BicubicSplineInterpolatingFunction(double[],double[],double[][],\n            double[][],double[][],double[][],boolean) constructor})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x x-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y y-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value at point (x, y) of the second partial derivative with\nrespect to y."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code x} (resp. {@code y}) is outside\nthe range defined by the boundary values of {@code xval} (resp.\n{@code yval})."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the internal data were not initialized\n(cf. {@link #BicubicSplineInterpolatingFunction(double[],double[],double[][],\n            double[][],double[][],double[][],boolean) constructor})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x x-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y y-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value at point (x, y) of the second partial cross-derivative."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code x} (resp. {@code y}) is outside\nthe range defined by the boundary values of {@code xval} (resp.\n{@code yval})."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the internal data were not initialized\n(cf. {@link #BicubicSplineInterpolatingFunction(double[],double[],double[][],\n            double[][],double[][],double[][],boolean) constructor})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param which First index in {@link #partialDerivatives}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x x-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y y-coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value at point (x, y) of the selected partial derivative."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code x} (resp. {@code y}) is outside\nthe range defined by the boundary values of {@code xval} (resp.\n{@code yval})."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the internal data were not initialized\n(cf. {@link #BicubicSplineInterpolatingFunction(double[],double[],double[][],\n            double[][],double[][],double[][],boolean) constructor})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Coordinate samples."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index in {@code val} corresponding to the interval\ncontaining {@code c}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code c} is out of the\nrange defined by the boundary values of {@code val}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param beta List of function values and function partial derivatives\nvalues."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the spline coefficients."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Sample values of the x-coordinate, in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a short, <code>0</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as an int, <code>0</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a long, <code>0L</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a float, <code>0.0F</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a double, <code>0.0</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue return if the value is null or if the conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a Boolean, <code>defaultValue</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue return if the value is null or if the conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a byte, <code>defaultValue</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue return if the value is null or if the conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a short, <code>defaultValue</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue return if the value is null or if the conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as an int, <code>defaultValue</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue return if the value is null or if the conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a long, <code>defaultValue</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue return if the value is null or if the conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a float, <code>defaultValue</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultValue return if the value is null or if the conversion fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value in the Map as a double, <code>defaultValue</code> if null map input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to convert to a Properties object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the properties object"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if a key or value in the provided map is {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hashmap containing the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param label The label to be used, may be <code>null</code>.\n If <code>null</code>, the label is not output.\n It typically represents the name of the property in a bean or similar."
    },
    {
        "oracle": ";",
        "javadocTag": "@param map The map to print, may be <code>null</code>.\n If <code>null</code>, the text 'null' is output."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the stream is <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param label The label to be used, may be <code>null</code>.\n  If <code>null</code>, the label is not output.\n  It typically represents the name of the property in a bean or similar."
    },
    {
        "oracle": ";",
        "javadocTag": "@param map The map to print, may be <code>null</code>.\n  If <code>null</code>, the text 'null' is output."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the stream is <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the stream to print to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param label the label to be used, may be <code>null</code>.\n  If <code>null</code>, the label is not output.\n  It typically represents the name of the property in a bean or similar."
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to print, may be <code>null</code>.\n  If <code>null</code>, the text 'null' is output"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lineage a stack consisting of any maps in which the previous\n  argument is contained. This is checked to avoid infinite recursion when\n  printing the output"
    },
    {
        "oracle": ";",
        "javadocTag": "@param debug flag indicating whether type names should be output."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the stream is <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the stream to indent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new HashMap containing the inverted data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the input map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if sub-array or entry matching used and an entry is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the array contents is mixed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map, possibly <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an empty map if the argument is <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to check, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if empty or null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to check, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if non-null and non-empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized map backed by the given map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable map backed by the given map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a predicated map backed by the given map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param url The URL to fetch."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while fetching the URL."
    },
    {
        "oracle": ";",
        "javadocTag": "@param url The URL to fetch."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if there are still events to read, false as soon as the file\n        is finished."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while closing the file."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graphId id of the graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param port port on which server will be bound"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if server creation failed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId Identifier of the graph where the attribute changed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The attribute new value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId Identifier of the graph where the attribute changed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldValue The attribute old value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue The attribute new value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId Identifier of the graph where the attribute was removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The removed attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId Identifier of the graph where the change occurred."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId Identifier of the node whose attribute changed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The attribute new value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId Identifier of the graph where the change occurred."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId Identifier of the node whose attribute changed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldValue The attribute old value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue The attribute new value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId Identifier of the graph where the attribute was removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeId Identifier of the node whose attribute was removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The removed attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId Identifier of the graph where the change occurred."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId Identifier of the edge whose attribute changed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The attribute new value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId Identifier of the graph where the change occurred."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId Identifier of the edge whose attribute changed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldValue The attribute old value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newValue The attribute new value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceId Identifier of the graph where the attribute was removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeId Identifier of the edge whose attribute was removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The removed attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename The file name where the graph will be written."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A file sink or null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgesAreDirected If true (default=false) edges are considered directed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgesAreDirected If true (default=false) edges are considered directed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param declareNodes If true (default=true) this reader outputs nodeAdded events."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graph to export."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If any I/O error occurs."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If any I/O error occurs."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileName Name of the file to output to."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A new writer."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If any I/O error occurs."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stream An already existing output stream."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A new writer."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If any I/O error occurs."
    },
    {
        "oracle": ";",
        "javadocTag": "@param writer An already existing writer."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A new writer."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If any I/O error occurs."
    },
    {
        "oracle": ";",
        "javadocTag": "@param group the style group to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return string representation of the style group usable in TikZ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graph to send as events to the file."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileName Name of the file to write."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs while writing."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graph to send as events to the file."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stream The stream where the graph is sent."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs while writing."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graph to send as events to the file."
    },
    {
        "oracle": ";",
        "javadocTag": "@param writer The writer where the graph is sent."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs while writing."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileName The name of the file where to output the graph events."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while writing."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stream The file stream where to output the graph events."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while writing."
    },
    {
        "oracle": ";",
        "javadocTag": "@param writer The writer where to output the graph events."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs while writing."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an I/O error occurs during write."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException "
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next event in the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the event"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e event producing an error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param msg message to put in the exception"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args arguments of the message"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new parse exception"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e event to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type expected type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name expected name"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true is type and name are valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e event to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type expected type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name expected name"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws XMLStreamException if event has invalid type or name"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stream "
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i Index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of this instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Number of surface elements of the sphere."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxDarkFraction Maximum fraction of the facets that can be dark.\nIf the fraction of \"non-illuminated\" facets is larger, no estimation\nof the value will be performed, and the {@code background} value will\nbe returned instead."
    },
    {
        "oracle": ";",
        "javadocTag": "@param darkThreshold Value of the illumination below which a facet is\nconsidered dark."
    },
    {
        "oracle": ";",
        "javadocTag": "@param background Value returned when the {@code maxDarkFraction}\nthreshold is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.OutOfRangeException if\n{@code maxDarkFraction} does not belong to the interval {@code [0, 1]}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Instance to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x First coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Second coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if (x, y) is a valid point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Coordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param val Coordinate samples."
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset how far back from found value to offset for querying"
    },
    {
        "oracle": ";",
        "javadocTag": "@param count total number of elements forward from beginning that will be\n       queried"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index in {@code val} corresponding to the interval containing\n        {@code c}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code c} is out of the range defined by\n        the boundary values of {@code val}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Sample values of the x-coordinate, in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Sample values of the y-coordinate, in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Values of the function on every grid point. the expected number\n       of elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if {@code x} or {@code y} are not\n        strictly increasing."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of x and y don't match the row, column\n        height of f"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Interpolation point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the interpolated value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if point dimension does not math sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param w Vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cosine of the angle between {@code v} and {@code w}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xval Arguments for the interpolation points.\n{@code xval[i][0]} is the first component of interpolation point\n{@code i}, {@code xval[i][1]} is the second component, and so on\nuntil {@code xval[i][d-1]}, the last component of that interpolation\npoint (where {@code dimension} is thus the dimension of the sampled\nspace)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param yval Values for the interpolation points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param brightnessExponent Brightness dimming factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@param microsphereElements Number of surface elements of the\nmicrosphere."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rand Unit vector generator for creating the microsphere."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the lengths of {@code yval} and\n{@code xval} (equal to {@code n}, the number of interpolation points)\ndo not match, or the the arrays {@code xval[0]} ... {@code xval[n]},\nhave lengths different from {@code dimension}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements Number of surface elements of the microsphere."
    },
    {
        "oracle": ";",
        "javadocTag": "@param exponent Exponent used in the power law that computes the\nweights (distance dimming factor) of the sample data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the first number"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y the second number"
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps the amount of error to allow when checking for equality"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>\n      <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>\n      <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y or\n      either argument is NaN</li></ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxUlps {@code (maxUlps - 1)} is the number of floating point\nvalues between {@code x} and {@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <ul><li>0 if  {@link #equals(double, double, int) equals(x, y, maxUlps)}</li>\n      <li>&lt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x &lt; y</li>\n      <li>&gt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x > y\n      or either argument is NaN</li></ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the values are equal."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the values are equal or both are NaN."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps the amount of absolute error to allow."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the values are equal or within range of each other."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps the amount of absolute error to allow."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the values are equal or within range of each other,\nor both are NaN."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxUlps {@code (maxUlps - 1)} is the number of floating point\nvalues between {@code x} and {@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if there are fewer than {@code maxUlps} floating\npoint values between {@code x} and {@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxUlps {@code (maxUlps - 1)} is the number of floating point\nvalues between {@code x} and {@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if both arguments are NaN or if there are less than\n{@code maxUlps} floating point values between {@code x} and {@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the values are equal."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the values are equal or both are NaN."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x First value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Second value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps Amount of allowed absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the values are two adjacent floating point\nnumbers or they are within range of each other."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x First value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Second value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps Amount of allowed relative error."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the values are two adjacent floating point\nnumbers or they are within range of each other."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps the amount of absolute error to allow."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the values are equal or within range of each other,\nor both are NaN."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxUlps {@code (maxUlps - 1)} is the number of floating point\nvalues between {@code x} and {@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if there are fewer than {@code maxUlps} floating\npoint values between {@code x} and {@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxUlps {@code (maxUlps - 1)} is the number of floating point\nvalues between {@code x} and {@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if both arguments are NaN or if there are less than\n{@code maxUlps} floating point values between {@code x} and {@code y}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Value to round."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale Number of digits to the right of the decimal point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the rounded value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Value to round."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale Number of digits to the right of the decimal point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param roundingMethod Rounding method as defined in {@link BigDecimal}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return all edges which have their tail in S, and their head in T. If\ncomputeMinCut(V source, V sink) has not been invoked, this method returns\nnull."
    },
    {
        "oracle": ";",
        "javadocTag": "@return source of last minCut call, null if there was no call"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sink of last minCut call, null if there was no call"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elementList list of paths at vertex v."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge edge (v->y)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if at least one path has been added in the\nlist, <code>false</code> otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of <code>RankingPathElement</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pathElement "
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge via which the vertex was encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cost obtained by concatenation."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the specified path element disconnects the\nguard-vertex, <code>false</code> otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param prevPathElement "
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge "
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the resulting path (obtained by\nconcatenating the specified edge to the specified path) is simple, <code>\nfalse</code> otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize max number of paths the list is able to store."
    },
    {
        "oracle": ";",
        "javadocTag": "@param prevPathElementList paths, list of <code>\nRankingPathElement</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge edge reaching the end vertex of the created paths."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize maximum number of paths the list is able to store."
    },
    {
        "oracle": ";",
        "javadocTag": "@param prevPathElementList paths, list of <code>\nRankingPathElement</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge edge reaching the end vertex of the created paths."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize maximum number of paths the list is able to store."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize max number of paths the list is able to store."
    },
    {
        "oracle": ";",
        "javadocTag": "@return set of Edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph - Graph to compute transitive closure for."
    },
    {
        "oracle": ";",
        "javadocTag": "@param augmentingPath "
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexSet1 "
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexSet2 "
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the intersection is NOT empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph graph over which to run algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if a negative weight edge is found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if graph has less than 2 vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize maximum number of paths the list is able to store."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elementList paths, list of <code>AbstractPathElement</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge edge reaching the end vertex of the created paths."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the specified prevPathElementList or edge\nis <code>null</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize maximum number of paths the list is able to store."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if <code>pathElement</code> is not\nempty."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize maximum number of paths the list is able to store."
    },
    {
        "oracle": ";",
        "javadocTag": "@param G target weighted bipartite graph to find matching in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param S first vertex partition of the target bipartite graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param T second vertex partition of the target bipartite graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix the original matrix to transform into a path matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pathMatrix the path matrix to reduce"
    },
    {
        "oracle": ";",
        "javadocTag": "@param directedGraph the directed graph that will be reduced transitively"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g The graph to be checked"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true for Eulerian and false for non-Eulerian"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g The graph to find an Eulerian circuit"
    },
    {
        "oracle": ";",
        "javadocTag": "@return null if no Eulerian circuit exists, or a list of vertices\nrepresenting the Eulerian circuit if one does exist"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the vertex whose predecessors are desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return all unique predecessors of the specified vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the vertex whose predecessors are desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return all predecessors of the specified vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the vertex whose successors are desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return all unique successors of the specified vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the vertex whose successors are desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return all successors of the specified vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph for which a neighbor index is to be created."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first element to find LCA for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the other element to find the LCA for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first found LCA of a and b, or null if there is no LCA."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first element to find LCA for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the other element to find the LCA for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the set of all LCA of a and b, or empty set if there is no LCA."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexSet the set of vertex to find parents of"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set of every parent of every vertex passed in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x set containing vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y set containing vertex, which may be ordered to give predictable\nresults"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first element of y that is also in x, or null if no such\nelement"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph simple undirected weighted bipartite graph to find matching\nin, with positive integer edge weights"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexPartition1 first vertex partition of the bipartite graph,\ndisjoint from vertexPartition2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexPartition2 second vertex partition of the bipartite graph,\ndisjoint from vertexPartition1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> "
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> "
    },
    {
        "oracle": ";",
        "javadocTag": "@param g is the graph to find the optimal tour for."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The optimal tour as a list of vertices."
    },
    {
        "oracle": ";",
        "javadocTag": "@param endVertex target vertex of the calculated paths."
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of paths, or <code>null</code> if no path exists between the\nstart vertex and the end vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph "
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex "
    },
    {
        "oracle": ";",
        "javadocTag": "@param k number of paths to be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph graph on which shortest paths are searched."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex start vertex of the calculated paths."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nPaths number of ranking paths between the start vertex and an end\nvertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nMaxHops maximum number of edges of the calculated paths."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the vertex whose neighbors are desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return all unique neighbors of the specified vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the vertex whose neighbors are desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return all neighbors of the specified vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph for which a neighbor index is to be created."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph for which vertex cover approximation is to be found."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set of vertices which is a vertex cover for the specified\ngraph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph for which vertex cover approximation is to be found."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set of vertices which is a vertex cover for the specified\ngraph."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the graph contains at least one cycle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the vertex to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if v is on at least one cycle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return set of all vertices which participate in at least one cycle in\nthis graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the vertex to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return set of all vertices reachable from v via at least one cycle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph the DirectedGraph in which to detect cycles"
    },
    {
        "oracle": ";",
        "javadocTag": "@param control1 first stepsize control factor (the factor is\nreset to default if lower than 0.0001 or greater than 0.9999)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param control2 second stepsize control factor (the factor\nis reset to default if lower than 0.0001 or greater than 0.9999)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param control3 third stepsize control factor (the factor is\nreset to default if lower than 0.0001 or greater than 0.9999)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param control4 fourth stepsize control factor (the factor\nis reset to default if lower than 1.0001 or greater than 999.9)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximalOrder maximal order in the extrapolation table (the\nmaximal order is reset to default if order <= 6 or odd)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param control1 first order control factor (the factor is\nreset to default if lower than 0.0001 or greater than 0.9999)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param control2 second order control factor (the factor\nis reset to default if lower than 0.0001 or greater than 0.9999)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param useInterpolationErrorForControl if true, interpolation error is used\nfor stepsize control"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mudifControlParameter interpolation order control parameter (the parameter\nis reset to default if <= 0 or >= 7)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y1 first state vector to use for scaling"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y2 second state vector to use for scaling"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale scaling array to update (can be shorter than state)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 initial time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 initial value of the state vector at t0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k iteration number (from 0 to sequence.length - 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale scaling array (can be shorter than state)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f placeholder where to put the state vector derivatives at each substep\n         (element 0 already contains initial derivative)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yMiddle placeholder where to put the state vector at the middle of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yEnd placeholder where to put the state vector at the end"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yTmp placeholder for one state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if computation was done properly,\n        false if stability check failed before end of computation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset offset to use in the coefficients table"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k index of the last updated point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param diag working diagonal of the Aitken-Neville's\ntriangle, without the last element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param last last element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@return order of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@return safety factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param safety safety factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return minimal reduction factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minReduction minimal reduction factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximal growth factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxGrowth maximal growth factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotK derivatives computed during the first stages"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 estimate of the step at the start of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y1 estimate of the step at the end of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h current step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return error ratio, greater than 1 if step should be rejected"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fsal indicate that the method is an <i>fsal</i>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c time steps from Butcher array (without the first zero)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a internal weights from Butcher array (without the first empty row)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b propagation weights for the high order method from Butcher array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param prototype prototype of the step interpolator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fsal indicate that the method is an <i>fsal</i>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c time steps from Butcher array (without the first zero)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a internal weights from Butcher array (without the first empty row)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b propagation weights for the high order method from Butcher array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param prototype prototype of the step interpolator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator to copy from. The copy is a deep\ncopy: its arrays are separated from the original arrays of the\ninstance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotK slopes at the intermediate points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotK slopes at the intermediate points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the multistep method\n(excluding the one being computed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Nordsieck transformer for the specified number of steps"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of steps of the method\n(excluding the one being computed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows number of rows of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return P matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param raw input buffer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param encoded output buffer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param raw input buffer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param encoded output buffer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param serializableObject The object to encode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The Base64-encoded object"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException if there is an error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if serializedObject is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param serializableObject The object to encode"
    },
    {
        "oracle": ";",
        "javadocTag": "@param options Specified options"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The Base64-encoded object"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException if there is an error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source The data to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The data in Base64-encoded form"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source The data to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param options Specified options"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The Base64-encoded data as a String"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException if there is an error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source The data to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param off Offset in array where conversion should begin"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len Length of data to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The Base64-encoded data as a String"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if source array, offset, or length are invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source The data to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param off Offset in array where conversion should begin"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len Length of data to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param options Specified options"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The Base64-encoded data as a String"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException if there is an error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if source array, offset, or length are invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source The data to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The Base64-encoded data as a byte[] (of ASCII characters)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source The data to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param off Offset in array where conversion should begin"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len Length of data to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param options Specified options"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The Base64-encoded data as a String"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException if there is an error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if source array, offset, or length are invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the array to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcOffset the index where conversion begins"
    },
    {
        "oracle": ";",
        "javadocTag": "@param destination the array to hold the conversion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param destOffset the index where output will be put"
    },
    {
        "oracle": ";",
        "javadocTag": "@param options alphabet type is pulled from this (standard, url-safe, ordered)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of decoded bytes converted"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if source or destination arrays are null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if srcOffset or destOffset are invalid\n        or there is not enough room in the array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source The Base64 encoded data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return decoded data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source The Base64 encoded data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param off The offset of where to begin decoding"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len The length of characters to decode"
    },
    {
        "oracle": ";",
        "javadocTag": "@param options Can specify options such as alphabet type to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return decoded data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException If bogus characters exist in source data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the string to decode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decoded data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException If there is a problem"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the string to decode"
    },
    {
        "oracle": ";",
        "javadocTag": "@param options encode options such as URL_SAFE"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decoded data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException if there is an error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param encodedObject The Base64 data to decode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The decoded and deserialized object"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException if there is a general error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if the decoded object is of a\n        class that cannot be found by the JVM"
    },
    {
        "oracle": ";",
        "javadocTag": "@param encodedObject The Base64 data to decode"
    },
    {
        "oracle": ";",
        "javadocTag": "@param options Various parameters related to decoding"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loader Optional class loader to use in deserializing classes."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The decoded and deserialized object"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException if there is a general error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if the decoded object is of a \n        class that cannot be found by the JVM"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dataToEncode byte array of data to encode in base64 form"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename Filename for saving encoded data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException if there is an error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dataToDecode Base64-encoded data as a string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename Filename for saving decoded data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException if there is an error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename Filename for reading encoded data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return decoded byte array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException if there is an error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename Filename for reading binary data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return base64-encoded string"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException if there is an error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param infile Input file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param outfile Output file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException if there is an error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param infile Input file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param outfile Output file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.io.IOException if there is an error"
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param buffer The buffer to unpack/decode"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startIndex the index at which the decoding starts in the buffer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endIndex the index at which the decoding stops"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a ByteBuffer that is the unpacked version of the input one. It may not have the same size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param buffer The buffer to unpack/decode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a ByteBuffer that is the unpacked version of the input one. It may not have the same size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param buffer The byteBuffer who's content has the encoded value of the needed  size integer."
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param buffer The buffer to pack/encode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true is the node has a parent end is after it in ascending order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node at which the sub-tree starts"
    },
    {
        "oracle": ";",
        "javadocTag": "@return child node just before the internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node at which the sub-tree starts"
    },
    {
        "oracle": ";",
        "javadocTag": "@return child node just after the internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the oriented point is direct"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical."
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical."
    },
    {
        "oracle": ";",
        "javadocTag": "@param tree inside/outside BSP tree representing the intervals set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical."
    },
    {
        "oracle": ";",
        "javadocTag": "@param boundary collection of boundary elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical."
    },
    {
        "oracle": ";",
        "javadocTag": "@param tree inside/outside BSP tree representing the intervals set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param boundary collection of boundary elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower bound of the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper bound of the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return size of the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return length of the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return barycenter of the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return midpoint of the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered to\nbelong to the boundary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a code representing the point status: either {@link\nLocation#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower lower bound of the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper upper bound of the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane underlying hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param remainingRegion remaining region of the hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the instance itself"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector vector to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a dummy sub hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a region containing the instance (really an {@link\nIntervalsSet IntervalsSet} instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hyperplane location"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the plus side of the hyperplane is towards\nabscissae greater than hyperplane location"
    },
    {
        "oracle": ";",
        "javadocTag": "@param location location of the hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param direct if true, the plus side of the hyperplane is towards\nabscissas greater than {@code location}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered to belong to the hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param location location of the hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param direct if true, the plus side of the hyperplane is towards\nabscissas greater than {@code location}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unique instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return nothing"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSubSpaceException in all cases"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default 1D vector format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale the specific locale used by the format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the 1D vector format specific to the given locale."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for components."
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix prefix to use instead of the default \"{\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix suffix to use instead of the default \"}\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix prefix to use instead of the default \"{\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix suffix to use instead of the default \"}\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for components."
    },
    {
        "oracle": ";",
        "javadocTag": "@return abscissa of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between p1 and p2 according to the L<sub>2</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square of the distance between p1 and p2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Object to test for equality to this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if two 1D vector objects are equal, false if\n        object is null, not an instance of Vector1D, or\n        not equal to this Vector1D instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code value for this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u3 third base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 first scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 second scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 third scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u3 third base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a4 fourth scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u4 fourth base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return start point of the segment"
    },
    {
        "oracle": ";",
        "javadocTag": "@return end point of the segment"
    },
    {
        "oracle": ";",
        "javadocTag": "@return line containing the segment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return distance between the instance and the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start start point of the segment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end end point of the segment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line line containing the segment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param selectedColumns Array of column indices."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The subMatrix containing the data in the specified rows and\ncolumns"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if the row or column selections are\n{@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if the row or column selections are empty (zero\nlength)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param destination The arrays where the submatrix data should be copied\n(if larger than rows/columns counts, only the upper-left part will be\nused)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the destination array is too\nsmall."
    },
    {
        "oracle": ";",
        "javadocTag": "@param selectedRows Array of row indices."
    },
    {
        "oracle": ";",
        "javadocTag": "@param selectedColumns Array of column indices."
    },
    {
        "oracle": ";",
        "javadocTag": "@param destination The arrays where the submatrix data should be copied\n(if larger than rows/columns counts, only the upper-left part will be\nused)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if the row or column selections are\n{@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if the row or column selections are empty (zero\nlength)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the destination array is too\nsmall."
    },
    {
        "oracle": ";",
        "javadocTag": "@param subMatrix array containing the submatrix replacement data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row row coordinate of the top, left element to be replaced"
    },
    {
        "oracle": ";",
        "javadocTag": "@param column column coordinate of the top, left element to be replaced"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code subMatrix} does not fit into\nthis matrix from element in {@code (row, column)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code subMatrix} is not rectangular\n(not all rows have the same length) or empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row to be fetched."
    },
    {
        "oracle": ";",
        "javadocTag": "@return row Matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified row index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Row matrix to be copied (must have one row and the same\nnumber of columns as the instance)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified row index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the row dimension of the\n{@code matrix} is not {@code 1}, or the column dimensions of {@code this}\nand {@code matrix} do not match."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column to be fetched."
    },
    {
        "oracle": ";",
        "javadocTag": "@return column Matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified column index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Column matrix to be copied (must have one column and the\nsame number of rows as the instance)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified column index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the column dimension of the\n{@code matrix} is not {@code 1}, or the row dimensions of {@code this}\nand {@code matrix} do not match."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row to be fetched."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a row vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified row index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector row vector to be copied (must have the same number of\ncolumn as the instance)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified row index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the {@code vector} dimension\ndoes not match the column dimension of {@code this} matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column to be fetched."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a column vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified column index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector column vector to be copied (must have the same number of\nrows as the instance)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified column index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the {@code vector} dimension\ndoes not match the row dimension of {@code this} matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row to be fetched."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of entries in the row."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified row index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array Row matrix to be copied (must have the same number of\ncolumns as the instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified row index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the {@code array} length does\nnot match the column dimension of {@code this} matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column to be fetched."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of entries in the column."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified column index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array Column array to be copied (must have the same number of\nrows as the instance)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified column index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the {@code array} length does\nnot match the row dimension of {@code this} matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row index of entry to be fetched."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column index of entry to be fetched."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the matrix entry at {@code (row, column)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the row or column index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row index of entry to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column index of entry to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the new value of the entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the row or column index is not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row index of the entry to be modified."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column index of the entry to be modified."
    },
    {
        "oracle": ";",
        "javadocTag": "@param increment value to add to the matrix entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the row or column index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row index of the entry to be modified."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column index of the entry to be modified."
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor Multiplication factor for the matrix entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the row or column index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return transpose matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the trace."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the vector to operate on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this * v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of {@code v} does not\nmatch the column dimension of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the vector to operate on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this * v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of {@code v} does not\nmatch the column dimension of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the row vector to premultiply by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code v * this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of {@code v} does not\nmatch the row dimension of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the row vector to premultiply by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code v * this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of {@code v} does not\nmatch the row dimension of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading the size of this source"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading from this source or\n    writing to {@code output}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading from this source or\n    writing to {@code sink}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading from this source"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading from this source or if\n    {@code processor} throws an {@code IOException}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading from this source"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs in the process of reading from this source or\n    {@code other}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sources the sources to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code ByteSource} containing the concatenated data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sources the sources to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code ByteSource} containing the concatenated data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sources the sources to concatenate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code ByteSource} containing the concatenated data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next two bytes of the input stream, interpreted as an \n        unsigned 16-bit integer in little-endian byte order"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next four bytes of the input stream, interpreted as an \n        {@code int} in little-endian byte order"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next eight bytes of the input stream, interpreted as a \n        {@code long} in little-endian byte order"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next four bytes of the input stream, interpreted as a\n        {@code float} in little-endian byte order"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next eight bytes of the input stream, interpreted as a\n        {@code double} in little-endian byte order"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next two bytes of the input stream, interpreted as a\n        {@code short} in little-endian byte order."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next two bytes of the input stream, interpreted as a \n        {@code char} in little-endian byte order"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return byte read from input"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an error is encountered while reading"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws EOFException if the end of file (EOF) is encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the stream to delegate to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line the line read from the input, without delimiter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true to continue processing, false to stop"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurred while deleting the file buffer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileThreshold the number of bytes before the stream should\n    switch to buffering to a file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileThreshold the number of bytes before the stream should\n    switch to buffering to a file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resetOnFinalize if true, the {@link #reset} method will\n    be called when the {@link ByteSource} returned by {@link\n    #asByteSource} is finalized"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code String} containing the contents of the line, not\n    including any line-termination characters, or {@code null} if the\n    end of the stream has been reached."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the stream to delegate to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param buf the byte array containing the data to process"
    },
    {
        "oracle": ";",
        "javadocTag": "@param off the initial offset into the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len the length of data to be processed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true to continue processing, false to stop"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n        is not a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n        is not a power of ten"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and\n        {@code sqrt(x)} is not an integer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code a + b} overflows in signed {@code long} arithmetic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code a - b} overflows in signed {@code long} arithmetic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code a * b} overflows in signed {@code long} arithmetic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed\n        {@code long} arithmetic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code n < 0}, {@code k < 0}, or {@code k > n}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n        is not a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n        is not a power of ten"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and\n        {@code sqrt(x)} is not an integer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code a + b} overflows in signed {@code int} arithmetic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code a - b} overflows in signed {@code int} arithmetic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code a * b} overflows in signed {@code int} arithmetic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed\n        {@code int} arithmetic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code n < 0}, {@code k < 0} or {@code k > n}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code x <= 0}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n        is not a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code x <= 0}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n        is not a power of ten"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code x < 0}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and\n        {@code sqrt(x)} is not an integer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}\n        is not an integer multiple of {@code b}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code n < 0}, {@code k < 0}, or {@code k > n}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if\n        <ul>\n        <li>{@code x} is infinite or NaN\n        <li>{@code x}, after being rounded to a mathematical integer using the specified\n        rounding mode, is either less than {@code Integer.MIN_VALUE} or greater than {@code\n        Integer.MAX_VALUE}\n        <li>{@code x} is not a mathematical integer and {@code mode} is\n        {@link RoundingMode#UNNECESSARY}\n        </ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if\n        <ul>\n        <li>{@code x} is infinite or NaN\n        <li>{@code x}, after being rounded to a mathematical integer using the specified\n        rounding mode, is either less than {@code Long.MIN_VALUE} or greater than {@code\n        Long.MAX_VALUE}\n        <li>{@code x} is not a mathematical integer and {@code mode} is\n        {@link RoundingMode#UNNECESSARY}\n        </ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if\n        <ul>\n        <li>{@code x} is infinite or NaN\n        <li>{@code x} is not a mathematical integer and {@code mode} is\n        {@link RoundingMode#UNNECESSARY}\n        </ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code x <= 0.0}, {@code x} is NaN, or {@code x} is\n        infinite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values a nonempty series of values, which will be converted to {@code double} values\n    (this may cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values a nonempty series of values, which will be converted to {@code double} values\n    (this may cause loss of precision)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code values} is empty or contains any non-finite value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values a nonempty series of values, which will be converted to {@code double} values\n    (this may cause loss of precision)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code values} is empty or contains any non-finite value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value a primitive {@code float} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code for the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first {@code float} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second {@code float} to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the result of invoking {@link Float#compare(float, float)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code float} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code float} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code array[i] == target} for some value of {@code\n    i}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code float} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code float} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the least index {@code i} for which {@code array[i] == target}, or\n    {@code -1} if no such index exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to search for the sequence {@code target}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target the array to search for as a sub-sequence of {@code array}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array an array of {@code float} values, possibly empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target a primitive {@code float} value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the UnivariateStatistic implementing the percentile"
    },
    {
        "oracle": ";",
        "javadocTag": "@param percentileImpl the percentileImpl to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the supplied implementation does not\n provide a <code>setQuantile</code> method"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the UnivariateStatistic implementing the skewness"
    },
    {
        "oracle": ";",
        "javadocTag": "@param skewnessImpl the UnivariateStatistic instance to use\nfor computing the skewness"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the UnivariateStatistic implementing the variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param varianceImpl the UnivariateStatistic instance to use\nfor computing the variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the UnivariateStatistic implementing the sum of squares"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sumsqImpl the UnivariateStatistic instance to use\nfor computing the sum of squares"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the UnivariateStatistic implementing the sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sumImpl the UnivariateStatistic instance to use\nfor computing the sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source DescriptiveStatistics to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest DescriptiveStatistics to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param window the window size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialDoubleArray the initial double[]."
    },
    {
        "oracle": ";",
        "javadocTag": "@param original DescriptiveStatistics instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the n-tuple to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the array\ndoes not match the one used at construction"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The dimension of the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The number of available values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stats univariate statistic array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return results array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component sums"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component sums of squares"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component log sums"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component means"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component standard deviations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the covariance matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component maxima"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component minima"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the array of component geometric means"
    },
    {
        "oracle": ";",
        "javadocTag": "@return String with line feeds displaying statistics"
    },
    {
        "oracle": ";",
        "javadocTag": "@param buffer buffer to fill"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix text prefix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator elements separator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix text suffix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to test equality against."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if object equals this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newImpl new implementations for statistics"
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldImpl old implementations for statistics"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array dimension\ndoes not match the one used at construction"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added\n(i.e. if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sumImpl the StorelessUnivariateStatistic instance to use\nfor computing the Sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array dimension\ndoes not match the one used at construction"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added\n (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the sum of squares"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sumsqImpl the StorelessUnivariateStatistic instance to use\nfor computing the sum of squares"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array dimension\ndoes not match the one used at construction"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added\n (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the minimum"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minImpl the StorelessUnivariateStatistic instance to use\nfor computing the minimum"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array dimension\ndoes not match the one used at construction"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added\n (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the maximum"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxImpl the StorelessUnivariateStatistic instance to use\nfor computing the maximum"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array dimension\ndoes not match the one used at construction"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added\n (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the log sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sumLogImpl the StorelessUnivariateStatistic instance to use\nfor computing the log sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array dimension\ndoes not match the one used at construction"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added\n (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the geometric mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param geoMeanImpl the StorelessUnivariateStatistic instance to use\nfor computing the geometric mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array dimension\ndoes not match the one used at construction"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added\n (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the StorelessUnivariateStatistic implementing the mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param meanImpl the StorelessUnivariateStatistic instance to use\nfor computing the mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array dimension\ndoes not match the one used at construction"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if data has already been added\n (i.e if n > 0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if n > 0."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension dimension to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if dimension != k"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k dimension of the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isCovarianceBiasCorrected if true, the unbiased sample\ncovariance is computed, otherwise the biased population covariance\nis computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source SecondMoment to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest SecondMoment to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code SecondMoment} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mean of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mean of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mean of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Mean to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest Mean to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m1 the moment"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code Mean} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source FourthMoment to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations to run the algorithm for.\n  If negative, no maximum will be used."
    },
    {
        "oracle": ";",
        "javadocTag": "@param measure the distance measure to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon the convergence criteria (default is 1e-3)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param random random generator to use for choosing initial centers"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of clusters"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum number of iterations, or -1 if no maximum is set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the random generator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@link EmptyClusterStrategy}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the points to cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of clusters containing the points"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if an empty cluster is encountered and the\n{@link #emptyStrategy} is set to {@code ERROR}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clusters the {@link Cluster}s to add the points to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the points to add to the given {@link Cluster}s"
    },
    {
        "oracle": ";",
        "javadocTag": "@param assignments points assignments to clusters"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of points assigned to different clusters as the iteration before"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the points to choose the initial centers from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial centers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clusters the {@link Cluster}s to search"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random point from the selected cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if clusters are all empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clusters the {@link Cluster}s to search"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random point from the selected cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if clusters are all empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clusters the {@link Cluster}s to search"
    },
    {
        "oracle": ";",
        "javadocTag": "@return point farthest to its cluster center"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if clusters are all empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clusters the {@link Cluster}s to search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point the point to find the nearest {@link Cluster} for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the nearest {@link Cluster} to the given point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the set of points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension the point dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the computed centroid for the set of points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the number of clusters to split the data into"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the number of clusters to split the data into"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations to run the algorithm for.\n  If negative, no maximum will be used."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the number of clusters to split the data into"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations to run the algorithm for.\n  If negative, no maximum will be used."
    },
    {
        "oracle": ";",
        "javadocTag": "@param measure the distance measure to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the number of clusters to split the data into"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations to run the algorithm for.\n  If negative, no maximum will be used."
    },
    {
        "oracle": ";",
        "javadocTag": "@param measure the distance measure to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param random random generator to use for choosing initial centers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the number of clusters to split the data into"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations to run the algorithm for.\n  If negative, no maximum will be used."
    },
    {
        "oracle": ";",
        "javadocTag": "@param measure the distance measure to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param random random generator to use for choosing initial centers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param emptyStrategy strategy to use for handling empty clusters that\nmay appear during algorithm iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param measure the distance measure to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clusters the clusters to evaluate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the computed score"
    },
    {
        "oracle": ";",
        "javadocTag": "@param score1 the first score"
    },
    {
        "oracle": ";",
        "javadocTag": "@param score2 the second score"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the first score is considered to be better, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 the first clusterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 the second clusterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between the two clusterables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cluster the cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the computed centroid for the cluster,\nor {@code null} if the cluster does not contain any points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param measure the distance measure to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the set of {@link Clusterable} instances"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link List} of clusters"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the algorithm has not yet converged after\n  the maximum number of iterations has been exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance measure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 the first clusterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 the second clusterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between the two clusterables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param measure the distance measure to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point the n-dimensional point in double space"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point the n-dimensional point in integer space"
    },
    {
        "oracle": ";",
        "javadocTag": "@param net Network to be trained with the SOFM algorithm."
    },
    {
        "oracle": ";",
        "javadocTag": "@param featuresIterator Training data iterator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param updateAction SOFM update procedure."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current number of calls."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Neuron to be updated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param features Training data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param learningRate Learning factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the update succeeded, {@code true} if a\nconcurrent update has been detected."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Neuron to be updated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param features Training data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param learningRate Learning factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@param net Network."
    },
    {
        "oracle": ";",
        "javadocTag": "@param features Sample data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param learningRate Current learning factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the winning neuron."
    },
    {
        "oracle": ";",
        "javadocTag": "@param current Current values of the features."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample Training data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param learningRate Learning factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new values for the features."
    },
    {
        "oracle": ";",
        "javadocTag": "@param distance Distance function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param learningFactor Learning factor update function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neighbourhoodSize Neighbourhood size update function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numCall Current step of the training task."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the function at {@code numCall}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initValue Initial value, i.e. {@link #value(long) value(0)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param slope Value of the function derivative at {@code numCall}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numCall Inflexion point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numCall Current step of the training task."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the function at {@code numCall}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initValue Initial value, i.e. {@link #value(long) value(0)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueAtNumCall Value of the function at {@code numCall}."
    },
    {
        "oracle": "Arrays.stream(predicates).anyMatch(jdVar -> jdVar==null);",
        "javadocTag": "@throws NullPointerException if any predicate in the array is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates an array of predicates to check, may not be null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates collection is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates a collection of predicates to check, may not be null"
    },
    {
        "oracle": "predicate1==null || predicate2==null;",
        "javadocTag": "@throws NullPointerException if either predicate is null"
    },
    {
        "oracle": "(predicate1==null) == false;",
        "javadocTag": "@param predicate1 the first predicate, may not be null"
    },
    {
        "oracle": "(predicate2==null) == false;",
        "javadocTag": "@param predicate2 the second predicate, may not be null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates array is null"
    },
    {
        "oracle": "Arrays.stream(predicates).anyMatch(jdVar -> jdVar==null);",
        "javadocTag": "@throws NullPointerException if any predicate in the array is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates an array of predicates to check, may not be null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates collection is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates a collection of predicates to check, may not be null"
    },
    {
        "oracle": "predicate1==null || predicate2==null;",
        "javadocTag": "@throws NullPointerException if either predicate is null"
    },
    {
        "oracle": "(predicate1==null) == false;",
        "javadocTag": "@param predicate1 the first predicate, may not be null"
    },
    {
        "oracle": "(predicate2==null) == false;",
        "javadocTag": "@param predicate2 the second predicate, may not be null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates array is null"
    },
    {
        "oracle": "Arrays.stream(predicates).anyMatch(jdVar -> jdVar==null);",
        "javadocTag": "@throws NullPointerException if any predicate in the array is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates an array of predicates to check, may not be null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates collection is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates a collection of predicates to check, may not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if the predicate is null"
    },
    {
        "oracle": "true ? methodResultID.equals(predicate) : true;",
        "javadocTag": "@return the <code>not</code> predicate"
    },
    {
        "oracle": "transformer==null;",
        "javadocTag": "@throws NullPointerException if the transformer is null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to wrap, may not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if the predicate is null."
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to wrap, may not be null"
    },
    {
        "oracle": "true ? methodResultID.equals(predicate) : true;",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if the predicate is null."
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to wrap, may not be null"
    },
    {
        "oracle": "true ? methodResultID.equals(predicate) : true;",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if the predicate is null."
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to wrap, may not be null"
    },
    {
        "oracle": "true ? methodResultID.equals(predicate) : true;",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": "transformer==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if the transformer or the predicate is null"
    },
    {
        "oracle": "true ? methodResultID.equals(predicate) : true;",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return <code>true</code>, always"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return <code>true</code>, always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws FunctorException always"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate predicate to switch on, not null"
    },
    {
        "oracle": "(trueTransformer==null) == false;",
        "javadocTag": "@param trueTransformer transformer used if true, not null"
    },
    {
        "oracle": "(falseTransformer==null) == false;",
        "javadocTag": "@param falseTransformer transformer used if false, not null"
    },
    {
        "oracle": "predicate==null || trueTransformer==null || falseTransformer==null;",
        "javadocTag": "@throws NullPointerException if either argument is null"
    },
    {
        "oracle": "predicate==null || trueTransformer==null;",
        "javadocTag": "@throws NullPointerException if either argument is null"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return the transformed result"
    },
    {
        "oracle": "iterable==null;",
        "javadocTag": "@throws NullPointerException if iterable is null"
    },
    {
        "oracle": "(iterable==null) == false;",
        "javadocTag": "@param iterable the iterable to wrap into a FluentIterable, may not be null"
    },
    {
        "oracle": "other==null;",
        "javadocTag": "@throws NullPointerException if other is null"
    },
    {
        "oracle": "(other==null) == false;",
        "javadocTag": "@param other the other iterable to combine, may not be null"
    },
    {
        "oracle": "other==null;",
        "javadocTag": "@throws NullPointerException if other is null"
    },
    {
        "oracle": "(other==null) == false;",
        "javadocTag": "@param other the other iterable to collate, may not be null"
    },
    {
        "oracle": "other==null;",
        "javadocTag": "@throws NullPointerException if other is null"
    },
    {
        "oracle": "(other==null) == false;",
        "javadocTag": "@param other the other iterable to collate, may not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if predicate is null"
    },
    {
        "oracle": "maxSize<0;",
        "javadocTag": "@throws IllegalArgumentException if maxSize is negative"
    },
    {
        "oracle": "elementsToSkip<0;",
        "javadocTag": "@throws IllegalArgumentException if elementsToSkip is negative"
    },
    {
        "oracle": "transformer==null;",
        "javadocTag": "@throws NullPointerException if transformer is null"
    },
    {
        "oracle": "other==null;",
        "javadocTag": "@throws NullPointerException if other is null"
    },
    {
        "oracle": "(other==null) == false;",
        "javadocTag": "@param other the other iterable to interleave, may not be null"
    },
    {
        "oracle": "(others==null) == false;",
        "javadocTag": "@param others the iterables to interleave, may not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use, may not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use, may not be null"
    },
    {
        "oracle": "closure==null;",
        "javadocTag": "@throws NullPointerException if closure is null"
    },
    {
        "oracle": "(closure==null) == false;",
        "javadocTag": "@param closure the closure to apply to each element, may not be null"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if collection is null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "a==null || b==null;",
        "javadocTag": "@throws NullPointerException if either a or b is null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first iterable, may not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second iterable, may not be null"
    },
    {
        "oracle": "a==null || b==null || c==null;",
        "javadocTag": "@throws NullPointerException if either of the provided iterables is null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first iterable, may not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second iterable, may not be null"
    },
    {
        "oracle": "(c==null) == false;",
        "javadocTag": "@param c the third iterable, may not be null"
    },
    {
        "oracle": "a==null || b==null || c==null || d==null;",
        "javadocTag": "@throws NullPointerException if either of the provided iterables is null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first iterable, may not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second iterable, may not be null"
    },
    {
        "oracle": "(c==null) == false;",
        "javadocTag": "@param c the third iterable, may not be null"
    },
    {
        "oracle": "(d==null) == false;",
        "javadocTag": "@param d the fourth iterable, may not be null"
    },
    {
        "oracle": "iterables==null;",
        "javadocTag": "@throws NullPointerException if either of the provided iterables is null"
    },
    {
        "oracle": "(iterables==null) == false;",
        "javadocTag": "@param iterables the iterables to combine, may not be null"
    },
    {
        "oracle": "a==null || b==null;",
        "javadocTag": "@throws NullPointerException if either of the provided iterables is null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first iterable, may not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second iterable, may not be null"
    },
    {
        "oracle": "a==null || b==null;",
        "javadocTag": "@throws NullPointerException if either of the provided iterables is null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first iterable, may not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second iterable, may not be null"
    },
    {
        "oracle": "iterable==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if either iterable or predicate is null"
    },
    {
        "oracle": "(iterable==null) == false;",
        "javadocTag": "@param iterable the iterable to filter, may not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate used to filter elements, may not be null"
    },
    {
        "oracle": "maxSize<0;",
        "javadocTag": "@throws IllegalArgumentException if maxSize is negative"
    },
    {
        "oracle": "iterable==null;",
        "javadocTag": "@throws NullPointerException if iterable is null"
    },
    {
        "oracle": "(iterable==null) == false;",
        "javadocTag": "@param iterable the iterable to limit, may not be null"
    },
    {
        "oracle": "(maxSize<0) == false;",
        "javadocTag": "@param maxSize the maximum number of elements, must not be negative"
    },
    {
        "oracle": "iterable==null;",
        "javadocTag": "@throws NullPointerException if iterable is null"
    },
    {
        "oracle": "(iterable==null) == false;",
        "javadocTag": "@param iterable the iterable to loop, may not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the whole format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/ouput parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link Fraction} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format The new whole format value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for the whole, numerator, and\n       denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wholeFormat the custom format for the whole."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numeratorFormat the custom format for the numerator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param denominatorFormat the custom format for the denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value double value to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations maximal number of iterations allowed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value double value to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p current numerator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q current denominator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fraction the object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the whole format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/ouput parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link BigFraction} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format The new whole format value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for the whole, numerator, and\n       denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wholeFormat the custom format for the whole."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numeratorFormat the custom format for the numerator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param denominatorFormat the custom format for the denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Value that is infinite or NaN."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args Optional arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@param specific Specific context pattern."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Value that is infinite or NaN."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args Optional arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lower end."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the higher end."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value at the lower end."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value at the higher end."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lo Lower end of the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hi Higher end of the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fLo Value at lower end of the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fHi Value at higher end of the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param specific Contextual information on what caused the exception."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lo Lower end of the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hi Higher end of the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fLo Value at lower end of the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fHi Value at higher end of the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args Additional arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Message pattern providing the specific context of\nthe error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args Arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Message pattern providing the specific context of the error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param arguments Values for replacing the placeholders in {@code pattern}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to the exception context."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to the exception to which the context relates"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Message pattern."
    },
    {
        "oracle": ";",
        "javadocTag": "@param arguments Values for replacing the placeholders in the message\npattern."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key Context key (not null)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Context value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key Context key."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the context value or {@code null} if the key does not exist."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the set of keys."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the message."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the localized message."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale Locale in which the message should be translated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the localized message."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale Locale in which the message should be translated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator Separator inserted between the message parts."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the localized message."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale Locale in which the message should be translated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param separator Message separator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a localized message string."
    },
    {
        "oracle": ";",
        "javadocTag": "@param out Stream."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException This should never happen."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in Stream."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException This should never happen."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException This should never happen."
    },
    {
        "oracle": ";",
        "javadocTag": "@param out Stream."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException This should never happen."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in Stream."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException This should never happen."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException This should never happen."
    },
    {
        "oracle": ";",
        "javadocTag": "@param out Stream."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException This should never happen."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in Stream."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException This should never happen."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException This should never happen."
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj Object that does not implement the {@code Serializable}\ninterface."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string that mentions which class could not be serialized."
    },
    {
        "oracle": ";",
        "javadocTag": "@param throwable the exception this context refers too"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array Array (possibly multidimensional)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of all the {@code Object} instances contained in\n{@code array}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source source text"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the source string."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale locale into which to get the string."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the localized string or the source string if no\nlocalized version is available."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceFormat source English format to use when no\nlocalized version is available"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the wrong dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the expected dimensions."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node (may be null) in question"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node (may be null) in question"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node (may be null) in question"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node (may be null) in question"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node (may be null) in question"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node to be rotated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node to be rotated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@param insertedNode the node to be inserted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dataElement the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@param deletedNode the node to be deleted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param replacementNode the node being replaced"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dataElement the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x one node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y another node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dataElement the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o the object being checked"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the KEY or VALUE int (used to put the right word in the\n             exception message)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if o is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if o is not Comparable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to be checked"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if key is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if key is not Comparable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to be checked"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if value is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if value is not Comparable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to be checked"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to be checked"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if key or value is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if key or value is not Comparable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newNode the node to be inserted"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the node already exists\n                                    in the value mapping"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code value for this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the KEY or VALUE int"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the string form of this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the keys/values in the map are\n not Comparable or are not mutually comparable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key or value in the map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the type of key in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the type of value in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return immutable and empty <code>MultiValuedMap</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the type of key in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the type of value in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an empty {@link MultiValuedMap} if the argument is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to check, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the {@link MultiValuedMap} to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the {@link MultiValuedMap} to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the {@link MultiValuedMap} to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the {@link MultiValuedMap} to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to look up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new <code>ListValuedMap</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@link SetValuedMap}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable {@link MultiValuedMap} backed by the provided map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a transformed <code>MultiValuedMap</code> backed by the given map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the collection is full"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum number of elements the collection can hold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new unmodifiable bounded collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new unmodifiable bounded collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if coll is not a {@code BoundedCollection}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if coll is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return total number of elements in all contained containers"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if all of the contained collections are empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if obj is contained in any of the contained collections"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an <code>IteratorChain</code> instance which supports\n <code>remove()</code>. Iteration occurs over contained collections in\n the order they were added, but this behavior should not be relied upon."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an object array of all the elements in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the elements in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previousState state vector at step start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predictedState predicted state vector at step end"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predictedScaled predicted value of the scaled derivatives at step end"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predictedNordsieck predicted value of the Nordsieck vector at step end"
    },
    {
        "oracle": ";",
        "javadocTag": "@return estimated normalized local discretization error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the method excluding the one being computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if order is 1 or less"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the method excluding the one being computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minStep minimal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxStep maximal step (sign is irrelevant, regardless of\nintegration direction, forward or backward), the last step can\nbe smaller than this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if order is 1 or less"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param step integration step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param forward integration direction indicator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDotK slopes at the intermediate points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalPreviousState start of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param globalCurrentState end of the global step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softPreviousState start of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param softCurrentState end of the restricted step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mapper equations mapper for the all equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return dimension of the secondary state parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 value of the independent <I>time</I> variable at integration start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param primary0 array containing the value of the primary state vector at integration start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondary0 array containing the value of the secondary state vector at integration start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param finalTime target time for the integration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <I>time</I> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param primary array containing the current value of the primary state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param primaryDot array containing the derivative of the primary state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondary array containing the current value of the secondary state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return derivative of the secondary state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <I>time</I> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the main state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot array containing the current value of the time derivative of the main state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dFdY placeholder array where to put the jacobian matrix of the ODE w.r.t. the main state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@return dimension of the secondary state parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <I>time</I> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param primary array containing the current value of the primary state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param primaryDot array containing the derivative of the primary state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondary array containing the current value of the secondary state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondaryDot placeholder array where to put the derivative of the secondary state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@return name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler handler for the accepted steps"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable collection of the added events handlers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler event handler"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxCheckInterval maximal time interval between switching\nfunction checks (this interval prevents missing sign changes in\ncase the integration steps becomes very large)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convergence convergence threshold in the event time search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterationCount upper limit of the iteration count in\nthe event time search events."
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler event handler"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxCheckInterval maximal time interval between switching\nfunction checks (this interval prevents missing sign changes in\ncase the integration steps becomes very large)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convergence convergence threshold in the event time search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterationCount upper limit of the iteration count in\nthe event time search events."
    },
    {
        "oracle": ";",
        "javadocTag": "@param solver solver to use to locate the event"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable collection of the added events handlers"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current value of the state at step start time t<sub>i</sub>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current signed value of the stepsize"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEvaluations maximal number of function evaluations (negative\nvalues are silently converted to maximal integer value, thus representing\nalmost unlimited evaluations)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximal number of functions evaluations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of evaluations of the differential equations function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equations differential equations to integrate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialState initial state (time, primary and secondary state vectors)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param finalTime target time for the integration\n(can be set to a value smaller than {@code t0} for backward integration)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return final state, its time will be the same as {@code finalTime} if\nintegration reached its target, but may be different if some {@link\norg.apache.commons.math3.ode.events.FieldEventHandler} stops it at some point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if integration step is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the location of an event cannot be bracketed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fode main first order differential equations set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pode secondary problem, without parameter Jacobian computation skill"
    },
    {
        "oracle": ";",
        "javadocTag": "@param paramsAndSteps parameters and steps to compute the Jacobians df/dp"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of equations mapped"
    },
    {
        "oracle": ";",
        "javadocTag": "@return dimension of the complete set of equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param state state to map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return flat array containing the mapped state, including primary and secondary components"
    },
    {
        "oracle": ";",
        "javadocTag": "@param state state to map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return flat array containing the mapped state derivative, including primary and secondary components"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y state array to map, including primary and secondary components"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot state derivative array to map, including primary and secondary components"
    },
    {
        "oracle": ";",
        "javadocTag": "@return mapped state"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if an array does not match total dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the equation, must be between 0 included and\n{@link #getNumberOfEquations()} (excluded)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param complete complete state or derivative array from which\nequation data should be retrieved"
    },
    {
        "oracle": ";",
        "javadocTag": "@return equation data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if index is out of range"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if complete state has not enough elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the equation, must be between 0 included and\n{@link #getNumberOfEquations()} (excluded)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new limit angle, with orientation opposite to the instance orientation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a dummy sub hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a region containing the instance (really an {@link\nArcsSet IntervalsSet} instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hyperplane location"
    },
    {
        "oracle": ";",
        "javadocTag": "@param location location of the hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param direct if true, the plus side of the hyperplane is towards\nangles greater than {@code location}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which angles are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane underlying hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param remainingRegion remaining region of the hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unique instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane underlying hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param remainingRegion remaining region of the hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return vertex location"
    },
    {
        "oracle": ";",
        "javadocTag": "@param circle circle to bind with this vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex other vertex to check instance against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return circle bound with both the instance and another vertex, or null if the\ntwo vertices do not share a circle yet"
    },
    {
        "oracle": ";",
        "javadocTag": "@param incoming incoming edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@return incoming edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param outgoing outgoing edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@return outgoing edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param location vertex location"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newPole circle pole"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new circle, with orientation opposite to the instance orientation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param direction direction for which phase is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return phase angle of the direction around the circle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha phase around the circle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return circle point on the sphere"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an arbitrary x axis on the circle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an arbitrary y axis point on the circle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return pole of the circle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other other circle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return arc of the instance that lies inside the other circle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a region containing the instance (really a {@link\nSphericalPolygonsSet SphericalPolygonsSet} instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param direction direction to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rotation rotation to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transform that can be applied to either {@link\nPoint Point}, {@link Circle Line} or {@link\norg.apache.commons.math3.geometry.partitioning.SubHyperplane\nSubHyperplane} instances"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pole circle pole"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which close sub-arcs are merged together"
    },
    {
        "oracle": ";",
        "javadocTag": "@param first first point contained in the great circle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param second second point contained in the great circle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which close sub-arcs are merged together"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pole circle pole"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first axis in the equator plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second axis in the equator plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which close sub-arcs are merged together"
    },
    {
        "oracle": ";",
        "javadocTag": "@param circle circle to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start start vertex of the convex cell boundary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return area"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start start vertex of the convex cell boundary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return barycenter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return area"
    },
    {
        "oracle": ";",
        "javadocTag": "@return barycenter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return points strictly inside convex cells"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance below which points are consider to be identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param center center of the polygon (the center is in the inside half)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param meridian point defining the reference meridian for first polygon vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param outsideRadius distance of the vertices to the center"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number of sides of the polygon"
    },
    {
        "oracle": ";",
        "javadocTag": "@return vertices array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplaneThickness tolerance below which points are consider to\nbelong to the hyperplane (which is therefore more a slab)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices vertices of the simple loop boundary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the BSP tree of the input vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplaneThickness tolerance below which points are considered to\nbelong to the hyperplane (which is therefore more a slab)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current tree node (it is a leaf node at the beginning\nof the call)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edges list of edges to insert in the cell defined by this node\n(excluding edges not belonging to the cell defined by this node)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if the tolerance setting does not allow to build\na clean non-ambiguous boundary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return boundary of the polygon, organized as an unmodifiable list of loops start vertices."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if the tolerance setting does not allow to build\na clean non-ambiguous boundary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a spherical cap enclosing the polygon"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of points known to be strictly in all inside convex cells"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of points known to be strictly in all outside convex cells"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance below which points are consider to be identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pole pole of the hemisphere (the pole is in the inside half)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance below which points are consider to be identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param center center of the polygon (the center is in the inside half)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param meridian point defining the reference meridian for first polygon vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param outsideRadius distance of the vertices to the center"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number of sides of the polygon"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance below which points are consider to be identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tree inside/outside BSP tree representing the region"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance below which points are consider to be identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param boundary collection of boundary elements, as a\ncollection of {@link SubHyperplane SubHyperplane} objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance below which points are consider to be identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplaneThickness tolerance below which points are considered to\nbelong to the hyperplane (which is therefore more a slab)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices vertices of the simple loop boundary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return start vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@return end vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@return length of the arc (can be greater than \\( \\pi \\))"
    },
    {
        "oracle": ";",
        "javadocTag": "@return circle supporting this edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha angle along the edge, counted from {@link #getStart()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an intermediate point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param next edge following the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param splitCircle circle splitting the edge in several parts"
    },
    {
        "oracle": ";",
        "javadocTag": "@param outsideList list where to put parts that are outside of the split circle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param insideList list where to put parts that are inside the split circle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param subStart start of the sub-edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param subEnd end of the sub-edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param subLength length of the sub-edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the possibly-compressed file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an InputStream for file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename the possibly-compressed file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an InputStream for filename"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FileNotFoundException if the file is not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the possibly-compressed file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an InputStreamReader for file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FileNotFoundException if the file cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the possibly-compressed file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charsetName null, or the name of a Charset to use when reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an InputStreamReader for file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FileNotFoundException if the file cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename the possibly-compressed file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a BufferedReader for file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FileNotFoundException if the file cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the possibility-compressed file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a BufferedReader for file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FileNotFoundException if the file cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename the possibly-compressed file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charsetName the character set to use when reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a BufferedReader for filename"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FileNotFoundException if the file cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the possibly-compressed file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@param charsetName the character set to use when reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a BufferedReader for file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FileNotFoundException if the file cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename the possibly-compressed file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a LineNumberReader for filename"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FileNotFoundException if the file cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the possibly-compressed file to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a LineNumberReader for file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FileNotFoundException if the file cannot be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename the possibly-compressed file to write"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a BufferedWriter for filename"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble writing the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename the possibly-compressed file to write"
    },
    {
        "oracle": ";",
        "javadocTag": "@param append if true, the resulting BufferedOutputStream appends to the end\nof the file instead of the beginning"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a BufferedOutputStream for filename"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble writing the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param classname name of the class, in binary class name format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return name of the class, in field descriptor format"
    },
    {
        "oracle": ";",
        "javadocTag": "@param primitive_name name of the type, in Java format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return name of the type, in field descriptor format"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if primitive_name is not a valid primitive type name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param bn the binary name to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the class name, in Class.getName format"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fd the class, in field descriptor format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the class name, in Class.getName format"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arglist an argument list, in Java format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return argument list, in JVML format"
    },
    {
        "oracle": ";",
        "javadocTag": "@param classname name of the type, in JVML format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return name of the type, in Java format"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arglist an argument list, in JVML format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return argument list, in Java format"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dir directory to add to the system classpath"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename file whose size to count"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of lines in filename"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename the file to infer a line separator from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inferred line separator used in filename"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to infer a line separator from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inferred line separator used in filename"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file1 first file to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file2 second file to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param trimLines if true, call String.trim on each line before comparing"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the files have the same contents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to create and write"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the file can be created and written"
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix the prefix string to be used in generating the file's\n name; must be at least three characters long"
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix the suffix string to be used in generating the file's\n name; may be null, in which case the suffix \".tmp\" will be used Returns:\n An abstract pathname denoting a newly-created empty file"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a File representing the newly-created temporary directory"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException If the prefix argument contains fewer\n than three characters"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If a file could not be created"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SecurityException If a security manager exists and its\n SecurityManager.checkWrite(java.lang.String) method does not allow a\n file to be created"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dirName the directory to delete"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if and only if the file or directory is successfully deleted; false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dir the directory to delete"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if and only if the file or directory is successfully deleted; false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name file whose name to expand"
    },
    {
        "oracle": ";",
        "javadocTag": "@return file with expanded file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name filename to expand"
    },
    {
        "oracle": ";",
        "javadocTag": "@return expanded filename"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name file to quote"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string version of the name that can be used in Java source"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o the object to write"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file to which to write the object"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble writing the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param file the file from which to read"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new multi key map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mapped value, null if no match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value previously mapped to this combined key, null if none"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value mapped to the removed key, null if key not in map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the key matches"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mapped value, null if no match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value previously mapped to this combined key, null if none"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value mapped to the removed key, null if key not in map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the key matches"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mapped value, null if no match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value previously mapped to this combined key, null if none"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value mapped to the removed key, null if key not in map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the key matches"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key5 the fifth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mapped value, null if no match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key5 the fifth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key1 the first key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key2 the second key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key3 the third key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key4 the fourth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key5 the fifth key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value previously mapped to this combined key, null if none"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the primary input {@code Future}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fallback the {@link FutureFallback} implementation to be called if\n    {@code input} fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the primary input {@code Future}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fallback the {@link FutureFallback} implementation to be called if\n    {@code input} fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor the executor that runs {@code fallback} if {@code input}\n    fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the primary input {@code Future}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param exceptionType the exception type that triggers use of {@code fallback}. To avoid hiding\n    bugs and other unrecoverable errors, callers should prefer more specific types, avoiding\n    {@code Throwable.class} in particular."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fallback the {@link Function} implementation to be called if {@code input} fails with\n    the expected exception type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the primary input {@code Future}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param exceptionType the exception type that triggers use of {@code fallback}. To avoid hiding\n    bugs and other unrecoverable errors, callers should prefer more specific types, avoiding\n    {@code Throwable.class} in particular."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fallback the {@link Function} implementation to be called if {@code input} fails with\n    the expected exception type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor the executor that runs {@code fallback} if {@code input} fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the primary input {@code Future}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param exceptionType the exception type that triggers use of {@code fallback}. To avoid hiding\n    bugs and other unrecoverable errors, callers should prefer more specific types, avoiding\n    {@code Throwable.class} in particular."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fallback the {@link AsyncFunction} implementation to be called if {@code input} fails\n    with the expected exception type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the primary input {@code Future}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param exceptionType the exception type that triggers use of {@code fallback}. To avoid hiding\n    bugs and other unrecoverable errors, callers should prefer more specific types, avoiding\n    {@code Throwable.class} in particular."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fallback the {@link AsyncFunction} implementation to be called if {@code input} fails\n    with the expected exception type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor the executor that runs {@code fallback} if {@code input} fails"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delegate The future to delegate to."
    },
    {
        "oracle": ";",
        "javadocTag": "@param time when to timeout the future"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the time unit of the time parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scheduledExecutor The executor service to enforce the timeout."
    },
    {
        "oracle": ";",
        "javadocTag": "@param input The future to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param function A function to transform the result of the input future\n    to the result of the output future"
    },
    {
        "oracle": ";",
        "javadocTag": "@return A future that holds result of the function (if the input succeeded)\n    or the original input's failure (if not)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input The future to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param function A function to transform the result of the input future\n    to the result of the output future"
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor Executor to run the function in."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A future that holds result of the function (if the input succeeded)\n    or the original input's failure (if not)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input The future to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param function A function to transform the result of the input future to the result of the\n    output future"
    },
    {
        "oracle": ";",
        "javadocTag": "@return A future that holds result of the function (if the input succeeded) or the original\n    input's failure (if not)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input The future to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param function A function to transform the result of the input future to the result of the\n    output future"
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor Executor to run the function in."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A future that holds result of the function (if the input succeeded) or the original\n    input's failure (if not)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input The future to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param function A Function to transform the results of the provided future\n    to the results of the returned future.  This will be run in the thread\n    that notifies input it is complete."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A future that holds result of the transformation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param input The future to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param function A Function to transform the results of the provided future\n    to the results of the returned future."
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor Executor to run the function in."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A future that holds result of the transformation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param input The future to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param function A Function to transform the results of the provided future\n    to the results of the returned future."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A future that returns the result of the transformation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nested The nested future to transform."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A future that holds result of the inner future."
    },
    {
        "oracle": ";",
        "javadocTag": "@param futures futures to combine"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a future that provides a list of the results of the component\n        futures"
    },
    {
        "oracle": ";",
        "javadocTag": "@param futures futures to combine"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a future that provides a list of the results of the component\n        futures"
    },
    {
        "oracle": ";",
        "javadocTag": "@param futures futures to combine"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a future that provides a list of the results of the component\n        futures"
    },
    {
        "oracle": ";",
        "javadocTag": "@param futures futures to combine"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a future that provides a list of the results of the component\n        futures"
    },
    {
        "oracle": ";",
        "javadocTag": "@param future The future attach the callback to."
    },
    {
        "oracle": ";",
        "javadocTag": "@param callback The callback to invoke when {@code future} is completed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param future The future attach the callback to."
    },
    {
        "oracle": ";",
        "javadocTag": "@param callback The callback to invoke when {@code future} is completed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor The executor to run {@code callback} when the future\n   completes."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws X if {@code get} throws any checked exception except for an {@code\n        ExecutionException} whose cause is not itself a checked exception"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UncheckedExecutionException if {@code get} throws an {@code\n        ExecutionException} with a {@code RuntimeException} as its cause"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExecutionError if {@code get} throws an {@code ExecutionException}\n        with an {@code Error} as its cause"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CancellationException if {@code get} throws a {@code\n        CancellationException}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code exceptionClass} extends {@code\n        RuntimeException} or does not have a suitable constructor"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws X if {@code get} throws any checked exception except for an {@code\n        ExecutionException} whose cause is not itself a checked exception"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UncheckedExecutionException if {@code get} throws an {@code\n        ExecutionException} with a {@code RuntimeException} as its cause"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExecutionError if {@code get} throws an {@code ExecutionException}\n        with an {@code Error} as its cause"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CancellationException if {@code get} throws a {@code\n        CancellationException}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code exceptionClass} extends {@code\n        RuntimeException} or does not have a suitable constructor"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws X if {@code get} throws any checked exception except for an {@code\n    ExecutionException} whose cause is not itself a checked exception"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UncheckedExecutionException if {@code get} throws an {@code\n    ExecutionException} with a {@code RuntimeException} as its cause"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExecutionError if {@code get} throws an {@code ExecutionException}\n    with an {@code Error} as its cause"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CancellationException if {@code get} throws a {@code\n    CancellationException}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code exceptionClass} extends {@code\n    RuntimeException} or does not have a suitable constructor"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws X if {@code get} throws any checked exception except for an {@code\n    ExecutionException} whose cause is not itself a checked exception"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UncheckedExecutionException if {@code get} throws an {@code\n    ExecutionException} with a {@code RuntimeException} as its cause"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExecutionError if {@code get} throws an {@code ExecutionException}\n    with an {@code Error} as its cause"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CancellationException if {@code get} throws a {@code\n    CancellationException}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code exceptionClass} extends {@code\n    RuntimeException} or does not have a suitable constructor"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UncheckedExecutionException if {@code get} throws an {@code\n        ExecutionException} with an {@code Exception} as its cause"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ExecutionError if {@code get} throws an {@code ExecutionException}\n        with an {@code Error} as its cause"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CancellationException if {@code get} throws a {@code\n        CancellationException}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param listener the listener to run when the computation is complete"
    },
    {
        "oracle": ";",
        "javadocTag": "@param executor the executor to run the listener in"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the executor or listener was null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws RejectedExecutionException if we tried to execute the listener\n        immediately but the executor rejected it."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InterruptedException if interrupted while waiting"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the monitor was entered"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the monitor was entered"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InterruptedException if interrupted while waiting"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the monitor was entered"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InterruptedException if interrupted while waiting"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the monitor was entered, which guarantees that the guard is now satisfied"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InterruptedException if interrupted while waiting"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the monitor was entered, which guarantees that the guard is now satisfied"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the monitor was entered, which guarantees that the guard is now satisfied"
    },
    {
        "oracle": ";",
        "javadocTag": "@return whether the monitor was entered, which guarantees that the guard is now satisfied"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The rotation angle in degrees."
    },
    {
        "oracle": ";",
        "javadocTag": "@param theta The rotation angle in degrees."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The graph estimated size in graph units."
    },
    {
        "oracle": ";",
        "javadocTag": "@param minx The minimum abscissa visible."
    },
    {
        "oracle": ";",
        "javadocTag": "@param miny The minimum ordinate visible."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxx The maximum abscissa visible."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxy The maximum abscissa visible."
    },
    {
        "oracle": ";",
        "javadocTag": "@param minx Lowest abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param miny Lowest ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param minz Lowest depth."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxx Highest abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxy Highest ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxz Highest depth."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a GraphMetrics instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param on If true, automatic adjustment is enabled."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The transformed point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The source point abscissa in pixels."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The source point ordinate in pixels."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The resulting points in graph units."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element to test."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the element is visible and therefore must be rendered."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The sprite count."
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier The sprite identifier to search for."
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier The sprite identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The set of sprites."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An iterator on sprites."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An iterator on sprites."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A Sprite factory."
    },
    {
        "oracle": ";",
        "javadocTag": "@param factory The new factory to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier The identifier of the new sprite to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The created sprite."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InvalidSpriteIDException If the given identifier contains a dot."
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier The sprite identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param position The sprite position (or null for (0,0,0))."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The created sprite."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InvalidSpriteIDException If the given identifier contains a dot."
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier The identifier of the new sprite to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@param spriteClass The class of the new sprite to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The created sprite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier The identifier of the new sprite to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@param spriteClass The class of the new sprite to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@param position The sprite position, or null for position (0, 0, 0)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The created sprite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier The identifier of the sprite to remove."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graph to associate with this manager;"
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier Identifier of the newly created sprite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param manager The sprite manager this sprite will pertain to."
    },
    {
        "oracle": ";",
        "javadocTag": "@param position The sprite initial position or null for (0,0,0,GU)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A new sprite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldStyle The old style."
    },
    {
        "oracle": ";",
        "javadocTag": "@param style The changed style or the new style of the element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param others The other colour set to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oldRule The style that changed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newRule The style that was added to the style sheet."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a style from which some settings are inherited."
    },
    {
        "oracle": ";",
        "javadocTag": "@param property The style property the value is searched for."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field The field to test."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if this style has a value for the given field."
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Another style."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parent The new parent."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event The event that triggers the alternate style."
    },
    {
        "oracle": ";",
        "javadocTag": "@param alternateStyle The alternative style."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parent The parent style."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A style."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A style."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A style."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A style."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The set of rules for graphs."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The set of rules for nodes."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The set of rules for edges."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The set of rules for sprites."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element a rules are searched for."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A set of rules matching the element, with the main rule at index\n        0."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rules The styling rules."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The unique identifier of the style group for the element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param listener The new listener."
    },
    {
        "oracle": ";",
        "javadocTag": "@param listener The listener to remove."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileName Name of the file containing the style sheet."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException For any kind of I/O error or parse error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param url Name of the file containing the style sheet."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException For any kind of I/O error or parse error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param styleSheet The string containing the whole style sheet."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException For any kind of I/O error or parse error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param select The elements for which this style must apply."
    },
    {
        "oracle": ";",
        "javadocTag": "@param styleString The style string to parse."
    },
    {
        "oracle": ";",
        "javadocTag": "@param styleSheetValue The style sheet name of content."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If the loading or parsing of the style sheet failed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param reader The reader pointing at the style sheet."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException For any kind of I/O error or parse error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newRule The new rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@param anyValue The value to convert."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the converted colour or null if the conversion failed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The value to convert."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The corresponding string, or null."
    },
    {
        "oracle": ";",
        "javadocTag": "@return initial state with derivatives added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return differential equations to integrate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return evaluations counter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <I>time</I> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return state completed with derivatives"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the ODE equations have not been set (i.e. if this method\nis called outside of a call to {@link #integrate(FieldExpandableODE, FieldODEState,\nRealFieldElement) integrate}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stateInitialized new value for the flag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator step interpolator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tEnd final integration time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return state at end of step"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the interpolator throws one because\nthe number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the location of an event cannot be bracketed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@param eqn set of differential equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t target time for the integration"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if integration span is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if adaptive step size integrators\ntolerance arrays dimensions are not compatible with equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if a reset occurred while last step was accepted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stepSize step size to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current step size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stepStart step start"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current step start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isLastStep if true, this step is the last one"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this step is the last one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@return primary set of differential equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return dimension of the complete set of equations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <I>time</I> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the complete state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot placeholder array where to put the time derivative of the complete state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondary secondary equations set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return index of the secondary equation in the expanded state"
    },
    {
        "oracle": ";",
        "javadocTag": "@return mapper for the primary set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return equations mappers for the secondary equations sets"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time current time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param primaryState primary part of the current state"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of the array does not\nmatch the primary set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return primary part of the current state"
    },
    {
        "oracle": ";",
        "javadocTag": "@return primary part of the current state derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the part to set as returned by {@link\n#addSecondaryEquations(SecondaryEquations)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondaryState secondary part of the current state"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of the partial state does not\nmatch the selected equations set dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the part to set as returned by {@link\n#addSecondaryEquations(SecondaryEquations)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return secondary part of the current state"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the part to set as returned by {@link\n#addSecondaryEquations(SecondaryEquations)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return secondary part of the current state derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param completeState complete current state to copy data from"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of the complete state does not\nmatch the complete equations sets dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@return complete current state"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of the complete state does not\nmatch the complete equations sets dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param primary the primary set of differential equations to be integrated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return starter integrator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param starterIntegrator starter integrator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 initial time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 initial value of the state vector at t0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t target time for the integration\n(can be set to a value smaller than <code>t0</code> for backward integration)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimension do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if integration step is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the location of an event cannot be bracketed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h step size to use for scaling"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t first steps times"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y first steps states"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot first steps derivatives"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Nordieck vector at first step (h<sup>2</sup>/2 y''<sub>n</sub>,\nh<sup>3</sup>/6 y'''<sub>n</sub> ... h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub>)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return minimal reduction factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minReduction minimal reduction factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximal growth factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxGrowth maximal growth factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return safety factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param safety safety factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of steps of the multistep method (excluding the one being computed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param error normalized error of the current step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return grow/shrink factor for next step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the multistep method\n(excluding the one being computed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the multistep method\n(excluding the one being computed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@return parameters names"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name parameter name to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the parameter is supported"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expandable expandable set into which variational equations should be registered"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of the partial state does not\nmatch the selected equations set dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MismatchedEquations if the primary set of the expandable set does\nnot match the one used to build the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param provider the parameter Jacobian provider to compute exactly the parameter Jacobian matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameterizedOde the parameterized ODE to compute the parameter Jacobian matrix using finite differences"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameter parameter to consider for Jacobian processing"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an orthogonal matrix close to m"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotARotationMatrixException if the matrix cannot be\northogonalized with the given threshold after 10 iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r1 first rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r2 second rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <i>distance</i> between r1 and r2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q0 scalar part of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q1 first coordinate of the vectorial part of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q2 second coordinate of the vectorial part of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param q3 third coordinate of the vectorial part of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param needsNormalization if true, the coordinates are considered\nnot to be normalized, a normalization preprocessing step is performed\nbefore using them"
    },
    {
        "oracle": ";",
        "javadocTag": "@param axis axis around which to rotate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param angle rotation angle."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the axis norm is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param axis axis around which to rotate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param angle rotation angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convention convention to use for the semantics of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the axis norm is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m rotation matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold convergence threshold for the iterative\northogonality correction (convergence is reached when the\ndifference between two steps of the Frobenius norm of the\ncorrection is below this threshold)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotARotationMatrixException if the matrix is not a 3X3\nmatrix, or if it cannot be transformed into an orthogonal matrix\nwith the given threshold, or if the determinant of the resulting\northogonal matrix is negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u1 first vector of the origin pair"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u2 second vector of the origin pair"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 desired image of u1 by the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 desired image of u2 by the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the norm of one of the vectors is zero,\nor if one of the pair is degenerated (i.e. the vectors of the pair are collinear)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u origin vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v desired image of u by the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the norm of one of the vectors is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of rotations to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha1 angle of the first elementary rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha2 angle of the second elementary rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha3 angle of the third elementary rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of rotations to compose, from left to right\n(i.e. we will use {@code r1.compose(r2.compose(r3, convention), convention)})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convention convention to use for the semantics of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha1 angle of the first elementary rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha2 angle of the second elementary rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha3 angle of the third elementary rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unique instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of segments endpoints"
    },
    {
        "oracle": ";",
        "javadocTag": "@param subLine other sub-line which may intersect instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param includeEndPoints if true, endpoints are considered to belong to\ninstance (i.e. they are closed sets) and may be returned, otherwise endpoints\nare considered to not belong to instance (i.e. they are open sets) and intersection\noccurring on endpoints lead to null being returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the intersection point if there is one, null if the sub-lines don't intersect"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start start point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end end point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an interval set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the points are equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param line underlying line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param remainingRegion remaining region of the line"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start start point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end end point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start start point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end end point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param segment single segment forming the sub-line"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the segment endpoints are equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Cartesian coordinates"
    },
    {
        "oracle": ";",
        "javadocTag": "@return radius r"
    },
    {
        "oracle": ";",
        "javadocTag": "@return azimuthal angle in x-y plane &theta;"
    },
    {
        "oracle": ";",
        "javadocTag": "@return polar (co-latitude) angle &Phi;"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sGradient gradient with respect to spherical coordinates\n{df/dr, df/d&theta;, df/d&Phi;}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return gradient with respect to Cartesian coordinates\n{df/dx, df/dy, df/dz}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sHessian Hessian with respect to spherical coordinates\n{{d<sup>2</sup>f/dr<sup>2</sup>, d<sup>2</sup>f/drd&theta;, d<sup>2</sup>f/drd&Phi;},\n {d<sup>2</sup>f/drd&theta;, d<sup>2</sup>f/d&theta;<sup>2</sup>, d<sup>2</sup>f/d&theta;d&Phi;},\n {d<sup>2</sup>f/drd&Phi;, d<sup>2</sup>f/d&theta;d&Phi;, d<sup>2</sup>f/d&Phi;<sup>2</sup>}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sGradient gradient with respect to spherical coordinates\n{df/dr, df/d&theta;, df/d&Phi;}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Hessian with respect to Cartesian coordinates\n{{d<sup>2</sup>f/dx<sup>2</sup>, d<sup>2</sup>f/dxdy, d<sup>2</sup>f/dxdz},\n {d<sup>2</sup>f/dxdy, d<sup>2</sup>f/dy<sup>2</sup>, d<sup>2</sup>f/dydz},\n {d<sup>2</sup>f/dxdz, d<sup>2</sup>f/dydz, d<sup>2</sup>f/dz<sup>2</sup>}}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return data transfer object that will be serialized"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Cartesian coordinates"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r radius"
    },
    {
        "oracle": ";",
        "javadocTag": "@param theta azimuthal angle in x-y plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param phi polar (co-latitude) angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isCardan if true, the rotation is related to Cardan angles,\nif false it is related to EulerAngles"
    },
    {
        "oracle": ";",
        "javadocTag": "@param specifier format specifier (to be translated)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parts to insert in the format (no translation)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ort orthogonal rotation matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return quaternion corresponding to the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new rotation whose effect is the reverse of the effect\nof the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return scalar coordinate of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@return first coordinate of the vectorial part of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@return second coordinate of the vectorial part of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@return third coordinate of the vectorial part of the quaternion"
    },
    {
        "oracle": ";",
        "javadocTag": "@return normalized axis of the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convention convention to use for the semantics of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return normalized axis of the rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return angle of the rotation (between 0 and &pi;)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order rotation order to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of three angles, in the order specified by the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CardanEulerSingularityException if the rotation is\nsingular with respect to the angles set specified"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order rotation order to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convention convention to use for the semantics of the angle"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of three angles, in the order specified by the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws CardanEulerSingularityException if the rotation is\nsingular with respect to the angles set specified"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a0 first array element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 second array element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 third array element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return new array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y ordinate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param z height"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constant vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight new weight for edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dim This is the dimension of the hypercube."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size number of vertices to be generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size number of vertices to be generated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size number of vertices to be generated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inwardSpokes if <code>true</code> and graph is directed, spokes\nare oriented from rim to hub; else from hub to rim."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows the number of rows"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cols the number of columns"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target receives the generated edges and vertices; if this is\nnon-empty on entry, the result will be a disconnected graph since\ngenerated elements will not be connected to existing elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexFactory called to produce new vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultMap unused parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size number of vertices to be generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size number of vertices to be generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed initial seed for the random generator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size number of vertices to be generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size number of vertices to be generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the aNumOfEdges passed in the\nconstructor, cannot be created on a graph of the concrete type with\naNumOfVertexes.\norg.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory#isNumberOfEdgesValid(org.jgrapht.Graph,\nint)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param size number of vertices to be generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param partitionOne This is the number of vertices in the first partition"
    },
    {
        "oracle": ";",
        "javadocTag": "@param partitionTwo This is the number of vertices in the second parition"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target receives the generated edges and vertices; if this is\nnon-empty on entry, the result will be a disconnected graph since\ngenerated elements will not be connected to existing elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexFactory called to produce new vertices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param resultMap if non-null, receives implementation-specific mappings\nfrom String roles to graph elements (or collections of graph elements)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order number of total vertices including the center vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex vertex whose degree is to be calculated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the degree of the specified vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex whose in-degree will be decremented."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dg the directed graph to be iterated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param queue initializer for queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inDegreeMap initializer for inDegreeMap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return start vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dg the directed graph to be iterated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dg the directed graph to be iterated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the graph being traversed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>true</tt> if there are no more uniterated vertices in the\ncurrently iterated connected component; <tt>false</tt> otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex encountered"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next vertex to be returned by this iterator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex a vertex which has already been seen."
    },
    {
        "oracle": ";",
        "javadocTag": "@return data associated with the seen vertex or <code>null</code> if no\ndata was associated with the vertex. A <code>null</code> return can also\nindicate that the vertex was explicitly associated with <code>\nnull</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex vertex in question"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>true</tt> if vertex has already been seen"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex re-encountered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge via which the vertex was re-encountered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex a vertex which has been seen."
    },
    {
        "oracle": ";",
        "javadocTag": "@param data data to be associated with the seen vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous value associated with specified vertex or <code>\nnull</code> if no data was associated with the vertex. A <code>\nnull</code> return can also indicate that the vertex was explicitly\nassociated with <code>null</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex vertex which has been finished"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> "
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> "
    },
    {
        "oracle": ";",
        "javadocTag": "@param g "
    },
    {
        "oracle": ";",
        "javadocTag": "@return TODO Document me"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph to be iterated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex the vertex iteration to be started."
    },
    {
        "oracle": ";",
        "javadocTag": "@param crossComponentTraversal if <code>true</code> traverses across\nconnected components."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if traverses across connected components,\notherwise <code>false</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the traversal listener to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the traversal listener to be removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the connected component finished event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the connected component started event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the edge traversal event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the vertex traversal event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the vertex traversal event."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex vertex being sought from start vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@return weighted length of shortest path known, or\nDouble.POSITIVE_INFINITY if no path found yet"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the spanned vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the spanning tree edge, or null if the vertex either has not been\nseen yet or is the start vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex re-encountered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge via which the vertex was re-encountered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex for which to calculate the path length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge via which the path is being extended."
    },
    {
        "oracle": ";",
        "javadocTag": "@return calculated path length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex a vertex which has just been encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge the edge via which the vertex was encountered."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new heap node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph to be iterated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph to be iterated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex the vertex iteration to be started."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph to be iterated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex the vertex iteration to be started."
    },
    {
        "oracle": ";",
        "javadocTag": "@param radius limit on weighted path length, or Double.POSITIVE_INFINITY\nfor unbounded search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph to be iterated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph to be iterated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex the vertex iteration to be started."
    },
    {
        "oracle": ";",
        "javadocTag": "@return stack"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph to be iterated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph to be iterated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startVertex the vertex iteration to be started."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if traverses across connected components,\notherwise <code>false</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param reuseEvents whether to reuse previously fired event objects\ninstead of creating a new event object for each event."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the <code>reuseEvents</code> flag."
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the traversal listener to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the traversal listener to be removed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertex the source vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex the target vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new edge whose endpoints are the specified source and target\nvertices."
    },
    {
        "oracle": "sample1==null || sample2==null;",
        "javadocTag": "@throws NullArgumentException if the arrays are <code>null</code>"
    },
    {
        "oracle": "sample1.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the length of the arrays is &lt; 2"
    },
    {
        "oracle": "sample1==null || sample2==null;",
        "javadocTag": "@throws NullArgumentException if the arrays are <code>null</code>"
    },
    {
        "oracle": "sample1.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the length of the arrays is &lt; 2"
    },
    {
        "oracle": "sample1==null || sample2==null;",
        "javadocTag": "@throws NullArgumentException if the arrays are <code>null</code>"
    },
    {
        "oracle": "sample1.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the length of the arrays is &lt; 2"
    },
    {
        "oracle": "sample1==null || sample2==null;",
        "javadocTag": "@throws NullArgumentException if the arrays are <code>null</code>"
    },
    {
        "oracle": "sample1.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the length of the arrays is &lt; 2"
    },
    {
        "oracle": "sampleStats1==null;",
        "javadocTag": "@throws NullArgumentException if the sample statistics are <code>null</code>"
    },
    {
        "oracle": "sampleStats1==null;",
        "javadocTag": "@throws NullArgumentException if the sample statistics are <code>null</code>"
    },
    {
        "oracle": "sampleStats1==null;",
        "javadocTag": "@throws NullArgumentException if the sample statistics are <code>null</code>"
    },
    {
        "oracle": "(n>1) == false;",
        "javadocTag": "@throws MathIllegalArgumentException if n is not greater than 1"
    },
    {
        "oracle": "maximalOrder<2;",
        "javadocTag": "@throws NumberIsTooSmallException if maximal order is lower than 2"
    },
    {
        "oracle": "maximalOrder<2;",
        "javadocTag": "@throws NumberIsTooSmallException if maximal order is lower than 2"
    },
    {
        "oracle": "maximalOrder<2;",
        "javadocTag": "@throws NumberIsTooSmallException if maximal order is lower than 2"
    },
    {
        "oracle": "xvals.length<5;",
        "javadocTag": "@throws NumberIsTooSmallException if the size of {@code xvals} is smaller\n        than 5."
    },
    {
        "oracle": "num==null || den==null;",
        "javadocTag": "@throws NullArgumentException if either of the arguments is null"
    },
    {
        "oracle": "(num==null) == false;",
        "javadocTag": "@param num the numerator, must not be {@code null}."
    },
    {
        "oracle": "(den==null) == false;",
        "javadocTag": "@param den the denominator, must not be {@code null}."
    },
    {
        "oracle": "denominator==0;",
        "javadocTag": "@throws ArithmeticException if the denominator is <code>zero</code>."
    },
    {
        "oracle": "bg==null;",
        "javadocTag": "@throws NullArgumentException if the {@link BigInteger} is <code>null</code>."
    },
    {
        "oracle": "(bg==null) == false;",
        "javadocTag": "@param bg the {@link BigInteger} to add, must'nt be <code>null</code>."
    },
    {
        "oracle": "fraction==null;",
        "javadocTag": "@throws NullArgumentException if the {@link BigFraction} is {@code null}."
    },
    {
        "oracle": "(fraction==null) == false;",
        "javadocTag": "@param fraction the {@link BigFraction} to add, must not be <code>null</code>."
    },
    {
        "oracle": "(object==null) == false;",
        "javadocTag": "@param object the object to compare to, must not be <code>null</code>."
    },
    {
        "oracle": "bg==null;",
        "javadocTag": "@throws NullArgumentException if the {@code BigInteger} is {@code null}"
    },
    {
        "oracle": "(bg==null) == false;",
        "javadocTag": "@param bg the {@code BigInteger} to divide by, must not be {@code null}"
    },
    {
        "oracle": "fraction==null;",
        "javadocTag": "@throws NullArgumentException if the {@code fraction} is {@code null}."
    },
    {
        "oracle": "(fraction==null) == false;",
        "javadocTag": "@param fraction Fraction to divide by, must not be {@code null}."
    },
    {
        "oracle": "bg==null;",
        "javadocTag": "@throws NullArgumentException if {@code bg} is {@code null}."
    },
    {
        "oracle": "fraction==null;",
        "javadocTag": "@throws NullArgumentException if {@code fraction} is {@code null}."
    },
    {
        "oracle": "(fraction==null) == false;",
        "javadocTag": "@param fraction Fraction to multiply by, must not be {@code null}."
    },
    {
        "oracle": "bg==null;",
        "javadocTag": "@throws NullArgumentException if the {@link BigInteger} is {@code null}."
    },
    {
        "oracle": "(bg==null) == false;",
        "javadocTag": "@param bg the {@link BigInteger} to subtract, cannot be {@code null}."
    },
    {
        "oracle": "fraction==null;",
        "javadocTag": "@throws NullArgumentException if the {@code fraction} is {@code null}."
    },
    {
        "oracle": "(fraction==null) == false;",
        "javadocTag": "@param fraction {@link BigFraction} to subtract, must not be {@code null}."
    },
    {
        "oracle": "size<=0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code size <= 0}."
    },
    {
        "oracle": "darkThreshold<0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotPositiveException if\n{@code darkThreshold < 0}."
    },
    {
        "oracle": "index>=parameters;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code index >= parameters}."
    },
    {
        "oracle": "manager==null;",
        "javadocTag": "@throws NullArgumentException if {@code manager} is {@code null}"
    },
    {
        "oracle": "a==null || m==null || b==null || x0==null;",
        "javadocTag": "@throws NullArgumentException if one of the parameters is {@code null}"
    },
    {
        "oracle": "a==null || m==null || b==null || x0==null;",
        "javadocTag": "@throws NullArgumentException if one of the parameters is {@code null}"
    },
    {
        "oracle": "a==null || m==null || b==null;",
        "javadocTag": "@throws NullArgumentException if one of the parameters is {@code null}"
    },
    {
        "oracle": "a==null || m==null || b==null || x0==null;",
        "javadocTag": "@throws NullArgumentException if one of the parameters is {@code null}"
    },
    {
        "oracle": "x<-0.5;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code x < -0.5}"
    },
    {
        "oracle": "x>1.5;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code x > 1.5}"
    },
    {
        "oracle": "x<-0.5;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code x < -0.5}."
    },
    {
        "oracle": "x>1.5;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code x > 1.5}."
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if values is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if values is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if values is null"
    },
    {
        "oracle": "p<=0 || p>1;",
        "javadocTag": "@throws OutOfRangeException if {@code p <= 0} or {@code p > 1}."
    },
    {
        "oracle": "p<=0 || p>1;",
        "javadocTag": "@throws OutOfRangeException if {@code p <= 0} or {@code p > 1}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "len<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code len <= 0}."
    },
    {
        "oracle": "len<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code len <= 0}"
    },
    {
        "oracle": "mean<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code len <= 0}"
    },
    {
        "oracle": "shape<=0 || scale<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code shape <= 0} or\n{@code scale <= 0}."
    },
    {
        "oracle": "numberOfSuccesses>populationSize || sampleSize>populationSize;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code numberOfSuccesses > populationSize},\nor {@code sampleSize > populationSize}."
    },
    {
        "oracle": "populationSize<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code populationSize <= 0}."
    },
    {
        "oracle": "numberOfSuccesses<0;",
        "javadocTag": "@throws NotPositiveException if {@code numberOfSuccesses < 0}."
    },
    {
        "oracle": "(r>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if the number of successes is not positive"
    },
    {
        "oracle": "p<0 || p>1;",
        "javadocTag": "@throws OutOfRangeException if the probability of success is not in the\nrange {@code [0, 1]}."
    },
    {
        "oracle": "df<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code df <= 0}"
    },
    {
        "oracle": "shape<=0 || scale<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code shape <= 0} or\n{@code scale <= 0}."
    },
    {
        "oracle": "numberOfElements<=0 || exponent<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code numberOfElements <= 0}\nor {@code exponent <= 0}."
    },
    {
        "oracle": "numeratorDf<=0 || denominatorDf<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if\n{@code numeratorDf <= 0} or {@code denominatorDf <= 0}."
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}"
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}"
    },
    {
        "oracle": "k>n;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code k > n}."
    },
    {
        "oracle": "k<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code k <= 0}."
    },
    {
        "oracle": "len<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code len <= 0}."
    },
    {
        "oracle": "numeratorDf<=0 || denominatorDf<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if\n{@code numeratorDf <= 0} or {@code denominatorDf <= 0}."
    },
    {
        "oracle": "shape<=0 || scale<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code shape <= 0} or\n{@code scale <= 0}."
    },
    {
        "oracle": "numberOfSuccesses>populationSize || sampleSize>populationSize;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code numberOfSuccesses > populationSize},\nor {@code sampleSize > populationSize}."
    },
    {
        "oracle": "populationSize<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code populationSize <= 0}."
    },
    {
        "oracle": "numberOfSuccesses<0;",
        "javadocTag": "@throws NotPositiveException if {@code numberOfSuccesses < 0}."
    },
    {
        "oracle": "(r>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if the number of successes is not positive"
    },
    {
        "oracle": "p<0 || p>1;",
        "javadocTag": "@throws OutOfRangeException if the probability of success is not in the\nrange {@code [0, 1]}."
    },
    {
        "oracle": "df<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code df <= 0}"
    },
    {
        "oracle": "shape<=0 || scale<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code shape <= 0} or\n{@code scale <= 0}."
    },
    {
        "oracle": "numberOfElements<=0 || exponent<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code numberOfElements <= 0}\nor {@code exponent <= 0}."
    },
    {
        "oracle": "(crossoverPoints>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if the number of {@code crossoverPoints} is not strictly positive"
    },
    {
        "oracle": "(first instanceof AbstractListChromosome) == false || (second instanceof AbstractListChromosome) == false;",
        "javadocTag": "@throws MathIllegalArgumentException iff one of the chromosomes is\n  not an instance of {@link AbstractListChromosome}"
    },
    {
        "oracle": "scale<=0 || shape<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code scale <= 0} or {@code shape <= 0}."
    },
    {
        "oracle": "scale<=0 || shape<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code scale <= 0} or {@code shape <= 0}."
    },
    {
        "oracle": "scale<=0 || shape<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code scale <= 0} or {@code shape <= 0}."
    },
    {
        "oracle": "scale<=0 || shape<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code scale <= 0} or {@code shape <= 0}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "categoryData==null;",
        "javadocTag": "@throws NullArgumentException if <code>categoryData</code> is <code>null</code>"
    },
    {
        "oracle": "categoryData==null;",
        "javadocTag": "@throws NullArgumentException if <code>categoryData</code> is <code>null</code>"
    },
    {
        "oracle": "categoryData==null;",
        "javadocTag": "@throws NullArgumentException if <code>categoryData</code> is <code>null</code>"
    },
    {
        "oracle": "categoryData==null;",
        "javadocTag": "@throws NullArgumentException if <code>categoryData</code> is <code>null</code>"
    },
    {
        "oracle": "isLast==true;",
        "javadocTag": "@param isLast true if the step is the last one"
    },
    {
        "oracle": "minimalStep>0;",
        "javadocTag": "@param minimalStep minimal step (must be positive even for backward\nintegration), the last step can be smaller than this"
    },
    {
        "oracle": "maximalStep>0;",
        "javadocTag": "@param maximalStep maximal step (must be positive even for backward\nintegration)"
    },
    {
        "oracle": "minimalStep>0;",
        "javadocTag": "@param minimalStep minimal step (must be positive even for backward\nintegration), the last step can be smaller than this"
    },
    {
        "oracle": "maximalStep>0;",
        "javadocTag": "@param maximalStep maximal step (must be positive even for backward\nintegration)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return quantile estimated by {@link #getResult()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximum in the data set added to this statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@return minimum in the data set added to this statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialFive list of initial five elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the quantile desired"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an instance of PSquareMarkers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the percentile"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the minimum of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Min to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest Min to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code Min} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code Median} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param estimationType one of the percentile {@link EstimationType  estimation types}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nanStrategy one of {@link NaNStrategy} to handle with NaNs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param kthSelector {@link KthSelector} to use for pivoting during search"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if p is not within (0,100]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if type or NaNStrategy passed is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source SynchronizedDescriptiveStatistics to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest SynchronizedDescriptiveStatistics to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param window the finite window size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code SynchronizedDescriptiveStatistics} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k dimension of the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isCovarianceBiasCorrected if true, the unbiased sample\ncovariance is computed, otherwise the biased population covariance\nis computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source SumOfSquares to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest SumOfSquares to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code SumOfSquares} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the product of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Product to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest Product to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code Product} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the parameters are not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source Sum to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest Sum to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code Sum} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source SumOfLogs to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest SumOfLogs to copy to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original the {@code SumOfLogs} instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the statistic applied to the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin the index of the first element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the statistic applied to the included array entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values values to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values array holding values to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length number of array elements to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object object to test equality against."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if object returns the same value as this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x independent variable value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y dependent variable value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reg model to append data from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x independent variable value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y dependent variable value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data array of observations to be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException if the length of {@code data[i]} is not\ngreater than or equal to 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the independent variables which form the design matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y the dependent or response variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException if the length of {@code x} does not equal\nthe number of independent variables in the model"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x a series of observations on the independent variables"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y a series of observations on the dependent variable\nThe length of x and y must be the same"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ModelSpecificationException if {@code x} is not rectangular, does not match\nthe length of {@code y} or does not contain sufficient data to estimate the model"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data array of observations to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return n number of observations that have been added."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x input <code>x</code> value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the intercept of the regression line if the model includes an\nintercept; 0 otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the regression includes an intercept; false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Allowed number of evaluations of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType Optimization type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link InitialGuess}</li>\n <li>{@link SimpleBounds}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value of the objective\nfunction."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link InitialGuess}</li>\n <li>{@link SimpleBounds}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the optimization type."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lower bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the upper bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value of the\nobjective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Point used in the line search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Direction used in the line search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimum Optimum found by the line search."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a 2-element array containing the new point (at index 0) and\nthe new direction (at index 1)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel Relative threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abs Absolute threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel Relative threshold for this optimizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abs Absolute threshold for this optimizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lineRel Relative threshold for the internal line search optimizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lineAbs Absolute threshold for the internal line search optimizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel Relative threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abs Absolute threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel Relative threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abs Absolute threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lineRel Relative threshold for the internal line search optimizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lineAbs Absolute threshold for the internal line search optimizer."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param evaluationFunction Evaluation function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param original Original simplex (to be preserved)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param coeff Linear coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator Comparator to use to sort simplex vertices from best\nto poorest."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the best point in the transformed simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sideLength Length of the sides of the default (hypercube)\nsimplex. See {@link AbstractSimplex#AbstractSimplex(int,double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex. See\n{@link AbstractSimplex#AbstractSimplex(int,double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Dimension of the simplex. See\n{@link AbstractSimplex#AbstractSimplex(int,double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sideLength Length of the sides of the default (hypercube)\nsimplex. See {@link AbstractSimplex#AbstractSimplex(int,double)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param steps Steps along the canonical axes representing box edges.\nThey may be negative but not zero. See"
    },
    {
        "oracle": ";",
        "javadocTag": "@param steps Steps along the canonical axes representing box edges.\nThey may be negative but not zero. See\n{@link AbstractSimplex#AbstractSimplex(double[])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param referenceSimplex Reference simplex. See\n{@link AbstractSimplex#AbstractSimplex(double[][])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param referenceSimplex Reference simplex. See\n{@link AbstractSimplex#AbstractSimplex(double[][])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param khi Expansion coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@param gamma Contraction coefficient."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if the reference simplex does not contain at least one point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if there is a dimension mismatch in the reference simplex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startPoint Initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point current point at which the search direction was computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r raw search direction (i.e. opposite of the gradient)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return approximation of H<sup>-1</sup>r where H is the objective function hessian"
    },
    {
        "oracle": ";",
        "javadocTag": "@param qy array containing qTy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta upper bound on the euclidean norm of diagR * lmDir"
    },
    {
        "oracle": ";",
        "javadocTag": "@param diag diagonal matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param work1 work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param work2 work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param work3 work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param qy array containing qTy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param diag diagonal matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lmDiag diagonal elements associated with lmDir"
    },
    {
        "oracle": ";",
        "javadocTag": "@param work work array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param jacobian Weighted Jacobian matrix at the current point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if the decomposition cannot be performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y vector to multiply (will be overwritten with the result)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param costRelativeTolerance Desired relative error in the sum of\nsquares."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parRelativeTolerance Desired relative error in the approximate\nsolution parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param orthoTolerance Desired max cosine on the orthogonality between\nthe function vector and the columns of the Jacobian."
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Desired threshold for QR ranking. If the squared norm\nof a column vector is smaller or equal to this threshold during QR\ndecomposition, it is considered to be a zero vector and hence the rank\nof the matrix is reduced."
    },
    {
        "oracle": ";",
        "javadocTag": "@param costRelativeTolerance Desired relative error in the sum of\nsquares."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parRelativeTolerance Desired relative error in the approximate\nsolution parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param orthoTolerance Desired max cosine on the orthogonality between\nthe function vector and the columns of the Jacobian."
    },
    {
        "oracle": ";",
        "javadocTag": "@param costRelativeTolerance Desired relative error in the sum of\nsquares."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parRelativeTolerance Desired relative error in the approximate\nsolution parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@param orthoTolerance Desired max cosine on the orthogonality between\nthe function vector and the columns of the Jacobian."
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Desired threshold for QR ranking. If the squared norm\nof a column vector is smaller or equal to this threshold during QR\ndecomposition, it is considered to be a zero vector and hence the rank\nof the matrix is reduced."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of evaluations of the Jacobian function."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the Jacobian dimension does not\nmatch problem dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param params Model parameters at which to compute the Jacobian."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the weighted Jacobian: W<sup>1/2</sup> J."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the Jacobian dimension does not\nmatch problem dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension does not match the\nproblem dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if there is no previous element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next element"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if there is no next element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the item to be retrieved next"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the item to be retrieved next"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException always thrown."
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to set into the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if next() has not yet been called."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the object type is unsuitable for the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to iterate over"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to iterate over"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index to start iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the start index is out of bounds"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to iterate over"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index to start iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index (exclusive) to finish iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the start or end index is out of bounds"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if end index is before the start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new unmodifiable list iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link OrderedMapIterator}<K, V>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new unmodifiable map iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ResettableIterator<E>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Iterator<E>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the iterator has more elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next key in the iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.util.NoSuchElementException if the iteration is finished"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if remove is not supported by the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if <code>next()</code> has not yet been called"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if <code>remove()</code> has already been called\n since the last call to <code>next()</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current key"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if <code>next()</code> has not yet been called"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if <code>next()</code> has not yet been called"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the new value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if setValue is not supported by the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if <code>next()</code> has not yet been called"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if <code>remove()</code> has been called since the\n last call to <code>next()</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string version of the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to iterate over"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new peeking iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param item the element to push back to the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if there is another object that matches the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next object which matches the given predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if there are no more elements that\n match the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if <code>hasNext()</code> has already\n been called."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the iterator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the transformer to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link IterableMap}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link Map}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the map is full"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum number of elements the map can hold"
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "k>n;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code k > n}."
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "k>n;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code k > n}."
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "k>n;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code k > n}."
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "n>20;",
        "javadocTag": "@throws MathArithmeticException if {@code n > 20}: The factorial value is too\nlarge to fit in a {@code long}."
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "k<0;",
        "javadocTag": "@throws NotPositiveException if {@code k < 0}."
    },
    {
        "oracle": "k>n;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code k > n}."
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "k>n;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code k > n}."
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws NotPositiveException if {@code n < 0}."
    },
    {
        "oracle": "k>n;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code k > n}."
    },
    {
        "oracle": "bytes!=null;",
        "javadocTag": "@param bytes the non-null byte array in which to put the\nrandom bytes"
    },
    {
        "oracle": "(n>0) == false;",
        "javadocTag": "@throws IllegalArgumentException if n is not positive."
    },
    {
        "oracle": "n>0;",
        "javadocTag": "@param n the bound on the random number to be returned.  Must be\npositive."
    },
    {
        "oracle": "((p1==null)==false) && (p1.equals(p2));",
        "javadocTag": "@throws MathIllegalArgumentException if the points are equal"
    },
    {
        "oracle": "((p1==null)==false) && (p1.equals(p2));",
        "javadocTag": "@throws MathIllegalArgumentException if the points are equal"
    },
    {
        "oracle": "((p1==null)==false) && (p1.equals(p2));",
        "javadocTag": "@throws MathIllegalArgumentException if the points are equal"
    },
    {
        "oracle": "steps==null;",
        "javadocTag": "@throws NullArgumentException if {@code steps} is {@code null}."
    },
    {
        "oracle": "steps.length==0;",
        "javadocTag": "@throws ZeroException if one of the steps is zero."
    },
    {
        "oracle": "beta<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code beta <= 0}"
    },
    {
        "oracle": "beta>0;",
        "javadocTag": "@param beta scale parameter (must be positive)"
    },
    {
        "oracle": "beta<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code beta <= 0}"
    },
    {
        "oracle": "beta>0;",
        "javadocTag": "@param beta scale parameter (must be positive)"
    },
    {
        "oracle": "numberOfElements<=0 || exponent<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code numberOfElements <= 0}\nor {@code exponent <= 0}."
    },
    {
        "oracle": "numberOfElements<=0 || exponent<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code numberOfElements <= 0}\nor {@code exponent <= 0}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "dimension<=0 || elements<=0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code dimension <= 0} or {@code elements <= 0}."
    },
    {
        "oracle": "exponent<0;",
        "javadocTag": "@throws NotPositiveException if {@code exponent < 0}."
    },
    {
        "oracle": "darkThreshold<0;",
        "javadocTag": "@throws NotPositiveException if {@code darkThreshold < 0}."
    },
    {
        "oracle": "exponent<0;",
        "javadocTag": "@throws NotPositiveException if {@code exponent < 0}."
    },
    {
        "oracle": "manager==null;",
        "javadocTag": "@throws NullArgumentException if {@code manager} is {@code null}"
    },
    {
        "oracle": "format==null;",
        "javadocTag": "@throws NullArgumentException if {@code format} is {@code null}."
    },
    {
        "oracle": "format==null;",
        "javadocTag": "@throws NullArgumentException if {@code format} is {@code null}."
    },
    {
        "oracle": "min>=maxEval;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if {@code min >= max}."
    },
    {
        "oracle": "true ? methodResultID==0 : true;",
        "javadocTag": "@return the value where the function is zero."
    },
    {
        "oracle": "initValue<=0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code initValue <= 0}."
    },
    {
        "oracle": "valueAtNumCall<=0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code valueAtNumCall <= 0}."
    },
    {
        "oracle": "valueAtNumCall>=initValue;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if {@code valueAtNumCall >= initValue}."
    },
    {
        "oracle": "numCall<=0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code numCall <= 0}."
    },
    {
        "oracle": "initValue<=0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code initValue <= 0}."
    },
    {
        "oracle": "slope>=0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if {@code slope >= 0}."
    },
    {
        "oracle": "numCall<=0;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NotStrictlyPositiveException if {@code numCall <= 0}."
    },
    {
        "oracle": "n>0;",
        "javadocTag": "@param n number to factors, must be &gt; 0"
    },
    {
        "oracle": "a>=0;",
        "javadocTag": "@param a first number, must be &ge; 0"
    },
    {
        "oracle": "b>=0;",
        "javadocTag": "@param b second number, must be &ge; 0"
    },
    {
        "oracle": "(minimalIterationCount>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive"
    },
    {
        "oracle": "maximalIterationCount>RombergIntegrator.ROMBERG_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@throws NumberIsTooLargeException if maximal number of iterations\nis greater than {@link #ROMBERG_MAX_ITERATIONS_COUNT}"
    },
    {
        "oracle": "maximalIterationCount<=RombergIntegrator.ROMBERG_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@param maximalIterationCount maximum number of iterations\n(must be less than or equal to {@link #ROMBERG_MAX_ITERATIONS_COUNT})"
    },
    {
        "oracle": "(minimalIterationCount>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive"
    },
    {
        "oracle": "maximalIterationCount>RombergIntegrator.ROMBERG_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@throws NumberIsTooLargeException if maximal number of iterations\nis greater than {@link #ROMBERG_MAX_ITERATIONS_COUNT}"
    },
    {
        "oracle": "maximalIterationCount<=RombergIntegrator.ROMBERG_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@param maximalIterationCount maximum number of iterations\n(must be less than or equal to {@link #ROMBERG_MAX_ITERATIONS_COUNT})"
    },
    {
        "oracle": "(minimalIterationCount>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive"
    },
    {
        "oracle": "maximalIterationCount>SimpsonIntegrator.SIMPSON_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@throws NumberIsTooLargeException if maximal number of iterations\nis greater than {@link #SIMPSON_MAX_ITERATIONS_COUNT}"
    },
    {
        "oracle": "maximalIterationCount<=SimpsonIntegrator.SIMPSON_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@param maximalIterationCount maximum number of iterations\n(must be less than or equal to {@link #SIMPSON_MAX_ITERATIONS_COUNT})"
    },
    {
        "oracle": "(minimalIterationCount>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive"
    },
    {
        "oracle": "maximalIterationCount>SimpsonIntegrator.SIMPSON_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@throws NumberIsTooLargeException if maximal number of iterations\nis greater than {@link #SIMPSON_MAX_ITERATIONS_COUNT}"
    },
    {
        "oracle": "maximalIterationCount<=SimpsonIntegrator.SIMPSON_MAX_ITERATIONS_COUNT;",
        "javadocTag": "@param maximalIterationCount maximum number of iterations\n(must be less than or equal to {@link #SIMPSON_MAX_ITERATIONS_COUNT})"
    },
    {
        "oracle": "n<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code n <= 0}"
    },
    {
        "oracle": "optimizer==null || generator==null;",
        "javadocTag": "@throws NullArgumentException if {@code optimizer} or {@code generator}\nis {@code null}."
    },
    {
        "oracle": "starts<1;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code starts < 1}."
    },
    {
        "oracle": "x==null || y==null;",
        "javadocTag": "@throws NullArgumentException if {@code x} or {@code y} are {@code null}."
    },
    {
        "oracle": "x.length==0 || y.length==0;",
        "javadocTag": "@throws NoDataException if {@code x} or {@code y} are zero-length."
    },
    {
        "oracle": "x==null || y==null;",
        "javadocTag": "@throws NullArgumentException if {@code x} or {@code y} are {@code null}."
    },
    {
        "oracle": "x.length==0 || y.length==0;",
        "javadocTag": "@throws NoDataException if {@code x} or {@code y} are zero-length."
    },
    {
        "oracle": "len<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code len <= 0}"
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}"
    },
    {
        "oracle": "true ? methodResultID>=lower : true;",
        "javadocTag": "@return a random integer greater than or equal to {@code lower}\nand less than or equal to {@code upper}"
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}"
    },
    {
        "oracle": "true ? methodResultID>=lower : true;",
        "javadocTag": "@return a random long integer greater than or equal to {@code lower} and\nless than or equal to {@code upper}"
    },
    {
        "oracle": "len<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code len <= 0}"
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}."
    },
    {
        "oracle": "true ? methodResultID>=lower : true;",
        "javadocTag": "@return a random integer greater than or equal to {@code lower} and less\nthan or equal to {@code upper}."
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}."
    },
    {
        "oracle": "true ? methodResultID>=lower : true;",
        "javadocTag": "@return a random long integer greater than or equal to {@code lower} and\nless than or equal to {@code upper}."
    },
    {
        "oracle": "mean<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code mean <= 0}."
    },
    {
        "oracle": "sigma<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code sigma <= 0}."
    },
    {
        "oracle": "mean<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code mean <= 0}."
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}"
    },
    {
        "oracle": "lower>=upper;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code lower >= upper}"
    },
    {
        "oracle": "k>n;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code k > n}."
    },
    {
        "oracle": "k<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code k <= 0}."
    },
    {
        "oracle": "k>c.size();",
        "javadocTag": "@throws NumberIsTooLargeException if {@code k > c.size()}."
    },
    {
        "oracle": "k<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code k <= 0}."
    },
    {
        "oracle": "(rowDimension>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if row or column dimension is not\npositive."
    },
    {
        "oracle": "s>0;",
        "javadocTag": "@param s scale parameter (must be positive)"
    },
    {
        "oracle": "s>0;",
        "javadocTag": "@param s scale parameter (must be positive)"
    },
    {
        "oracle": "bandwidth==0.25;",
        "javadocTag": "@param bandwidth when computing the loess fit at\na particular point, this fraction of source points closest\nto the current point is taken into account for computing\na least-squares regression.\nA sensible value is usually 0.25 to 0.5, the default value is\n{@link #DEFAULT_BANDWIDTH}."
    },
    {
        "oracle": "bandwidth==0;",
        "javadocTag": "@param robustnessIters This many robustness iterations are done.\nA sensible value is usually 0 (just the initial fit without any\nrobustness iterations) to 4, the default value is\n{@link #DEFAULT_ROBUSTNESS_ITERS}."
    },
    {
        "oracle": "bandwidth<0 || bandwidth>1;",
        "javadocTag": "@throws OutOfRangeException if bandwidth does not lie in the interval [0,1]."
    },
    {
        "oracle": "robustnessIters<0;",
        "javadocTag": "@throws NotPositiveException if {@code robustnessIters} is negative."
    },
    {
        "oracle": "bandwidth==0.25;",
        "javadocTag": "@param bandwidth when computing the loess fit at\na particular point, this fraction of source points closest\nto the current point is taken into account for computing\na least-squares regression.\nA sensible value is usually 0.25 to 0.5, the default value is\n{@link #DEFAULT_BANDWIDTH}."
    },
    {
        "oracle": "bandwidth==0;",
        "javadocTag": "@param robustnessIters This many robustness iterations are done.\nA sensible value is usually 0 (just the initial fit without any\nrobustness iterations) to 4, the default value is\n{@link #DEFAULT_ROBUSTNESS_ITERS}."
    },
    {
        "oracle": "starts<1;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code starts < 1}."
    },
    {
        "oracle": "starts==1;",
        "javadocTag": "@param starts Number of starts to perform. If {@code starts == 1},\nthe {@link #optimize(OptimizationData[]) optimize} will return the\nsame solution as the given {@code optimizer} would return."
    },
    {
        "oracle": "min>=maxEval;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NumberIsTooLargeException if {@code min >= max}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the stored value of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Value of an objective function at the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param func Function whose optimum should be bracketed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goal {@link GoalType Goal type}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xA Initial point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xB Initial point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximum number of evaluations\nis exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of evalutations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of evalutations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lower bound of the bracket."
    },
    {
        "oracle": ";",
        "javadocTag": "@return function value at {@link #getLo()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the higher bound of the bracket."
    },
    {
        "oracle": ";",
        "javadocTag": "@return function value at {@link #getHi()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a point in the middle of the bracket."
    },
    {
        "oracle": ";",
        "javadocTag": "@return function value at {@link #getMid()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code f(x)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of evaluations is\nexceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param growLimit Expanding factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEvaluations Maximum number of evaluations allowed for finding\na bracketing interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goalType Type of optimization goal: either\n{@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startPoint Start point for optimization."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value for objective\nfunction."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iteration Current iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous Best point in the previous iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@param current Best point in the current iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the algorithm is considered to have converged."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the optima."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if {@link\n#optimize(int,MultivariateFunction,GoalType,double[]) optimize}\nhas not been called."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goal Goal type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Single-start optimizer to wrap."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator Random vector generator to use for restarts."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param observations Target values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight List of the values of the diagonal."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight Weight matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSquareMatrixException if the argument is not\na square matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Single-start optimizer to wrap."
    },
    {
        "oracle": ";",
        "javadocTag": "@param starts Number of starts to perform (including the\nfirst one), multi-start is disabled if value is less than or\nequal to 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator Random vector generator to use for restarts."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param target Target value for the objective functions at optimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight Weights for the least squares cost computation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startPoint Start point for optimization."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value for objective\nfunction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Single-start optimizer to wrap."
    },
    {
        "oracle": ";",
        "javadocTag": "@param starts Number of starts to perform (including the\nfirst one), multi-start is disabled if value is less than or\nequal to 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator Random vector generator to use for restarts."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Single-start optimizer to wrap."
    },
    {
        "oracle": ";",
        "javadocTag": "@param starts Number of starts to perform (including the\nfirst one), multi-start is disabled if value is less than or\nequal to 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator Random vector generator to use for restarts."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the row index of the entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the column index of the entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the relative symmetry threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold Relative symmetry threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension the size of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index of the entry being visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value of the entry being visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned after visiting all entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return type of field elements of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return vector copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this + v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as {@code this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to be subtracted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this - v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code v} is not the same size as {@code this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d value to be added to each entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this + d}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d value to be added to each entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d value to be subtracted to each entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this - d}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d value to be subtracted to each entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d value to multiply all entries by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this * d}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d value to multiply all entries by"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d value to divide all entries by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this / d}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if {@code d} is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d value to divide all entries by"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if {@code d} is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector containing the result of applying the function to each entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if one of the entries is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if one of the entries is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector by which instance elements must be multiplied"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialListCapacity the initial capacity used for value collections"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialMapCapacity the initial hashmap capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialListCapacity the initial capacity used for value collections"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map a <code>MultiValuedMap</code> to copy into this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map a <code>Map</code> to copy into this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the map to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new lazy list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the element at the given index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the element at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current size"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator over the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fromIndex the index to start from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to search"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the object, -1 if not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the object is found"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list as an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to add before"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the element to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the collection to be added to this list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if this list changed as a result of the call"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to store at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous object at that index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous object at that index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startIndex the first allowed index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endIndex the last allowed index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@link SetUniqueList}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable set view"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if object was added"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to insert at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to add in iterator order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this collection changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to insert at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to add in iterator order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this collection changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to insert at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list the {@link List} to populate the {@link Set}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@link Set} populated with all elements of the provided\n  {@link List}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum cache size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximumCacheSize the new maximum cache size"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a node, or <code>null</code> if there are no nodes in the cache."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the cache is full"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node to add to the cache"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value of the new node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the newly created node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximumCacheSize the maximum cache size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new unmodifiable list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new fixed size list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed List"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new growth list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to add at"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the underlying list doesn't implement set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the underlying list rejects the element"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the underlying list rejects the element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to add at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to add at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the list changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the underlying list doesn't implement set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the underlying list rejects the element"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the underlying list rejects the element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the object to set at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object previously at that index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the underlying list doesn't implement set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the underlying list rejects the element"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the underlying list rejects the element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialSize the initial size of the ArrayList"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if initial size is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key or value in {@code multimap} is\n    null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key, value, or entry is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyComparator the comparator that determines the key ordering"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueComparator the comparator that determines the value ordering"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multimap the multimap whose contents are copied to this multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code TreeSet} containing a collection of values for one\n    key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param distinctElements the expected number of distinct elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the elements that the multiset should contain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedKeys the expected number of distinct keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedValuesPerKey the expected average number of values per key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multimap the multimap whose contents are copied to this multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code LinkedHashSet} containing a collection of values for\n    one key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to associate with values in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new decorated set containing a collection of values for one key"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any of the first {@code n} elements of {@code elements} is\n         null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to make an immutable copy of"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an immutable map containing those entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code HashMap}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedSize the number of entries you expect to add to the\n       returned map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code HashMap} with enough capacity to hold {@code\n        expectedSize} entries without resizing"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the mappings to be placed in the new map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code HashMap} initialized with the mappings from {@code\n        map}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code LinkedHashMap}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedSize the number of entries you expect to add to the\n       returned map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code LinkedHashMap} with enough capacity to hold\n        {@code expectedSize} entries without resizing"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the mappings to be placed in the new map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, {@code LinkedHashMap} initialized with the mappings from\n        {@code map}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code ConcurrentMap}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code TreeMap}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the sorted map whose mappings are to be placed in the new map\n       and whose comparator is to be used to sort the new map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code TreeMap} initialized with the mappings from {@code\n        map} and using the comparator of {@code map}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator to sort the keys with"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code TreeMap}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the key type for this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code EnumMap}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map from which to initialize this {@code EnumMap}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code EnumMap} initialized with the mappings from {@code\n        map}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code m} is not an {@code EnumMap}\n        instance and contains no mappings"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new, empty {@code IdentityHashMap}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param left the map to treat as the \"left\" map for purposes of comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@param right the map to treat as the \"right\" map for purposes of comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the difference between the two maps"
    },
    {
        "oracle": ";",
        "javadocTag": "@param left the map to treat as the \"left\" map for purposes of comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@param right the map to treat as the \"right\" map for purposes of comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueEquivalence the equivalence relationship to use to compare\n   values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the difference between the two maps"
    },
    {
        "oracle": ";",
        "javadocTag": "@param left the map to treat as the \"left\" map for purposes of comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@param right the map to treat as the \"right\" map for purposes of comparison"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the difference between the two maps"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the values to use when constructing the {@code Map}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyFunction the function used to produce the key for each value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map mapping the result of evaluating the function {@code\n        keyFunction} on each value in the input collection to that value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code keyFunction} produces the same\n        key for more than one value in the input collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the values to use when constructing the {@code Map}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyFunction the function used to produce the key for each value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map mapping the result of evaluating the function {@code\n        keyFunction} on each value in the input collection to that value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code keyFunction} produces the same\n        key for more than one value in the input collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param properties a {@code Properties} object to be converted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an immutable map containing all the entries in {@code properties}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if any key in {@code Properties} is not a {@code\n        String}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key or value in {@code Properties} is\n        null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to be associated with the returned entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to be associated with the returned entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entrySet the entries for which to return an unmodifiable view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry for which to return an unmodifiable view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bimap the bimap to be wrapped in a synchronized view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a sychronized view of the specified bimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bimap the bimap for which an unmodifiable view is to be returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the specified bimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the navigable map for which an unmodifiable view is to be returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of the specified navigable map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param navigableMap the navigable map to be \"wrapped\" in a synchronized\n   navigable map."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized view of the specified navigable map."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the delegate (unwrapped) collection of map entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o the object that might be contained in {@code c}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the delegate (unwrapped) collection of map entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o the object to remove from {@code c}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code c} was changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if duplicate keys or values are added"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if duplicate keys or values are added"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if duplicate keys or values are added"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if duplicate keys or values are added"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if two keys have the same value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key or value in {@code map} is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if two keys have the same value or two\n        values have the same key"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key, value, or entry is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedKeys the expected number of distinct keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedValuesPerKey the expected average number of values per key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multimap the multimap whose contents are copied to this multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if neither range nor the domain has a lower bound, or if\n    neither has an upper bound"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if this range set is {@linkplain #isEmpty() empty}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if this range set does not support the {@code add}\n        operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if this range set does not support the {@code remove}\n        operation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param occurrences the number of occurrences to remove, may be zero,\n  in which case no change is made to the multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of occurrences of the object in the multiset\n  before the operation; possibly zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Set of unique MultiSet elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Set of MultiSet entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return iterator over all elements in the MultiSet"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the total size of the multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to check against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the MultiSet contains all the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection of elements to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if this call changed the multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection of elements to retain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if this call changed the multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code of the MultiSet"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator over nothing"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list iterator over nothing"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an ordered iterator over nothing"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map iterator over nothing"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map iterator over nothing"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the single object over which to iterate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a singleton iterator over the object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the single object over which to iterate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a singleton list iterator over the object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array over which to iterate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator over the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array over which to iterate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator over the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the array is not an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array over which to iterate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index to start iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator over part of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array over which to iterate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index to start iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator over part of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the array is not an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array over which to iterate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index to start iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index to finish iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator over part of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if array bounds are invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if end is before start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array over which to iterate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index to start iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index to finish iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator over part of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the array is not an array or end is before start"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if array bounds are invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array over which to iterate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list iterator over the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array over which to iterate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list iterator over the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the array is not an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array over which to iterate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index to start iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list iterator over part of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array over which to iterate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index to start iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list iterator over part of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the array is not an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array over which to iterate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index to start iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index to finish iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list iterator over part of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if array bounds are invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if end is before start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array over which to iterate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index to start iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index to finish iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list iterator over part of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the array is not an array or end is before start"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if array bounds are invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max the maximum number of elements returned by this iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new bounded iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset the index of the first element of the decorated iterator to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link BigFraction} instance with the resulting values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link BigFraction} instance with the resulting values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the negation of this fraction."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fraction percentage as a {@code double}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param exponent exponent to which this {@code BigFraction} is to be\n           raised."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>this<sup>exponent</sup></tt>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param exponent exponent to which this <code>BigFraction</code> is to be raised."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>this<sup>exponent</sup></tt> as a <code>BigFraction</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param exponent exponent to which this <code>BigFraction</code> is to be raised."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>this<sup>exponent</sup></tt> as a <code>BigFraction</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param exponent exponent to which this <code>BigFraction</code> is to be raised."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>this<sup>exponent</sup></tt>."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the reciprocal fraction."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the reduced <code>BigFraction</code>. It doesn't change anything if\n        the fraction can be reduced."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code BigFraction} instance with the resulting values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the {@code integer} to subtract."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code BigFraction} instance with the resulting values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the {@code long} to subtract."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code BigFraction} instance with the resulting values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link BigFraction} instance with the resulting values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the fraction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param num the numerator."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if the denominator is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the double value to convert to a fraction."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if value is NaN or infinite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the double value to convert to a fraction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon maximum error allowed. The resulting fraction is within\n           <code>epsilon</code> of <code>value</code>, in absolute terms."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations maximum number of convergents."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FractionConversionException if the continued fraction failed to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the double value to convert to a fraction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon maximum error allowed. The resulting fraction is within\n           <code>epsilon</code> of <code>value</code>, in absolute terms."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxDenominator maximum denominator value allowed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations maximum number of convergents."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FractionConversionException if the continued fraction failed to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the double value to convert to a fraction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxDenominator The maximum allowed value for denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FractionConversionException if the continued fraction failed to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param num the numerator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param num the numerator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param den the denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param num the numerator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param num the numerator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param den the denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default number format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale the specific locale used by the format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default number format specific to the given locale."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the denominator format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the numerator format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the new denominator format value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the new numerator format value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/output parsing parameter.  On output, <code>pos</code>\n       holds the index of the next non-whitespace character."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/output parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first non-whitespace character."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the double value to format"
    },
    {
        "oracle": ";",
        "javadocTag": "@param buffer StringBuffer to append to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param position On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to the appended buffer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the long value to format"
    },
    {
        "oracle": ";",
        "javadocTag": "@param buffer StringBuffer to append to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param position On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to the appended buffer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for both the numerator and denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numeratorFormat the custom format for the numerator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param denominatorFormat the custom format for the denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return available complex format locales."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Fraction object to format"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a formatted fraction in proper form."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default complex format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale the specific locale used by the format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the complex format specific to the given locale."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default complex format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale the specific locale used by the format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the complex format specific to the given locale."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default number format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fraction the object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FractionConversionException if the number cannot be converted to a fraction"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if <code>obj</code> is not a valid type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link Fraction} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathParseException if the beginning of the specified string\n           cannot be parsed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/output parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link Fraction} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for both the numerator and denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numeratorFormat the custom format for the numerator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param denominatorFormat the custom format for the denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unique instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unique instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fraction the object to format."
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if iterator parameter is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to use, not null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if iterator parameter is null"
    },
    {
        "oracle": "estimatedSize<1;",
        "javadocTag": "@throws IllegalArgumentException if the size is less than 1"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to use, not null"
    },
    {
        "oracle": "closure==null;",
        "javadocTag": "@throws NullPointerException if closure is null"
    },
    {
        "oracle": "(closure==null) == false;",
        "javadocTag": "@param closure the closure to apply to each element, may not be null"
    },
    {
        "oracle": "closure==null;",
        "javadocTag": "@throws NullPointerException if closure is null"
    },
    {
        "oracle": "(closure==null) == false;",
        "javadocTag": "@param closure the closure to perform, may not be null"
    },
    {
        "oracle": "iterator==null ? methodResultID==null : true;",
        "javadocTag": "@return the last element in the iterator, or null if iterator is null or empty"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use, may not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use, may not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use, may not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use, may not be null"
    },
    {
        "oracle": "transformer==null;",
        "javadocTag": "@throws NullPointerException if {@code transformer} is null"
    },
    {
        "oracle": "transformer==null || delimiter==null || prefix==null || suffix==null;",
        "javadocTag": "@throws NullPointerException if either transformer, delimiter, prefix or suffix is null"
    },
    {
        "oracle": "loadFactor>0.0 && loadFactor<1.0;",
        "javadocTag": "@param loadFactor the load factor, must be &gt; 0.0f and generally &lt; 1.0f"
    },
    {
        "oracle": "initialCapacity<0;",
        "javadocTag": "@throws IllegalArgumentException if the initial capacity is negative"
    },
    {
        "oracle": "initialCapacity<0;",
        "javadocTag": "@throws IllegalArgumentException if the initial capacity is negative"
    },
    {
        "oracle": "loadFactor<=0;",
        "javadocTag": "@throws IllegalArgumentException if the load factor is less than or equal to zero"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "true ? methodResultID.equals(inverseMap) : true;",
        "javadocTag": "@return the inverse map"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to wrap, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map mappings to be stored in this map, may not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map mappings to be stored in this map, may not be null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws NullPointerException if values is null"
    },
    {
        "oracle": "(values==null) == false;",
        "javadocTag": "@param values the values to add to the collection at the key, may not be null"
    },
    {
        "oracle": "bag==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if bag or transformer is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "bag==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if bag or transformer is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "bag==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if bag or transformer is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "multiset==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if multiset or predicate is null"
    },
    {
        "oracle": "(multiset==null) == false;",
        "javadocTag": "@param multiset the multiset to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "multiset==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if multiset or predicate is null"
    },
    {
        "oracle": "(multiset==null) == false;",
        "javadocTag": "@param multiset the multiset to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to call, not null"
    },
    {
        "oracle": "bag==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if bag or predicate is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "bag==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if bag or predicate is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "this.getEnumeration()==null;",
        "javadocTag": "@throws NullPointerException if the underlying enumeration is null"
    },
    {
        "oracle": "this.getEnumeration()==null;",
        "javadocTag": "@throws NullPointerException if the enumeration is null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if the predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to decorate, not null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "bag==null || lock==null;",
        "javadocTag": "@throws NullPointerException if bag or lock is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "(lock==null) == false;",
        "javadocTag": "@param lock the lock to use, must not be null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "size<1;",
        "javadocTag": "@throws IllegalArgumentException if the size is &lt; 1"
    },
    {
        "oracle": "coll==null;",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": "(coll==null) == false;",
        "javadocTag": "@param coll the collection to copy into the queue, may not be null"
    },
    {
        "oracle": "element==null;",
        "javadocTag": "@throws NullPointerException if the given element is null"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return true, always"
    },
    {
        "oracle": "element==null;",
        "javadocTag": "@throws NullPointerException if the given element is null"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return true, always"
    },
    {
        "oracle": "coll==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if collection or predicate is null"
    },
    {
        "oracle": "(coll==null) == false;",
        "javadocTag": "@param coll the collection to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "coll==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if collection or predicate is null"
    },
    {
        "oracle": "(coll==null) == false;",
        "javadocTag": "@param coll the collection to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "((map==null)==false) && (map.isEmpty()) ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return true if the map is empty or null"
    },
    {
        "oracle": "map==null ? methodResultID==null : true;",
        "javadocTag": "@return the Collection in the {@link MultiValuedMap}, or null if input map is null"
    },
    {
        "oracle": "map==null ? methodResultID==null : true;",
        "javadocTag": "@return the Collection in the {@link MultiValuedMap} as List, or null if input map is null"
    },
    {
        "oracle": "map==null ? methodResultID==null : true;",
        "javadocTag": "@return the Collection in the {@link MultiValuedMap} as Set, or null if input map is null"
    },
    {
        "oracle": "map==null ? methodResultID==null : true;",
        "javadocTag": "@return the Collection in the {@link MultiValuedMap} as Bag, or null if input map is null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the {@link MultiValuedMap} to decorate, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the {@link MultiValuedMap} to transform, must not be null, typically empty"
    },
    {
        "oracle": "keyTransformer==null;",
        "javadocTag": "@param keyTransformer the transformer for the map keys, null means no transformation"
    },
    {
        "oracle": "valueTransformer==null;",
        "javadocTag": "@param valueTransformer the transformer for the map values, null means no transformation"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the first child iterator in the IteratorChain, not null"
    },
    {
        "oracle": "first==null || second==null;",
        "javadocTag": "@throws NullPointerException if either iterator is null"
    },
    {
        "oracle": "(first==null) == false;",
        "javadocTag": "@param first the first child iterator in the IteratorChain, not null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numCall Argument for which the function returns\n{@code valueAtNumCall}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initValue Initial value, i.e.\n{@link NeighbourhoodSizeFunction#value(long) value(0)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueAtNumCall Value of the function at {@code numCall}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numCall Argument for which the function returns\n{@code valueAtNumCall}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the neighbourhood size function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initValue Initial value, i.e.\n{@link NeighbourhoodSizeFunction#value(long) value(0)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param slope Value of the function derivative at {@code numCall}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numCall Inflexion point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the neighbourhood size function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initValue Initial value, i.e.\n{@link LearningFactorFunction#value(long) value(0)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueAtNumCall Value of the function at {@code numCall}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numCall Argument for which the function returns\n{@code valueAtNumCall}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the learning factor function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initValue Initial value, i.e.\n{@link LearningFactorFunction#value(long) value(0)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param slope Value of the function derivative at {@code numCall}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numCall Inflexion point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the learning factor function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numCall Current step of the training task."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the function at {@code numCall}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numCall Current step of the training task."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the function at {@code numCall}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param features Data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neurons List of neurons to scan. If the list is empty\n{@code null} will be returned."
    },
    {
        "oracle": ";",
        "javadocTag": "@param distance Distance function. The neuron's features are\npassed as the first argument to {@link DistanceMeasure#compute(double[],double[])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the neuron whose features are closest to the given data."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the size of the input is not compatible with the neurons features\nsize."
    },
    {
        "oracle": ";",
        "javadocTag": "@param features Data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neurons List of neurons to scan. If the list is empty\n{@code null} will be returned."
    },
    {
        "oracle": ";",
        "javadocTag": "@param distance Distance function. The neuron's features are\npassed as the first argument to {@link DistanceMeasure#compute(double[],double[])}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the two neurons whose features are closest to the given data."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the size of the input is not compatible with the neurons features\nsize."
    },
    {
        "oracle": ";",
        "javadocTag": "@param features Data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neurons List of neurons to scan. If it is empty, an empty array\nwill be returned."
    },
    {
        "oracle": ";",
        "javadocTag": "@param distance Distance function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the neurons, sorted in increasing order of distance in data\nspace."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the size of the input is not compatible with the neurons features\nsize."
    },
    {
        "oracle": ";",
        "javadocTag": "@param map Network."
    },
    {
        "oracle": ";",
        "javadocTag": "@param distance Function to use for computing the average\ndistance from a neuron to its neighbours."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the matrix of average distances."
    },
    {
        "oracle": ";",
        "javadocTag": "@param data Feature vectors."
    },
    {
        "oracle": ";",
        "javadocTag": "@param map Network."
    },
    {
        "oracle": ";",
        "javadocTag": "@param distance Function to use for determining the best matching unit."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of hits for each neuron in the map."
    },
    {
        "oracle": ";",
        "javadocTag": "@param data Feature vectors."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neurons List of neurons to scan."
    },
    {
        "oracle": ";",
        "javadocTag": "@param distance Distance function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the error."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if {@code data} is empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@param data Feature vectors."
    },
    {
        "oracle": ";",
        "javadocTag": "@param net Network."
    },
    {
        "oracle": ";",
        "javadocTag": "@param distance Distance function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the error."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if {@code data} is empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance with the same state as this instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator {@link Comparator} used for sorting the neurons."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of neurons, sorted in the order prescribed by the\ngiven {@code comparator}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param features Initial values for the neuron's features."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the neuron's identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of {@code features}\nis different from the expected size (as set by the\n{@link #Network(long,int) constructor})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neuron Neuron to be removed from this network."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if {@code n} does not belong to\nthis network."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size of the features set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Neuron."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Neuron."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the neurons do not exist in the\nnetwork."
    },
    {
        "oracle": ";",
        "javadocTag": "@param linkSet Neuron identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Neuron identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Neuron."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Neuron."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the neurons do not exist in the\nnetwork."
    },
    {
        "oracle": ";",
        "javadocTag": "@param linkSet Neuron identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Neuron identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the neuron associated with the given {@code id}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the neuron does not exist in the\nnetwork."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neurons Neurons for which to retrieve the neighbours."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of neighbours."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neurons Neurons for which to retrieve the neighbours."
    },
    {
        "oracle": ";",
        "javadocTag": "@param exclude Neurons to exclude from the returned list.\nCan be {@code null}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of neighbours."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neuron Neuron for which to retrieve the neighbours."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of neighbours."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neuron Neuron for which to retrieve the neighbours."
    },
    {
        "oracle": ";",
        "javadocTag": "@param exclude Neurons to exclude from the returned list.\nCan be {@code null}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of neighbours."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a value that will serve as a unique identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in Input stream."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the proxy instance that will be actually serialized."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nextId Next available identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param featureSize Number of features."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neuronList Neurons."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neighbourIdList Links associated to each of the neurons in\n{@code neuronList}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if an inconsistency is detected\n(which probably means that the serialized form has been corrupted)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialIdentifier Identifier for the first neuron that\nwill be added to this network."
    },
    {
        "oracle": ";",
        "javadocTag": "@param featureSize Size of the neuron's features."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound of the range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound of the range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Random number generator used to draw samples from a\nuniform distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an initializer such that the features will be initialized with\nvalues within the given range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound of the range."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Comparator<? super V>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the top item on the stack"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the number of items down to go"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the n'th item on the stack, zero relative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws EmptyStackException if there are not enough items on the\n stack to satisfy this request"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the top item on the stack"
    },
    {
        "oracle": ";",
        "javadocTag": "@param item the item to be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to be searched for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the 1-based depth into the stack of the object, or -1 if not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialSize the initial size to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the iterator has a previous element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous key in the iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.util.NoSuchElementException if the iteration is finished"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return total number of elements in all contained containers"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if all of the contained sets are empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if obj is contained in any of the contained sets"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an <code>IteratorChain</code> instance which supports\n <code>remove()</code>. Iteration occurs over contained collections in\n the order they were added, but this behavior should not be relied upon."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an object array of all the elements in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the elements in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to use, populating if possible"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of all the elements in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the collection was modified"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if SetMutator hasn't been set or add is unsupported"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the object cannot be added due to its type"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the object cannot be added because its null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the object cannot be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj object to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the object is removed, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to check for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if all elements contained"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the composite was modified"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if SetMutator hasn't been set or add is unsupported"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the object cannot be added due to its type"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the object cannot be added because its null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the object cannot be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the composite was modified"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if removeAll is unsupported"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the composite was modified"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if retainAll is unsupported"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if clear is unsupported"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mutator the mutator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set the set to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if a SetMutator is set, but fails to resolve a collision"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if there is no SetMutator set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set1 the first Set to be appended to the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set2 the second Set to be appended to the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sets the Sets to be appended to the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set set to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return A new HashSet containing all of the elements in this composite.\n  The new collection is <i>not</i> backed by this composite."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Unmodifiable list of all sets in this composite."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the set mutator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set the initial set in the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sets the initial sets in the composite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed {@link NavigableSet}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed {@link NavigableSet}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated navigable set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new predicated navigable set."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the set contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated navigable set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the set contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new ordered set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new ordered set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new ordered set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable list view"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the position of the element in the ordered {@link Set}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the element at position {@code index}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the element to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the first occurrence of the object, or {@code -1} if\n        this ordered set does not contain this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index at which the element is to be inserted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the element to be inserted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the position to insert the elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection containing the elements to be inserted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if this ordered set changed as a result of the call"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index of the element to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the element that has been remove from the ordered set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new unmodifiable set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if set is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array is not rectangular"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if {@code counts} has negative entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param counts array representation of 2-way table"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level of the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff null hypothesis can be rejected with confidence\n1 - alpha"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array is not rectangular"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if {@code counts} has any negative entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if <code>alpha</code> is not in the range (0, 0.5]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed1 array of observed frequency counts of the first data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed2 array of observed frequency counts of the second data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return chiSquare test statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException the the length of the arrays does not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if any entries in <code>observed1</code> or\n<code>observed2</code> are negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if either all counts of <code>observed1</code> or\n<code>observed2</code> are zero, or if the count at some index is zero\nfor both arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed1 array of observed frequency counts of the first data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed2 array of observed frequency counts of the second data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException the the length of the arrays does not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if any entries in <code>observed1</code> or\n<code>observed2</code> are negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if either all counts of <code>observed1</code> or\n<code>observed2</code> are zero, or if the count at the same index is zero\nfor both arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed1 array of observed frequency counts of the first data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed2 array of observed frequency counts of the second data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level of the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff null hypothesis can be rejected with confidence\n1 - alpha"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException the the length of the arrays does not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if any entries in <code>observed1</code> or\n<code>observed2</code> are negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if either all counts of <code>observed1</code> or\n<code>observed2</code> are zero, or if the count at the same index is zero\nfor both arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if <code>alpha</code> is not in the range (0, 0.5]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs performing the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in input 2-way table to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the array is not valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if the array contains any negative entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfTrials number of trials performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfSuccesses number of successes observed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param probability assumed probability of a single trial under the null hypothesis"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alternativeHypothesis type of hypothesis being evaluated (one- or two-sided)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level of the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the null hypothesis can be rejected with confidence {@code 1 - alpha}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfTrials number of trials performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfSuccesses number of successes observed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param probability assumed probability of a single trial under the null hypothesis"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alternativeHypothesis type of hypothesis being evaluated (one- or two-sided)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param distribution reference distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data sample being being evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param exact whether or not to force exact computation of the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the p-value associated with the null hypothesis that {@code data} is a sample from\n        {@code distribution}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InsufficientDataException if {@code data} does not have length at least 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param distribution reference distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data sample being evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Kolmogorov-Smirnov statistic \\(D_n\\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InsufficientDataException if {@code data} does not have length at least 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first sample dataset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second sample dataset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param strict whether or not the probability to compute is expressed as a strict inequality\n       (ignored for large samples)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value associated with the null hypothesis that {@code x} and {@code y} represent\n        samples from the same distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InsufficientDataException if either {@code x} or {@code y} does not have length at\n        least 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first sample dataset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second sample dataset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value associated with the null hypothesis that {@code x} and {@code y} represent\n        samples from the same distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InsufficientDataException if either {@code x} or {@code y} does not have length at\n        least 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return test statistic \\(D_{n,m}\\) used to evaluate the null hypothesis that {@code x} and\n        {@code y} represent samples from the same underlying distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InsufficientDataException if either {@code x} or {@code y} does not have length at\n        least 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return test statistic \\(n m D_{n,m}\\) used to evaluate the null hypothesis that {@code x} and\n        {@code y} represent samples from the same underlying distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InsufficientDataException if either {@code x} or {@code y} does not have length at\n        least 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if either {@code x} or {@code y} is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param distribution reference distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data sample being being evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the p-value associated with the null hypothesis that {@code data} is a sample from\n        {@code distribution}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InsufficientDataException if {@code data} does not have length at least 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param distribution reference distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data sample being being evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level of the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the null hypothesis that {@code data} is a sample from {@code distribution}\n        can be rejected with confidence 1 - {@code alpha}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InsufficientDataException if {@code data} does not have length at least 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterations number of bootstrap resampling iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param strict whether or not the null hypothesis is expressed as a strict inequality"
    },
    {
        "oracle": ";",
        "javadocTag": "@return estimated p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterations number of bootstrap resampling iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return estimated p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if algorithm fails to convert {@code h} to a\n        {@link org.apache.commons.math3.fraction.BigFraction} in expressing {@code d} as \\((k\n        - h) / m\\) for integer {@code k, m} and \\(0 \\le h < 1\\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the algorithm fails to convert {@code h} to a\n        {@link org.apache.commons.math3.fraction.BigFraction} in expressing {@code d} as \\((k\n        - h) / m\\) for integer {@code k, m} and \\(0 \\le h < 1\\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Size of the vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Size of the vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param preset All entries will be set with this value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Data for the new vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyArray If {@code true}, the input array will be copied,\notherwise it will be referenced."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Data for the new vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyArray If {@code true}, the input array will be copied,\notherwise it will be referenced."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos Position of the first entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Number of entries to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the size of {@code d} is less\nthan {@code pos + size}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos Position of the first entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Number of entries to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the size of {@code d} is less\nthan {@code pos + size}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Vector to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param deep If {@code true} perform a deep copy, otherwise perform\na shallow copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 First vector (will be put in front of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 Second vector (will be put at back of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 First vector (will be put in front of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 Second vector (will be put at back of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 First vector (will be put in front of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 Second vector (will be put at back of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 First vector (will be put in front of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 Second vector (will be put at back of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 First vector (will be put in front of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 Second vector (will be put at back of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 First vector (will be put in front of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 Second vector (will be put at back of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 First vector (will be put in front of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 Second vector (will be put at back of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if both arrays are empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 First vector (will be put in front of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 Second vector (will be put at back of the new vector)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if both arrays are empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b right-hand side of the equation A &times; X = B"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector X that minimizes the two norm of A &times; X - B"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the matrices dimensions do not match."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if the decomposed matrix is singular."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b right-hand side of the equation A &times; X = B"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a matrix X that minimizes the two norm of A &times; X - B"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the matrices dimensions do not match."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if the decomposed matrix is singular."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the decomposed matrix is non-singular."
    },
    {
        "oracle": ";",
        "javadocTag": "@return pseudo-inverse matrix (which is the inverse, if it exists),\nif the decomposition can pseudo-invert the decomposed matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if the decomposed matrix is singular and the decomposition\ncan not compute a pseudo-inverse"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the L matrix (or null if decomposed matrix is singular)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the U matrix (or null if decomposed matrix is singular)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the P rows permutation matrix (or null if decomposed matrix is singular)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the pivot permutation vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return determinant of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a solver"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Matrix to decompose."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix The matrix to decompose."
    },
    {
        "oracle": ";",
        "javadocTag": "@param singularityThreshold threshold (based on partial row norm)\nunder which a matrix is considered singular"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the tests are to be performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonPositiveDefiniteOperatorException if {@code a} or {@code m} is\nnot positive definite"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta the &delta; parameter for the default stopping criterion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param check {@code true} if positive definiteness of both matrix and\npreconditioner should be checked"
    },
    {
        "oracle": ";",
        "javadocTag": "@param manager the custom iteration manager"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta the &delta; parameter for the default stopping criterion"
    },
    {
        "oracle": ";",
        "javadocTag": "@param check {@code true} if positive definiteness of both matrix and\npreconditioner should be checked"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the total number of entries of the\nmatrix is larger than {@code Integer.MAX_VALUE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} + {@code m}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to be subtracted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} - {@code m}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if {@code m} is an\n{@code OpenMapRealMatrix}, and the total number of entries of the product\nis larger than {@code Integer.MAX_VALUE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to postmultiply by."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} * {@code m}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the number of rows of {@code m}\ndiffer from the number of columns of {@code this} matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the total number of entries of the\nproduct is larger than {@code Integer.MAX_VALUE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row row index of the matrix element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param column column index of the matrix element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return key within the map to access the matrix element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowDimension Number of rows of the matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnDimension Number of columns of the matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the total number of entries of the\nmatrix is larger than {@code Integer.MAX_VALUE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the U matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the B matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the V matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the main diagonal elements of the B matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the main diagonal elements of the B matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the secondary diagonal elements of the B matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the matrix is transformed to upper bi-diagonal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix the matrix to transform."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the L matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transpose of the matrix L of the decomposition"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startIndex the index at which the encoding starts in the buffer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endIndex the index at which the encoding stops"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a ByteBuffer that is the packed version of the input one. It may not have the same size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param buffer The buffer to pack/encode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a ByteBuffer that is the packed version of the input one. It may not have the same size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param capacity "
    },
    {
        "oracle": ";",
        "javadocTag": "@return "
    },
    {
        "oracle": ";",
        "javadocTag": "@param attributeName The name of the attribute."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attributeValue The value of the attribute."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if the attribute must be removed from the stream of graph\n        events."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The identifier value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The index value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The label to search."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The label string value or null if not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The name of the number to search."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The number value or NaN if not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The name of the number to search."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The vector of numbers or null if not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The name of the array to search."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The array of objects or null if not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The name of the hash to search."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The hash or null if not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The name of the attribute to search."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if a value is present for this attribute."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The name of the attribute to search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param clazz The expected class of the attribute value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if a value is present for this attribute."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The name of the label."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if a value is present for this attribute and implements\n        CharSequence."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The name of the number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if a value is present for this attribute and can contain a\n        double (inherits from Number)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The name of the vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if a value is present for this attribute and can contain a\n        sequence of numbers."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The name of the array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if a value is present for this attribute and can contain an\n        array object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key The name of the hash."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if a value is present for this attribute and can contain a\n        hash."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An iterator on the key set of attributes."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterable view on attribute keys."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable collection containing the attribute keys."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values The attribute value or set of values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values The attribute value or array of values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute The attribute name."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values The attribute value or array of values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attributes A set of (key,value) pairs."
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute Name of the attribute to remove."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of attributes."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The graph containing this node or null if unknown."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The number of edges/relations/links."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the count of edges that only leave this node plus all undirected\n        edges."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the count of edges that only enter this node plus all undirected\n        edges."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Identifier of the target node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if a directed edge goes from this node to 'id' or if an\n        undirected edge exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Identifier of the source node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if a directed edge goes from this node to 'id' or if an\n        undirected edge exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Identifier of another node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if a edge exists between this node and node 'id'."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Identifier of the target node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Directed edge going from this node to 'id', or undirected edge if\n        it exists, else null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Identifier of the source node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Directed edge going from node 'id' to this node, or undirected\n        edge if it exists, else null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Identifier of the opposite node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Edge between node 'id' and this node if it exists, else null."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The iterator, edges are iterated in arbitrary order."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The iterator, edges are iterated in arbitrary order."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The iterator, edges are iterated in arbitrary order."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The iterator, neighbors are iterated in arbitrary order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i Index of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The i-th edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundException if <code>i</code> is negative or greater than or equal to the\n            degree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i Index of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The i-th entering edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundException if <code>i</code> is negative or greater than or equal to the\n            in-degree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i Index of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The i-th leaving edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundException if <code>i</code> is negative or greater than or equal to the\n            out-degree"
    },
    {
        "oracle": ";",
        "javadocTag": "@return An iterator able to explore the graph in a breadth first way\n        starting at this node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param directed If false, the iterator will ignore edge orientation (the\n           default is \"True\")."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An iterator able to explore the graph in a breadth first way\n        starting at this node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An iterator able to explore the graph in a depth first way\n        starting at this node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param directed If false, the iterator will ignore edge orientation (the\n           default is \"True\")."
    },
    {
        "oracle": ";",
        "javadocTag": "@return An iterator able to explore the graph in a depth first way\n        starting at this node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A collection containing all directed and undirected edges,\n        leaving or entering."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A collection of only edges that leave this node plus all\n        undirected edges."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A collection of only edges that enter this node plus all\n        undirected edges."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A collection containing all directed and undirected edges,\n        leaving or entering."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A collection of only edges that leave this node plus all\n        undirected edges."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A collection of only edges that enter this node plus all\n        undirected edges."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node The target node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if a directed edge goes from this node to the other node or\n        if an undirected edge exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index of the target node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if a directed edge goes from this node to the other node or\n        if an undirected edge exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is negative or greater than {@code\n            getNodeCount() - 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node The source node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if a directed edge goes from the other node to this node or\n        if an undirected edge exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index of the source node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if a directed edge goes from the other node to this node or\n        if an undirected edge exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is negative or greater than {@code\n            getNodeCount() - 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>any</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>one</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any predicate in the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if none of decorated predicates return true"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return never"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicates array of predicates, cloned, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformers matching array of transformers, cloned, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>chained</code> transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element in the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map a map of predicates to transformers"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>switch</code> transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any transformer in the map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the map elements are of the wrong type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the predicates"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the transformers"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clone if {@code true} the input arguments will be cloned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicates array of predicates, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformers matching array of transformers, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultTransformer the transformer to use if no match, null means return null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicates array of predicates, cloned, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformers matching array of transformers, cloned, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to call, null means nop"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>transformer</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>and</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if either decorated predicate returns true"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the input/output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed result which is the input"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map, not cloned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to use for lookup, not cloned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type the factory creates"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return never"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closures the closures to chain, copied, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>chained</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closures a collection of closures to chain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>chained</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any closure in the collection is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object passed to each closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the closures"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clone if {@code true} the input argument will be cloned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closures the closures to chain, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closures the closures to chain, copied, no nulls"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>and</code> predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if both decorated predicates return true"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type the factory creates"
    },
    {
        "oracle": ";",
        "javadocTag": "@param prototype the object to clone each time in the factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\nthe {@code prototype} is {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the prototype cannot be cloned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the object type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return never"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the predicates"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if input is of stored type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type to check for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param methodName the method name to call"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an invoker transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param methodName the method name to call"
    },
    {
        "oracle": ";",
        "javadocTag": "@param paramTypes the parameter types of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the arguments to pass to the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an invoker transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if paramTypes does not match args"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first number"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second number to subtract from a"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a-b if no overflows occur"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if an overflow occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first number"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second number to subtract from a"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a-b if no overflows occur"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if an overflow occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first number to multiply"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second number to multiply"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a*b if no overflows occur"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if an overflow occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first number to multiply"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second number to multiply"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a*b if no overflows occur"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if an overflow occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a dividend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b divisor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a dividend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b divisor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a dividend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b divisor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a dividend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b divisor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param magnitude the value to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sign the sign for the returned value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the magnitude with the same sign as the {@code sign} argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param magnitude the value to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sign the sign for the returned value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the magnitude with the same sign as the {@code sign} argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d number from which exponent is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return exponent for d in IEEE754 representation, without bias"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f number from which exponent is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return exponent for d in IEEE754 representation, without bias"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a unused"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Value to be added to end of array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param values Values to be added to end of array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Value to be added to the array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value which has been discarded or \"pushed\" out of the array\nby this rolling insert."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value New value to substitute for the most recently added value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value that has been replaced in the array."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if the array is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expansion factor to be checked"
    },
    {
        "oracle": ";",
        "javadocTag": "@param contraction criteria to be checked"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the contractionCriteria is less than\nthe expansionCriteria."
    },
    {
        "oracle": ";",
        "javadocTag": "@param contraction Criterion to be checked."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expansion Factor to be checked."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the number of elements to discard from the front of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the number of elements to discard from the end of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the number of elements to discard from the front/end of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param front true if elements are to be discarded from the front\nof the array, false if elements are to be discarded from the end\nof the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if i is greater than numElements."
    },
    {
        "oracle": ";",
        "javadocTag": "@param size Size of the new internal storage array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the contraction criteria used to reclaim memory."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the contraction criterion used to reclaim memory."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index to fetch a value from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value stored at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the double array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the expansion factor of this expandable double array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the expansion mode."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the length of the internal storage array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the length of the internal array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of elements."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the internal storage array used by this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the internal storage array used by this object."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the start index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param contractionCriteria contraction criteria"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the contractionCriteria is less than\n        the expansionCriteria."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to be applied on this array."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the result."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index to store a value in"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to store at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expansionFactor the new expansion factor value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expansionMode The expansionMode to set."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the specified mode value is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expansionMode Expansion mode to use for resizing the array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i a new number of elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if array satisfies the contraction criteria"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the starting index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source ResizableDoubleArray to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dest ResizableArray to replace with a copy of the source array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new ResizableDoubleArray with the same data and configuration\nproperties as this"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object object to be compared for equality with this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff object is a ResizableDoubleArray with the same data and\nproperties as this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code representing this {@code ResizableDoubleArray}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity Initial size of the internal storage array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialArray initial array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity Initial size of the internal storage array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expansionFactor The array will be expanded based on this\nparameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if parameters are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity Initial size of the internal storage array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expansionFactor The array will be expanded based on this\nparameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if parameters are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity Initial size of the internal storage array.."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expansionFactor The array will be expanded based on this\nparameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the map elements are of the wrong type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param objectsAndClosures a map of objects to closures"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any closure in the map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new unmodifiable trie"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of bits per element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the bit length of the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bitIndex the bit index to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lengthInBits the maximum key length in bits to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the bit is set in the given key and\n  {@code bitIndex} &lt; {@code lengthInBits}, {@code false} otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offsetInBits the bit offset in the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lengthInBits the maximum key length in bits to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other the other key to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param otherOffsetInBits the bit offset in the other key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param otherLengthInBits the maximum key length in bits for the other key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix the prefix to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offsetInBits the bit offset in the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lengthInBits the maximum key length in bits to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if this is a valid prefix for the given key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to use in the search"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@link Entry} whose key is closest in a bitwise XOR metric\n  to the provided key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to use in the search"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the key that is closest in a bitwise XOR metric to the provided key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to use in the search"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value whose key is closest in a bitwise XOR metric\nto the provided key"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if provided key is of an incompatible type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to use in the search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offsetInBits the prefix offset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lengthInBits the number of significant prefix bits"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link SortedMap} view of this {@link Trie} with all elements whose\n  key is prefixed by the search key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the start entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@link KeyAnalyzer} used by this {@link Trie}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyAnalyzer the {@link KeyAnalyzer} to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed sorted map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed sorted map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the eldest key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the most recently inserted key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to get after"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to get before"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to retrieve"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the key at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashIndex the index into the data array to store at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param next the next entry in sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashCode the hash code to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the newly created entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hashIndex the index into the data structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous the previous entry in the chain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to query, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>before</code> field of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the entry is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry to query, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>after</code> field of the entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the entry is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entrySet iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the keySet iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the values iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity, must be a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@param threshold the threshold, must be sensible"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mapped value, null if no match"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map is currently size zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value previously mapped to this key, null if none"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new AbstractHashedMap or subclass"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the mapping to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value mapped to the removed key, null if key not in map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the map iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the entrySet view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the keySet view"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the values view"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mMinusX {@code m - x}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k {@code k}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b {@code b}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q {@code q}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a {@code a}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param oneOverN {@code 1 / n}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k If {@code b > 0}, value of the function for x going towards +&infin;.\nIf {@code b < 0}, value of the function for x going towards -&infin;."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Abscissa of maximum growth."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Growth rate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q Parameter that affects the position of the curve along the\nordinate axis."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a If {@code b > 0}, value of the function for x going towards -&infin;.\nIf {@code b < 0}, value of the function for x going towards +&infin;."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Parameter that affects near which asymptote the maximum\ngrowth occurs."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Value at which to compute the sigmoid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lo Lower asymptote."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hi Higher asymptote."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the sigmoid function at {@code x}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lo Lower asymptote."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hi Higher asymptote."
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalized If {@code true}, the function is\n<code> sin(&pi;x) / &pi;x</code>, otherwise {@code sin(x) / x}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xTimesOmegaPlusPhase {@code omega * x + phase}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param amplitude Amplitude."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the harmonic oscillator function at {@code x}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param amplitude Amplitude."
    },
    {
        "oracle": ";",
        "javadocTag": "@param omega Angular frequency."
    },
    {
        "oracle": ";",
        "javadocTag": "@param phase Phase."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point at which the function must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the function value for the given point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the parameter's dimension is wrong for the function being evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.MathIllegalArgumentException when the activated method itself can ascertain that preconditions,\nspecified in the API expressed at the level of the activated method,\nhave been violated.  In the vast majority of cases where Commons Math\nthrows this exception, it is the result of argument checking of actual\nparameters immediately passed to a method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k index of the coordinate with respect to which the partial\nderivative is computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the partial derivative function with respect to k<sup>th</sup> point coordinate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the gradient function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Point at which the function value should be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the function."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException when the activated method itself can\nascertain that a precondition, specified in the API expressed at the\nlevel of the activated method, has been violated.\nWhen Commons Math throws an {@code IllegalArgumentException}, it is\nusually the consequence of checking the actual parameters passed to\nthe method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x x-coordinate for which the function value should be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y y-coordinate for which the function value should be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z z-coordinate for which the function value should be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point at which the function must be evaluated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return function value for the given point"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if point's dimension is wrong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Point for which the function value should be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters Function parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Point for which the function value should be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters Function parameters."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the point for which the function value should be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if {@code x} does not\nsatisfy the function's constraints (argument out of bound, or unsupported\nderivative order for example)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the point for which the function value should be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if {@code x} does not\nsatisfy the function's constraints (argument out of bound, or unsupported\nderivative order for example)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters number of free parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return cached rules set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if order is too large"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters number of free parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueCompiler compiler for the value part"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sizes array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters number of free parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueCompiler compiler for the value part"
    },
    {
        "oracle": ";",
        "javadocTag": "@param derivativeCompiler compiler for the derivative part"
    },
    {
        "oracle": ";",
        "javadocTag": "@return derivatives indirection array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters number of free parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueCompiler compiler for the value part"
    },
    {
        "oracle": ";",
        "javadocTag": "@param derivativeCompiler compiler for the derivative part"
    },
    {
        "oracle": ";",
        "javadocTag": "@return lower derivatives indirection array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters number of free parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueCompiler compiler for the value part"
    },
    {
        "oracle": ";",
        "javadocTag": "@param derivativeCompiler compiler for the derivative part"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerIndirection lower derivatives indirection array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return multiplication indirection array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters number of free parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valueCompiler compiler for the value part"
    },
    {
        "oracle": ";",
        "javadocTag": "@param derivativeCompiler compiler for the derivative part"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sizes sizes array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param derivativesIndirection derivatives indirection array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return multiplication indirection array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if order is too large"
    },
    {
        "oracle": ";",
        "javadocTag": "@param orders derivation orders with respect to each parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return index of the partial derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the numbers of parameters does not\nmatch the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if sum of derivation orders is larger\nthan the instance limits"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameters number of free parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order derivation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sizes sizes array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param orders derivation orders with respect to each parameter\n(the lenght of this array must match the number of parameters)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return index of the partial derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if sum of derivation orders is larger\nthan the instance limits"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of a partial derivative in source derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcP number of free parameters in source derivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcDerivativesIndirection derivatives indirection array for the source\nderivative structure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleStats DescriptiveStatistics holding sample summary statitstics"
    },
    {
        "oracle": ";",
        "javadocTag": "@return t statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of samples is &lt; 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample1 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample2 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return t statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample1 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample2 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return t statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleStats1 StatisticalSummary describing data from the first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleStats2 StatisticalSummary describing data from the second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return t statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of samples is &lt; 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleStats1 StatisticalSummary describing data from the first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleStats2 StatisticalSummary describing data from the second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return t statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of samples is &lt; 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu constant value to compare sample mean against"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu constant value to compare sample mean against"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level of the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if <code>alpha</code> is not in the range (0, 0.5]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu constant value to compare sample mean against"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleStats StatisticalSummary describing sample data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of samples is &lt; 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu constant value to compare sample mean against"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleStats StatisticalSummary describing sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level of the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of samples is &lt; 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if <code>alpha</code> is not in the range (0, 0.5]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample1 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample2 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value for t-test"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample1 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample2 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value for t-test"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample1 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample2 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level of the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the null hypothesis can be rejected with\nconfidence 1 - alpha"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if <code>alpha</code> is not in the range (0, 0.5]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample1 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample2 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level of the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the null hypothesis can be rejected with\nconfidence 1 - alpha"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if <code>alpha</code> is not in the range (0, 0.5]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleStats1 StatisticalSummary describing data from the first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleStats2 StatisticalSummary describing data from the second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value for t-test"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of samples is &lt; 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleStats1 StatisticalSummary describing data from the first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleStats2 StatisticalSummary describing data from the second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value for t-test"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of samples is &lt; 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleStats1 StatisticalSummary describing sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleStats2 StatisticalSummary describing sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level of the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the null hypothesis can be rejected with\nconfidence 1 - alpha"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the number of samples is &lt; 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if <code>alpha</code> is not in the range (0, 0.5]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first sample variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second sample variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n1 first sample n"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n2 second sample n"
    },
    {
        "oracle": ";",
        "javadocTag": "@return approximate degrees of freedom"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m sample mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu constant to test against"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v sample variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n sample n"
    },
    {
        "oracle": ";",
        "javadocTag": "@return t test statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m1 first sample mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m2 second sample mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first sample variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second sample variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n1 first sample n"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n2 second sample n"
    },
    {
        "oracle": ";",
        "javadocTag": "@return t test statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m1 first sample mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m2 second sample mean"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first sample variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second sample variance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n1 first sample n"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n2 second sample n"
    },
    {
        "oracle": ";",
        "javadocTag": "@return t test statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator Underlying generator for uncorrelated normalized\ncomponents."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.linear.NonPositiveDefiniteMatrixException if the covariance matrix is not strictly positive definite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integers array), if null\nthe seed of the generator will be related to the current time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (64 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integers array), if null\nthe seed of the generator will be related to the current time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (64 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random scalar with null mean and unit standard deviation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator underlying random generator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integers array), if null\nthe seed of the generator will be related to the current time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (64 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bits number of random bits to produce"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random bits generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a pseudorandom, uniformly distributed {@code long}\nvalue between 0 (inclusive) and n (exclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start Index at which to start inserting the generated bytes."
    },
    {
        "oracle": ";",
        "javadocTag": "@param len Number of bytes to insert."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code len < 0} or {@code len > bytes.length - start}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param bytes Array in which to put the generated bytes. Cannot be {@code null}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start Index at which to start inserting the generated bytes."
    },
    {
        "oracle": ";",
        "javadocTag": "@param len Number of bytes to insert."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng Generator whose methods will be called through\ntheir corresponding overridden synchronized version.\nTo ensure thread-safety, the wrapped generator <em>must</em>\nnot be used directly."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random vector as a newly built array of double"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean expected mean values for each component"
    },
    {
        "oracle": ";",
        "javadocTag": "@param standardDeviation standard deviation for each component"
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator underlying generator for uncorrelated normalized\ncomponents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension dimension of the vectors to generate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator underlying generator for uncorrelated normalized\ncomponents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integers array), if null\nthe seed of the generator will be related to the current time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (64 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return generated value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException in REPLAY_MODE if a file I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if mode is not recognized"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the underlying random generator thwrows one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values array to be filled"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException in REPLAY_MODE if a file I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if mode is not recognized"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the underlying random generator thwrows one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length length of output array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return array of generated values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException in REPLAY_MODE if a file I/O error occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if mode is not recognized"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the underlying random generator thwrows one"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs reading the input file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if URL contains no data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param binCount the number of bins used in computing the empirical\ndistribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an error occurs reading the input file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ZeroException if URL contains no data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Value of property mode."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mode New value of the data generation mode."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Values file URL."
    },
    {
        "oracle": ";",
        "javadocTag": "@param url String representation for new valuesFileURL."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MalformedURLException if url is not well formed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param url URL of the values file."
    },
    {
        "oracle": ";",
        "javadocTag": "@return EmpircalDistribution built by {@link #computeDistribution()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an error occurs opening the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an error occurs closing the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Mean used in data generation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu new Mean value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Standard deviation used when operating in {@link #GAUSSIAN_MODE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sigma New standard deviation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed Value with which to reseed the {@link RandomDataImpl}\nused to generate random data."
    },
    {
        "oracle": ";",
        "javadocTag": "@return next random value from the empirical distribution digest"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if digest has not been initialized"
    },
    {
        "oracle": ";",
        "javadocTag": "@return next value from the replay file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is a problem reading from the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if URL contains no data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberFormatException if an invalid numeric string is\n  encountered in the file"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random uniform value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the underlying random generator thwrows one"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random exponential value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the underlying random generator thwrows one"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random Gaussian value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the underlying random generator thwrows one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param randomData the RandomDataImpl instance used to source random data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator source of random data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the dimension index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param j the digit index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the base for this dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param digit the j-th digit"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scrambled digit"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index in the sequence to skip to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the i-th point in the Halton sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the next point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension the space dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension the space dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights used during scrambling, may be null in which case no scrambling will be performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the space dimension is outside the range [1, len], where\n  len refers to the length of the bases array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integers array), if null\nthe seed of the generator will be related to the current time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (64 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len the length of the string to be generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random string of hex characters of length {@code len}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower lower bound for generated integer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper upper bound for generated integer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower lower bound for generated long integer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper upper bound for generated long integer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len the length of the string to be generated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param uB Upper bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the stored point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to the internal array storing the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the stored value of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference to the internal array storing the value of\nthe objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return data transfer object that will be serialized"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point coordinates. This instance will store\na copy of the array, not the array passed as argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Value of the objective function at the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point coordinates."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Value of the objective function at the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyArray if {@code true}, the input arrays will be copied,\notherwise they will be referenced."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iteration Index of current iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous Best point in the previous iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@param current Best point in the current iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the arguments satify the convergence criterion."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold relative tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold absolute tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold Relative tolerance threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold Absolute tolerance threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIter Maximum iteration count."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iteration Index of current iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous Best point in the previous iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@param current Best point in the current iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the arguments satify the convergence criterion."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold relative tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold absolute tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold Relative tolerance threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold Absolute tolerance threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIter Maximum iteration count."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximal number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of evaluations of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximal number of iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of evaluations of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object used to check for convergence."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data.\nThis method will register the following data:\n<ul>\n <li>{@link MaxEval}</li>\n <li>{@link MaxIter}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a point/value pair that satisfies the convergence criteria."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyIterationsException if the maximal number of\niterations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a point/value pair that satisfies the convergence criteria."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyIterationsException if the maximal number of\niterations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point/value pair giving the optimal value of the\nobjective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the allowed evaluations\nhave been exhausted."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyIterationsException if the allowed iterations\nhave been exhausted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data.\nThe following data will be looked for:\n<ul>\n <li>{@link MaxEval}</li>\n <li>{@link MaxIter}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of objective function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIter Maximum number of algorithm iterations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the optima sorted from best to worst."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if {@code optData} does not contain an\ninstance of {@link MaxEval} or {@link InitialGuess}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimum Result of an optimization run."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Single-start optimizer to wrap."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator Random vector generator to use for restarts."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array containing the optima."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if {@link #optimize(OptimizationData[])\noptimize} has not been called."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if {@code optData} does not contain an\ninstance of {@link MaxEval} or {@link SearchInterval}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goal Goal type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Single-start optimizer to wrap."
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator Random generator to use for restarts."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Point and value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Point and value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param isMinim {@code true} if the selected point must be the one with\nthe lowest value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the best point, or {@code null} if {@code a} and {@code b} are\nboth {@code null}. When {@code a} and {@code b} have the same function\nvalue, {@code a} is returned."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel Relative threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abs Absolute threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Additional, user-defined, convergence checking\nprocedure."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rel Relative threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@param abs Absolute threshold."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to be optimized."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iteration Index of current iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous Best point in the previous iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@param current Best point in the current iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the algorithm has converged."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold relative tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold absolute tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeThreshold relative tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteThreshold absolute tolerance threshold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIter Maximum iteration count."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lower bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the upper bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the start value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lo Lower bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hi Upper bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@param init Start value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lo Lower bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hi Upper bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the point."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the stored value of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value Value of an objective function at the point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param func Function whose optimum should be bracketed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param goal {@link GoalType Goal type}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xA Initial point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xB Initial point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximum number of evaluations\nis exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of evalutations."
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if <code>array</code> is <code>null</code>"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if <code>array</code> is <code>null</code>"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if <code>array</code> is <code>null</code>"
    },
    {
        "oracle": "key==null || value==null;",
        "javadocTag": "@throws NullPointerException if either the key or value is null"
    },
    {
        "oracle": "(key==null) == false;",
        "javadocTag": "@param key the key to add, must not be null"
    },
    {
        "oracle": "(value==null) == false;",
        "javadocTag": "@param value the value to add, must not be null"
    },
    {
        "oracle": "this.values()!=null || this.values()!=null || this.values()!=null && this.values()==null || this.values()==null || this.values()==null;",
        "javadocTag": "@throws NullPointerException (optional) if the map limits the values to\n non-null and null was specified"
    },
    {
        "oracle": "this.values()!=null || this.values()!=null || this.values()!=null && this.values()==null || this.values()==null || this.values()==null;",
        "javadocTag": "@throws NullPointerException (optional) if the map limits the values to\n non-null and null was specified"
    },
    {
        "oracle": "this.values()!=null || this.values()!=null || this.values()!=null && this.values()==null || this.values()==null || this.values()==null;",
        "javadocTag": "@throws NullPointerException (optional) if the map limits the values to\n non-null and null was specified"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "predicatesAndClosures==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "queue==null;",
        "javadocTag": "@throws NullPointerException if the queue is null"
    },
    {
        "oracle": "(queue==null) == false;",
        "javadocTag": "@param queue the queue to make unmodifiable, must not be null"
    },
    {
        "oracle": "queue==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if the queue or predicate is null"
    },
    {
        "oracle": "(queue==null) == false;",
        "javadocTag": "@param queue the queue to predicate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate used to evaluate new elements, must not be null"
    },
    {
        "oracle": "queue==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if the queue or transformer is null"
    },
    {
        "oracle": "(queue==null) == false;",
        "javadocTag": "@param queue the queue to predicate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer for the queue, must not be null"
    },
    {
        "oracle": "true ? methodResultID.equals(QueueUtils.EMPTY_QUEUE) : true;",
        "javadocTag": "@return an empty {@link Queue}"
    },
    {
        "oracle": "((set1==null)==false) && (set1.equals(set2)) ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return whether the sets are equal by value comparison"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if the set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to synchronize, must not be null"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if the set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to make unmodifiable, must not be null"
    },
    {
        "oracle": "set==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if the set or predicate is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to predicate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate for the set, must not be null"
    },
    {
        "oracle": "set==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if the set or transformer is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to transform, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer for the set, must not be null"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if the set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to order, must not be null"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if the set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the sorted set to synchronize, must not be null"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if the set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the sorted set to make unmodifiable, must not be null"
    },
    {
        "oracle": "set==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if the set or predicate is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the sorted set to predicate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate for the sorted set, must not be null"
    },
    {
        "oracle": "set==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if the set or transformer is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to transform, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer for the set, must not be null"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if the set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the navigable set to make unmodifiable, must not be null"
    },
    {
        "oracle": "set==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if the set or predicate is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the navigable set to predicate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate for the navigable set, must not be null"
    },
    {
        "oracle": "set==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if the set or transformer is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the navigable set to transform, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer for the set, must not be null"
    },
    {
        "oracle": "a==null || b==null;",
        "javadocTag": "@throws NullPointerException if either input set is null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first set, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second set, must not be null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the set to subtract from, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the set to subtract, must not be null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first set, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second set, must not be null"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the first set, must not be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the second set, must not be null"
    },
    {
        "oracle": "true ? methodResultID==false : true;",
        "javadocTag": "@return false always"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if the predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to decorate, not null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "((o1==null)==false) && (o1.equals(o2)) ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return whether the two objects are equal."
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value mapped to this key"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the <code>put</code> method is not supported"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException (optional) if the map limits the type of the\n value and the specified value is inappropriate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException (optional) if the map limits the values\n in some way and the value was invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to find the key for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mapped key, or <code>null</code> if not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException (optional) if the map limits the type of the\n value and the specified value is inappropriate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to find the key-value pair for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the key that was removed, <code>null</code> if nothing removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException (optional) if the map limits the type of the\n value and the specified value is inappropriate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if this method is not supported\n by the implementation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an inverted bidirectional map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set view of the values contained in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o1 the first object to be equated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param o2 the second object to be equated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param o the object to calculate the hash for."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash of the object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of occurrences of the object, zero if not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to update"
    },
    {
        "oracle": ";",
        "javadocTag": "@param count the number of occurrences of the object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of occurrences of the object before this operation, zero\n  if the object was not contained in the multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> always, as the size of the MultiSet is increased\n  in any case"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param occurrences the number of occurrences to add, may be zero,\n  in which case no change is made to the multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of occurrences of the object in the multiset before\n  this operation; possibly zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if this call changed the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to remove"
    },
    {
        "oracle": "(((file==null)==false) && (file.exists())) == false;",
        "javadocTag": "@throws FileNotFoundException if the {@code file} does not exist"
    },
    {
        "oracle": "(((file==null)==false) && (file.exists())) == false;",
        "javadocTag": "@throws FileNotFoundException if the {@code file} does not exist"
    },
    {
        "oracle": "c>0;",
        "javadocTag": "@param c the number of compression rounds (must be positive)"
    },
    {
        "oracle": "d>0;",
        "javadocTag": "@param d the number of finalization rounds (must be positive)"
    },
    {
        "oracle": "swallowIOException==false;",
        "javadocTag": "@throws IOException if {@code swallowIOException} is false and\n    {@link Flushable#flush} throws an {@code IOException}."
    },
    {
        "oracle": "size<=0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is nonpositive"
    },
    {
        "oracle": "size<=0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is nonpositive"
    },
    {
        "oracle": "position<0;",
        "javadocTag": "@throws IndexOutOfBoundsException if {@code position} is negative or\n    greater than or equal to the size of {@code iterable}"
    },
    {
        "oracle": "position<0;",
        "javadocTag": "@throws IndexOutOfBoundsException if {@code position} is negative"
    },
    {
        "oracle": "limitSize<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code limitSize} is negative"
    },
    {
        "oracle": "size<=0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is nonpositive"
    },
    {
        "oracle": "size<=0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is nonpositive"
    },
    {
        "oracle": "position<0;",
        "javadocTag": "@throws IndexOutOfBoundsException if {@code position} is negative or\n    greater than or equal to the number of elements remaining in\n    {@code iterator}"
    },
    {
        "oracle": "position<0;",
        "javadocTag": "@throws IndexOutOfBoundsException if {@code position} is negative"
    },
    {
        "oracle": "limitSize<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code limitSize} is negative"
    },
    {
        "oracle": "offset<0 || length<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code offset} or {@code length} is negative"
    },
    {
        "oracle": "sources==null;",
        "javadocTag": "@throws NullPointerException if any of {@code sources} is {@code null}"
    },
    {
        "oracle": "sources==null;",
        "javadocTag": "@throws NullPointerException if any of {@code sources} is {@code null}"
    },
    {
        "oracle": "element==null;",
        "javadocTag": "@throws NullPointerException if {@code element} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "(a==null) == false;",
        "javadocTag": "@param a the instance to convert; will never be null"
    },
    {
        "oracle": "true ? (methodResultID==null) == false : true;",
        "javadocTag": "@return the converted instance; <b>must not</b> be null"
    },
    {
        "oracle": "(b==null) == false;",
        "javadocTag": "@param b the instance to convert; will never be null"
    },
    {
        "oracle": "true ? (methodResultID==null) == false : true;",
        "javadocTag": "@return the converted instance; <b>must not</b> be null"
    },
    {
        "oracle": "a==null ? methodResultID==null : methodResultID!=null;",
        "javadocTag": "@return the converted value; is null <i>if and only if</i> {@code a} is null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "valuesInOrder==null;",
        "javadocTag": "@throws NullPointerException if any of the provided values is null"
    },
    {
        "oracle": "leastValue==null || remainingValuesInOrder==null;",
        "javadocTag": "@throws NullPointerException if any of the provided values is null"
    },
    {
        "oracle": "k<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code k} is negative"
    },
    {
        "oracle": "k<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code k} is negative"
    },
    {
        "oracle": "k<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code k} is negative"
    },
    {
        "oracle": "k<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code k} is negative"
    },
    {
        "oracle": "expectedKeys<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code expectedKeys < 0}"
    },
    {
        "oracle": "off<0;",
        "javadocTag": "@throws IndexOutOfBoundsException if {@code off < 0} or {@code off + len > bytes.length} or\n  {@code len < 0}"
    },
    {
        "oracle": "x<=0;",
        "javadocTag": "@throws IllegalArgumentException if {@code x <= 0}"
    },
    {
        "oracle": "x<=0;",
        "javadocTag": "@throws IllegalArgumentException if {@code x <= 0}"
    },
    {
        "oracle": "k<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code k < 0}"
    },
    {
        "oracle": "x<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code x < 0}"
    },
    {
        "oracle": "q==0;",
        "javadocTag": "@throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}\n        is not an integer multiple of {@code b}"
    },
    {
        "oracle": "m<=0;",
        "javadocTag": "@throws ArithmeticException if {@code m <= 0}"
    },
    {
        "oracle": "m<=0;",
        "javadocTag": "@throws ArithmeticException if {@code m <= 0}"
    },
    {
        "oracle": "a<0 || b<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code a < 0} or {@code b < 0}"
    },
    {
        "oracle": "n<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code n < 0}"
    },
    {
        "oracle": "input==null;",
        "javadocTag": "@throws NullPointerException if {@code input} is null and this predicate does not accept null\n    arguments"
    },
    {
        "oracle": "first==null && second==null;",
        "javadocTag": "@throws NullPointerException if both {@code first} and {@code second} are null"
    },
    {
        "oracle": "first!=null ? methodResultID.equals(first) : methodResultID.equals(second);",
        "javadocTag": "@return {@code first} if it is non-null; otherwise {@code second} if it is non-null"
    },
    {
        "oracle": "initialCapacity<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code initialCapacity} is negative"
    },
    {
        "oracle": "concurrencyLevel<=0;",
        "javadocTag": "@throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive"
    },
    {
        "oracle": "size<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is negative"
    },
    {
        "oracle": "weight<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code weight} is negative"
    },
    {
        "oracle": "duration<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code duration} is negative"
    },
    {
        "oracle": "duration<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code duration} is negative"
    },
    {
        "oracle": "duration<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code duration} is negative"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "initialCapacity<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code initialCapacity} is negative"
    },
    {
        "oracle": "size<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is negative"
    },
    {
        "oracle": "concurrencyLevel<=0;",
        "javadocTag": "@throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive"
    },
    {
        "oracle": "duration<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code duration} is negative"
    },
    {
        "oracle": "duration<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code duration} is negative"
    },
    {
        "oracle": "minLength<0 || padding<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code minLength} or {@code padding} is\n    negative"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if {@code collection} or any of its elements\n    is null"
    },
    {
        "oracle": "this.bits()<32;",
        "javadocTag": "@throws IllegalStateException if {@code bits() < 32}"
    },
    {
        "oracle": "this.bits()<64;",
        "javadocTag": "@throws IllegalStateException if {@code bits() < 64}"
    },
    {
        "oracle": "off<0;",
        "javadocTag": "@throws IndexOutOfBoundsException if {@code off < 0} or {@code off + len > bytes.length}\n  or {@code len < 0}"
    },
    {
        "oracle": "string==null;",
        "javadocTag": "@throws NullPointerException if {@code string} is null"
    },
    {
        "oracle": "n<=0;",
        "javadocTag": "@throws IllegalArgumentException if any alphabet or padding characters appear in the separator\n        string, or if {@code n <= 0}"
    },
    {
        "oracle": "expression==false;",
        "javadocTag": "@throws IllegalArgumentException if {@code expression} is false"
    },
    {
        "oracle": "expression==false;",
        "javadocTag": "@throws IllegalArgumentException if {@code expression} is false"
    },
    {
        "oracle": "expression==false;",
        "javadocTag": "@throws IllegalArgumentException if {@code expression} is false"
    },
    {
        "oracle": "errorMessageTemplate==null || errorMessageArgs==null;",
        "javadocTag": "@throws NullPointerException if the check fails and either {@code errorMessageTemplate} or\n    {@code errorMessageArgs} is null (don't let this happen)"
    },
    {
        "oracle": "expression==false;",
        "javadocTag": "@throws IllegalStateException if {@code expression} is false"
    },
    {
        "oracle": "expression==false;",
        "javadocTag": "@throws IllegalStateException if {@code expression} is false"
    },
    {
        "oracle": "expression==false;",
        "javadocTag": "@throws IllegalStateException if {@code expression} is false"
    },
    {
        "oracle": "errorMessageTemplate==null || errorMessageArgs==null;",
        "javadocTag": "@throws NullPointerException if the check fails and either {@code errorMessageTemplate} or\n    {@code errorMessageArgs} is null (don't let this happen)"
    },
    {
        "oracle": "reference==null;",
        "javadocTag": "@throws NullPointerException if {@code reference} is null"
    },
    {
        "oracle": "reference==null;",
        "javadocTag": "@throws NullPointerException if {@code reference} is null"
    },
    {
        "oracle": "reference==null;",
        "javadocTag": "@throws NullPointerException if {@code reference} is null"
    },
    {
        "oracle": "index<0 || (index<size) == false;",
        "javadocTag": "@throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}"
    },
    {
        "oracle": "size<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is negative"
    },
    {
        "oracle": "index<0 || (index<size) == false;",
        "javadocTag": "@throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}"
    },
    {
        "oracle": "size<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is negative"
    },
    {
        "oracle": "index<0 || index>size;",
        "javadocTag": "@throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}"
    },
    {
        "oracle": "size<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is negative"
    },
    {
        "oracle": "index<0 || index>size;",
        "javadocTag": "@throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}"
    },
    {
        "oracle": "size<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is negative"
    },
    {
        "oracle": "start<0 || end<0 || start>size || end>size || end<start || end<start;",
        "javadocTag": "@throws IndexOutOfBoundsException if either index is negative or is greater than {@code size},\n    or if {@code end} is less than {@code start}"
    },
    {
        "oracle": "size<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code size} is negative"
    },
    {
        "oracle": "true ? methodResultID.equals(element) : true;",
        "javadocTag": "@return the provided element"
    },
    {
        "oracle": "capacity<1;",
        "javadocTag": "@throws IllegalArgumentException if {@code capacity} is less than 1"
    },
    {
        "oracle": "capacity<1;",
        "javadocTag": "@throws IllegalArgumentException if {@code capacity} is less than 1"
    },
    {
        "oracle": "escaper==null;",
        "javadocTag": "@throws NullPointerException if escaper is null"
    },
    {
        "oracle": "expectedKeys<0 || expectedValuesPerKey<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code expectedKeys} or {@code\n     expectedValuesPerKey} is negative"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of radix digits"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mode desired rounding mode\nNote that the rounding mode is common to all {@link Dfp} instances\nbelonging to the current {@link DfpField} in the system and will\naffect all future calculations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return current rounding mode"
    },
    {
        "oracle": ";",
        "javadocTag": "@return IEEE 854 status flags"
    },
    {
        "oracle": ";",
        "javadocTag": "@param flags desired value for the flags"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bits bits to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@link Dfp} with a value of 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@link Dfp} with the same value as x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@link Dfp} with the same value as x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@link Dfp} with the same value as x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x value to convert to an instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@link Dfp} with the same value as x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d instance to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@link Dfp} with the same value as d"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string representation of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@link Dfp} parsed from specified string"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sign sign of the Dfp to create"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@link Dfp} with a non-finite value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value &radic;2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value &radic;2 split in two pieces"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value &radic;2 / 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value &radic;3"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value &radic;3 / 3"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value &pi;"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value &pi; split in two pieces"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value e"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value e split in two pieces"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value ln(2)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value ln(2) split in two pieces"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value ln(5)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value ln(5) split in two pieces"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link Dfp} with value ln(10)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a string representation of the number to split"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of two {@link Dfp Dfp} instances which sum equals a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param highPrecisionDecimalDigits precision at which the string constants mus be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param one constant with value 1 at desired precision"
    },
    {
        "oracle": ";",
        "javadocTag": "@param two constant with value 2 at desired precision"
    },
    {
        "oracle": ";",
        "javadocTag": "@param three constant with value 3 at desired precision"
    },
    {
        "oracle": ";",
        "javadocTag": "@return &pi;"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a number for which we want the exponential"
    },
    {
        "oracle": ";",
        "javadocTag": "@param one constant with value 1 at desired precision"
    },
    {
        "oracle": ";",
        "javadocTag": "@param decimalDigits minimal number of decimal digits."
    },
    {
        "oracle": ";",
        "javadocTag": "@param decimalDigits minimal number of decimal digits"
    },
    {
        "oracle": ";",
        "javadocTag": "@param computeConstants if true, the transcendental constants for the given precision\nmust be computed (setting this flag to false is RESERVED for the internal recursive call)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param random random generator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the static random generator shared by GA implementation classes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initial the initial, seed population."
    },
    {
        "oracle": ";",
        "javadocTag": "@param condition the stopping condition used to stop evolution."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the population that satisfies the stopping condition."
    },
    {
        "oracle": ";",
        "javadocTag": "@param current the current population."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the population for the next generation."
    },
    {
        "oracle": ";",
        "javadocTag": "@return crossover policy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return crossover rate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return mutation policy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return mutation rate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return selection policy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of generations evolved"
    },
    {
        "oracle": ";",
        "javadocTag": "@param crossoverPolicy The {@link CrossoverPolicy}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param crossoverRate The crossover rate as a percentage (0-1 inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mutationPolicy The {@link MutationPolicy}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mutationRate The mutation rate as a percentage (0-1 inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param selectionPolicy The {@link SelectionPolicy}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the crossover or mutation rate is outside the [0, 1] range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param population the population from which the chromosomes are choosen."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the selected chromosomes."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the population is not compatible with this {@link SelectionPolicy}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param chromosomes the list of chromosomes"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the list of chromosomes exceeds the population limit"
    },
    {
        "oracle": ";",
        "javadocTag": "@param chromosomeColl a {@link Collection} of chromosomes"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the population would exceed the population limit when\nadding this chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unmodifiable list of chromosomes"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of chromosomes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param chromosome the chromosome to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the population would exceed the {@code populationLimit} after\n  adding this chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fittest chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@param populationLimit maximal population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if the population limit is not a positive number (&lt; 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the new population size is smaller than the current number\n  of chromosomes in the population"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current population size."
    },
    {
        "oracle": ";",
        "javadocTag": "@return chromosome iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param populationLimit maximal size of the population"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if the population limit is not a positive number (&lt; 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param chromosomes list of chromosomes to be added to the population"
    },
    {
        "oracle": ";",
        "javadocTag": "@param populationLimit maximal size of the population"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if the population limit is not a positive number (&lt; 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the list of chromosomes exceeds the population limit"
    },
    {
        "oracle": ";",
        "javadocTag": "@param population ignored (no impact on result)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> IFF the maximum number of generations has been exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of generations that have passed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxGenerations number of generations to evolve"
    },
    {
        "oracle": ";",
        "javadocTag": "@param chromosomeRepresentation representation of the chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the representation of the chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcWidth source block width ({@link #BLOCK_SIZE} or smaller)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcStartRow start row in the source block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcEndRow end row (exclusive) in the source block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcStartColumn start column in the source block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcEndColumn end column (exclusive) in the source block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dstBlock destination block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dstStartRow start row in the destination block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dstStartColumn start column in the destination block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row the row to be set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix row matrix (must have one row and the same number of columns\nas the instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the matrix dimensions do\nnot match one instance row."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified row index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Column matrix (must have one column and the same number of rows\nas the instance)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the matrix dimensions do\nnot match one instance column."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified column index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param blockRow row index (in block sense) of the block"
    },
    {
        "oracle": ";",
        "javadocTag": "@return height (number of rows) of the block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param blockColumn column index (in block sense) of the block"
    },
    {
        "oracle": ";",
        "javadocTag": "@return width (number of columns) of the block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows Number of rows in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param columns Number of columns in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if row or column dimension is not\npositive."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rawData Data for the new matrix, in raw layout."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the {@code blockData} shape is\ninconsistent with block layout."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows the number of rows in the new matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columns the number of columns in the new matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param blockData data for new matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyArray if true, the input array will be copied, otherwise\nit will be referenced"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the {@code blockData} shape is\ninconsistent with block layout."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if row or column dimension is not\npositive."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} + m."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as this matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to be subtracted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} + m."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as this matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to postmultiply by."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} * m."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the number of columns of this\nmatrix is not equal to the number of rows of {@code m}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the 2-dimensional array of entries."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the underlying data array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in Data to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if the input array is empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the input array is not rectangular."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if the input array is {@code null}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowDimension Number of rows in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnDimension Number of columns in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Data for the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code d} is not rectangular."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if there are not at least one row and one column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Data for the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code d} is not rectangular."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if there are not at least one row and one column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Data for the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyArray Whether to copy or reference the input array."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code d} is not rectangular."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if there are not at least one row and one column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Data for the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyArray Whether to copy or reference the input array."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code d} is not rectangular."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if there are not at least one row and one column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Column vector holding data for new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v Column vector holding data for new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the type of field elements of the matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowDimension the number of rows in the new matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnDimension the number of columns in the new matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new matrix of the same type as the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of this matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} + {@code m}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this} matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to be subtracted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} - {@code m}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as {@code this} matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Value to be added to each entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code d} + {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d Value to multiply all entries by."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code d} * {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to postmultiply by."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} * {@code m}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the number of columns of\n{@code this} matrix is not equal to the number of rows of matrix\n{@code m}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to premultiply by."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code m} * {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the number of columns of {@code m}\ndiffers from the number of rows of {@code this} matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p raise this to power p"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this^p"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a 2-dimensional array of entries."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the matrix containing the data of the specified rows and columns."
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "keyPredicate==null;",
        "javadocTag": "@param keyPredicate the predicate to validate the keys, null means no check"
    },
    {
        "oracle": "valuePredicate==null;",
        "javadocTag": "@param valuePredicate the predicate to validate to values, null means no check"
    },
    {
        "oracle": "bag==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if bag or transformer is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "bag==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if bag or transformer is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "bag==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if bag or transformer is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "map==null || factory==null;",
        "javadocTag": "@throws NullPointerException if map or factory is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory to use, must not be null"
    },
    {
        "oracle": "map==null || factory==null;",
        "javadocTag": "@throws NullPointerException if map or factory is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory to use, must not be null"
    },
    {
        "oracle": "map==null || factory==null;",
        "javadocTag": "@throws NullPointerException if map or factory is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory to use, must not be null"
    },
    {
        "oracle": "map==null || factory==null;",
        "javadocTag": "@throws NullPointerException if map or factory is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory to use, must not be null"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if list is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return the transformed result"
    },
    {
        "oracle": "root==null;",
        "javadocTag": "@param root the root object, null will result in an empty iterator"
    },
    {
        "oracle": "transformer==null;",
        "javadocTag": "@param transformer the transformer to use, null will use a no effect transformer"
    },
    {
        "oracle": "rootIterator==null;",
        "javadocTag": "@param rootIterator the root iterator, null will result in an empty iterator"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to decorate, must not be null"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return a transformed object"
    },
    {
        "oracle": "type==null;",
        "javadocTag": "@throws NullPointerException if the class is null"
    },
    {
        "oracle": "(type==null) == false;",
        "javadocTag": "@param type the type to check for, may not be null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to check, not cloned, not null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates array is null"
    },
    {
        "oracle": "Arrays.stream(predicates).anyMatch(jdVar -> jdVar==null);",
        "javadocTag": "@throws NullPointerException if any predicate in the array is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to check, cloned, not null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates array is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to check, cloned, not null"
    },
    {
        "oracle": "transformers==null;",
        "javadocTag": "@throws NullPointerException if the transformers array is null"
    },
    {
        "oracle": "Arrays.stream(transformers).anyMatch(jdVar -> jdVar==null);",
        "javadocTag": "@throws NullPointerException if any transformer in the array is null"
    },
    {
        "oracle": "transformers==null;",
        "javadocTag": "@throws NullPointerException if the transformers collection is null"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return the transformed result"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "comparators==null;",
        "javadocTag": "@throws NullPointerException if comparators array is null or contains a null"
    },
    {
        "oracle": "(comparators==null) == false && comparators.length > 0 && Arrays.stream(comparators).noneMatch(jdVar -> jdVar == null);",
        "javadocTag": "@param comparators the comparators to use, not null or empty or containing nulls"
    },
    {
        "oracle": "comparators==null || ((comparators==null)==false) && (comparators.contains(null));",
        "javadocTag": "@throws NullPointerException if comparators collection is null or contains a null"
    },
    {
        "oracle": "(comparators==null) == false || ((comparators==null)==false) && (comparators.isEmpty());",
        "javadocTag": "@param comparators the comparators to use, not null or empty or containing nulls"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if the Bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to synchronize, must not be null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if the Bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag whose unmodifiable view is to be returned, must not be null"
    },
    {
        "oracle": "bag==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if the Bag or Predicate is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to predicate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate for the bag, must not be null"
    },
    {
        "oracle": "bag==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if the Bag or Transformer is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to predicate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer for the bag, must not be null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if the SortedBag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to synchronize, must not be null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if the SortedBag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag whose unmodifiable view is to be returned, must not be null"
    },
    {
        "oracle": "bag==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if the SortedBag or Predicate is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the sorted bag to predicate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate for the bag, must not be null"
    },
    {
        "oracle": "bag==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if the Bag or Transformer is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to predicate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer for the bag, must not be null"
    },
    {
        "oracle": "true ? methodResultID.equals(BagUtils.EMPTY_BAG) : true;",
        "javadocTag": "@return an empty Bag"
    },
    {
        "oracle": "true ? methodResultID.equals(BagUtils.EMPTY_SORTED_BAG) : true;",
        "javadocTag": "@return an empty sorted Bag"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "initialCapacity<0;",
        "javadocTag": "@throws IllegalArgumentException if the initial capacity is negative"
    },
    {
        "oracle": "initialCapacity<0;",
        "javadocTag": "@throws IllegalArgumentException if the initial capacity is negative"
    },
    {
        "oracle": "loadFactor<0;",
        "javadocTag": "@throws IllegalArgumentException if the load factor is less than zero"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "methodName==null;",
        "javadocTag": "@throws NullPointerException if methodName is null"
    },
    {
        "oracle": "methodName==null;",
        "javadocTag": "@throws NullPointerException if methodName is null"
    },
    {
        "oracle": "coll==null;",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": "comparator==null;",
        "javadocTag": "@throws NullPointerException if comparator is null"
    },
    {
        "oracle": "comparator==null || criterion==null;",
        "javadocTag": "@throws NullPointerException if comparator or criterion is null"
    },
    {
        "oracle": "(pair==null) == false;",
        "javadocTag": "@param pair the pair to copy, must not be null"
    },
    {
        "oracle": "entry==null;",
        "javadocTag": "@throws NullPointerException if the entry is null"
    },
    {
        "oracle": "(entry==null) == false;",
        "javadocTag": "@param entry the entry to copy, must not be null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "queue==null;",
        "javadocTag": "@throws NullPointerException if queue is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fromIndexInclusive the index to start from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param toIndexExclusive the index to end at"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the new sublist"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node node to update"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value new value of the node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return newly created node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value of the new node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new node containing the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node node to insert before"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value of the newly added node"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if <code>node</code> is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node node to insert after"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value of the newly added node"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if <code>node</code> is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeToInsert new node to insert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param insertBeforeNode node to insert before"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if either node is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if <code>node</code> is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index, starting from 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endMarkerAllowed whether or not the end marker can be returned if\nstartIndex is set to the list's size"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the node at the given index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param subList the sublist to get an iterator for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterator on the given sublist"
    },
    {
        "oracle": ";",
        "javadocTag": "@param subList the sublist to get an iterator for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fromIndex the index to start from, relative to the sublist"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new list iterator on the given sublist"
    },
    {
        "oracle": ";",
        "javadocTag": "@param outputStream the stream to write the object to"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if anything goes wrong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputStream the stream to read the object from"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if any error occurs while reading from the stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if a class read from the stream can not be loaded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterator that does <b>not</b> support concurrent modification"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new cursor iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fromIndex the index to start from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new cursor iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new cursor iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fromIndex the index to start from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new cursor iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is out of range\n     (index &lt; 0 || index &gt; size())."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node node to update"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value new value of the node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nodeToInsert new node to insert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param insertBeforeNode node to insert before"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if either node is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if <code>node</code> is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cursor the cursor to register"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cursor the cursor to deregister"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node that was changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node that was changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node the node that was changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param subList the sublist to get an iterator for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fromIndex the index to start from, relative to the sublist"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list iterator for the sublist"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the elements in the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new predicated list"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the list contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated list"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the list contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first key currently in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the last key currently in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to search for next from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next key, null if no match or at end"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to search for previous from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous key, null if no match or at start"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed Queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed Queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable Queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs while writing to the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs while reading from the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if the class of a serialized object can not be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param queue the queue to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if queue is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs while writing to the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if an I/O error occurs while writing to the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException if the class of a serialized object can not be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@return this queue's size"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this queue is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@return always returns {@code false}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the capacity limit has been reached, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum number of elements the collection can hold"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the position of the element in the queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the element at position {@code index}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the requested position is outside the range [0, size)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code n!}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the size of the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the number of non-empty subsets"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code S(n,k)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if some overflow happens, typically for n exceeding 25 and\nk between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Size of the set from which subsets are selected."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Size of the subsets to be enumerated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an {@link Iterator iterator} over the k-sets in n."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Size of the set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Size of the subsets to be counted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e The {@link IterationEvent} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e The {@link IterationEvent} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e The {@link IterationEvent} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e The {@link IterationEvent} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param work data array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first element of the slice"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end index after the last element of the slice"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the pivot element chosen between the\nfirst and the last element of the array slice"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException when indices exceeds range"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The index corresponding to a simple average of\nthe first and the last element indices of the array slice"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException when indices exceeds range"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code this} number is infinite"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if {@code this} is {@code NaN}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return base 10 logarithm of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the primitive {@code double} value of the object to be created"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o the object that gets transformed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a double primitive representation of the Object o."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if Object <code>o</code>\ncannot successfully be transformed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the rounding mode."
    },
    {
        "oracle": ";",
        "javadocTag": "@param roundingMode rounding mode for decimal divisions"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the scale"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale scale for division operations"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if {@code a} is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if {@code this} is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@return double value corresponding to the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return BigDecimal value corresponding to the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val value of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val value of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unscaledVal unscaled value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale scale to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unscaledVal unscaled value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale scale to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mc to used"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val value of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mc context to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in character representation of the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in character representation of the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset offset of the first character to analyze"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len length of the array slice to analyze"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in character representation of the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset offset of the first character to analyze"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len length of the array slice to analyze"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mc context to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param in character representation of the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mc context to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val value of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val value of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mc context to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val value of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val value of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mc context to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val value of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val value of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mc context to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val character representation of the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param val character representation of the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mc context to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x an addend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y an addend"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result can not be represented\nas an {@code int}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an addend"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b an addend"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result can not be represented as an long"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the size of the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the size of the subsets to be counted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code n choose k}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result is too large to be\nrepresented by a long integer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the size of the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the size of the subsets to be counted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code n choose k}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result is too large to be\nrepresented by a long integer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the size of the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the size of the subsets to be counted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code n choose k}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result is too large to be\nrepresented by a long integer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code n!}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result is too large to be represented\nby a {@code long}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code n!}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code n!}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q Number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the greatest common divisor (never negative)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code int} value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Positive number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Positive number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the greatest common divisor."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated multiset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized bag backed by that bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of that bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a predicated bag backed by the given bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a transformed bag backed by the given bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Bag that complies to the Collection contract"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a synchronized bag backed by that bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable view of that bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a predicated bag backed by the given bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a transformed bag backed by the given bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key used in the search"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link SortedMap} view of this {@link Trie} with all elements whose\n  key is prefixed by the search key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to remove from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param item the item to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the mapping was removed, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the map is unmodifiable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the key or value is of an invalid type"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the key or value is null and null is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of key-collection mappings in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the map contains the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the value is of an invalid type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to store against"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to add to the collection at the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return typically the value added if the map changed and null if the map did not change"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the map is unmodifiable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the key or value is of an invalid type"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the key or value is null and null is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the key or value is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a collection view of the values contained in this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator Iterator to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if I've already started iterating"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Iterator count"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if IteratorChain cannot be modified, false if it can"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if elements remain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Object from the current Iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.util.NoSuchElementException if all the Iterators are\nexhausted"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the remove operator is not\nsupported by the underlying Iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the next method has not yet been called,\nor the remove method has already been called after the last call to the\nnext method."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if iterators collection doesn't contain an\niterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link ResettableListIterator}<E>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link ListIterator}<E>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new unmodifiable ordered map iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this iterator has remaining elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next interleaved element"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if no child iterator has any more elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if there is no last returned element, or if\n  the last returned element has already been removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first child iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second child iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first child iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second child iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the third child iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterators the array of iterators"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any iterator is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new unmodifiable iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if iteration has started"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the Iterator to replace"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator Iterator to place at the given index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if index &lt; 0 or index &gt; size()"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if iteration has started"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unmodifiable list of iterators added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@link Comparator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comp the {@link Comparator} to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if iteration has started"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this iterator has remaining elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next ordered element"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if no child iterator has any more elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if there is no last returned element, or if\nthe last returned element has already been removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the iterator that returned the last element"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if there is no last returned element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code false} iff there was no value to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if iteration started"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if no comparator is set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initIterCapacity the initial capacity for the internal list of\n  child iterators"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first child ordered iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second child ordered iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterators the array of iterators"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterators the collection of iterators"
    },
    {
        "oracle": "divisor==null;",
        "javadocTag": "@throws NullArgumentException if {@code divisor} is {@code null}."
    },
    {
        "oracle": "(x==null) == false;",
        "javadocTag": "@param x First value (cannot be {@code null})."
    },
    {
        "oracle": "(y==null) == false;",
        "javadocTag": "@param y Second value (cannot be {@code null})."
    },
    {
        "oracle": "(x==null) == false;",
        "javadocTag": "@param x First value (cannot be {@code null})."
    },
    {
        "oracle": "(y==null) == false;",
        "javadocTag": "@param y Second value (cannot be {@code null})."
    },
    {
        "oracle": "(x==null) == false;",
        "javadocTag": "@param x First value (cannot be {@code null})."
    },
    {
        "oracle": "(y==null) == false;",
        "javadocTag": "@param y Second value (cannot be {@code null})."
    },
    {
        "oracle": "(x==null) == false;",
        "javadocTag": "@param x First value (cannot be {@code null})."
    },
    {
        "oracle": "(y==null) == false;",
        "javadocTag": "@param y Second value (cannot be {@code null})."
    },
    {
        "oracle": "factor==null;",
        "javadocTag": "@throws NullArgumentException if {@code factor} is {@code null}."
    },
    {
        "oracle": "subtrahend==null;",
        "javadocTag": "@throws NullArgumentException if {@code subtrahend} is {@code null}."
    },
    {
        "oracle": "x==null;",
        "javadocTag": "@throws NullArgumentException if x is {@code null}."
    },
    {
        "oracle": "n<=0;",
        "javadocTag": "@throws NotPositiveException if {@code n <= 0}."
    },
    {
        "oracle": "x.length==0 || y.length==0 || f.length==0 || dFdX.length==0 || dFdY.length==0 || d2FdXdY.length==0;",
        "javadocTag": "@throws NoDataException if any of the arrays has zero length."
    },
    {
        "oracle": "x.length==0 || y.length==0 || f.length==0 || dFdX.length==0 || dFdY.length==0 || d2FdXdY.length==0;",
        "javadocTag": "@throws NoDataException if any of the arrays has zero length."
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws NullArgumentException if values is null"
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if d is null"
    },
    {
        "oracle": "value==null;",
        "javadocTag": "@throws NullArgumentException if value is null"
    },
    {
        "oracle": "value==null;",
        "javadocTag": "@throws NullArgumentException if value is null"
    },
    {
        "oracle": "end<start;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}."
    },
    {
        "oracle": "end<start;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}."
    },
    {
        "oracle": "end<start;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}."
    },
    {
        "oracle": "end<start;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code end < start}."
    },
    {
        "oracle": "lower>upper;",
        "javadocTag": "@throws NumberIsTooLargeException if lower is greater than upper"
    },
    {
        "oracle": "order==1;",
        "javadocTag": "@throws NumberIsTooSmallException if order is 1 or less"
    },
    {
        "oracle": "order==1;",
        "javadocTag": "@throws IllegalArgumentException if order is 1 or less"
    },
    {
        "oracle": "true ? methodResultID.equals(highOrder) : true;",
        "javadocTag": "@return updated high order derivatives"
    },
    {
        "oracle": "this.getNorm()==null;",
        "javadocTag": "@throws MathArithmeticException if the norm of the instance is null"
    },
    {
        "oracle": "true ? methodResultID==this : true;",
        "javadocTag": "@return the dot product this.v"
    },
    {
        "oracle": "true ? methodResultID==this : true;",
        "javadocTag": "@return the dot product this.v"
    },
    {
        "oracle": "steps==null;",
        "javadocTag": "@throws NullArgumentException if {@code steps} is {@code null}."
    },
    {
        "oracle": "steps.length==0;",
        "javadocTag": "@throws ZeroException if one of the steps is zero."
    },
    {
        "oracle": "true ? methodResultID.equals(highOrder) : true;",
        "javadocTag": "@return updated high order derivatives"
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "(rowDimension>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if row or column dimension is not positive."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "v.length==0;",
        "javadocTag": "@throws NoDataException if v is empty"
    },
    {
        "oracle": "bytes!=null;",
        "javadocTag": "@param bytes the non-null byte array in which to put the\nrandom bytes"
    },
    {
        "oracle": "(n>0) == false;",
        "javadocTag": "@throws IllegalArgumentException if n is not positive."
    },
    {
        "oracle": "n>0;",
        "javadocTag": "@param n the bound on the random number to be returned.  Must be\npositive."
    },
    {
        "oracle": "(degree>0) == false;",
        "javadocTag": "@throws NotPositiveException if degree is not positive"
    },
    {
        "oracle": "(xDegree>0) == false || (yDegree>0) == false;",
        "javadocTag": "@throws NotPositiveException if degrees are not positive"
    },
    {
        "oracle": "maxIter<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code maxIter <= 0}."
    },
    {
        "oracle": "true ? methodResultID==0 : true;",
        "javadocTag": "@return the size of the boundary (this is 0 in 1D, a length in\n2D, an area in 3D ...)"
    },
    {
        "oracle": "num<2;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code num < 2}."
    },
    {
        "oracle": "xArray.length<2;",
        "javadocTag": "@throws MathIllegalArgumentException if the array length is less than 2"
    },
    {
        "oracle": "generator==null;",
        "javadocTag": "@throws NullArgumentException if generator is null"
    },
    {
        "oracle": "alpha>2 || beta>1 || beta<-1 || beta>1;",
        "javadocTag": "@throws OutOfRangeException if {@code alpha <= 0} or {@code alpha > 2}\nor {@code beta < -1} or {@code beta > 1}"
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "true ? methodResultID==this : true;",
        "javadocTag": "@return for convenience, return {@code this}"
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}"
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}"
    },
    {
        "oracle": "true ? methodResultID==this : true;",
        "javadocTag": "@return for convenience, return {@code this}"
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "true ? methodResultID==this : true;",
        "javadocTag": "@return for convenience, return {@code this}"
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "d==null;",
        "javadocTag": "@throws NullArgumentException if {@code d} is {@code null}."
    },
    {
        "oracle": "true ? methodResultID==this : true;",
        "javadocTag": "@return for convenience, return {@code this}"
    },
    {
        "oracle": "true ? methodResultID==this : true;",
        "javadocTag": "@return for convenience, return {@code this}"
    },
    {
        "oracle": "(minimalIterationCount>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive"
    },
    {
        "oracle": "(minimalIterationCount>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if minimal number of iterations\nis not strictly positive"
    },
    {
        "oracle": "f==null;",
        "javadocTag": "@throws NullArgumentException if {@code f} is {@code null}."
    },
    {
        "oracle": "maxEval>=maxEval;",
        "javadocTag": "@throws MathIllegalArgumentException if {@code min >= max}."
    },
    {
        "oracle": "nans==1;",
        "javadocTag": "@param nans code of the value, must be one of {@link #INFINITE},\n{@link #SNAN},  {@link #QNAN}"
    },
    {
        "oracle": "code==1;",
        "javadocTag": "@param code code of the value, must be one of {@link #INFINITE},\n{@link #SNAN},  {@link #QNAN}"
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the array index\n parameters are not valid"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "points==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the data points are null or the number\n    of clusters is larger than the number of data points"
    },
    {
        "oracle": "points==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the data points are null or the number\n    of clusters is larger than the number of data points"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if values is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the array is null or the indices are not valid"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if values is null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws MathIllegalArgumentException if values is null"
    },
    {
        "oracle": "(original instanceof BinaryChromosome) == false;",
        "javadocTag": "@throws MathIllegalArgumentException if <code>original</code> is not an instance of {@link BinaryChromosome}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "f==null || target==null || weights==null || startPoint==null;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NullArgumentException if\nany argument is {@code null}."
    },
    {
        "oracle": "lower<=upper;",
        "javadocTag": "@param lower lower bound of the interval, must be lesser or equal\nto {@code upper} (may be {@code Double.NEGATIVE_INFINITY})"
    },
    {
        "oracle": "upper>=lower;",
        "javadocTag": "@param upper upper bound of the interval, must be greater or equal\nto {@code lower} (may be {@code Double.POSITIVE_INFINITY})"
    },
    {
        "oracle": "lower<=upper;",
        "javadocTag": "@param lower lower bound of the interval, must be lesser or equal\nto {@code upper} (may be {@code Double.NEGATIVE_INFINITY})"
    },
    {
        "oracle": "upper>=lower;",
        "javadocTag": "@param upper upper bound of the interval, must be greater or equal\nto {@code lower} (may be {@code Double.POSITIVE_INFINITY})"
    },
    {
        "oracle": "(first instanceof AbstractListChromosome) == false || (second instanceof AbstractListChromosome) == false;",
        "javadocTag": "@throws MathIllegalArgumentException if the chromosomes are not an instance of {@link AbstractListChromosome}"
    },
    {
        "oracle": "v.length==3;",
        "javadocTag": "@throws DimensionMismatchException if the array length is not 3."
    },
    {
        "oracle": "this.getNorm()==1 ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return {@code true} if the norm is 1 within the given tolerance,\n{@code false} otherwise"
    },
    {
        "oracle": "steps.length==0;",
        "javadocTag": "@throws IllegalArgumentException if one of the steps is zero."
    },
    {
        "oracle": "variablesToInclude==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the variablesToInclude array is null or zero length"
    },
    {
        "oracle": "noIntercept==true;",
        "javadocTag": "@param noIntercept true means the model is to be estimated without an intercept term"
    },
    {
        "oracle": "data==null;",
        "javadocTag": "@throws NullArgumentException if the data array is null"
    },
    {
        "oracle": "nobs<nvars;",
        "javadocTag": "@throws InsufficientDataException if <code>nobs</code> is less than\n<code>nvars + 1</code>"
    },
    {
        "oracle": "y==null;",
        "javadocTag": "@throws NullArgumentException if y is null"
    },
    {
        "oracle": "y.length==0;",
        "javadocTag": "@throws NoDataException if y is empty"
    },
    {
        "oracle": "x==null;",
        "javadocTag": "@throws NullArgumentException if x is null"
    },
    {
        "oracle": "x.length==0;",
        "javadocTag": "@throws NoDataException if x is empty"
    },
    {
        "oracle": "x==null || y==null;",
        "javadocTag": "@throws NullArgumentException if {@code x} or {@code y} is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f the integrand function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower the min bound for the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper the upper bound for the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the root."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of evaluations\nis exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the maximum iteration count is exceeded\nor the integrator detects convergence problems otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy relative accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy absolute accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimalIterationCount minimum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximalIterationCount maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if maximal number of iterations\nis lesser than or equal to the minimal number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy relative accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy absolute accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimalIterationCount minimum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximalIterationCount maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if maximal number of iterations\nis lesser than or equal to the minimal number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the accuracy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the accuracy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the actual min limit"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the actual upper limit"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f the integrand function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param min the lower bound for the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max the upper bound for the interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of integral"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximum number of function\nevaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the maximum iteration count is exceeded\nor the integrator detects convergence problems otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of function evaluations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param baseIntegrator integrator holding integration parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the stage of 1/2 refinement, n = 0 is no refinement"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of n-th stage integral"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of evaluations\nis exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy relative accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy absolute accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimalIterationCount minimum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if maximal number of iterations\nis lesser than or equal to the minimal number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimalIterationCount minimum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if maximal number of iterations\nis lesser than or equal to the minimal number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Abscissa for which the function value should be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Ordinate for which the function value should be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the derivative function"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the derivative function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the point for which the function value should be computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point at which the objective function must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective function value at specified point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Maximum absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Maximum relative error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Maximum absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param functionValueAccuracy Maximum function value error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point at which the objective function must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective function value and derivative at specified point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Maximum absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Maximum relative error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Maximum absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param functionValueAccuracy Maximum function value error."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of evaluations of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the function value accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to solve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the arguments do not satisfy the requirements specified by the solver."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if\nthe allowed number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to solve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startValue Start value to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the arguments do not satisfy the requirements specified by the solver."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if\nthe allowed number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to solve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startValue Start value to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.MathIllegalArgumentException if the arguments do not satisfy the requirements specified by the solver."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if\nthe allowed number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param functionValueAccuracy Maximum function value error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to solve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowedSolution The kind of solutions that the root-finding algorithm may\naccept as solutions."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.MathIllegalArgumentException if the arguments do not satisfy the requirements specified by the solver."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if\nthe allowed number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to solve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param baseGraph the graph object to base building on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param baseGraph the graph object to base building on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source source vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param target target vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight weight of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this builder object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param baseGraph the graph object to base building on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source source vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param target target vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight weight of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this builder object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param baseGraph the graph object to base building on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the {@code this} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices the vertices to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source source vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param target target vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices the vertices to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source source vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param target target vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the built graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the built unmodifiable graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param baseGraph the graph object to base building on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param baseGraph the graph object to base building on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param baseGraph the graph object to base building on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param base the backing graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the backing graph on which an unmodifiable graph is to be\ncreated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A list of the vertices that define the path."
    },
    {
        "oracle": ";",
        "javadocTag": "@param simpleGraph The simple graph where the path is."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices A list of vertices that make up the path."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the vertices are not in the path or\nif they do not define a path in the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the edge factory of the new graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param base the base (backing) graph on which the subgraph will be based."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexSubset vertices to include in the subgraph. If <code>\nnull</code> then all vertices are included."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeSubset edges to in include in the subgraph. If <code>\nnull</code> then all the edges whose vertices found in the graph are\nincluded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the edge factory of the new graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph for which the edge to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertex source vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex target vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight weight of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The newly created edge if added to the graph, otherwise <code>\nnull</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph for which the specified edge to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertex source vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex target vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The newly created edge if added to the graph, otherwise <code>\nnull</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetGraph the graph for which the specified edge to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceGraph the graph in which the specified edge is already\npresent"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge edge to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph for which the specified edge to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceVertex source vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetVertex target vertex of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weight weight of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The newly created edge if added to the graph, otherwise <code>\nnull</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@param destination the graph to which vertices and edges are added."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the graph used as source for vertices and edges to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if and only if the destination graph has been\nchanged as a result of this operation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param destination the graph to which vertices and edges are added."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the graph used as source for vertices and edges to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@param destination the graph to which edges are to be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the graph used as a source for edges to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edges the edges to be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>true</tt> if this graph changed as a result of the call"
    },
    {
        "oracle": ";",
        "javadocTag": "@param destination the graph to which edges are to be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertices the vertices to be added to the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>true</tt> if graph changed as a result of the call"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph to look for neighbors in."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex to get the neighbors of."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of the vertices that are the neighbors of the specified\nvertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph to look for predecessors in."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex to get the predecessors of."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of the vertices that are the direct predecessors of the\nspecified vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph to look for successors in."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex to get the successors of."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of the vertices that are the direct successors of the\nspecified vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the graph for which an undirected view is to be returned."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an undirected view of the specified graph, if it is directed, or\nor the specified graph itself if it is already undirected."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the graph is neither DirectedGraph\nnor UndirectedGraph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g graph containing e and v"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e edge in g"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vertex in g"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff e is incident on v"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g graph containing e and v"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e edge in g"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vertex in g"
    },
    {
        "oracle": ";",
        "javadocTag": "@return vertex opposite to v across e"
    },
    {
        "oracle": ";",
        "javadocTag": "@param path path of interest"
    },
    {
        "oracle": ";",
        "javadocTag": "@return corresponding vertex list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex vertex whose degree is to be calculated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the degree of the specified vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex for which the list of incoming edges to be\nreturned."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set of all edges incoming into the specified vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex vertex whose degree is to be calculated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the degree of the specified vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex for which the list of outgoing edges to be\nreturned."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a set of all edges outgoing from the specified vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e edge on which to set weight"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equations complete set of differential equations to integrate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialState initial state (time, primary and secondary state vectors)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t target time for the integration\n(can be set to a value smaller than <code>t0</code> for backward integration)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimension do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if integration step is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the location of an event cannot be bracketed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h step size to use for scaling"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t first steps times"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y first steps states"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot first steps derivatives"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Nordieck vector at first step (h<sup>2</sup>/2 y''<sub>n</sub>,\nh<sup>3</sup>/6 y'''<sub>n</sub> ... h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub>)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return minimal reduction factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minReduction minimal reduction factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximal growth factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxGrowth maximal growth factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return safety factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param safety safety factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of steps of the multistep method (excluding the one being computed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newStepSize new step size to use in the scaled and Nordsieck arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@param error normalized error of the current step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return grow/shrink factor for next step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the multistep method\n(excluding the one being computed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which the time and state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nSteps number of steps of the multistep method\n(excluding the one being computed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param order order of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecAbsoluteTolerance allowed absolute error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vecRelativeTolerance allowed relative error"
    },
    {
        "oracle": ";",
        "javadocTag": "@return name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler handler for the accepted steps"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable collection of the added events handlers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler event handler"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxCheckInterval maximal time interval between switching\nfunction checks (this interval prevents missing sign changes in\ncase the integration steps becomes very large)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convergence convergence threshold in the event time search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterationCount upper limit of the iteration count in\nthe event time search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler event handler"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxCheckInterval maximal time interval between switching\nfunction checks (this interval prevents missing sign changes in\ncase the integration steps becomes very large)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convergence convergence threshold in the event time search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterationCount upper limit of the iteration count in\nthe event time search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param solver The root-finding algorithm to use to detect the state\nevents."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable collection of the added events handlers"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current value of the step start time t<sub>i</sub>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return current signed value of the stepsize"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEvaluations maximal number of function evaluations (negative\nvalues are silently converted to maximal integer value, thus representing\nalmost unlimited evaluations)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximal number of functions evaluations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of evaluations of the differential equations function"
    },
    {
        "oracle": ";",
        "javadocTag": "@return parameterName parameter name"
    },
    {
        "oracle": ";",
        "javadocTag": "@return hP parameter step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hParam parameter step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param parameterName parameter name"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hP parameter step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param model model to add at the end of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the model to append is not\ncompatible with the instance (dimension of the state vector,\npropagation direction, hole between the dates)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimensions of the states or\nthe number of secondary states do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded\nduring step finalization"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d1 first dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d2 second dimansion"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if dimensions do not match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator for the last accepted step."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded\nduring step finalization"
    },
    {
        "oracle": ";",
        "javadocTag": "@return initial integration time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return final integration time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time time of the interpolated point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return state at interpolated time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time point to locate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interval step interval"
    },
    {
        "oracle": ";",
        "javadocTag": "@return -1 if the double is before the interval, 0 if it is in\nthe interval, and +1 if it is after the interval, according to\nthe interval direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@return dimension of the problem"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <I>time</I> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot placeholder array where to put the time derivative of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equations second order equations set to convert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <I>time</I> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the main state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot array containing the current value of the time derivative\nof the main state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param paramName name of the parameter to consider"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dFdP placeholder array where to put the Jacobian matrix of the\nODE with respect to the parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimensions do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnknownParameterException if the parameter is not supported"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equations differential equations to integrate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 initial time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 initial value of the state vector at t0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot0 initial value of the first derivative of the state\nvector at t0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t target time for the integration\n(can be set to a value smaller thant <code>t0</code> for backward integration)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y placeholder where to put the state vector at each\nsuccessful step (and hence at the end of integration), can be the\nsame object as y0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yDot placeholder where to put the first derivative of\nthe state vector at time t, can be the same object as yDot0"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if the integrator cannot perform integration"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if integration parameters are wrong (typically\ntoo small integration span)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return field to which state vector elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param eqn equations to integrate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 start value of the independent <i>time</i> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 array containing the start value of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t target time for the integration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xMax high bound along the x direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yMin low bound along the y direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yMax high bound along the y direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param zMin low bound along the z direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param zMax high bound along the z direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tree inside/outside BSP tree representing the region"
    },
    {
        "oracle": ";",
        "javadocTag": "@param boundary collection of boundary elements, as a\ncollection of {@link SubHyperplane SubHyperplane} objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xMin low bound along the x direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xMax high bound along the x direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yMin low bound along the y direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param yMax high bound along the y direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param zMin low bound along the z direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param zMax high bound along the z direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the instance (in fact, its name)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return axis of the first rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return axis of the second rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return axis of the second rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name name of the rotation order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a1 axis of the first rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a2 axis of the second rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a3 axis of the third rotation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return abscissa of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ordinate of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return height of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return vector coordinates"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a constant vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return L<sub>1</sub> norm for the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Euclidean norm for the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return square of the Euclidean norm for the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return L<sub>&infin;</sub> norm for the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return azimuth (&alpha;) of the vector, between -&pi; and +&pi;"
    },
    {
        "oracle": ";",
        "javadocTag": "@return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor scale factor to apply to v before adding it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor scale factor to apply to v before adding it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor scale factor to apply to v before adding it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor scale factor to apply to v before adding it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to subtract"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to subtract"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor scale factor to apply to v before subtracting it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to subtract"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor scale factor to apply to v before subtracting it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to subtract"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor scale factor to apply to v before subtracting it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to subtract"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor scale factor to apply to v before subtracting it"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to subtract"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new normalized vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the norm is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new normalized vector orthogonal to the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return angular separation between v1 and v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if either vector has a null norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return angular separation between v1 and v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if either vector has a null norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return angular separation between v1 and v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if either vector has a null norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector which is opposite to the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a scalar"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a scalar"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if any coordinate of this vector is NaN; false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if any coordinate of this vector is infinite and none are NaN;\nfalse otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Object to test for equality to this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if two 3D vector objects are equal, false if\n        object is null, not an instance of Vector3D, or\n        not equal to this Vector3D instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code value for this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v other vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cross product this ^ v as a new Vector3D"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v other vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cross product this ^ v as a new Vector3D"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection to search, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first element of the collection which matches the predicate or null if none could be found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the closure type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closure the closure to perform, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object the {@link Iterator} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the closure type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closure the closure to perform, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the closure type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closure the closure to perform, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the last element in the collection, or null if either collection or closure is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object the {@link Collection} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the closure type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closure the closure to perform, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the last element in the collection, or null if either iterator or closure is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use as a filter, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the collection is modified by this call, false otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use as a filter, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the collection is modified by this call, false otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the type of object the {@link Collection} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the {@link Collection} to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to perform, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the {@link Iterable} to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of matches for the predicate in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the {@link Iterable} to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if at least one element of the collection matches the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the {@link Iterable} to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if every element of the collection matches the predicate or if the\ncollection is empty, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the elements matching the predicate (new list)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <R> the type of the output {@link Collection}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputCollection the collection to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <R> the type of the output {@link Collection}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputCollection the collection to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the elements <b>not</b> matching the predicate (new list)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the type of object the {@link Iterable} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <R> the type of the output {@link Collection}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputCollection the collection to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the type of object in the input collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the type of object in the output collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed result (new list)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the type of object in the input collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the type of object in the output collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputIterator the iterator to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed result (new list)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the type of object in the input collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the type of object in the output collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <R> the type of the output collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputCollection the collection to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the output collection with the transformed input added"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the type of object in the input collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the type of object in the output collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <R> the type of the output collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param inputIterator the iterator to get the input from, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to use, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the outputCollection with the transformed input added"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object the {@link Collection} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to add, if null it will not be added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the collection changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the type of object the {@link Collection} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a boolean indicating whether the collection has changed or not."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the type of object the {@link Collection} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a boolean indicating whether the collection has changed or not."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the type of object the {@link Collection} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the collections was changed, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <C> the type of object the {@link Collection} contains"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the collection was changed, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to get a value from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to get"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object in the {@link Iterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param z The depth."
    },
    {
        "oracle": ";",
        "javadocTag": "@param box The spring box."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param box The spring box."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z The depth."
    },
    {
        "oracle": ";",
        "javadocTag": "@param is3D If true the simulation dimensions count is 3 else 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@param is3D If true the simulation dimensions count is 3 else 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@param randomNumberGenerator The random number generator to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the vector length."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the vector length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scalar The multiplier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graph to control."
    },
    {
        "oracle": ";",
        "javadocTag": "@param view The view to control."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graph to control."
    },
    {
        "oracle": ";",
        "javadocTag": "@param view The view to control."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event The event that generated the key."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event The event that generated the key."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event The event that generated the key."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The estimated frame-per-second measure of the last frame."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The last frame time in seconds."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The number of frames measure."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The average number of frames per second."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The time used by a frame in average."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The coordinate at parametric position `t` on the curve."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The point at parametric position `t` on the curve."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The point at parametric position `t` on the curve."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the given reference to `result`."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The derivative at parametric position `t` on the curve."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The derivative point at parametric position `t` on the curve."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the given reference to `result`."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A vector perpendicular to the curve at position `t`."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the given reference to `result`."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A vector perpendicular to the curve at position `t`."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The new identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graphic graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param ppipe The source of events from another thread or machine (null if\n           source != null)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source The source of events from this thread (null if ppipe != null)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The new proxy pipe."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The new viewer pipe."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The view identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A view or null if not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The default view or null if no default view has been installed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param openInAFrame It true, the view is placed in a frame, else the view is only\n           created and you must embed it yourself in your application."
    },
    {
        "oracle": ";",
        "javadocTag": "@param view The view to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The old view that was at the given identifier, if any, else null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The new view identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param renderer The renderer to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The created view."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The new view identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param renderer The renderer to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param openInAFrame If true the view is open in a frame, else the returned view is\n           a JPanel that can be inserted in a GUI."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The created view."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The view identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param policy The close frame policy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param layoutAlgorithm The algorithm to use (see Layouts.newLayoutAlgorithm() for the\n           default algorithm)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source The source of graph events."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph THe graph to draw."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graph to render."
    },
    {
        "oracle": ";",
        "javadocTag": "@param threadingModel The threading model."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a view id"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Camera instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The first node or sprite at the given coordinates or null if\nnothing found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x1 The rectangle lowest point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y1 The rectangle lowest point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x2 The rectangle highest point abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y2 The rectangle highest point ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The set of sprites and nodes in the given rectangle."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graphic graph to represent."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graphChanged True if the graph changed since the last call to this method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graphic graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x1 The selection start abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y1 The selection start ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The new end selection abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The new end selection ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x2 The selection stop abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y2 The selection stop ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param frozen If true the element cannot be moved automatically."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The requested position abscissa in pixels."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The requested position ordinate in pixels."
    },
    {
        "oracle": ";",
        "javadocTag": "@param manager The new manager, or null to set the default manager."
    },
    {
        "oracle": ";",
        "javadocTag": "@param manager The new manager, or null to set the default manager"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the listener"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the listener"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the listener"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the listener"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the listener"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the listener"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The view centre."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The new abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The new ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z The new depth."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A real for which value 1 means the graph is fully visible and\n        uses the whole view port."
    },
    {
        "oracle": ";",
        "javadocTag": "@param percent Percent of the graph visible."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key to be searched for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map place to store the mapping from each key to its corresponding\n    values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the elements that the multiset should contain"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code elements} is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator that will be used to sort this multiset. A null value indicates that\n         the elements' <i>natural ordering</i> should be used."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a view of this immutable list in reverse order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedKeys the expected number of distinct keys"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expectedValuesPerKey the expected average number of values per key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param multimap the multimap whose contents are copied to this multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new {@code HashSet} containing a collection of values for one key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param distinctElements the expected number of distinct elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the elements that the multiset should contain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the elements that the multiset should contain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to look for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the nonnegative number of occurrences of the element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param occurrences the number of occurrences to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous count of the element before the operation; possibly zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@param occurrences the number of occurrences of {@code element} to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the removal was possible (including if {@code occurrences} is zero)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the count of {@code element} in the multiset before this call"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the change was successful. This usually indicates\n    that the multiset has been modified, but not always: in the case that\n    {@code expectedOldCount == newCount}, the method will return {@code true} if\n    the condition was met."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if duplicate keys are provided"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if duplicate keys are provided"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if duplicate keys are provided"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if duplicate keys are provided"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key or value in {@code map} is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key, value, or entry is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if two entries have the same key"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key or value in {@code multimap} is\n        null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key, value, or entry is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key or value in {@code multimap} is\n        null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key, value, or entry is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the given value is already bound to a\n    different key in this bimap. The bimap will remain unmodified in this\n    event. To avoid this exception, call {@link #forcePut} instead."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key with which the specified value is to be associated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to be associated with the specified key"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value which was previously associated with the key, which may\n    be {@code null}, or {@code null} if there was no previous entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if an attempt to {@code put} any\n    entry fails. Note that some map entries may have been added to the\n    bimap before the exception was thrown."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the inverse view of this bimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the elements are not mutually comparable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the elements are not mutually comparable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the method increased the size of the multimap, or\n    {@code false} if the multimap already contained the key-value pair and\n    doesn't allow duplicates"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the multimap changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the multimap changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the multimap changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the collection of replaced values, or an empty collection if no\n    values were previously associated with the key. The collection\n    <i>may</i> be modifiable, but updating it will have no effect on the\n    multimap."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the values that were removed (possibly empty). The returned\n    collection <i>may</i> be modifiable, but updating it will have no\n    effect on the multimap."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the elements are not mutually comparable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the elements are not mutually comparable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the elements are not mutually comparable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any of the first {@code n} elements of {@code contents} is\n         null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if an initial capacity was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the maximum size of the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if a maximum size was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if a concurrency level was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the key strength was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the value strength was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the value strength was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param duration the length of time after an entry is created that it should be automatically\n    removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the unit that {@code duration} is expressed in"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the time to live or time to idle was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param duration the length of time after an entry is last accessed that it should be\n    automatically removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unit the unit that {@code duration} is expressed in"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the time to idle or time to live was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if a removal listener was already set"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a serializable concurrent map having the requested features"
    },
    {
        "oracle": ";",
        "javadocTag": "@param computingFunction the function used to compute new values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a serializable concurrent map having the requested features"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an empty collection of values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to associate with values in the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an empty collection of values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator across map entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map place to store the mapping from each key to its corresponding\n    values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object object whose subscriber methods should be registered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param object object whose subscriber methods should be unregistered."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the object was not previously registered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param event event to post."
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier a brief name for this bus, for logging purposes.  Should\n                   be a valid Java identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return bytes in the string, or null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the String for which to count bytes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c a character"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of bytes used to represent c"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of bytes printed so far"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of bytes written so far"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of characters printed so far"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the string to be printed, or null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the boolean to be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the char to be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the char[] to be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d the double to be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f the float to be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the int to be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the long to be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the string to be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param buf the char[] to be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param buf character array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param off offset from which to start writing characters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len number of characters to write"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the string to be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string to be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param off offset from which to start writing characters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len number of characters to write"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out an output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out an output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@param autoFlush if true, the println() methods will flush the output buffer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out a Writer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out a writer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param autoFlush if true, the println() methods will flush the output buffer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key with which the specified value is to be associated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to be associated with the specified key."
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous value associated with specified key, or <code>null</code>\n       if there was no mapping for key.  A <code>null</code> return can\n       also indicate that the HashMap previously associated\n       <code>null</code> with the specified key."
    },
    {
        "oracle": ";",
        "javadocTag": "@param newCapacity the new capacity, MUST be a power of two;\n       must be greater than current capacity unless current\n       capacity is MAXIMUM_CAPACITY (in which case value\n       is irrelevant)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m mappings to be stored in this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key whose mapping is to be removed from the map."
    },
    {
        "oracle": ";",
        "javadocTag": "@return previous value associated with specified key, or <code>null</code>\n       if there was no mapping for key.  A <code>null</code> return can\n       also indicate that the map previously associated <code>null</code>\n       with the specified key."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity of the\n     <code>WeakIdentityHashMap</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor of the\n     <code>WeakIdentityHashMap</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity of the\n     <code>WeakIdentityHashMap</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t the map whose mappings are to be placed in this map."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iter the iterator to wrap."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args command-line arguments; see documentation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is a problem reading a file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reader where to read the entry from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next entry, or null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is a problem reading a file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param entry the entry whose first line to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first line of entry"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <A> type of first argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <B> type of second argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a pair of the values (a, b)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the first element of the pair"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b the second element of the pair"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the error output from compiling the files"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileNames paths to the files to be compiled as Strings"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is a problem reading a file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filenames the paths of the Java source to be compiled as Strings"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the process that executed the external compile command"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws Error if an empty list of filenames is provided."
    },
    {
        "oracle": ";",
        "javadocTag": "@param fileNames all the files that were attempted to be compiled"
    },
    {
        "oracle": ";",
        "javadocTag": "@param errorString the error string that indicates which files\n  could not be compiled"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sourceFilePath the path to the .java file"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the path to the corresponding .class file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pathName path to check for existence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the file exists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param compiler an array of Strings representing a command that runs a\nJava compiler (it could be the full path name or whatever is used on\nthe commandline), plus any command-line options."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeLimit the maximum permitted compilation time, in msec"
    },
    {
        "oracle": ";",
        "javadocTag": "@param compiler a list of Strings representing a command that runs a\nJava compiler (it could be the full path name or whatever is used on\nthe commandline), plus any command-line options."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeLimit the maximum permitted compilation time, in msec"
    },
    {
        "oracle": ";",
        "javadocTag": "@param compiler a command that runs a Java compiler; for instance, it\ncould be the full path name or whatever is used on the commandline.\nIt may contain command-line arguments, and is split on spaces."
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeLimit the maximum permitted compilation time, in msec"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator of all objects selected."
    },
    {
        "oracle": ";",
        "javadocTag": "@param num_elts the number of elements to select from each bucket"
    },
    {
        "oracle": ";",
        "javadocTag": "@param eq partioner that determines how to partition the objects from\n the iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a String representing the elapsed time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param task the task to be queued on the task list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param responsible name of the responsible party, or null; search for tasks assigned to responsible"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a TaskManger with only those tasks assigned to responsible"
    },
    {
        "oracle": ";",
        "javadocTag": "@param milestone milestone to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return TaskManger with only the tasks in the given milestone"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new TaskManger with only completed tasks"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new TaskManger with only completed tasks"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filenames list of files to read tasks from"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if there is trouble reading a file"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key that is to be mapped to the given\n               <code>value</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to which the given <code>key</code> is to be\n               mapped"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous value to which this key was mapped, or\n         <code>null</code> if if there was no mapping for the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the key whose mapping is to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value to which this key was mapped, or <code>null</code> if\n         there was no mapping for the key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity of the\n                         <code>WeakHashMap</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param loadFactor the load factor of the <code>WeakHashMap</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialCapacity the initial capacity of the\n                         <code>WeakHashMap</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param h the Hasher to use when hashing values for this map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args command-line arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException if a file cannot be read"
    },
    {
        "oracle": ";",
        "javadocTag": "@return array of ranks"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotANumberException if the selected {@link NaNStrategy} is {@code FAILED}\nand a {@link Double#NaN} is encountered in the input data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ranks input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return array with NaN-valued entries removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ranks array to recode"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to replace NaNs with"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ranks array to be searched for NaNs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff ranks contains one or more NaNs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ranks array of ranks"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tiesTrace list of indices where <code>ranks</code> is constant\n-- that is, for any i and j in TiesTrace, <code> ranks[i] == ranks[j]\n</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data array to modify"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tiesTrace list of index values to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ranks array to modify"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nanPositions list of index values to set to <code>Double.NaN</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ranks array to search for <code>NaNs</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of indexes i such that <code>ranks[i] = NaN</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tiesStrategy the TiesStrategy to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nanStrategy the NaNStrategy to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nanStrategy NaNStrategy to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tiesStrategy TiesStrategy to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param randomGenerator source of random data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nanStrategy NaNStrategy to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param randomGenerator source of random data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data array of data to be ranked"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of ranks corresponding to the elements of the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values array of values to sum"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of the values or <code>Double.NaN</code> if the array\nis empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of the squared values or <code>Double.NaN</code> if the\narray is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of the squares of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the product of the values or Double.NaN if the array is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the product of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of the natural logs of the values or Double.NaN if\nthe array is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum of the natural logs of the values or Double.NaN if\nlength = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mean of the values or Double.NaN if the array is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the mean of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the geometric mean of the values or Double.NaN if the array is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the geometric mean of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance of the values or Double.NaN if the array is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean the precomputed mean value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean the precomputed mean value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the variance of the values or Double.NaN if the array is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the population variance of the values or Double.NaN if the array is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the population variance of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean the precomputed mean value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the population variance of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean the precomputed mean value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the population variance of the values or Double.NaN if the array is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum of the values or Double.NaN if the array is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum of the values or Double.NaN if length = 0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the minimum of the values or Double.NaN if the array is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param splitCircle circle splitting the edge in several parts"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list list where to put the sub-edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@return end vertex of the edge ({@code subEnd} if the edge was long enough and really\nadded, {@code subStart} if the edge was too small and therefore ignored)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start start vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end end vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length length of the arc (it can be greater than \\( \\pi \\))"
    },
    {
        "oracle": ";",
        "javadocTag": "@param circle circle supporting the edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sub boundary facet"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reversed if true, the facet has the inside on its plus side"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node node to which the edge belongs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous edge to be continued"
    },
    {
        "oracle": ";",
        "javadocTag": "@return other edge, starting where the previous one ends (they\nhave not been connected yet)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if there is not a single other edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@return boundary edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if there is not a single other edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param root tree root"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance below which points are consider to be identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param theta azimuthal angle \\( \\theta \\) in the x-y plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param phi polar angle \\( \\varphi \\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return normalized vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if \\( \\varphi \\) is not in the [\\( 0; \\pi \\)] range"
    },
    {
        "oracle": ";",
        "javadocTag": "@return azimuthal angle \\( \\theta \\) in the x-y plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return polar angle \\( \\varphi \\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return normalized vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector which is opposite to the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the angular separation between p1 and p2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Object to test for equality to this"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if two points on the 2-sphere objects are equal, false if\n        object is null, not an instance of S2Point, or\n        not equal to this S2Point instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code value for this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param theta azimuthal angle \\( \\theta \\) in the x-y plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param phi polar angle \\( \\varphi \\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if \\( \\varphi \\) is not in the [\\( 0; \\pi \\)] range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector 3D vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if vector norm is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param theta azimuthal angle \\( \\theta \\) in the x-y plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param phi polar angle \\( \\varphi \\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector corresponding vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param support support points (may be empty)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ball whose boundary lies on the prescribed support points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return center of the ball"
    },
    {
        "oracle": ";",
        "javadocTag": "@return radius of the ball (can be negative if the ball is empty)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return support points used to define the ball"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of support points used to define the ball"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the point is within the ball or at boundary"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@param margin margin to consider"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the point is within the ball enlarged\nby the margin or at boundary"
    },
    {
        "oracle": ";",
        "javadocTag": "@param center center of the ball"
    },
    {
        "oracle": ";",
        "javadocTag": "@param radius radius of the ball"
    },
    {
        "oracle": ";",
        "javadocTag": "@param support support points used to define the ball"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points points to be enclosed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return enclosing ball"
    },
    {
        "oracle": ";",
        "javadocTag": "@param extreme subset of extreme points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nbExtreme number of extreme points to consider"
    },
    {
        "oracle": ";",
        "javadocTag": "@param support points that must belong to the ball support"
    },
    {
        "oracle": ";",
        "javadocTag": "@return enclosing ball, for the extreme subset only"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points points to be enclosed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ball current ball"
    },
    {
        "oracle": ";",
        "javadocTag": "@return farthest point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance below which points are consider to be identical"
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator generator for balls on support"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points points to enclose"
    },
    {
        "oracle": ";",
        "javadocTag": "@return enclosing ball"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current BSP tree node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sub sub-hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if inside leaf nodes have been found on the plus side"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if inside leaf nodes have been found on the minus side"
    },
    {
        "oracle": ";",
        "javadocTag": "@param region region on which to operate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return original point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return projected point, or null if there are no boundary"
    },
    {
        "oracle": ";",
        "javadocTag": "@return offset of the point with respect to the boundary it is projected on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original original point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param projected projected point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset offset of the point with respect to the boundary it is projected on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return projection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node internal node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return regions in the node sub-hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sub sub-hyperplane defining the region"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list to fill up"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point projected point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane hyperplane into which the point was projected"
    },
    {
        "oracle": ";",
        "javadocTag": "@param part boundary part"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if point lies on the boundary part"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point projected point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane hyperplane into which the point was projected"
    },
    {
        "oracle": ";",
        "javadocTag": "@param part boundary part"
    },
    {
        "oracle": ";",
        "javadocTag": "@return projection to a singular point of boundary part (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original original point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newTree inside/outside BSP tree representing the new region"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the built region"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new region, copy of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the instance is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node root node of the sub-tree (<em>must</em> have {@link\nRegion Region} tree semantics, i.e. the leaf nodes must have\n{@code Boolean} attributes representing an inside/outside\nproperty)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the sub-tree starting at the given node is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the instance covers the full space"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node root node of the sub-tree (<em>must</em> have {@link\nRegion Region} tree semantics, i.e. the leaf nodes must have\n{@code Boolean} attributes representing an inside/outside\nproperty)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the sub-tree starting at the given node covers the full space"
    },
    {
        "oracle": ";",
        "javadocTag": "@return dimension of the secondary state parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param complete complete state or derivative array from which\nequation data should be retrieved"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equationData placeholder where to put equation data"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of the equation data does not\nmatch the mapper dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equationData equation data to be inserted into the complete array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param complete placeholder where to put equation data (only the\npart corresponding to the equation will be overwritten)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the dimension of the equation data does not\nmatch the mapper dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param firstIndex index of the first equation element in complete state arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension dimension of the secondary state parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g raw value of function g"
    },
    {
        "oracle": ";",
        "javadocTag": "@return transformed value of function g"
    },
    {
        "oracle": ";",
        "javadocTag": "@return underlying event handler"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximal time interval between events handler checks"
    },
    {
        "oracle": ";",
        "javadocTag": "@return convergence threshold for event localization"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper limit in the iteration count for event localization"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator valid for the current step"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the interpolator throws one because\nthe number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator step interpolator for the proposed step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the event handler triggers an event before\nthe end of the proposed step"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the interpolator throws one because\nthe number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the event cannot be bracketed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return occurrence time of the event triggered in the current\nstep or infinity if no events are triggered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param state state at the end of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the integration should be stopped"
    },
    {
        "oracle": ";",
        "javadocTag": "@param state state at the beginning of the next step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return reset state (may by the same as initial state if only\nderivatives should be reset), or null if nothing is reset"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler event handler"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxCheckInterval maximal time interval between switching\nfunction checks (this interval prevents missing sign changes in\ncase the integration steps becomes very large)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convergence convergence threshold in the event time search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterationCount upper limit of the iteration count in\nthe event time search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param solver Root-finding algorithm to use to detect state events"
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialState initial time, state vector and derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param finalTime target time for the integration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param state current value of the independent <i>time</i> variable, state vector\nand derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value of the g switching function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param state current value of the independent <i>time</i> variable, state vector\nand derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@param increasing if true, the value of the switching function increases\nwhen times increases around event (note that increase is measured with respect\nto physical time, not with respect to integration which may go backward in time)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return indication of what the integrator should do next, this\nvalue must be one of {@link Action#STOP}, {@link Action#RESET_STATE},\n{@link Action#RESET_DERIVATIVES} or {@link Action#CONTINUE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param state current value of the independent <i>time</i> variable, state vector\nand derivative"
    },
    {
        "oracle": ";",
        "javadocTag": "@return reset state (note that it does not include the derivatives, they will\nbe added automatically by the integrator afterwards)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 start value of the independent <i>time</i> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 array containing the start value of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t target time for the integration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <i>time</i> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return value of the g switching function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <i>time</i> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param increasing if true, the value of the switching function increases\nwhen times increases around event (note that increase is measured with respect\nto physical time, not with respect to integration which may go backward in time)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return indication of what the integrator should do next, this\nvalue must be one of {@link Action#STOP}, {@link Action#RESET_STATE},\n{@link Action#RESET_DERIVATIVES} or {@link Action#CONTINUE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <i>time</i> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the state vector\nthe new state should be put in the same array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return underlying event handler"
    },
    {
        "oracle": ";",
        "javadocTag": "@param expandable equation being integrated"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximal time interval between events handler checks"
    },
    {
        "oracle": ";",
        "javadocTag": "@return convergence threshold for event localization"
    },
    {
        "oracle": ";",
        "javadocTag": "@return upper limit in the iteration count for event localization"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator valid for the current step"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the interpolator throws one because\nthe number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator interpolator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return complete state"
    },
    {
        "oracle": ";",
        "javadocTag": "@param interpolator step interpolator for the proposed step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the event handler triggers an event before\nthe end of the proposed step"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the interpolator throws one because\nthe number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the event cannot be bracketed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return occurrence time of the event triggered in the current\nstep or infinity if no events are triggered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t value of the independent <i>time</i> variable at the\nend of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the state vector\nat the end of the step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the integration should be stopped"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t value of the independent <i>time</i> variable at the\nbeginning of the next step"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array were to put the desired state vector at the beginning\nof the next step"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the integrator should reset the derivatives too"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler event handler"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxCheckInterval maximal time interval between switching\nfunction checks (this interval prevents missing sign changes in\ncase the integration steps becomes very large)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param convergence convergence threshold in the event time search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterationCount upper limit of the iteration count in\nthe event time search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param solver Root-finding algorithm to use to detect state events"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rawHandler event handler to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filter filter to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if triggered events are increasing events"
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous transformer active on the previous point with respect\nto integration direction (may be null if no previous point is known)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g current value of the g function"
    },
    {
        "oracle": ";",
        "javadocTag": "@return next transformer transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name parameter name"
    },
    {
        "oracle": ";",
        "javadocTag": "@return parameter value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param name parameter name"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value parameter value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equations differential equations to integrate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 initial time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 initial value of the state vector at t0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t target time for the integration\n(can be set to a value smaller than <code>t0</code> for backward integration)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y placeholder where to put the state vector at each successful\n step (and hence at the end of integration), can be the same object as y0"
    },
    {
        "oracle": ";",
        "javadocTag": "@return stop time, will be the same as target time if integration reached its\ntarget, but may be different if some {@link\norg.apache.commons.math3.ode.events.EventHandler} stops it at some point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if arrays dimension do not match equations settings"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if integration step is too small"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of functions evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoBracketingException if the location of an event cannot be bracketed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return returns the NaNStrategy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the TiesStrategy"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data array to be ranked"
    },
    {
        "oracle": ";",
        "javadocTag": "@param region region to check against the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the instance contains the specified tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a code representing the point status: either {@link\nLocation#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return projection of the point on the boundary"
    },
    {
        "oracle": ";",
        "javadocTag": "@param includeBoundaryAttributes if true, the boundary attributes\nat internal nodes are guaranteed to be included (they may be\nincluded even if the argument is false, if they have already been\ncomputed due to a previous call)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return underlying BSP tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size of the instance (this is a length in 1D, an area\nin 2D, a volume in 3D ...)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an object representing the barycenter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane reference hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return one of {@link Side#PLUS Side.PLUS}, {@link Side#MINUS\nSide.MINUS}, {@link Side#BOTH Side.BOTH} or {@link Side#HYPER\nSide.HYPER} (the latter result can occur only if the tree\ncontains only one cut hyperplane)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sub sub-hyperplane traversing the region"
    },
    {
        "oracle": ";",
        "javadocTag": "@return filtered sub-hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new object representing the transformed point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane hyperplane to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new object representing the transformed hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sub sub-hyperplane to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original hyperplane in which the sub-hyperplane is\ndefined (this is the original hyperplane, the transform has\n<em>not</em> been applied to it)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformed hyperplane in which the sub-hyperplane is\ndefined (this is the transformed hyperplane, the transform\n<em>has</em> been applied to it)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new object representing the transformed sub-hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node node to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator nodes iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return tolerance below which points are considered to belong to hyperplanes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current tree node (it is a leaf node at the beginning\nof the call)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param boundary collection of edges belonging to the cell defined\nby the node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a code representing the point status: either {@link\nRegion.Location#INSIDE}, {@link Region.Location#OUTSIDE} or\n{@link Region.Location#BOUNDARY}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node root node of the region"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a code representing the point status: either {@link\nRegion.Location#INSIDE INSIDE}, {@link Region.Location#OUTSIDE\nOUTSIDE} or {@link Region.Location#BOUNDARY BOUNDARY}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node root node of the region"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a code representing the point status: either {@link\nRegion.Location#INSIDE INSIDE}, {@link Region.Location#OUTSIDE\nOUTSIDE} or {@link Region.Location#BOUNDARY BOUNDARY}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size size of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param barycenter barycenter of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param barycenter barycenter of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current BSP tree node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sub sub-hyperplane traversing the region"
    },
    {
        "oracle": ";",
        "javadocTag": "@return filtered sub-hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transform transform to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new region, resulting from the application of the\ntransform to the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current BSP tree node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transform transform to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map transformed nodes map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical."
    },
    {
        "oracle": ";",
        "javadocTag": "@param tree inside/outside BSP tree representing the region"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical."
    },
    {
        "oracle": ";",
        "javadocTag": "@param boundary collection of boundary elements, as a\ncollection of {@link SubHyperplane SubHyperplane} objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplanes array of bounding hyperplanes (if null, an\nempty region will be built)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points are considered identical."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current BSP tree node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sub sub-hyperplane to characterize"
    },
    {
        "oracle": ";",
        "javadocTag": "@param splitters nodes that did split the current one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sub part of the cut sub-hyperplane known to touch an outside cell"
    },
    {
        "oracle": ";",
        "javadocTag": "@param splitters sub-hyperplanes that did split the current one"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sub part of the cut sub-hyperplane known to touch an inside cell"
    },
    {
        "oracle": ";",
        "javadocTag": "@param splitters sub-hyperplanes that did split the current one"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the cut sub-hyperplane touches outside cells"
    },
    {
        "oracle": ";",
        "javadocTag": "@return parts of the cut sub-hyperplane known to touch outside cells\n(may be null or empty)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return nodes that were used to split the outside touching part"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the cut sub-hyperplane touches inside cells"
    },
    {
        "oracle": ";",
        "javadocTag": "@return parts of the cut sub-hyperplane known to touch inside cells\n(may be null or empty)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return nodes that were used to split the inside touching part"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current BSP tree node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sub sub-hyperplane to characterize"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyper underlying hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param remaining remaining region of the hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new sub-hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return underlying hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return remaining region of the hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transform D-dimension transform to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param node current BSP tree node"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformed image of the instance hyperplane by the transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transform transform to apply"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map transformed nodes map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane underlying hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param remainingRegion remaining region of the hyperplane"
    },
    {
        "oracle": ";",
        "javadocTag": "@param hyperplane hyperplane to insert, it will be chopped in\norder to fit in the cell defined by the parent nodes of the\ninstance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if a cut sub-hyperplane has been inserted (i.e. if\nthe cell now has two leaf child nodes)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new tree, copy of the instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return cut sub-hyperplane, null if this is a leaf tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@return tree on the plus side of the cut hyperplane, null if this\nis a leaf tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@return tree on the minus side of the cut hyperplane, null if this\nis a leaf tree"
    },
    {
        "oracle": ";",
        "javadocTag": "@return parent node, null if the node has no parents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param attribute attribute to associate with the node"
    },
    {
        "oracle": ";",
        "javadocTag": "@return attribute associated with the node or null if no\nattribute has been explicitly set using the {@link #setAttribute\nsetAttribute} method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor object visiting the tree nodes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sub sub-hyperplane to fit"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new sub-hyperplane, guaranteed to have no part outside\nof the instance cell"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the tree cell to which the point belongs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance tolerance below which points close to a cut hyperplane\nare considered to belong to the hyperplane itself"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the tree cell to which the point belongs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename file name to appear in printed messages"
    },
    {
        "oracle": ";",
        "javadocTag": "@param is input stream from which to read classfile bytes to process"
    },
    {
        "oracle": ";",
        "javadocTag": "@param is input stream from which to read a class"
    },
    {
        "oracle": ";",
        "javadocTag": "@return array of three version numbers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <A> type of first argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <B> type of second argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a WeakIdentityPair of (a, b)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param root the root document"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if processing completed without an error"
    },
    {
        "oracle": ";",
        "javadocTag": "@param option the command-line option"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of command-line arguments needed when using the option"
    },
    {
        "oracle": ";",
        "javadocTag": "@param options the command-line options to be checked: an array of 1- or 2-element arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@param reporter where to report errors"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the command-line options are valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param options the command-line options to parse: a list of 1- or 2-element arrays"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws Exception if there is trouble"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the user-visible doclet output"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws Exception if there is trouble"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the HTML documentation for the underlying options instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param padding the padding to add in the Javadoc output"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the HTML documentation for the underlying options instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param oi the option to describe"
    },
    {
        "oracle": ";",
        "javadocTag": "@return HTML describing oi"
    },
    {
        "oracle": ";",
        "javadocTag": "@param doc a Javadoc comment to convert to HTML"
    },
    {
        "oracle": ";",
        "javadocTag": "@return HTML version of doc"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string to check for being a regular expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@param groups number of groups expected"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff s is a regular expression with groups groups"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c char to check for being a regular expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff c is a regular expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string to check for being a regular expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@return null, or a string describing why the argument is not a regex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string to check for being a regular expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@param groups number of groups expected"
    },
    {
        "oracle": ";",
        "javadocTag": "@return null, or a string describing why the argument is not a regex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string to check for being a regular expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@return null, or a PatternSyntaxException describing why the argument is not a regex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string to check for being a regular expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@param groups number of groups expected"
    },
    {
        "oracle": ";",
        "javadocTag": "@return null, or a PatternSyntaxException describing why the argument is not a regex"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s string to check for being a regular expression"
    },
    {
        "oracle": ";",
        "javadocTag": "@param groups number of groups expected"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p pattern whose groups to count"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the count of groups in the argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param className name of the class"
    },
    {
        "oracle": ";",
        "javadocTag": "@return class URL, or null of the class was not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff the process has timed out"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the timeout time in msecs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the exit value for the subprocess"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the error stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the exit value of the subprocess"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the process if finished, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeLimit in milliseconds"
    },
    {
        "oracle": ";",
        "javadocTag": "@param timeLimit in milliseconds"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cacheStdout If true, causes the TimeLimitProcess to consume the standard output of the\nunderlying process, and to cache it.  After the process terminates (on\nits own or by being timed out), the output is available via the\ncached_stdout method.  This is necessary because when a Java process\nis terminated, its standard output is no longer available."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the array whose elements to intern in place"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an interned version of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to test for interning"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff value is interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the value to intern"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an interned Integer with value i"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an interned Integer parsed from s"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the value to intern"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an interned Integer with value i"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an interned Long parsed from s"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the array to canonicalize"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a canonical representation for the int[] array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the array to canonicalize"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a canonical representation for the long[] array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d the value to intern"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an interned Double with value d"
    },
    {
        "oracle": ";",
        "javadocTag": "@param s the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an interned Double parsed from s"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the array to canonicalize"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a canonical representation for the double[] array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the array to canonicalize"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a canonical representation for the String[] array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a the array to canonicalize"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a canonical representation for the Object[] array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a an Object to canonicalize"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a canonical version of a"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seq the sequence whose subsequence should be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the start of the subsequence to be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the end of the subsequence to be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a subsequence of seq from start to end that is interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seq the sequence whose subsequence should be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the start of the subsequence to be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the end of the subsequence to be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a subsequence of seq from start to end that is interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seq the sequence whose subsequence should be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the start of the subsequence to be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the end of the subsequence to be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a subsequence of seq from start to end that is interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seq the sequence whose subsequence should be interned"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the values to use when constructing the {@code\n    ImmutableListMultimap}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyFunction the function used to produce the key for each value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code ImmutableListMultimap} mapping the result of evaluating the\n    function {@code keyFunction} on each value in the input collection to\n    that value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any of the following cases is true:\n    <ul>\n    <li>{@code values} is null\n    <li>{@code keyFunction} is null\n    <li>An element in {@code values} is null\n    <li>{@code keyFunction} returns {@code null} for any element of {@code\n        values}\n    </ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the values to use when constructing the {@code\n    ImmutableListMultimap}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyFunction the function used to produce the key for each value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code ImmutableListMultimap} mapping the result of evaluating the\n    function {@code keyFunction} on each value in the input collection to\n    that value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any of the following cases is true:\n    <ul>\n    <li>{@code values} is null\n    <li>{@code keyFunction} is null\n    <li>An element in {@code values} is null\n    <li>{@code keyFunction} returns {@code null} for any element of {@code\n        values}\n    </ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator over the elements contained in this collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if this range map is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code lower} is greater than <i>or\n    equal to</i> {@code upper}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code lower} is greater than {@code\n    upper}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code lower} is greater than {@code\n    upper}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code lower} is greater than {@code\n    upper}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code lower} is greater than {@code\n    upper}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the parameters are not <i>mutually\n    comparable</i>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if {@code values} is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if this range is unbounded below (that is, {@link\n    #hasLowerBound()} returns {@code false})"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if this range is unbounded below (that is, {@link\n    #hasLowerBound()} returns {@code false})"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if this range is unbounded above (that is, {@link\n    #hasUpperBound()} returns {@code false})"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if this range is unbounded above (that is, {@link\n    #hasUpperBound()} returns {@code false})"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code isConnected(connectedRange)} is {@code false}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any key or value in {@code map} is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if any value is not an instance of the type\n    specified by its key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of elements desired\n\n<p><b>{@code Stream} equivalent:</b> <pre>   {@code"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the first element is null; if this is a possibility, use\n    {@code iterator().next()} or {@link Iterables#getFirst} instead."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the last element is null; if this is a possibility, use\n    {@link Iterables#getLast} instead."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize the maximum number of elements in the returned fluent iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the function by which to sort list elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the function by which to sort set elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any element of this iterable is {@code null}, or if {@code\n    valueFunction} produces {@code null} for any key"
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyFunction the function used to produce the key for each value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any of the following cases is true:\n    <ul>\n      <li>{@code keyFunction} is null\n      <li>An element in this fluent iterable is null\n      <li>{@code keyFunction} returns {@code null} for any element of this iterable\n    </ul>\n\n<p><b>{@code Stream} equivalent:</b> {@code stream.collect(Collectors.groupingBy(keyFunction))}\nbehaves similarly, but returns a mutable {@code Map<K, List<E>>} instead, and may not preserve\nthe order of entries)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param keyFunction the function used to produce the key for each value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a map mapping the result of evaluating the function {@code\n    keyFunction} on each value in this fluent iterable to that value"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code keyFunction} produces the same\n    key for more than one value in this fluent iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any elements of this fluent iterable is null, or\n    if {@code keyFunction} produces {@code null} for any value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the type of the elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a newly-allocated array into which all the elements of this fluent iterable have\n    been copied"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection to copy elements to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code collection}, for convenience"
    },
    {
        "oracle": ";",
        "javadocTag": "@param element the element to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list the list to be searched."
    },
    {
        "oracle": ";",
        "javadocTag": "@param key the value to be searched for."
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator by which the list is ordered."
    },
    {
        "oracle": ";",
        "javadocTag": "@param presentBehavior the specification for what to do if at least one element of the list\n       compares as equal to the key."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absentBehavior the specification for what to do if no elements of the list compare as\n       equal to the key."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index determined by the {@code KeyPresentBehavior}, if the key is in the list;\n        otherwise the index determined by the {@code KeyAbsentBehavior}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next element if there was one. If {@code endOfData} was called\n    during execution, the return value will be ignored."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws RuntimeException if any unrecoverable error happens. This exception\n    will propagate outward to the {@code hasNext()}, {@code next()}, or\n    {@code peek()} invocation that invoked this method. Any further\n    attempts to use the iterator will result in an\n    {@link IllegalStateException}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code null}; a convenience so your {@code computeNext}\n    implementation can use the simple statement {@code return endOfData();}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param key key to store in the multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value value to store in the multimap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map place to store the mapping from each key to its corresponding\n    values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator that defines the order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return comparator itself if it is already an {@code Ordering}; otherwise\n    an ordering that wraps that comparator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param valuesInOrder the values that the returned comparator will be able\n    to compare, in the order the comparator should induce"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the comparator described above"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code valuesInOrder} contains any\n    duplicate values (according to {@link Object#equals})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param leastValue the value which the returned comparator should consider\n    the \"least\" of all values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param remainingValuesInOrder the rest of the values that the returned\n    comparator will be able to compare, in the order the comparator should\n    follow"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the comparator described above"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if any duplicate values (according to\n    {@link Object#equals(Object)}) are present among the method arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparators the comparators to try in order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator whose minimum element is to be determined"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if {@code iterator} is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the parameters are not <i>mutually\n    comparable</i> under this ordering."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable whose minimum element is to be determined"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if {@code iterable} is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the parameters are not <i>mutually\n    comparable</i> under this ordering."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to compare, returned if less than or equal to b."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b value to compare."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the parameters are not <i>mutually\n    comparable</i> under this ordering."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to compare, returned if less than or equal to the rest."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b value to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c value to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rest values to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the parameters are not <i>mutually\n    comparable</i> under this ordering."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator whose maximum element is to be determined"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if {@code iterator} is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the parameters are not <i>mutually\n    comparable</i> under this ordering."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable whose maximum element is to be determined"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if {@code iterable} is empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the parameters are not <i>mutually\n    comparable</i> under this ordering."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to compare, returned if greater than or equal to b."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b value to compare."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the parameters are not <i>mutually\n    comparable</i> under this ordering."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a value to compare, returned if greater than or equal to the rest."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b value to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c value to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rest values to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the parameters are not <i>mutually\n    comparable</i> under this ordering."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an immutable {@code RandomAccess} list of the {@code k} least\n    elements in ascending order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an immutable {@code RandomAccess} list of the {@code k} least\n    elements in ascending order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an immutable {@code RandomAccess} list of the {@code k} greatest\n    elements in <i>descending order</i>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an immutable {@code RandomAccess} list of the {@code k} greatest\n    elements in <i>descending order</i>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any of {@code elements} (or {@code\n    elements} itself) is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sortedList the list to be searched"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bits Sort order for each Comparator.  Extra bits are ignored,\n              unless extra Comparators are added by another method."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the true first singleton BooleanComparator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the false first singleton BooleanComparator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param trueFirst when <code>true</code>, sort\n<code>true</code> <code>Boolean</code>s before <code>false</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a singleton BooleanComparator instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b1 the first boolean to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b2 the second boolean to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return negative if obj1 is less, positive if greater, zero if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException when either argument <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code for this comparator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the trueFirst flag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param trueFirst when <code>true</code>, sort\n <code>true</code> boolean values before <code>false</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj1 the first object to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj2 the second object to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return negative if obj1 is less, positive if greater, zero if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a suitable hash code"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator Comparator to reverse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton ComparableComparator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj1 the first object to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj2 the second object to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return negative if obj1 is less, positive if greater, zero if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if <i>obj1</i> is not a <code>Comparable</code>,\n        or when <code>((Comparable)obj1).compareTo(obj2)</code> does"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code for this comparator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare with"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj1 the first object to transform then compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj2 the second object to transform then compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return negative if obj1 is less, positive if greater, zero if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code for this comparator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer what will transform the arguments to <code>compare</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer what will transform the arguments to <code>compare</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param decorated the decorated Comparator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if attempts to change the FixedOrderComparator yield an\n UnsupportedOperationException, false if it can be changed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@link UnknownObjectBehavior}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param unknownObjectBehavior the flag for unknown behaviour -\nUNKNOWN_AFTER, UNKNOWN_BEFORE or UNKNOWN_THROW_EXCEPTION"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if a comparison has been performed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the item to be added to the Comparator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if obj has been added for the first time, false if\n it was already known to the Comparator."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if a comparison has already been made"
    },
    {
        "oracle": ";",
        "javadocTag": "@param existingObj an item already in the Comparator's set of\n known objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@param newObj an item to be added to the Comparator's set of\n known objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if newObj has been added for the first time, false if\n it was already known to the Comparator."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if existingObject is not in the\n Comparator's set of known objects."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if a comparison has already been made"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj1 the first object to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj2 the second object to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return negative if obj1 is less, positive if greater, zero if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if obj1 or obj2 are not known\n to this Comparator and an alternative behavior has not been set\n via {@link #setUnknownObjectBehavior(UnknownObjectBehavior)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code for this comparator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param items the items that the comparator can compare in order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param items the items that the comparator can compare in order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o1 the first object to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o2 the object to compare it to."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>-1</code> if <code>o1</code> is \"lower\" than (less than,\n before, etc.) <code>o2</code>; <code>1</code> if <code>o1</code> is\n \"higher\" than (greater than, after, etc.) <code>o2</code>; or\n <code>0</code> if <code>o1</code> and <code>o2</code> are equal."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code for this comparator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to compare this comparator with."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the specified object is a NullComparator\n with equivalent <code>null</code> comparison behavior\n (i.e. <code>null</code> high or low) and with equivalent underlying\n non-<code>null</code> object comparators."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nonNullComparator the comparator to use when comparing two\n non-<code>null</code> objects.  This argument cannot be\n <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if <code>nonNullComparator</code> is\n <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nullsAreHigh a <code>true</code> value indicates that\n <code>null</code> should be compared as higher than a\n non-<code>null</code> object.  A <code>false</code> value indicates\n that <code>null</code> should be compared as lower than a\n non-<code>null</code> object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nonNullComparator the comparator to use when comparing two\n non-<code>null</code> objects. This argument cannot be\n <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nullsAreHigh a <code>true</code> value indicates that\n <code>null</code> should be compared as higher than a\n non-<code>null</code> object.  A <code>false</code> value indicates\n that <code>null</code> should be compared as lower than a\n non-<code>null</code> object."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if <code>nonNullComparator</code> is\n <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection, possibly <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an empty collection if the argument is <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the generic type that is able to represent the types contained\n       in both input collections."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the union of the two collections"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the generic type that is able to represent the types contained\n       in both input collections."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the intersection of the two collections"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the generic type that is able to represent the types contained\n       in both input collections."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the symmetric difference of the two collections"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the generic type that is able to represent the types contained\n       in both input collections."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new collection with the results"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the condition used to determine which elements of <i>b</i> are\n       subtracted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the generic type that is able to represent the types contained\n       in both input collections."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new collection with the results"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> iff the intersection of the collections has the same cardinality\n  as the set of unique elements from the second collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> iff the intersection of the collections is non-empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the type of object in the returned {@link Map}. This is a super type of <I>."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the populated cardinality map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> iff <i>a</i> is a sub-collection of <i>b</i>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> iff the collections contain the same elements with the same cardinalities."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equator the Equator used for testing equality"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> iff the collections contain the same elements with the same cardinalities."
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to find the cardinality of"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the {@link Iterable} to search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the type of object that the {@link Iterable} may contain."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the the number of occurrences of obj in coll"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The new end selection abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The new end selection ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x2 The selection stop abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y2 The selection stop ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param element The element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The requested position abscissa in pixels."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The requested position ordinate in pixels."
    },
    {
        "oracle": ";",
        "javadocTag": "@param renderer The renderer (or null to remove it)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param renderer The renderer (or null to remove it)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graphics The Swing graphics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The graphic representation of the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param px2Gu The ratio to pass from pixels to graph units."
    },
    {
        "oracle": ";",
        "javadocTag": "@param widthPx The width in pixels of the view port."
    },
    {
        "oracle": ";",
        "javadocTag": "@param heightPx The height in pixels of the view port."
    },
    {
        "oracle": ";",
        "javadocTag": "@param minXGu The minimum visible point abscissa of the graph in graph\n           units."
    },
    {
        "oracle": ";",
        "javadocTag": "@param minYGu The minimum visible point ordinate of the graph in graph\n           units."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxXGu The maximum visible point abscissa of the graph in graph\n           units."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxYGu The maximum visible point ordinate of the graph in graph\n           units."
    },
    {
        "oracle": ";",
        "javadocTag": "@param on Add the panel in its own frame or remove it if it already was\n          in its own frame."
    },
    {
        "oracle": ";",
        "javadocTag": "@param width The new width."
    },
    {
        "oracle": ";",
        "javadocTag": "@param height The new height."
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier The view unique identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The new layout or the default GraphStream \"Spring-Box\" layout if\n        the \"gs.ui.layout\" system property is either not set or contains\n        a class that cannot be found."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a value between 0 and 1. 1 means fully stabilized."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The stabilization limit."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A number between 0 and 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A real number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value A number in [0..1]."
    },
    {
        "oracle": ";",
        "javadocTag": "@param qualityLevel The quality level, a number between 0 and 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param send If true, send node informations to a \"layout.info\" attribute."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The node new X."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The node new Y."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z The node new Z."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param frozen If true the node is frozen."
    },
    {
        "oracle": ";",
        "javadocTag": "@param ms The number of milliseconds to wait."
    },
    {
        "oracle": ";",
        "javadocTag": "@param longNap The time to wait between stabilized layout invocations, by\n           default 80."
    },
    {
        "oracle": ";",
        "javadocTag": "@param shortNap The time to wait between non stabilized layout invocations, by\n           default 10."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source The source of graph events."
    },
    {
        "oracle": ";",
        "javadocTag": "@param layout The layout algorithm to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source The source of graph events."
    },
    {
        "oracle": ";",
        "javadocTag": "@param layout The layout algorithm to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start Start the layout thread immediately ? Else the start() method\n           must be called later."
    },
    {
        "oracle": ";",
        "javadocTag": "@param graph The source of graph events."
    },
    {
        "oracle": ";",
        "javadocTag": "@param layout The layout algorithm to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param start Start the layout thread immediately ? Else the start() method\n           must be called later."
    },
    {
        "oracle": ";",
        "javadocTag": "@param replay If the graph already contains some data, replay events to\n           create the data, this is mostly always needed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A set of edges."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dx The x component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dy The y component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dz The z component."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The new x."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The new y."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z The new z."
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta The computed displacement vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta The computed displacement vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta The computed displacement vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta The computed displacement vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e The edge to connect."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e THe edge to disconnect."
    },
    {
        "oracle": ";",
        "javadocTag": "@param box The spring box."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param box The spring box."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param z The depth."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node One of the nodes of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The other node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The edge identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n0 The first node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n1 The second node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The actual level of energy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A value that indicates the level of stabilization in [0-1]."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The average energy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param stepsBack The number of steps back in history. This number must not be larger than\n           the size of the memory (energy buffer) else it is set to this size."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The energy value at stepsBack in time."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The value to accumulate to the current cell."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The gravity factor, usually between 0 and 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value The new gravity factor, usually between 0 and 1."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The n-tree."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The theta value (between 0 and 1)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param theta The new value for theta (between 0 and 1)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n0 source node of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n1 target node of the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The identifier of the new node/particle."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The new node/particle."
    },
    {
        "oracle": ";",
        "javadocTag": "@param is3D If true the simulation dimensions count is 3 else 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@param is3D If true the simulation dimensions count is 3 else 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@param randomNumberGenerator The random number generator to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param is3D If true the simulation dimensions count is 3 else 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@param is3D If true the simulation dimensions count is 3 else 2."
    },
    {
        "oracle": ";",
        "javadocTag": "@param randomNumberGenerator The random number generator to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param box The spring box."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param box The spring box."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x The abscissa."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y The ordinate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations Maximum number of \"iterations\" to complete."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the regularized gamma function P(a, x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return digamma(x) to within 10-8 relative or absolute error whichever is smaller."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return trigamma(x) to within 10-8 relative or absolute error whichever is smaller"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The Lanczos approximation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The value of {@code 1.0 / Gamma(1.0 + x) - 1.0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The value of {@code log(Gamma(1 + x))}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of {@code Gamma(x)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Parameter {@code a}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Parameter {@code b}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the regularized beta function I(x, a, b)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.MaxCountExceededException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Parameter {@code a}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Parameter {@code b}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon When the absolute value of the nth item in the\nseries is less than epsilon the approximation ceases to calculate\nfurther elements in the series."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the regularized beta function I(x, a, b)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.MaxCountExceededException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Parameter {@code a}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Parameter {@code b}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations Maximum number of \"iterations\" to complete."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the regularized beta function I(x, a, b)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.MaxCountExceededException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x the value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Parameter {@code a}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Parameter {@code b}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon When the absolute value of the nth item in the\nseries is less than epsilon the approximation ceases to calculate\nfurther elements in the series."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations Maximum number of \"iterations\" to complete."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the regularized beta function I(x, a, b)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.MaxCountExceededException if the algorithm fails to converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Parameter {@code a}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Parameter {@code b}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon This parameter is ignored."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations This parameter is ignored."
    },
    {
        "oracle": ";",
        "javadocTag": "@return log(B(a, b))."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a First argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Second argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of {@code log(Gamma(a + b))}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code a} or {@code b} is lower than\n{@code 1.0} or greater than {@code 2.0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a First argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Second argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of {@code log(Gamma(b) / Gamma(a + b))}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code a < 0.0} or {@code b < 10.0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a First argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Second argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of {@code Delta(b) - Delta(a + b)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code a < 0} or {@code a > b}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code b < 10}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p First argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q Second argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of {@code Delta(p) + Delta(q) - Delta(p + q)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code p < 10.0} or {@code q < 10.0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p First argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q Second argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of {@code log(Beta(p, q))}, {@code NaN} if\n{@code p <= 0} or {@code q <= 0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field field to which elements belong"
    },
    {
        "oracle": ";",
        "javadocTag": "@param original original array (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return copied array or null if original array was null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return main state dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@return main state at time"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number of secondary states."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the secondary set as returned\nby {@link FieldExpandableODE#addSecondaryEquations(FieldSecondaryEquations)}\n(beware index 0 corresponds to main state, additional states start at 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return secondary state dimension"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the secondary set as returned\nby {@link FieldExpandableODE#addSecondaryEquations(FieldSecondaryEquations)}\n(beware index 0 corresponds to main state, additional states start at 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return secondary state at time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param state state at time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param state state at time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondaryState state at time (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return derivative of the main state at time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the secondary set as returned\nby {@link FieldExpandableODE#addSecondaryEquations(FieldSecondaryEquations)}\n(beware index 0 corresponds to main state, additional states start at 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return derivative of the secondary state at time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param state state at time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param derivative derivative of the state at time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param time time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param state state at time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param derivative derivative of the state at time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondaryState state at time (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param secondaryDerivative derivative of the state at time (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return dimension of the problem"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t0 value of the independent <I>time</I> variable at integration start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y0 array containing the value of the state vector at integration start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param finalTime target time for the integration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t current value of the independent <I>time</I> variable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y array containing the current value of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return time derivative of the state vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return starter integrator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param starterIntegrator starter integrator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between the instance and p according to the L<sub>1</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between the instance and p according to the L<sub>1</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between the instance and p according to the L<sub>2</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between the instance and p according to the L<sub>2</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between the instance and p according to the L<sub>&infin;</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between the instance and p according to the L<sub>&infin;</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square of the distance between the instance and p"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square of the distance between the instance and p"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the dot product v1.v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the dot product v1.v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the dot product v1.v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cross product v1 ^ v2 as a new Vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cross product v1 ^ v2 as a new Vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cross product v1 ^ v2 as a new Vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between v1 and v2 according to the L<sub>1</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between v1 and v2 according to the L<sub>1</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between v1 and v2 according to the L<sub>1</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between v1 and v2 according to the L<sub>2</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between v1 and v2 according to the L<sub>2</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between v1 and v2 according to the L<sub>2</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square of the distance between v1 and v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square of the distance between v1 and v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v1 first vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v2 second vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the field elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the square of the distance between v1 and v2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for components"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of this vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y ordinate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param z height"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v coordinates array"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if array does not have 3 elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha azimuth (&alpha;) around Z\n             (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param u base (unscaled) vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a scale factor"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g2 "
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the edge factory of the new graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the edge factory of the new graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edge edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return ."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex vertex."
    },
    {
        "oracle": ";",
        "javadocTag": "@return ."
    },
    {
        "oracle": ";",
        "javadocTag": "@return G<sub>2</sub>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the edge factory of the new graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if and only if graph loops are allowed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if and only if multiple edges are allowed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeSetFactory factory to use for subsequently created edge sets\n(this call has no effect on existing edge sets)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a shallow copy of this set."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws RuntimeException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the edge factory of the new graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowMultipleEdges whether to allow multiple edges or not."
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowLoops whether to allow edges that are self-loops or not."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the edge factory of the new graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the edge factory of the new graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the edge factory of the new graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@return weight of this edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param base the backing graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the backing graph over which an unweighted view is to be\ncreated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertex the vertex for which the edge set is being created;\nsophisticated factories may be able to use this information to choose an\noptimal set representation (e.g. ArrayUnenforcedSet for a vertex expected\nto have low degree, and LinkedHashSet for a vertex expected to have high\ndegree)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return new set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the backing graph (the delegate)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param reuseEvents whether to reuse previously fired event objects\ninstead of creating a new event object for each event."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the <code>reuseEvents</code> flag."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source edge source"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target edge target"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source edge source"
    },
    {
        "oracle": ";",
        "javadocTag": "@param target edge target"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the backing graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the backing graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param reuseEvents whether to reuse previously fired event objects\ninstead of creating a new event object for each event."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the backing graph is already a\nlistenable graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the backing directed graph over which an undirected view is to\nbe created."
    },
    {
        "oracle": ";",
        "javadocTag": "@return source of this edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@return target of this edge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param base the backing graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param base the base (backing) graph on which the subgraph will be based."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexSubset vertices to include in the subgraph. If <code>\nnull</code> then all vertices are included."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeSubset edges to in include in the subgraph. If <code>\nnull</code> then all the edges whose vertices found in the graph are\nincluded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param base the backing graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the backing graph over which an unweighted view is to be\ncreated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the edge factory of the new graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the backing graph on which an unmodifiable graph is to be\ncreated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the vertex to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the vertex was added, otherwise <code>\nfalse</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param base the base (backing) graph on which the subgraph will be based."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexSubset vertices to include in the subgraph. If <code>\nnull</code> then all vertices are included."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeSubset edges to in include in the subgraph. If <code>\nnull</code> then all the edges whose vertices found in the graph are\nincluded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param base the base (backing) graph on which the subgraph will be based."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexSubset vertices to include in the subgraph. If <code>\nnull</code> then all vertices are included."
    },
    {
        "oracle": ";",
        "javadocTag": "@param base the base (backing) graph on which the subgraph will be based."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexSubset vertices to include in the subgraph. If <code>\nnull</code> then all vertices are included."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeSubset edges to in include in the subgraph. If <code>\nnull</code> then all the edges whose vertices found in the graph are\nincluded."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of this graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vertex"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if this assertion holds."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if specified vertex does not exist in\nthis graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edges edges to be removed from this graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <tt>true</tt> if this graph changed as a result of the call."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexSet the vertex set V to be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeSet the edge set E to be printed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of (V,E)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the hash code value this graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj object to be compared for equality with this graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the specified object is equal to this graph"
    },
    {
        "oracle": ";",
        "javadocTag": "@param base the base (backing) graph on which the subgraph will be based."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mask vertices and edges to exclude in the subgraph. If a\nvertex/edge is masked, it is as if it is not in the subgraph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the edge factory of the new graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the backing graph over which a weighted view is to be created."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weightMap A mapping of edges to weights. If an edge is not present\nin the weight map, the edge weight for the underlying graph is returned.\nNote that a live reference to this map is retained, so if the caller\nchanges the map after construction, the changes will affect the"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the edge factory of the new graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the backing graph on which an unmodifiable graph is to be\ncreated."
    },
    {
        "oracle": ";",
        "javadocTag": "@param base the base (backing) graph on which the subgraph will be based."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vertexSubset vertices to include in the subgraph. If <code>\nnull</code> then all vertices are included."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeSubset edges to in include in the subgraph. If <code>\nnull</code> then all the edges whose vertices found in the graph are\nincluded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the edge factory of the new graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@param edgeClass class on which to base factory for edges"
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the base (backing) graph on which the edge-reversed view will be\nbased."
    },
    {
        "oracle": ";",
        "javadocTag": "@param g the backing graph over which a weighted view is to be created."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weightMap A mapping of edges to weights. If an edge is not present\nin the weight map, the edge weight for the underlying graph is returned.\nNote that a live reference to this map is retained, so if the caller\nchanges the map after construction, the changes will affect the\nAsWeightedGraph instance as well."
    },
    {
        "oracle": ";",
        "javadocTag": "@param baseGraph the graph object to base building on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param baseGraph the graph object to base building on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximalIterationCount maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if number of points is out of [2; 5]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if maximal number of iterations\nis lesser than or equal to the minimal number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number of points desired (must be between 2 and 5 inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy relative accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy absolute accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if number of points is out of [2; 5]"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number of points desired (must be between 2 and 5 inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimalIterationCount minimum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximalIterationCount maximum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if number of points is out of [2; 5]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if maximal number of iterations\nis lesser than or equal to the minimal number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the stage of 1/2 refinement. Must be larger than 0."
    },
    {
        "oracle": ";",
        "javadocTag": "@param previousStageResult Result from the previous call to the\n{@code stage} method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound of the integration interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param diffMaxMin Difference between the lower bound and upper bound\nof the integration interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of n-th stage integral"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of evaluations\nis exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy relative accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy absolute accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimalIterationCount minimum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if maximal number of iterations\nis lesser than or equal to the minimal number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimalIterationCount minimum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if maximal number of iterations\nis lesser than or equal to the minimal number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy relative accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy absolute accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimalIterationCount minimum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if maximal number of iterations\nis lesser than or equal to the minimal number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimalIterationCount minimum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if maximal number of iterations\nis lesser than or equal to the minimal number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy relative accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy absolute accuracy of the result"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimalIterationCount minimum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if maximal number of iterations\nis lesser than or equal to the minimal number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minimalIterationCount minimum number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if maximal number of iterations\nis lesser than or equal to the minimal number of iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfPoints Number of integration points."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the integration rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the elements of the rule pair do not\nhave the same length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfPoints Order of the rule to be retrieved."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the points and weights corresponding to the given order."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the elements of the rule pair do not\nhave the same length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rule Rule to be stored."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the elements of the pair do not\nhave the same length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfPoints Order of the rule to be computed."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the computed rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the elements of the pair do not\nhave the same length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> Type of the number used to represent the points and\nweights of the quadrature rules."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rule Points and weights."
    },
    {
        "oracle": ";",
        "javadocTag": "@return points and weights as {@code double}s."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfPoints Order of the integration rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Gauss-Legendre integrator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfPoints Order of the integration rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound Lower bound of the integration interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound Upper bound of the integration interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Gauss-Legendre integrator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfPoints Order of the integration rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Gauss-Legendre integrator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfPoints Order of the integration rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerBound Lower bound of the integration interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param upperBound Upper bound of the integration interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Gauss-Legendre integrator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfPoints Order of the integration rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Gauss-Hermite integrator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param factory Integration rule factory."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfPoints Order of the integration rule."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the integration nodes and weights."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if number of points is not positive"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the elements of the rule pair do not\nhave the same length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rule Original points and weights."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Lower bound of the integration interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Lower bound of the integration interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the points and weights adapted to the new interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mContext Precision setting for computing the quadrature rules."
    },
    {
        "oracle": ";",
        "javadocTag": "@param points Integration points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights Weights of the corresponding integration nodes."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if the {@code points} are not\nsorted in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if points and weights don't have the same length"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pointsAndWeights Integration points and corresponding weights."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if the {@code points} are not\nsorted in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to integrate."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the integral of the weighted function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the order of the integration rule (the number of integration\npoints)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the integration point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the integration point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index index of the integration point"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the weight."
    },
    {
        "oracle": ";",
        "javadocTag": "@param points Integration points."
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights Weights of the corresponding integration nodes."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if the {@code points} are not\nsorted in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if points and weights don't have the same length"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pointsAndWeights Integration points and corresponding weights."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if the {@code points} are not\nsorted in increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if the number of iterations\nexceeds the allowed maximum number"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lower bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the upper bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point at which the objective function must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective function value at specified point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of function\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param q Number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the greatest common divisor, never negative."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code long} value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the least common multiple, never negative."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code int} value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Number."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the least common multiple, never negative."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result cannot be represented\nas a non-negative {@code long} value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result can not be\nrepresented as an {@code int}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result can not be represented\nas a {@code long}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Minuend."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Subtrahend."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result can not be represented\nas an {@code int}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Value."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result can not be represented as a\n{@code long}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Number to raise."
    },
    {
        "oracle": ";",
        "javadocTag": "@return \\( k^e \\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result would overflow."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Number to raise."
    },
    {
        "oracle": ";",
        "javadocTag": "@return k<sup>e</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Number to raise."
    },
    {
        "oracle": ";",
        "javadocTag": "@return \\( k^e \\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result would overflow."
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Number to raise."
    },
    {
        "oracle": ";",
        "javadocTag": "@return k<sup>e</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Number to raise."
    },
    {
        "oracle": ";",
        "javadocTag": "@return k<sup>e</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Number to raise."
    },
    {
        "oracle": ";",
        "javadocTag": "@return k<sup>e</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k Number to raise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param e Exponent (must be positive or zero)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return k<sup>e</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if {@code e < 0}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the size of the set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the number of non-empty subsets"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code S(n,k)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if some overflow happens, typically for n exceeding 25 and\nk between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a Addend."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b Addend."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Pattern to use for any thrown exception."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the sum {@code a + b}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the result cannot be represented\nas a {@code long}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the number to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the argument is a power of two"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The index corresponding to a pivot chosen between the\nfirst, middle and the last indices of the array slice"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException when indices exceeds range"
    },
    {
        "oracle": ";",
        "javadocTag": "@return available complex format locales."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Complex object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A formatted number in the form \"Re(c) + Im(c)i\"."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Double object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A formatted number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param complex the object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absIm Absolute value of the imaginary part of a complex number."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended."
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\noffsets of the alignment field."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toAppendTo where the text is to be appended"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos On input: an alignment field, if desired. On output: the\n           offsets of the alignment field"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value passed in as toAppendTo."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException is {@code obj} is not a valid type."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the imaginaryCharacter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the imaginaryFormat."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the default complex format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale the specific locale used by the format."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the complex format specific to the given locale."
    },
    {
        "oracle": ";",
        "javadocTag": "@param locale the specific locale used by the format."
    },
    {
        "oracle": ";",
        "javadocTag": "@param imaginaryCharacter Imaginary character."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the complex format specific to the given locale."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if {@code imaginaryCharacter} is an\nempty string."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the realFormat."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link Complex} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathParseException if the beginning of the specified string\ncannot be parsed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the string to parse"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pos input/ouput parsing parameter."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the parsed {@link Complex} object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for both real and imaginary parts."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if {@code realFormat} is {@code null}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param realFormat the custom format for the real part."
    },
    {
        "oracle": ";",
        "javadocTag": "@param imaginaryFormat the custom format for the imaginary part."
    },
    {
        "oracle": ";",
        "javadocTag": "@param imaginaryCharacter The custom imaginary character."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if {@code imaginaryCharacter} is an\nempty string."
    },
    {
        "oracle": ";",
        "javadocTag": "@param imaginaryCharacter The custom imaginary character."
    },
    {
        "oracle": ";",
        "javadocTag": "@param format the custom format for both real and imaginary parts."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if {@code imaginaryCharacter} is an\nempty string."
    },
    {
        "oracle": ";",
        "javadocTag": "@param imaginaryCharacter The custom imaginary character."
    },
    {
        "oracle": ";",
        "javadocTag": "@param realFormat the custom format for the real part."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException if the iterators collection contains an\n  element that's not an {@link Iterator}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if there is another element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next element in the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the next element in the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if there is a previous element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous element in the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the previous element in the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the list is unmodifiable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if there is no element to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the list is unmodifiable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the iterator is not in a valid state for set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the list is unmodifiable"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the iterator is not in a valid state for set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list the list to create a reversed iterator for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the iterator is within its bounds, {@code false} otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to be decorated"
    },
    {
        "oracle": ";",
        "javadocTag": "@param offset the index of the first element of the decorated iterator to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max the maximum number of elements of the decorated iterator to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next object"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.util.NoSuchElementException if there are no more elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the iterator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param source the object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if there is a previous element to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the previous element"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if there is no previous element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next element"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if there is no next element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the item to be retrieved next"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the item to be retrieved next"
    },
    {
        "oracle": ";",
        "javadocTag": "@param o the element to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException always thrown."
    },
    {
        "oracle": ";",
        "javadocTag": "@param o the element to set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if {@link #next()} or {@link #previous()} has not been called\nbefore {@link #set(Object)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to iterate over"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if <code>array</code> is not an array."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to iterate over"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startIndex the index to start iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if <code>array</code> is not an array."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the start index is out of bounds"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array the array to iterate over"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startIndex the index to start iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@param endIndex the index (exclusive) to finish iterating at"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if <code>array</code> is not an array."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the start or end index is out of bounds"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if end index is before the start"
    },
    {
        "oracle": ";",
        "javadocTag": "@param count the number of time this method has been called (starts with 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next iterator, or null if there are no more."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if elements remain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return element from the current Iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws java.util.NoSuchElementException if all the Iterators are exhausted"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the remove operator is not\n  supported by the underlying Iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the next method has not yet been called,\n  or the remove method has already been called after the last call to the next method."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if there are more elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object after the last element returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if there are no elements in the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the element that would be returned if next() were called"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if there are no elements in the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if there are more elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object before the last element returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if there are no elements in the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the element that would be returned if previous() were called"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if there are no elements in the list"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the remove method is\nnot supported by the iterator implementation of the underlying\nlist"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the element to insert"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the add method is not\n supported by the iterator implementation of the underlying list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param obj the element with which to replace the last element returned"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the set method is not\n supported by the iterator implementation of the underlying list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the current list size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param list the list to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the list it null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new peeking iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next element from the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next element from the iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if the iterator is already exhausted according to {@link #hasNext()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if {@link #peek()} or {@link #element()} has been called\n  prior to the call to {@link #remove()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value to start from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterator the iterator to start from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if elements remain in the iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next element from the iteration"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchElementException if all the Iterators are exhausted"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws UnsupportedOperationException if the remove operator is not supported by the underlying Iterator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalStateException if the next method has not yet been called, or the remove method has\n  already been called after the last call to the next method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param bound the index to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param len the length of the array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param type the index type (for error messages)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if there is a next element to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next element in the array"
    },
    {
        "oracle": "x.length==0 || y.length==0;",
        "javadocTag": "@throws NoDataException if {@code x} or {@code y} are zero-length"
    },
    {
        "oracle": "(rowDimension>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if row or column dimension is not positive"
    },
    {
        "oracle": "stateTransition==null || control==null || processNoise==null || initialStateEstimate==null || initialErrorCovariance==null;",
        "javadocTag": "@throws NullArgumentException if any of the input arrays is {@code null}"
    },
    {
        "oracle": "stateTransition==null || control==null || processNoise==null;",
        "javadocTag": "@throws NullArgumentException if any of the input arrays is {@code null}"
    },
    {
        "oracle": "x.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the number of points is less than 2."
    },
    {
        "oracle": "x.length<2;",
        "javadocTag": "@throws NumberIsTooSmallException if the number of points is less than 2."
    },
    {
        "oracle": "isLast==true;",
        "javadocTag": "@param isLast true if the step is the last one"
    },
    {
        "oracle": "numberOfTrials<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}."
    },
    {
        "oracle": "numberOfSuccesses<0;",
        "javadocTag": "@throws NotPositiveException if {@code numberOfSuccesses < 0}."
    },
    {
        "oracle": "numberOfSuccesses>numberOfTrials;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}."
    },
    {
        "oracle": "numberOfTrials<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}."
    },
    {
        "oracle": "numberOfSuccesses<0;",
        "javadocTag": "@throws NotPositiveException if {@code numberOfSuccesses < 0}."
    },
    {
        "oracle": "numberOfSuccesses>numberOfTrials;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}."
    },
    {
        "oracle": "numberOfTrials<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}."
    },
    {
        "oracle": "numberOfSuccesses<0;",
        "javadocTag": "@throws NotPositiveException if {@code numberOfSuccesses < 0}."
    },
    {
        "oracle": "numberOfSuccesses>numberOfTrials;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}."
    },
    {
        "oracle": "numberOfTrials<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}."
    },
    {
        "oracle": "numberOfSuccesses<0;",
        "javadocTag": "@throws NotPositiveException if {@code numberOfSuccesses < 0}."
    },
    {
        "oracle": "numberOfSuccesses>numberOfTrials;",
        "javadocTag": "@throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}."
    },
    {
        "oracle": "numberOfTrials>0;",
        "javadocTag": "@param numberOfTrials number of trials (must be positive)"
    },
    {
        "oracle": "confidenceLevel==0;",
        "javadocTag": "@param confidenceLevel confidence level (must be strictly between 0 and 1)"
    },
    {
        "oracle": "minStep>0;",
        "javadocTag": "@param minStep minimal step (must be positive even for backward\nintegration), the last step can be smaller than this"
    },
    {
        "oracle": "maxStep>0;",
        "javadocTag": "@param maxStep maximal step (must be positive even for backward\nintegration)"
    },
    {
        "oracle": "isLast==true;",
        "javadocTag": "@param isLast true if the step is the last one"
    },
    {
        "oracle": "points==null;",
        "javadocTag": "@throws MathIllegalArgumentException if the data points are null or the number\n  of clusters is larger than the number of data points"
    },
    {
        "oracle": "mu<0.5;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code mu < 0.5}"
    },
    {
        "oracle": "omega<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code omega <= 0}"
    },
    {
        "oracle": "omega>0;",
        "javadocTag": "@param omega scale parameter (must be positive)"
    },
    {
        "oracle": "mu<0.5;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code mu < 0.5}"
    },
    {
        "oracle": "omega<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code omega <= 0}"
    },
    {
        "oracle": "omega>0;",
        "javadocTag": "@param omega scale parameter (must be positive)"
    },
    {
        "oracle": "mu<0.5;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code mu < 0.5}"
    },
    {
        "oracle": "omega<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code omega <= 0}"
    },
    {
        "oracle": "omega>0;",
        "javadocTag": "@param omega scale parameter (must be positive)"
    },
    {
        "oracle": "maxIter<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code maxIter <= 0}."
    },
    {
        "oracle": "beta<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code beta <= 0}"
    },
    {
        "oracle": "beta>0;",
        "javadocTag": "@param beta scale parameter (must be positive)"
    },
    {
        "oracle": "beta<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code beta <= 0}"
    },
    {
        "oracle": "beta>0;",
        "javadocTag": "@param beta scale parameter (must be positive)"
    },
    {
        "oracle": "observed1.length<2;",
        "javadocTag": "@throws DimensionMismatchException the the length of the arrays does not\nmatch or their common length is less than 2"
    },
    {
        "oracle": "true ? methodResultID==a-a : true;",
        "javadocTag": "@return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;"
    },
    {
        "oracle": "(e1.equals(e2)) == false ? (methodResultID.equals(MathUtils.min(e1, e2))) == false : methodResultID.equals(e1) && methodResultID.equals(e2);",
        "javadocTag": "@return max(a1, e2)"
    },
    {
        "oracle": "(e1.equals(e2)) == false ? (methodResultID.equals(MathUtils.max(e1, e2))) == false : methodResultID.equals(e1) && methodResultID.equals(e2);",
        "javadocTag": "@return min(a1, e2)"
    },
    {
        "oracle": "true ? methodResultID==magnitude : true;",
        "javadocTag": "@return a value with magnitude equal to {@code magnitude} and with the\nsame sign as the {@code sign} argument."
    },
    {
        "oracle": "true ? methodResultID==magnitude : true;",
        "javadocTag": "@return a value with magnitude equal to {@code magnitude} and with the\nsame sign as the {@code sign} argument."
    },
    {
        "oracle": "true ? methodResultID==magnitude : true;",
        "javadocTag": "@return a value with magnitude equal to {@code magnitude} and with the\nsame sign as the {@code sign} argument."
    },
    {
        "oracle": "true ? methodResultID==magnitude : true;",
        "javadocTag": "@return a value with magnitude equal to {@code magnitude} and with the\nsame sign as the {@code sign} argument."
    },
    {
        "oracle": "o==null;",
        "javadocTag": "@throws NullArgumentException if {@code o} is {@code null}."
    },
    {
        "oracle": "o==null;",
        "javadocTag": "@throws NullArgumentException if {@code o} is {@code null}."
    },
    {
        "oracle": "(rowDimension>0) == false;",
        "javadocTag": "@throws NotStrictlyPositiveException if row or column dimension is not\npositive."
    },
    {
        "oracle": "p<0;",
        "javadocTag": "@throws NotPositiveException if {@code p < 0}"
    },
    {
        "oracle": "(this.isSquare()) == false;",
        "javadocTag": "@throws NonSquareMatrixException if the matrix is not square"
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "subMatrix.length==0;",
        "javadocTag": "@throws NoDataException if {@code subMatrix} is empty."
    },
    {
        "oracle": "subMatrix==null;",
        "javadocTag": "@throws NullArgumentException if {@code subMatrix} is {@code null}."
    },
    {
        "oracle": "(this.isSquare()) == false;",
        "javadocTag": "@throws NonSquareMatrixException if the matrix is not square."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "endRow<startRow || endColumn<startColumn;",
        "javadocTag": "@throws NumberIsTooSmallException if {@code endRow < startRow} or\n{@code endColumn < startColumn}."
    },
    {
        "oracle": "shape<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code shape <= 0}."
    },
    {
        "oracle": "shape<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code shape <= 0}."
    },
    {
        "oracle": "shape<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code shape <= 0}."
    },
    {
        "oracle": "shape<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code shape <= 0}."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "binCount<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code binCount <= 0}."
    },
    {
        "oracle": "binCount>0;",
        "javadocTag": "@param binCount number of bins. Must be strictly positive."
    },
    {
        "oracle": "binCount<=0;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code binCount <= 0}."
    },
    {
        "oracle": "binCount>0;",
        "javadocTag": "@param binCount number of bins. Must be strictly positive."
    },
    {
        "oracle": "in==null;",
        "javadocTag": "@throws NullArgumentException if in is null"
    },
    {
        "oracle": "url==null;",
        "javadocTag": "@throws NullArgumentException if url is null"
    },
    {
        "oracle": "file==null;",
        "javadocTag": "@throws NullArgumentException if file is null"
    },
    {
        "oracle": "true ? methodResultID==0 : true;",
        "javadocTag": "@return the point at which the function value is zero."
    },
    {
        "oracle": "coefficients==null;",
        "javadocTag": "@throws NullArgumentException if the {@code coefficients} is\n{@code null}."
    },
    {
        "oracle": "coefficients.length==0;",
        "javadocTag": "@throws NoDataException if the {@code coefficients} array is empty."
    },
    {
        "oracle": "coefficients==null;",
        "javadocTag": "@throws NullArgumentException if the {@code coefficients} is\n{@code null}"
    },
    {
        "oracle": "coefficients.length==0;",
        "javadocTag": "@throws NoDataException if the {@code coefficients} array is empty"
    },
    {
        "oracle": "coefficients==null;",
        "javadocTag": "@throws NullArgumentException if the {@code coefficients} is\n{@code null}."
    },
    {
        "oracle": "coefficients.length==0;",
        "javadocTag": "@throws NoDataException if the {@code coefficients} array is empty."
    },
    {
        "oracle": "coefficients==null;",
        "javadocTag": "@throws NullArgumentException if the {@code coefficients} is\n{@code null}"
    },
    {
        "oracle": "coefficients.length==0;",
        "javadocTag": "@throws NoDataException if the {@code coefficients} array is empty"
    },
    {
        "oracle": "window<1 && (window==DescriptiveStatistics.INFINITE_WINDOW) == false;",
        "javadocTag": "@throws MathIllegalArgumentException if window size is less than 1 but\nnot equal to {@link #INFINITE_WINDOW}"
    },
    {
        "oracle": "original==null;",
        "javadocTag": "@throws NullArgumentException if original is null"
    },
    {
        "oracle": "source==null || dest==null;",
        "javadocTag": "@throws NullArgumentException if either source or dest is null"
    },
    {
        "oracle": "starts<1;",
        "javadocTag": "@throws NotStrictlyPositiveException if {@code starts < 1}."
    },
    {
        "oracle": "starts==1;",
        "javadocTag": "@param starts Number of starts to perform. If {@code starts == 1},\nthe {@code optimize} methods will return the same solution as\n{@code optimizer} would."
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "nSteps<2;",
        "javadocTag": "@throws NumberIsTooSmallException if number of steps is smaller than 2"
    },
    {
        "oracle": "minStep>0;",
        "javadocTag": "@param minStep minimal step (must be positive even for backward\nintegration), the last step can be smaller than this"
    },
    {
        "oracle": "maxStep>0;",
        "javadocTag": "@param maxStep maximal step (must be positive even for backward\nintegration)"
    },
    {
        "oracle": "minStep>0;",
        "javadocTag": "@param minStep minimal step (must be positive even for backward\nintegration), the last step can be smaller than this"
    },
    {
        "oracle": "maxStep>0;",
        "javadocTag": "@param maxStep maximal step (must be positive even for backward\nintegration)"
    },
    {
        "oracle": "f==null || goalType==null || startPoint==null;",
        "javadocTag": "@throws org.apache.commons.math3.exception.NullArgumentException if\nany argument is {@code null}."
    },
    {
        "oracle": "data==null;",
        "javadocTag": "@throws NullArgumentException if either {@code data} or {@code data[0]}\nis {@code null}."
    },
    {
        "oracle": "data==null;",
        "javadocTag": "@throws NullArgumentException if either {@code data} or {@code data[0]}\nis {@code null}."
    },
    {
        "oracle": "(dimension>0) == false;",
        "javadocTag": "@throws IllegalArgumentException if dimension is not positive"
    },
    {
        "oracle": "(dimension>0) == false;",
        "javadocTag": "@throws IllegalArgumentException if dimension is not positive"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the length of the chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@param chromosomeRepresentation the inner array representation of the new chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@return new instance extended from FixedLengthChromosome with the given arrayRepresentation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param representation inner representation of the chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@param representation inner representation of the chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@param representation inner representation of the chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyList if {@code true}, the representation will be copied, otherwise it will be referenced."
    },
    {
        "oracle": ";",
        "javadocTag": "@param first first parent (p1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param second second parent (p2)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return pair of two children (c1,c2)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the two chromosomes is different"
    },
    {
        "oracle": ";",
        "javadocTag": "@param first the first chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@param second the second chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the pair of new chromosomes that resulted from the crossover."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the two chromosomes is different"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the beginnings of the next generation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param elitismRate how many best chromosomes will be directly transferred to the next generation [in %]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the elitism rate is outside the [0, 1] range"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the elitism rate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param chromosomes list of chromosomes in the population"
    },
    {
        "oracle": ";",
        "javadocTag": "@param populationLimit maximal size of the population"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elitismRate how many best chromosomes will be directly transferred to the next generation [in %]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if the population limit is not a positive number (&lt; 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if the list of chromosomes exceeds the population limit"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the elitism rate is outside the [0, 1] range"
    },
    {
        "oracle": ";",
        "javadocTag": "@param populationLimit maximal size of the population"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elitismRate how many best chromosomes will be directly transferred to the next generation [in %]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotPositiveException if the population limit is not a positive number (&lt; 1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the elitism rate is outside the [0, 1] range"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fitness"
    },
    {
        "oracle": ";",
        "javadocTag": "@param another another chromosome to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <ul>\n  <li>-1 if <code>another</code> is better than <code>this</code></li>\n  <li>1 if <code>another</code> is worse than <code>this</code></li>\n  <li>0 if the two chromosomes have the same fitness</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param another chromosome to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if <code>another</code> is equivalent to this chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@param population Population to search"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Chromosome with the same representation, or <code>null</code> if no such chromosome exists."
    },
    {
        "oracle": ";",
        "javadocTag": "@param population Population to search"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the two chromosomes is different"
    },
    {
        "oracle": ";",
        "javadocTag": "@param first the first chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@param second the second chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the pair of new chromosomes that resulted from the crossover"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the two chromosomes is different"
    },
    {
        "oracle": ";",
        "javadocTag": "@param pattern Message pattern."
    },
    {
        "oracle": ";",
        "javadocTag": "@param args Arguments."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <S> generic type of the sequence values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence the unpermuted sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param representation representation of the permutation ([0,1] vector)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sortedRepr sorted <code>representation</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list with the sequence values permuted according to the representation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException iff the length of the <code>sequence</code>,\n  <code>representation</code> or <code>sortedRepr</code> lists are not equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param another chromosome to compare"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true iff chromosomes encode the same permutation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l length of the permutation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return representation of a random permutation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l length of the permutation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return representation of an identity permutation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <S> type of the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data list of data determining the order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator how the data will be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list representation of the permutation corresponding to the parameters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <S> type of the data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param originalData the original, unpermuted data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param permutedData the data, somehow permuted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return representation of a permutation corresponding to the permutation\n  <code>originalData -> permutedData</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException iff the length of <code>originalData</code>\n  and <code>permutedData</code> lists are not equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException iff the <code>permutedData</code> and\n  <code>originalData</code> lists contain different data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l length of list to generate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return list of integers from 0 to l-1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param representation list of [0,1] values representing the permutation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@param representation array of [0,1] values representing the permutation"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InvalidRepresentationException iff the <code>representation</code> can not represent a valid chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@param population the population to test."
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if this stopping condition is met by the given population,\n  <code>false</code> otherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence the unpermuted (original) sequence of objects"
    },
    {
        "oracle": ";",
        "javadocTag": "@return permutation of <code>sequence</code> represented by this permutation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the second chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c1 the first chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c2 the second chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@param population the population from which the chromosomes are chosen."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the selected chromosomes."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the tournament arity is bigger than the population size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param population the population from which the chromosomes are chosen."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the selected chromosome."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the tournament arity is bigger than the population size"
    },
    {
        "oracle": ";",
        "javadocTag": "@return arity of the tournament"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arity arity of the tournament"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arity how many chromosomes will be drawn to the tournament"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of crossover points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param first first parent (p1)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param second second parent (p2)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return pair of two children (c1,c2)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the two chromosomes is different"
    },
    {
        "oracle": ";",
        "javadocTag": "@param first the first chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@param second the second chromosome"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the pair of new chromosomes that resulted from the crossover"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the two chromosomes is different"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException is {@code endRow < startRow} of\n{@code endColumn < startColumn}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param selectedRows Array of row indices."
    },
    {
        "oracle": ";",
        "javadocTag": "@param selectedColumns Array of column indices."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the matrix containing the data in the\nspecified rows and columns."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if row or column selections are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startRow Initial row index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param endRow Final row index (inclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startColumn Initial column index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param endColumn Final column index (inclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param destination The array where the submatrix data should be copied\n(if larger than rows/columns counts, only the upper-left part will be modified)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the dimensions of\n{@code destination} are not large enough to hold the submatrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param selectedRows Array of row indices."
    },
    {
        "oracle": ";",
        "javadocTag": "@param selectedColumns Array of column indices."
    },
    {
        "oracle": ";",
        "javadocTag": "@param destination Arrays where the submatrix data should be copied\n(if larger than rows/columns counts, only the upper-left part will be used)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the dimensions of\n{@code destination} do not match those of {@code this}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the indices are not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param subMatrix Array containing the submatrix replacement data."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row coordinate of the top-left element to be replaced."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column coordinate of the top-left element to be replaced."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code subMatrix} does not fit into this\nmatrix from element in {@code (row, column)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if a row or column of {@code subMatrix} is empty."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code subMatrix} is not\nrectangular (not all rows have the same length)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row to be fetched."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a row matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified row index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix Row matrix (must have one row and the same number\nof columns as the instance)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified row index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the matrix dimensions do not match one instance row."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column to be fetched."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a column matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified column index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix column matrix (must have one column and the same\nnumber of rows as the instance)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified column index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the matrix dimensions do\nnot match one instance column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row to be fetched"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a row vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified row index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector row vector (must have the same number of columns\nas the instance)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified row index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the vector dimension does not\nmatch one instance row."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column to be fetched."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a column vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified column index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param vector Column vector (must have the same number of rows\nas the instance)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified column index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the vector dimension does not\nmatch one instance column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row to be fetched."
    },
    {
        "oracle": ";",
        "javadocTag": "@return array of entries in the row."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified row index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param array Row matrix (must have the same number of columns as\nthe instance)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified row index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the array size does not match\none instance row."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column the column to be fetched"
    },
    {
        "oracle": ";",
        "javadocTag": "@return array of entries in the column"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified column index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column the column to be set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array column array (must have the same number of rows as the instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified column index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the array size does not match\none instance column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row row location of entry to be fetched"
    },
    {
        "oracle": ";",
        "javadocTag": "@param column column location of entry to be fetched"
    },
    {
        "oracle": ";",
        "javadocTag": "@return matrix entry in row,column"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the row or column index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row row location of entry to be set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param column column location of entry to be set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value matrix entry to be set in row,column"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the row or column index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row location of entry to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column location of entry to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param increment Value to add to the current matrix entry in\n{@code (row, column)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the row or column index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row location of entry to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column location of entry to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param factor Multiplication factor for the current matrix entry\nin {@code (row,column)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the row or column index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@return transpose matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return trace"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the vector to operate on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this * v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the number of columns of\n{@code this} matrix is not equal to the size of the vector {@code v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the vector to operate on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this * v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the number of columns of\n{@code this} matrix is not equal to the size of the vector {@code v}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the row vector to premultiply by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code v * this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the number of rows of {@code this}\nmatrix is not equal to the size of the vector {@code v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param v the row vector to premultiply by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code v * this}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the number of rows of {@code this}\nmatrix is not equal to the size of the vector {@code v}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor visitor used to process all matrix entries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\nof the walk"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "this.isEmpty();",
        "javadocTag": "@throws NoSuchElementException if this map is empty"
    },
    {
        "oracle": "this.isEmpty();",
        "javadocTag": "@throws NoSuchElementException if this map is empty"
    },
    {
        "oracle": "true ? methodResultID.equals(value) : true;",
        "javadocTag": "@return the value previously mapped to the key"
    },
    {
        "oracle": "closure==null;",
        "javadocTag": "@throws NullPointerException if the closure is null"
    },
    {
        "oracle": "(closure==null) == false;",
        "javadocTag": "@param closure the closure to run each time in the transformer, not null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if the predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to run each time in the transformer, not null"
    },
    {
        "oracle": "factory==null;",
        "javadocTag": "@throws NullPointerException if the factory is null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory to run each time in the transformer, not null"
    },
    {
        "oracle": "transformers==null;",
        "javadocTag": "@throws NullPointerException if the transformers array or any of the transformers is null"
    },
    {
        "oracle": "transformers==null;",
        "javadocTag": "@throws NullPointerException if the transformers collection or any of the transformers is null"
    },
    {
        "oracle": "predicate==null || trueTransformer==null;",
        "javadocTag": "@throws NullPointerException if either the predicate or transformer is null"
    },
    {
        "oracle": "true ? methodResultID.equals(trueTransformer) : true;",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": "predicate==null || trueTransformer==null;",
        "javadocTag": "@throws NullPointerException if either the predicate or transformer is null"
    },
    {
        "oracle": "true ? methodResultID.equals(trueTransformer) : true;",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": "predicate==null || trueTransformer==null;",
        "javadocTag": "@throws NullPointerException if either the predicate or transformer is null"
    },
    {
        "oracle": "true ? methodResultID.equals(trueTransformer) : true;",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": "predicates==null || transformers==null;",
        "javadocTag": "@throws NullPointerException if any element in the arrays is null"
    },
    {
        "oracle": "predicates==null || transformers==null;",
        "javadocTag": "@throws NullPointerException if any element in the arrays is null"
    },
    {
        "oracle": "defaultTransformer==null;",
        "javadocTag": "@param defaultTransformer the default to call if no predicate matches, null means return null"
    },
    {
        "oracle": "true ? methodResultID.equals(defaultTransformer) : true;",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": "predicatesAndTransformers==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "objectsAndTransformers==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "methodName==null;",
        "javadocTag": "@throws NullPointerException if the methodName is null."
    },
    {
        "oracle": "(methodName==null) == false;",
        "javadocTag": "@param methodName the method name to call on the input object, may not be null"
    },
    {
        "oracle": "methodName==null;",
        "javadocTag": "@throws NullPointerException if the method name is null"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": "(collection==null) == false;",
        "javadocTag": "@param collection the collection to decorate, must not be null"
    },
    {
        "oracle": "collection==null || lock==null;",
        "javadocTag": "@throws NullPointerException if the collection or lock is null"
    },
    {
        "oracle": "(collection==null) == false;",
        "javadocTag": "@param collection the collection to decorate, must not be null"
    },
    {
        "oracle": "(lock==null) == false;",
        "javadocTag": "@param lock the lock object to use, must not be null"
    },
    {
        "oracle": "coll==null;",
        "javadocTag": "@throws NullPointerException if collection is null"
    },
    {
        "oracle": "(coll==null) == false;",
        "javadocTag": "@param coll the collection to decorate, must not be null"
    },
    {
        "oracle": "set==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if set or transformer is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "set==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if set or transformer is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "set==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if set or transformer is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "maxSize<1;",
        "javadocTag": "@throws IllegalArgumentException if the maximum size is less than one"
    },
    {
        "oracle": "maxSize<1;",
        "javadocTag": "@throws IllegalArgumentException if the initial size is larger than {@code maxSize}"
    },
    {
        "oracle": "initialSize<0;",
        "javadocTag": "@throws IllegalArgumentException if the maximum size is less than one"
    },
    {
        "oracle": "maxSize<1;",
        "javadocTag": "@throws IllegalArgumentException if the maximum size is less than one"
    },
    {
        "oracle": "maxSize<1;",
        "javadocTag": "@throws IllegalArgumentException if the load factor is less than zero"
    },
    {
        "oracle": "loadFactor<0;",
        "javadocTag": "@throws IllegalArgumentException if the maximum size is less than one"
    },
    {
        "oracle": "maxSize<1;",
        "javadocTag": "@throws IllegalArgumentException if the load factor is less than zero"
    },
    {
        "oracle": "initialSize<0;",
        "javadocTag": "@throws IllegalArgumentException if the initial size is negative or larger than the maximum size"
    },
    {
        "oracle": "loadFactor<0;",
        "javadocTag": "@throws IllegalArgumentException if the maximum size is less than one"
    },
    {
        "oracle": "maxSize<1;",
        "javadocTag": "@throws IllegalArgumentException if the load factor is less than zero"
    },
    {
        "oracle": "loadFactor<0;",
        "javadocTag": "@throws IllegalArgumentException if the maximum size is less than one"
    },
    {
        "oracle": "maxSize<1;",
        "javadocTag": "@throws IllegalArgumentException if the load factor is less than zero"
    },
    {
        "oracle": "initialSize<0;",
        "javadocTag": "@throws IllegalArgumentException if the initial size is negative or larger than the maximum size"
    },
    {
        "oracle": "loadFactor<0;",
        "javadocTag": "@throws IllegalArgumentException if the maximum size is less than one"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "((map==null)==false) && (map.isEmpty());",
        "javadocTag": "@throws IllegalArgumentException if the map is empty"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "((map==null)==false) && (map.isEmpty());",
        "javadocTag": "@throws IllegalArgumentException if the map is empty"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return {@code true}"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to wrap, must not be null"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if list is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if list is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "this.add(element);",
        "javadocTag": "@param element the object to add at the specified index"
    },
    {
        "oracle": "set==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if set or transformer is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "set==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if set or transformer is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "set==null || transformer==null;",
        "javadocTag": "@throws NullPointerException if set or transformer is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "(transformer==null) == false;",
        "javadocTag": "@param transformer the transformer to use for conversion, must not be null"
    },
    {
        "oracle": "(comp==null) == false;",
        "javadocTag": "@param comp the comparator to use to sort; must not be null,\n  unless you'll be invoking {@link #setComparator(Comparator)} later on."
    },
    {
        "oracle": "(comp==null) == false;",
        "javadocTag": "@param comp the comparator to use to sort; must not be null,\n  unless you'll be invoking {@link #setComparator(Comparator)} later on."
    },
    {
        "oracle": "a==null || b==null;",
        "javadocTag": "@throws NullPointerException if either iterator is null"
    },
    {
        "oracle": "(comp==null) == false;",
        "javadocTag": "@param comp the comparator to use to sort; must not be null,\n  unless you'll be invoking {@link #setComparator(Comparator)} later on."
    },
    {
        "oracle": "iterators==null;",
        "javadocTag": "@throws NullPointerException if iterators array is or contains null"
    },
    {
        "oracle": "(comp==null) == false;",
        "javadocTag": "@param comp the comparator to use to sort; must not be null,\n  unless you'll be invoking {@link #setComparator(Comparator)} later on."
    },
    {
        "oracle": "iterators==null || ((iterators==null)==false) && (iterators.contains(null));",
        "javadocTag": "@throws NullPointerException if the iterators collection is or contains null"
    },
    {
        "oracle": "(comp==null) == false;",
        "javadocTag": "@param comp the comparator to use to sort; must not be null,\n  unless you'll be invoking {@link #setComparator(Comparator)} later on."
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to add to the collation, must not be null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "bag==null;",
        "javadocTag": "@throws NullPointerException if bag is null"
    },
    {
        "oracle": "(bag==null) == false;",
        "javadocTag": "@param bag the bag to decorate, must not be null"
    },
    {
        "oracle": "coll==null;",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": "(coll==null) == false;",
        "javadocTag": "@param coll the collection to decorate, must not be null"
    },
    {
        "oracle": "this.isEmpty();",
        "javadocTag": "@throws java.util.NoSuchElementException if this map is empty"
    },
    {
        "oracle": "this.isEmpty();",
        "javadocTag": "@throws java.util.NoSuchElementException if this map is empty"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "keyPredicate==null;",
        "javadocTag": "@param keyPredicate the predicate to validate the keys, null means no check"
    },
    {
        "oracle": "valuePredicate==null;",
        "javadocTag": "@param valuePredicate the predicate to validate to values, null means no check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to increment"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the updated index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to decrement"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the updated index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an iterator over this queue's elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param size the size of the queue (cannot be changed)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type of the elements in the queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new predicated queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the queue contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object being added"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the result of adding to the underlying queue"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the add is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the Queue contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new empty FluentIterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param singleton the singleton element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new FluentIterable containing the singleton"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the elements to be contained in the FluentIterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new FluentIterable containing the provided elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new FluentIterable wrapping the provided iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elements the elements to append to the iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, combining this iterable with the elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, combining this iterable with other"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, collating this iterable with the other in natural order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param comparator the comparator to define an ordering, may be null,\n  in which case natural ordering will be used"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, collating this iterable with the other in natural order"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable with the same contents as this iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate used to filter elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, providing a filtered view of this iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxSize the maximum number of elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, providing a bounded view of this iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, providing a looping view of this iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, providing a reversed view of this iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param elementsToSkip the number of elements to skip"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, providing a view of this iterable by skipping\n  the first N elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer applied to each element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, providing a transformed view of this iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, providing a unique view of this iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, providing an unmodifiable view of this iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, interleaving this iterable with others"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new iterable, interleaving this iterable with others"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if either of the provided iterables is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an Enumeration over the elements of this iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if all elements contained in this iterable match the predicate,\n  false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if at least one element contained in this iterable matches the predicate,\n  false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if this iterable does not contain any elements, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the object is contained in this iterable, false otherwise"
    },
    {
        "oracle": ";",
        "javadocTag": "@param position the position of the element to return"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the element"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the provided position is outside the\n  valid range of this iterable: [0, size)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size of this iterable"
    },
    {
        "oracle": ";",
        "javadocTag": "@param collection the collection to add the elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param arrayClass the class of array to create"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of the iterable contents"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArrayStoreException if arrayClass is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of the iterable contents"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the input/output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the input/output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constantToReturn the constant object to return each time in the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the input/output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the input/output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformers an array of transformers to chain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the input/output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformers a collection of transformers to chain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the input / output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to switch on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param trueTransformer the transformer called if the predicate is true"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to switch on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param trueTransformer the transformer called if the predicate is true"
    },
    {
        "oracle": ";",
        "javadocTag": "@param falseTransformer the transformer called if the predicate is false"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": "expectedSize<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code expectedSize} is negative"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if {@code elements} or any of its contents is\n     null"
    },
    {
        "oracle": "expectedSize<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code expectedSize} is negative"
    },
    {
        "oracle": "comparator==null;",
        "javadocTag": "@throws NullPointerException if {@code comparator} is null"
    },
    {
        "oracle": "(((map==null)==false) && (map.isEmpty())) == false;",
        "javadocTag": "@throws IllegalArgumentException if {@code map} is not empty"
    },
    {
        "oracle": "sets==null;",
        "javadocTag": "@throws NullPointerException if {@code sets}, any one of the {@code sets},\n    or any element of a provided set is null"
    },
    {
        "oracle": "sets==null;",
        "javadocTag": "@throws NullPointerException if {@code sets}, any one of the {@code sets},\n    or any element of a provided set is null"
    },
    {
        "oracle": "set==null || ((set==null)==false) && (set.contains(null));",
        "javadocTag": "@throws NullPointerException if {@code set} is or contains {@code null}"
    },
    {
        "oracle": "expectedRows<0 || expectedCellsPerRow<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code expectedRows} or {@code\n    expectedCellsPerRow} is negative"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "reference==null;",
        "javadocTag": "@throws NullPointerException if {@code reference} is null"
    },
    {
        "oracle": "array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "(array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code int} values"
    },
    {
        "oracle": "array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "(array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code int} values"
    },
    {
        "oracle": "minLength<0 || padding<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code minLength} or {@code padding} is\n    negative"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if {@code collection} or any of its elements\n    is null"
    },
    {
        "oracle": "expectedKeys<0 || expectedValuesPerKey<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code expectedKeys} or {@code\n     expectedValuesPerKey} is negative"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "distinctElements<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code distinctElements} is negative"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws NullPointerException if any of {@code values} is null"
    },
    {
        "oracle": "(this.hasNext()) == false;",
        "javadocTag": "@throws IllegalStateException if there has been a call to {@link #peek()}\n    since the most recent call to {@link #next()} and this implementation\n    does not support this sequence of calls (optional)"
    },
    {
        "oracle": "element==null;",
        "javadocTag": "@throws NullPointerException if {@code element} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "elements==null;",
        "javadocTag": "@throws NullPointerException if any of {@code elements} is null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "expectedInsertions>0;",
        "javadocTag": "@param expectedInsertions the number of expected insertions to the constructed\n    {@code BloomFilter<T>}; must be positive"
    },
    {
        "oracle": "fpp>0 && fpp<1.0;",
        "javadocTag": "@param fpp the desired false positive probability (must be positive and less than 1.0)"
    },
    {
        "oracle": "expectedInsertions>0;",
        "javadocTag": "@param expectedInsertions the number of expected insertions to the constructed\n    {@code BloomFilter<T>}; must be positive"
    },
    {
        "oracle": "fpp>0 && fpp<1.0;",
        "javadocTag": "@param fpp the desired false positive probability (must be positive and less than 1.0)"
    },
    {
        "oracle": "expectedInsertions>0;",
        "javadocTag": "@param expectedInsertions the number of expected insertions to the constructed\n    {@code BloomFilter<T>}; must be positive"
    },
    {
        "oracle": "expectedInsertions>0;",
        "javadocTag": "@param expectedInsertions the number of expected insertions to the constructed\n    {@code BloomFilter<T>}; must be positive"
    },
    {
        "oracle": "n>0;",
        "javadocTag": "@param n expected insertions (must be positive)"
    },
    {
        "oracle": "m>0;",
        "javadocTag": "@param m total number of bits in Bloom filter (must be positive)"
    },
    {
        "oracle": "n>0;",
        "javadocTag": "@param n expected insertions (must be positive)"
    },
    {
        "oracle": "((interfaceType==null)==false) && (interfaceType.isEnum());",
        "javadocTag": "@throws IllegalArgumentException if {@code interfaceType} is a regular\n    class, enum, or annotation type, rather than an interface"
    },
    {
        "oracle": "interruptible==true;",
        "javadocTag": "@throws InterruptedException if {@code interruptible} is true and our\n    thread is interrupted during execution"
    },
    {
        "oracle": "throwable!=null;",
        "javadocTag": "@param throwable the non-null {@code Throwable} to extract causes from"
    },
    {
        "oracle": "key!=null;",
        "javadocTag": "@param key the non-null key whose value should be loaded"
    },
    {
        "oracle": "true ? (methodResultID==null) == false : true;",
        "javadocTag": "@return the value associated with {@code key}; <b>must not be null</b>"
    },
    {
        "oracle": "key!=null;",
        "javadocTag": "@param key the non-null key whose value should be loaded"
    },
    {
        "oracle": "oldValue!=null;",
        "javadocTag": "@param oldValue the non-null old value corresponding to {@code key}"
    },
    {
        "oracle": "true ? (methodResultID==null) == false : true;",
        "javadocTag": "@return the future new value associated with {@code key};\n    <b>must not be null, must not return null</b>"
    },
    {
        "oracle": "(function==null) == false;",
        "javadocTag": "@param function the function to be used for loading values; must never return {@code null}"
    },
    {
        "oracle": "(supplier==null) == false;",
        "javadocTag": "@param supplier the supplier to be used for loading values; must never return {@code null}"
    },
    {
        "oracle": "array!=null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null && (array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code double} values"
    },
    {
        "oracle": "array!=null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null && (array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code double} values"
    },
    {
        "oracle": "minLength<0 || padding<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code minLength} or {@code padding} is\n    negative"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if {@code collection} or any of its elements\n    is null"
    },
    {
        "oracle": "result==null;",
        "javadocTag": "@param result the result to return on successful completion. If you don't\n    need a particular result, consider using constructions of the form:\n    {@code ListenableFuture<?> f = ListenableFutureTask.create(runnable,\n    null)}"
    },
    {
        "oracle": "array!= null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!= null && (array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code float} values"
    },
    {
        "oracle": "array!= null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!= null && (array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code float} values"
    },
    {
        "oracle": "minLength<0 || padding<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code minLength} or {@code padding} is\n    negative"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if {@code collection} or any of its elements\n    is null"
    },
    {
        "oracle": "expectedSize<0;",
        "javadocTag": "@throws IllegalArgumentException if the specified expected size is negative"
    },
    {
        "oracle": "array!=null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null && (array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code long} values"
    },
    {
        "oracle": "array!=null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null && (array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code long} values"
    },
    {
        "oracle": "minLength<0 || padding<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code minLength} or {@code padding} is\n    negative"
    },
    {
        "oracle": "collection==null;",
        "javadocTag": "@throws NullPointerException if {@code collection} or any of its elements\n    is null"
    },
    {
        "oracle": "array!=null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null && (array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of unsigned {@code long} values"
    },
    {
        "oracle": "array!=null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null && (array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of unsigned {@code long} values"
    },
    {
        "oracle": "divisor==0;",
        "javadocTag": "@throws ArithmeticException if divisor is 0"
    },
    {
        "oracle": "divisor==0;",
        "javadocTag": "@throws ArithmeticException if divisor is 0"
    },
    {
        "oracle": "s==null;",
        "javadocTag": "@throws NullPointerException if {@code s} is null\n        (in contrast to {@link Long#parseLong(String)})"
    },
    {
        "oracle": "s==null;",
        "javadocTag": "@throws NullPointerException if {@code s} is null\n        (in contrast to {@link Long#parseLong(String)})"
    },
    {
        "oracle": "plusForSpace==true;",
        "javadocTag": "@param plusForSpace true if ASCII space should be escaped to {@code +}\n       rather than {@code %20}"
    },
    {
        "oracle": "expectedSize<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code expectedSize} is negative"
    },
    {
        "oracle": "expectedSize<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code expectedSize} is negative"
    },
    {
        "oracle": "keys==null;",
        "javadocTag": "@throws NullPointerException if any element of {@code keys} is\n    {@code null}, or if {@code valueFunction} produces {@code null}\n    for any key"
    },
    {
        "oracle": "keys==null;",
        "javadocTag": "@throws NullPointerException if any element of {@code keys} is\n    {@code null}, or if {@code valueFunction} produces {@code null}\n    for any key"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws NullPointerException if any elements of {@code values} is null, or\n        if {@code keyFunction} produces {@code null} for any value"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@throws NullPointerException if any elements of {@code values} is null, or\n        if {@code keyFunction} produces {@code null} for any value"
    },
    {
        "oracle": "((c==null)==false) && (c.contains(o)) ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return {@code true} if {@code c} contains {@code o}"
    },
    {
        "oracle": "array!= null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null && (array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code short} values"
    },
    {
        "oracle": "array!=null && array.length==0;",
        "javadocTag": "@throws IllegalArgumentException if {@code array} is empty"
    },
    {
        "oracle": "array!=null && (array.length==0) == false;",
        "javadocTag": "@param array a <i>nonempty</i> array of {@code short} values"
    },
    {
        "oracle": "minLength<0 || padding<0;",
        "javadocTag": "@throws IllegalArgumentException if {@code minLength} or {@code padding} is\n    negative"
    },
    {
        "oracle": "true ? methodResultID.equals(MultiSetUtils.EMPTY_MULTISET) : true;",
        "javadocTag": "@return an empty MultiSet"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the list to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate predicate to switch on, not null"
    },
    {
        "oracle": "(trueClosure==null) == false;",
        "javadocTag": "@param trueClosure closure used if true, not null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate predicate to switch on, not null"
    },
    {
        "oracle": "(trueClosure==null) == false;",
        "javadocTag": "@param trueClosure closure used if true, not null"
    },
    {
        "oracle": "(falseClosure==null) == false;",
        "javadocTag": "@param falseClosure closure used if false, not null"
    },
    {
        "oracle": "predicate==null || trueClosure==null;",
        "javadocTag": "@throws NullPointerException if either argument is null"
    },
    {
        "oracle": "predicate==null || trueClosure==null || falseClosure==null;",
        "javadocTag": "@throws NullPointerException if any argument is null"
    },
    {
        "oracle": "predicate==null;",
        "javadocTag": "@throws NullPointerException if the predicate is null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to decorate, not null"
    },
    {
        "oracle": "values==null;",
        "javadocTag": "@param values the values to add to the collection at the key, null ignored"
    },
    {
        "oracle": "list==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if list or predicate is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "list==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if list or predicate is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use for validation, must not be null"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if <code>array</code> is <code>null</code>"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if <code>array</code> is <code>null</code>"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if <code>array</code> is <code>null</code>"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory to call, not null"
    },
    {
        "oracle": "factory==null;",
        "javadocTag": "@throws NullPointerException if the factory is null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory to call, not null"
    },
    {
        "oracle": "true ? methodResultID.equals(this) : true;",
        "javadocTag": "@return the transformed result"
    },
    {
        "oracle": "initialSize<0;",
        "javadocTag": "@throws IllegalArgumentException if the specified initial size\n is negative"
    },
    {
        "oracle": "this.isEmpty() ? methodResultID == true : methodResultID == false;",
        "javadocTag": "@return true if the stack is currently empty"
    },
    {
        "oracle": "this.isEmpty();",
        "javadocTag": "@throws EmptyStackException if the stack is empty"
    },
    {
        "oracle": "this.isEmpty();",
        "javadocTag": "@throws EmptyStackException if the stack is empty"
    },
    {
        "oracle": "true ? methodResultID.equals(item) : true;",
        "javadocTag": "@return the item just pushed"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException if the key is null"
    },
    {
        "oracle": "value==null;",
        "javadocTag": "@throws NullPointerException if the value is null"
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException if the key is null"
    },
    {
        "oracle": "this.containsKey(key) ? methodResultID==null : true;",
        "javadocTag": "@return the value to which this map maps the specified key,\n or null if the map contains no mapping for this key"
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException if the key is null"
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException if the key is null"
    },
    {
        "oracle": "value==null;",
        "javadocTag": "@throws NullPointerException if the value is null"
    },
    {
        "oracle": "this.containsValue(value) ? methodResultID==null : true;",
        "javadocTag": "@return the key to which this map maps the specified value,\n or null if the map contains no mapping for this value."
    },
    {
        "oracle": "value==null;",
        "javadocTag": "@throws NullPointerException if the value is null"
    },
    {
        "oracle": "this.isEmpty();",
        "javadocTag": "@throws NoSuchElementException if this map is empty"
    },
    {
        "oracle": "this.isEmpty();",
        "javadocTag": "@throws NoSuchElementException if this map is empty"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "initialCapacity<0;",
        "javadocTag": "@throws IllegalArgumentException if the initial capacity is negative"
    },
    {
        "oracle": "initialCapacity<0;",
        "javadocTag": "@throws IllegalArgumentException if the initial capacity is negative"
    },
    {
        "oracle": "loadFactor<0;",
        "javadocTag": "@throws IllegalArgumentException if the load factor is less than zero"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "list==null || factory==null;",
        "javadocTag": "@throws NullPointerException if list or factory is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory to use for creation, must not be null"
    },
    {
        "oracle": "list==null || factory==null;",
        "javadocTag": "@throws NullPointerException if list or factory is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "(factory==null) == false;",
        "javadocTag": "@param factory the factory to use for creation, must not be null"
    },
    {
        "oracle": "node==null;",
        "javadocTag": "@throws NullPointerException if node is null"
    },
    {
        "oracle": "(((node==null)==false) && (node.hasChildNodes()));",
        "javadocTag": "@param node Node, who's child nodes are wrapped by this class. Must not be null"
    },
    {
        "oracle": "nodeList==null;",
        "javadocTag": "@throws NullPointerException if nodeList is null"
    },
    {
        "oracle": "(nodeList==null) == false;",
        "javadocTag": "@param nodeList node list, which is wrapped by this class. Must not be null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "(pair==null) == false;",
        "javadocTag": "@param pair the pair to copy, must not be null"
    },
    {
        "oracle": "entry==null;",
        "javadocTag": "@throws NullPointerException if the entry is null"
    },
    {
        "oracle": "(entry==null) == false;",
        "javadocTag": "@param entry the entry to copy, must not be null"
    },
    {
        "oracle": "true ? methodResultID==true : true;",
        "javadocTag": "@return true always"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "keyTransformer==null;",
        "javadocTag": "@param keyTransformer the transformer to use for key conversion, null means no conversion"
    },
    {
        "oracle": "valueTransformer==null;",
        "javadocTag": "@param valueTransformer the transformer to use for value conversion, null means no conversion"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "keyTransformer==null;",
        "javadocTag": "@param keyTransformer the transformer to use for key conversion, null means no transformation"
    },
    {
        "oracle": "valueTransformer==null;",
        "javadocTag": "@param valueTransformer the transformer to use for value conversion, null means no transformation"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "keyTransformer==null;",
        "javadocTag": "@param keyTransformer the transformer to use for key conversion, null means no transformation"
    },
    {
        "oracle": "valueTransformer==null;",
        "javadocTag": "@param valueTransformer the transformer to use for value conversion, null means no transformation"
    },
    {
        "oracle": "true ? methodResultID.equals(map) : true;",
        "javadocTag": "@return the transformed object"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to check, not cloned, not null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates array is null"
    },
    {
        "oracle": "Arrays.stream(predicates).anyMatch(jdVar -> jdVar==null);",
        "javadocTag": "@throws NullPointerException if any predicate in the array is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to check, cloned, not null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates array is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to check, cloned, not null"
    },
    {
        "oracle": "coll==null;",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": "true ? methodResultID.equals(this.getTransformer()) : true;",
        "javadocTag": "@return the transformed object"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if list is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if list is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to decorate, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": "set==null;",
        "javadocTag": "@throws NullPointerException if set is null"
    },
    {
        "oracle": "(set==null) == false;",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": "(map==null) == false;",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix matrix to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a rank-transformed matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of NaN positions in the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param indices a set containing the indices to be removed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the input array without the values at the specified indices"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rankingAlgorithm ranking algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dataMatrix matrix of data with columns representing\nvariables to correlate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dataMatrix matrix of data with columns representing\nvariables to correlate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rankingAlgorithm ranking algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximum radius of the neighborhood"
    },
    {
        "oracle": ";",
        "javadocTag": "@return minimum number of points needed for a cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the points to cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of clusters"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cluster Cluster to expand"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Point to add to cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@param neighbors List of neighbors"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the data set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visited the set of already visited points"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the expanded cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point the point to look for"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points possible neighbors"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the List of neighbors"
    },
    {
        "oracle": ";",
        "javadocTag": "@param one first list"
    },
    {
        "oracle": ";",
        "javadocTag": "@param two second list"
    },
    {
        "oracle": ";",
        "javadocTag": "@return merged lists"
    },
    {
        "oracle": ";",
        "javadocTag": "@param eps maximum radius of the neighborhood to be considered"
    },
    {
        "oracle": ";",
        "javadocTag": "@param minPts minimum number of points needed for a cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference (not a copy!) to the wrapped array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point the n-dimensional point in integer space"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point point to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return points contained in the cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@param center the point which is to be the center of this cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a reference (not a copy!) to the wrapped array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point the n-dimensional point in integer space"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the point to compute the distance from"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the distance from the given point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the Collection of points to compute the centroid of"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the centroid of the given Collection of Points"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the points to cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the number of clusters to split the data into"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numTrials number of trial runs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterationsPerTrial the maximum number of iterations to run the algorithm\n    for at each trial run.  If negative, no maximum will be used"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of clusters containing the points"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if an empty cluster is encountered and the\n{@link #emptyStrategy} is set to {@code ERROR}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the points to cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the number of clusters to split the data into"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations the maximum number of iterations to run the algorithm\n    for.  If negative, no maximum will be used"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list of clusters containing the points"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if an empty cluster is encountered and the\n{@link #emptyStrategy} is set to {@code ERROR}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> type of the points to cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clusters the {@link Cluster}s to add the points to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the points to add to the given {@link Cluster}s"
    },
    {
        "oracle": ";",
        "javadocTag": "@param assignments points assignments to clusters"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of points assigned to different clusters as the iteration before"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> type of the points to cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@param points the points to choose the initial centers from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the number of centers to choose"
    },
    {
        "oracle": ";",
        "javadocTag": "@param random random generator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial centers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clusters the {@link Cluster}s to search"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random point from the selected cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if clusters are all empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clusters the {@link Cluster}s to search"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random point from the selected cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if clusters are all empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clusters the {@link Cluster}s to search"
    },
    {
        "oracle": ";",
        "javadocTag": "@return point farthest to its cluster center"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ConvergenceException if clusters are all empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> type of the points to cluster"
    },
    {
        "oracle": ";",
        "javadocTag": "@param clusters the {@link Cluster}s to search"
    },
    {
        "oracle": ";",
        "javadocTag": "@param point the point to find the nearest {@link Cluster} for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the index of the nearest {@link Cluster} to the given point"
    },
    {
        "oracle": ";",
        "javadocTag": "@param random random generator to use for choosing initial centers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param random random generator to use for choosing initial centers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param emptyStrategy strategy to use for handling empty clusters that\nmay appear during algorithm iterations"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample1 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample2 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return t statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if the arrays are empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the arrays is not equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample1 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample2 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return p-value for t-test"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if the arrays are empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the arrays is not equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample1 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sample2 array of sample data values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha significance level of the test"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the null hypothesis can be rejected with\nconfidence 1 - alpha"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoDataException if the arrays are empty"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of the arrays is not equal"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if <code>alpha</code> is not in the range (0, 0.5]"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MaxCountExceededException if an error occurs computing the p-value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu comparison constant"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observed array of values"
    },
    {
        "oracle": ";",
        "javadocTag": "@return t statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu comparison constant"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random string of hex characters of length {@code len}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower lower bound for generated integer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper upper bound for generated integer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower lower bound for generated integer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper upper bound for generated integer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean the mean of the Poisson distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random value following the specified Poisson distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mu the mean of the distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sigma the standard deviation of the distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random value following the specified Gaussian distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean the mean of the distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random value following the specified exponential distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower the exclusive lower bound of the support"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper the exclusive upper bound of the support"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a uniformly distributed random value between lower and upper\n(exclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if one of the bounds is infinite"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotANumberException if one of the bounds is NaN"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower the lower bound of the support"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper the exclusive upper bound of the support"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lowerInclusive {@code true} if the lower bound is inclusive"
    },
    {
        "oracle": ";",
        "javadocTag": "@return uniformly distributed random value in the {@code (lower, upper)}\ninterval, if {@code lowerInclusive} is {@code false}, or in the\n{@code [lower, upper)} interval, if {@code lowerInclusive} is\n{@code true}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if one of the bounds is infinite"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotANumberException if one of the bounds is NaN"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the domain of the permutation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the size of the permutation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random {@code k}-permutation of {@code n}, as an array of\nintegers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param c the collection to be sampled"
    },
    {
        "oracle": ";",
        "javadocTag": "@param k the size of the sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random sample of {@code k} elements from {@code c}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random vector as an array of double."
    },
    {
        "oracle": ";",
        "javadocTag": "@param len the desired string length."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the random string."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng random generator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n the bound on the random number to be returned.  Must be\npositive."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a pseudorandom, uniformly distributed {@code long}\nvalue between 0 (inclusive) and n (exclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if n is not positive."
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape the median of the Gamma distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale the scale parameter of the Gamma distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Gamma(shape, scale) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param populationSize the population size of the Hypergeometric distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfSuccesses number of successes in the population of the Hypergeometric distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sampleSize the sample size of the Hypergeometric distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Hypergeometric(numberOfSuccesses, sampleSize) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r the number of successes of the Pascal distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param p the probability of success of the Pascal distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Pascal(r, p) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param df the degrees of freedom of the T distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value from the T(df) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param shape the shape parameter of the Weibull distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale the scale parameter of the Weibull distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Weibull(shape, size) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfElements the number of elements of the ZipfDistribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param exponent the exponent of the ZipfDistribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Zipf(numberOfElements, exponent) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha first distribution shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param beta second distribution shape parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the beta(alpha, beta) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfTrials number of trials of the Binomial distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param probabilityOfSuccess probability of success of the Binomial distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Binomial(numberOfTrials, probabilityOfSuccess) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param median the median of the Cauchy distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale the scale parameter of the Cauchy distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the Cauchy(median, scale) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param df the degrees of freedom of the ChiSquare distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the ChiSquare(df) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numeratorDf the numerator degrees of freedom of the F distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@param denominatorDf the denominator degrees of freedom of the F distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@return random value sampled from the F(numeratorDf, denominatorDf) distribution"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if one of the bounds is infinite"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotANumberException if one of the bounds is NaN"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotFiniteNumberException if one of the bounds is infinite"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotANumberException if one of the bounds is NaN"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the seed value to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the seed value to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param algorithm the name of the PRNG algorithm"
    },
    {
        "oracle": ";",
        "javadocTag": "@param provider the name of the provider"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchAlgorithmException if the specified algorithm is not available"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NoSuchProviderException if the specified provider is not installed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Random used to generate random data"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the SecureRandom used to generate secure random data, wrapped in a\n{@link RandomGenerator}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rand the source of (non-secure) random data\n(may be null, resulting in the default generator)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (32 bits integers array), if null\nthe seed of the generator will be related to the current time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the initial seed (64 bits integer)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed the seed value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed {@code int}\n value from this random number generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a pseudorandom, uniformly distributed {@code int}\nvalue between 0 (inclusive) and n (exclusive)."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed {@code long}\nvalue from this random number generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed\n{@code boolean} value from this random number generator's\nsequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed {@code float}\nvalue between {@code 0.0} and {@code 1.0} from this\nrandom number generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed\n {@code double} value between {@code 0.0} and\n {@code 1.0} from this random number generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, Gaussian (\"normally\") distributed\n{@code double} value with mean {@code 0.0} and\nstandard deviation {@code 1.0} from this random number\n generator's sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param seed initial seed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a random scalar with zero location and unit scale"
    },
    {
        "oracle": ";",
        "javadocTag": "@param generator underlying random generator to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param alpha Stability parameter. Must be in range (0, 2]"
    },
    {
        "oracle": ";",
        "javadocTag": "@param beta Skewness parameter. Must be in range [-1, 1]"
    },
    {
        "oracle": ";",
        "javadocTag": "@param randomGenerator wrapped RandomGenerator instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a Random instance wrapping the RandomGenerator"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next pseudorandom, uniformly distributed\n<code>boolean</code> value from this random number generator's\nsequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of evalutations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lower bound of the bracket."
    },
    {
        "oracle": ";",
        "javadocTag": "@return function value at {@link #getLo()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the higher bound of the bracket."
    },
    {
        "oracle": ";",
        "javadocTag": "@return function value at {@link #getHi()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a point in the middle of the bracket."
    },
    {
        "oracle": ";",
        "javadocTag": "@return function value at {@link #getMid()}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code f(x)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of evaluations is\nexceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param growLimit Expanding factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEvaluations Maximum number of evaluations allowed for finding\na bracketing interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. In addition to those documented in\n{@link BaseOptimizer#parseOptimizationData(OptimizationData[])\nBaseOptimizer}, this method will register the following data:\n<ul>\n <li>{@link GoalType}</li>\n <li>{@link SearchInterval}</li>\n <li>{@link UnivariateObjectiveFunction}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the optimization type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data.\nThe following data will be looked for:\n<ul>\n <li>{@link GoalType}</li>\n <li>{@link SearchInterval}</li>\n <li>{@link UnivariateObjectiveFunction}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lower bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the upper bounds."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Point at which the objective function must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the objective function value at the specified point."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. In addition to those documented in\n{@link BaseOptimizer#parseOptimizationData(OptimizationData[]) BaseOptimizer},\nthis method will register the following data:\n<ul>\n <li>{@link InitialGuess}</li>\n <li>{@link SimpleBounds}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. The following data will be looked for:\n<ul>\n <li>{@link InitialGuess}</li>\n <li>{@link SimpleBounds}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial guess, or {@code null} if not set."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the lower bounds, or {@code null} if not set."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the upper bounds, or {@code null} if not set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iteration Current iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@param previous Best point in the previous iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@param current Best point in the current iteration."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the algorithm is considered to have converged."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a counter for the evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a counter for the evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object used to check for convergence."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the allowed number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance suitable for allowing {@link Integer#MAX_VALUE}\nevaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Allowed number of evalutations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point current point at which the search direction was computed"
    },
    {
        "oracle": ";",
        "javadocTag": "@param r raw search direction (i.e. opposite of the gradient)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return approximation of H<sup>-1</sup>r where H is the objective function hessian"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathUnsupportedOperationException if bounds were passed to the\n{@link #optimize(OptimizationData[]) optimize} method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param updateFormula formula to use for updating the &beta; parameter,\nmust be one of {@link Formula#FLETCHER_REEVES} or\n{@link Formula#POLAK_RIBIERE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param updateFormula formula to use for updating the &beta; parameter,\nmust be one of {@link Formula#FLETCHER_REEVES} or\n{@link Formula#POLAK_RIBIERE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lineSearchSolver Solver to use during line search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param updateFormula formula to use for updating the &beta; parameter,\nmust be one of {@link Formula#FLETCHER_REEVES} or\n{@link Formula#POLAK_RIBIERE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeTolerance Relative threshold for line search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteTolerance Absolute threshold for line search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialBracketingRange Extent of the initial interval used to\nfind an interval that brackets the optimum in order to perform the\nline search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param updateFormula formula to use for updating the &beta; parameter,\nmust be one of {@link Formula#FLETCHER_REEVES} or\n{@link Formula#POLAK_RIBIERE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lineSearchSolver Solver to use during line search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param preconditioner Preconditioner."
    },
    {
        "oracle": ";",
        "javadocTag": "@param updateFormula formula to use for updating the &beta; parameter,\nmust be one of {@link Formula#FLETCHER_REEVES} or\n{@link Formula#POLAK_RIBIERE}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param preconditioner Preconditioner."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeTolerance Relative threshold for line search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteTolerance Absolute threshold for line search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param initialBracketingRange Extent of the initial interval used to\nfind an interval that brackets the optimum in order to perform the\nline search."
    },
    {
        "oracle": ";",
        "javadocTag": "@param function vectorial residuals function to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observations observations to be compared to objective function to compute residuals"
    },
    {
        "oracle": ";",
        "javadocTag": "@param function vectorial residuals function to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observations observations to be compared to objective function to compute residuals"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights weights to apply to the residuals"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the observations vector and the weights\nvector dimensions do not match (objective function dimension is checked only when\nthe {@link #value(double[])} method is called)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param function vectorial residuals function to wrap"
    },
    {
        "oracle": ";",
        "javadocTag": "@param observations observations to be compared to objective function to compute residuals"
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale scaling matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the observations vector and the scale\nmatrix dimensions do not match (objective function dimension is checked only when\nthe {@link #value(double[])} method is called)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param params Point at which the gradient must be evaluated."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the gradient at the specified point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data. In addition to those documented in\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\nMultivariateOptimizer}, this method will register the following data:\n<ul>\n <li>{@link ObjectiveFunctionGradient}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@inheritDoc}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyEvaluationsException if the maximal number of\nevaluations (of the objective function) is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optData Optimization data.\nThe following data will be looked for:\n<ul>\n <li>{@link ObjectiveFunctionGradient}</li>\n</ul>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param checker Convergence checker."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Unbounded values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the bounded values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point Bounded values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the unbounded values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param point unbounded value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return underlying function value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param bounded bounded function"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lower lower bounds for each element of the input parameters array\n(some elements may be set to {@code Double.NEGATIVE_INFINITY} for\nunbounded values)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param upper upper bounds for each element of the input parameters array\n(some elements may be set to {@code Double.POSITIVE_INFINITY} for\nunbounded values)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if lower and upper bounds are not\nconsistent, either according to dimension or to values"
    },
    {
        "oracle": ";",
        "javadocTag": "@param startPoint Starting point."
    },
    {
        "oracle": ";",
        "javadocTag": "@param direction Search direction."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the optimum."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param optimizer Optimizer on behalf of which the line search\nbe performed.\nIts {@link MultivariateOptimizer#computeObjectiveValue(double[])\ncomputeObjectiveValue} method will be called by the\n{@link #search(double[],double[]) search} method."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeTolerance Search will stop when the function relative\ndifference between successive iterations is below this value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteTolerance Search will stop when the function absolute\ndifference between successive iterations is below this value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to convert to a string, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer used to get a string representation of an element"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of {@code iterable}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to convert to a string, may be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer used to get a string representation of an element"
    },
    {
        "oracle": ";",
        "javadocTag": "@param delimiter the string to delimit elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@param prefix the prefix, prepended to the string representation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param suffix the suffix, appended to the string representation"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of {@code iterable}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable to check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterable the iterable, possibly <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an empty iterator if the argument is <code>null</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to search for"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of occurrences of the object, zero if not found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the object was not already in the <code>uniqueSet</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nCopies the number of copies to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the object was not already in the <code>uniqueSet</code>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if this call changed the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@param nCopies the number of copies to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if this call changed the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the Set of unique Bag elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the total size of the Bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to check against"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if the Bag contains all the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to remove"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if this call changed the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@param coll the collection to retain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return <code>true</code> if this call changed the collection"
    },
    {
        "oracle": ";",
        "javadocTag": "@return iterator over all elements in the Bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to evaluate, should not be changed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true or false"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassCastException (runtime) if the input is the wrong class"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException (runtime) if the input is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FunctorException (runtime) if the predicate encounters a problem"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the comparator in use, or null if natural ordering"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the first element in the sorted bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the last element in the sorted bag"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <K> the key type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the value type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return an unmodifiable trie backed by the given trie"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to run each time in the closure, null means nop"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param count the number of times to loop"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closure the closure to call repeatedly"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>for</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>while</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>do-while</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param methodName the name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>invoker</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param methodName the name of the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param paramTypes the parameter types"
    },
    {
        "oracle": ";",
        "javadocTag": "@param args the arguments"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>invoker</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the paramTypes and args don't match"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closures an array of closures to chain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>chained</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closures a collection of closures to chain"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>chained</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any closure in the collection is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the validating predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param trueClosure the closure called if the predicate is true"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>if</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to switch on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param trueClosure the closure called if the predicate is true"
    },
    {
        "oracle": ";",
        "javadocTag": "@param falseClosure the closure called if the predicate is false"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>switch</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>switch</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the either array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the arrays have different sizes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param defaultClosure the default to call if no predicate matches"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>switch</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if the either array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the arrays are different sizes"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicatesAndClosures a map of predicates to closures"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>switch</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if any closure in the map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval maximum number of evaluations"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a complex root of the polynomial"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximum number of evaluations is exceeded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param functionValueAccuracy Function value accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param functionValueAccuracy Maximum function value error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param functionValueAccuracy Maximum function value error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to solve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximum evaluation count is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Maximum absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Maximum relative error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Maximum absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Maximum relative error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Maximum absolute error."
    },
    {
        "oracle": ";",
        "javadocTag": "@param functionValueAccuracy Maximum function value error."
    },
    {
        "oracle": ";",
        "javadocTag": "@return maximal order"
    },
    {
        "oracle": ";",
        "javadocTag": "@param targetY target value for y"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x reference points abscissas for interpolation,\nnote that this array <em>is</em> modified during computation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y reference points ordinates for interpolation"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start start index of the points to consider (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end end index of the points to consider (exclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return guessed root (will be a NaN if two points share the same y)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximalOrder maximal order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximalOrder maximal order."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeAccuracy Relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param absoluteAccuracy Absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param functionValueAccuracy Function value accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maximalOrder maximal order."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the maximum number of function evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of evaluations of the objective function."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the absolute accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the relative accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the function value accuracy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to solve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowedSolution The kind of solutions that the root-finding algorithm may\naccept as solutions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A value where the function is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.MathIllegalArgumentException if the arguments do not satisfy the requirements specified by the solver."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if\nthe allowed number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxEval Maximum number of evaluations."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function to solve."
    },
    {
        "oracle": ";",
        "javadocTag": "@param min Lower bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound for the interval."
    },
    {
        "oracle": ";",
        "javadocTag": "@param startValue Start value to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowedSolution The kind of solutions that the root-finding algorithm may\naccept as solutions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return A value where the function is zero."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.MathIllegalArgumentException if the arguments do not satisfy the requirements specified by the solver."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.TooManyEvaluationsException if\nthe allowed number of evaluations is exceeded."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Domain values where the function changes value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param y Values of the function."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonMonotonicSequenceException if the {@code x} array is not sorted in strictly increasing order."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code x} and {@code y} do not\nhave the same length."
    },
    {
        "oracle": ";",
        "javadocTag": "@param xMinusMean {@code x - mean}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param norm Normalization factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i2s2 Inverse of twice the square of the standard deviation."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the Gaussian at {@code x}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param norm Normalization factor."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean Mean."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sigma Standard deviation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param mean Mean."
    },
    {
        "oracle": ";",
        "javadocTag": "@param sigma Standard deviation."
    },
    {
        "oracle": ";",
        "javadocTag": "@param c Constant."
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Value at which to compute the logit."
    },
    {
        "oracle": ";",
        "javadocTag": "@param lo Lower bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hi Higher bound."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the logit function at {@code x}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code x < lo} or {@code x > hi}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if parameter is outside of function domain"
    },
    {
        "oracle": ";",
        "javadocTag": "@param lo Lower bound of the function domain."
    },
    {
        "oracle": ";",
        "javadocTag": "@param hi Higher bound of the function domain."
    },
    {
        "oracle": ";",
        "javadocTag": "@param p Power."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> input and output type for the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate predicate to switch on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param trueTransformer transformer used if true"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>if</code> transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if input is the same object as the stored value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object to compare to"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of the object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>closure</code> transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicates the predicates to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cloned predicates"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object the returned predicate should \"accept\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to coerce."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the coerced predicate."
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicates the predicates to validate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicates the predicates to validate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return predicate array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closures the closures to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the cloned closures"
    },
    {
        "oracle": ";",
        "javadocTag": "@param closures the closures to validate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object the returned closure should \"accept\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param closure the closure to coerce."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the coerced closure."
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformers the transformers to copy"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a clone of the transformers"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformers the transformers to validate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object the returned transformer should \"accept\""
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to coerce."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the coerced transformer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if decorated transformer returns Boolean.TRUE"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FunctorException if the transformer returns an invalid type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to decorate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the singleton instance"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Transformer<I, O> that always returns null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <I> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <O> the output type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constantToReturn the constant object to return each time in the factory"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>constant</code> factory."
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object which is ignored"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the stored constant"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the constant"
    },
    {
        "oracle": ";",
        "javadocTag": "@param constantToReturn the constant to return each time"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the input type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>predicate</code> transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object to transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformed result"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>while</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true is do-while, false if while"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the type that the closure acts on"
    },
    {
        "oracle": ";",
        "javadocTag": "@param count the number of times to execute the closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the <code>for</code> closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param input the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the count"
    },
    {
        "oracle": ";",
        "javadocTag": "@param count the number of times to execute the closure"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if decorated predicate returns true or input is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate as the only element in an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to call after the null check"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type that the predicate queries"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to call"
    },
    {
        "oracle": ";",
        "javadocTag": "@param predicate the predicate to call with the result of the transform"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the input object which will be transformed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if decorated predicate returns true"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the predicate as the only element in an array"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the transformer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param transformer the transformer to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x Argument."
    },
    {
        "oracle": ";",
        "javadocTag": "@return tan(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x a number"
    },
    {
        "oracle": ";",
        "javadocTag": "@return atan(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xa number from which arctangent is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@param xb extra bits for x (may be 0.0)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param leftPlane if true, result angle must be put in the left half plane"
    },
    {
        "oracle": ";",
        "javadocTag": "@return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y ordinate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x abscissa"
    },
    {
        "oracle": ";",
        "javadocTag": "@return phase angle of point (x,y) between {@code -PI} and {@code PI}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number on which evaluation is done"
    },
    {
        "oracle": ";",
        "javadocTag": "@return arc sine of x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number on which evaluation is done"
    },
    {
        "oracle": ";",
        "javadocTag": "@return arc cosine of x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number on which evaluation is done"
    },
    {
        "oracle": ";",
        "javadocTag": "@return cubic root of x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x angle in degrees"
    },
    {
        "oracle": ";",
        "javadocTag": "@return x converted into radians"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x angle in radians"
    },
    {
        "oracle": ";",
        "javadocTag": "@return x converted into degrees"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number from which absolute value is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return abs(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number from which absolute value is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return abs(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number from which absolute value is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return abs(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number from which absolute value is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return abs(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number from which ulp is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ulp(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number from which ulp is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return ulp(x)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d number to multiply"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n power of 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return d &times; 2<sup>n</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f number to multiply"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n power of 2"
    },
    {
        "oracle": ";",
        "javadocTag": "@return f &times; 2<sup>n</sup>"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d base number"
    },
    {
        "oracle": ";",
        "javadocTag": "@param direction (the only important thing is whether\n{@code direction} is greater or smaller than {@code d})"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next machine representable number in the specified direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param f base number"
    },
    {
        "oracle": ";",
        "javadocTag": "@param direction (the only important thing is whether\n{@code direction} is greater or smaller than {@code f})"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the next machine representable number in the specified direction"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number from which floor is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a double number f such that f is an integer f <= x < f + 1.0"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number from which ceil is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a double number c such that c is an integer c - 1.0 < x <= c"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number from which nearest whole number is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a double number r such that r is an integer r - 0.5 <= x <= r + 0.5"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number from which closest long is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return closest long to x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x number from which closest int is requested"
    },
    {
        "oracle": ";",
        "javadocTag": "@return closest int to x"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x a value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y a value"
    },
    {
        "oracle": ";",
        "javadocTag": "@return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dividend the number to be divided"
    },
    {
        "oracle": ";",
        "javadocTag": "@param divisor the number by which to divide"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the remainder, rounded"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number to convert to int"
    },
    {
        "oracle": ";",
        "javadocTag": "@return integer with same valie as n if no overflows occur"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if n cannot fit into an int"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number to increment"
    },
    {
        "oracle": ";",
        "javadocTag": "@return n+1 if no overflows occur"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if an overflow occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number to increment"
    },
    {
        "oracle": ";",
        "javadocTag": "@return n+1 if no overflows occur"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if an overflow occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number to decrement"
    },
    {
        "oracle": ";",
        "javadocTag": "@return n-1 if no overflows occur"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if an overflow occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n number to decrement"
    },
    {
        "oracle": ";",
        "javadocTag": "@return n-1 if no overflows occur"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if an overflow occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first number to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second number to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a+b if no overflows occur"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if an overflow occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@param a first number to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b second number to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a+b if no overflows occur"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if an overflow occurs"
    },
    {
        "oracle": ";",
        "javadocTag": "@return determinant of the matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a solver"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix the matrix to decompose"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSymmetricMatrixException if the matrix is not symmetric."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonPositiveDefiniteMatrixException if the matrix is not\nstrictly positive definite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix the matrix to decompose"
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeSymmetryThreshold threshold above which off-diagonal\nelements are considered too different and matrix not symmetric"
    },
    {
        "oracle": ";",
        "javadocTag": "@param absolutePositivityThreshold threshold below which diagonal\nelements are considered null and matrix not positive definite"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonSymmetricMatrixException if the matrix is not symmetric."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NonPositiveDefiniteMatrixException if the matrix is not\nstrictly positive definite."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b right-hand side of the equation A &times; X = B"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a vector X that minimizes the two norm of A &times; X - B"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the matrices dimensions do not match."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if the decomposed matrix is singular."
    },
    {
        "oracle": ";",
        "javadocTag": "@param b right-hand side of the equation A &times; X = B"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a matrix X that minimizes the two norm of A &times; X - B"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws org.apache.commons.math3.exception.DimensionMismatchException if the matrices dimensions do not match."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if the decomposed matrix is singular."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the decomposed matrix is non-singular"
    },
    {
        "oracle": ";",
        "javadocTag": "@return inverse matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws SingularMatrixException if the decomposed matrix is singular."
    },
    {
        "oracle": ";",
        "javadocTag": "@param dimension the size of the vector"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the index of the first entry to be visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end the index of the last entry to be visited (inclusive)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index of the entry being visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the value of the entry being visited"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value returned by\n{@link RealVector#walkInDefaultOrder(RealVectorPreservingVisitor)},\n{@link RealVector#walkInDefaultOrder(RealVectorPreservingVisitor, int, int)},\n{@link RealVector#walkInOptimizedOrder(RealVectorPreservingVisitor)}\nor\n{@link RealVector#walkInOptimizedOrder(RealVectorPreservingVisitor, int, int)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rawData Data array in raw layout."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new data array containing the same entries but in blocks layout."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if {@code rawData} is not rectangular."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows Number of rows in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param columns Number of columns in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new data array in blocks layout."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to be added."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} + m."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the same\nsize as this matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to be subtracted."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} - m."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if {@code m} is not the\nsame size as this matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param m Matrix to postmultiply by."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code this} * m."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the matrices are not compatible."
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcBlock source block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcWidth source block width ({@link #BLOCK_SIZE} or smaller)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcStartRow start row in the source block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcEndRow end row (exclusive) in the source block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcStartColumn start column in the source block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param srcEndColumn end column (exclusive) in the source block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dstBlock destination block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dstStartRow start row in the destination block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dstStartColumn start column in the destination block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param row the row to be set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix row matrix (must have one row and the same number of columns\nas the instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified row index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the matrix dimensions do\nnot match one instance row."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column the column to be set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param matrix column matrix (must have one column and the same number of rows\nas the instance)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the specified column index is invalid."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MatrixDimensionMismatchException if the matrix dimensions do\nnot match one instance column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param blockRow row index (in block sense) of the block"
    },
    {
        "oracle": ";",
        "javadocTag": "@return height (number of rows) of the block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param blockColumn column index (in block sense) of the block"
    },
    {
        "oracle": ";",
        "javadocTag": "@return width (number of columns) of the block"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows the number of rows in the new matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param columns the number of columns in the new matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if row or column dimension is not\npositive."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rawData data for new matrix, in raw layout"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the shape of {@code blockData} is\ninconsistent with block layout."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if row or column dimension is not\npositive."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rows Number of rows in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param columns Number of columns in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param blockData data for new matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@param copyArray Whether the input array will be copied or referenced."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the shape of {@code blockData} is\ninconsistent with block layout."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NotStrictlyPositiveException if row or column dimension is not\npositive."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row index of the matrix element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param column Column index of the matrix element."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the key within the map to access the matrix element."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param field Field to which the elements belong."
    },
    {
        "oracle": ";",
        "javadocTag": "@param rowDimension Number of rows in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param columnDimension Number of columns in the new matrix."
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Instance to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param other Instance to copy."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrong Row dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expected Column dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the size of this vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index location of entry to be fetched."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the vector entry at {@code index}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index element index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value new value for the element."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index location of entry to be set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param increment Value to add to the vector entry."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if the index is not valid."
    },
    {
        "oracle": ";",
        "javadocTag": "@param v vector to append to this one."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new vector."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d double to append."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node Another node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if an edge exists between this node and the other node."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index of another node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if an edge exists between this node and the other node."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is negative or greater than {@code\n            getNodeCount() - 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node The target node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Directed edge going from this node to the parameter node, or\n        undirected edge if it exists, else null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index of the target node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Directed edge going from this node to the parameter node, or\n        undirected edge if it exists, else null."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is negative or greater than {@code\n            getNodeCount() - 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node The source node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Directed edge going from the parameter node to this node, or\n        undirected edge if it exists, else null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index of the source node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Directed edge going from the parameter node to this node, or\n        undirected edge if it exists, else null."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is negative or greater than {@code\n            getNodeCount() - 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node The opposite node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Edge between this node and the parameter node if it exists, else\n        null."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index The index of the opposite node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return Edge between node with index i and this node if it exists, else\n        null."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is negative or greater than {@code\n            getNodeCount() - 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Identifier of the node to find."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The searched node or null if not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Identifier of the edge to find."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The searched edge or null if not found."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if enabled."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if enabled."
    },
    {
        "oracle": ";",
        "javadocTag": "@return True if exceptions must be thrown when accessing a null\n        attribute."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The step."
    },
    {
        "oracle": ";",
        "javadocTag": "@param on if true, exceptions will be thrown when accessing a non\n           existing attribute."
    },
    {
        "oracle": ";",
        "javadocTag": "@param nf the new NodeFactory"
    },
    {
        "oracle": ";",
        "javadocTag": "@param ef the new EdgeFactory"
    },
    {
        "oracle": ";",
        "javadocTag": "@param on True or false."
    },
    {
        "oracle": ";",
        "javadocTag": "@param on True or false."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Arbitrary and unique string identifying the node."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The created node (or the already existing node)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IdAlreadyInUseException If strict checking is enabled the identifier is already used."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id The unique identifier of the node to remove."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The removed node. If strict checking is disabled, it can return\n        null if the node to remove does not exist."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ElementNotFoundException If no node matches the given identifier and strict checking\n            is enabled."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique and arbitrary string identifying the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node1 The first node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node2 The second node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The newly created edge, an existing edge or {@code null} (see the\n        detailed description above)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IdAlreadyInUseException If an edge with the same id already exists and strict\n            checking is enabled."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ElementNotFoundException If strict checking is enabled, and 'node1' or 'node2' are not\n            registered in the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws EdgeRejectedException If strict checking is enabled and the edge is not accepted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique and arbitrary string identifying the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node1 The first node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param node2 The second node identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@param directed Is the edge directed?"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The newly created edge, an existing edge or {@code null} (see the\n        detailed description above)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IdAlreadyInUseException If an edge with the same id already exists and strict\n            checking is enabled."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ElementNotFoundException If strict checking is enabled, and 'node1' or 'node2' are not\n            registered in the graph."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws EdgeRejectedException If strict checking is enabled and the edge is not accepted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param from The origin node identifier to select the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param to The destination node identifier to select the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The removed edge, or null if strict checking is disabled and at\n        least one of the two given nodes does not exist or there is no\n        edge between them"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ElementNotFoundException If the 'from' or 'to' node is not registered in the graph or\n            not connected and strict checking is enabled."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Identifier of the edge to remove."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The removed edge, or null if strict checking is disabled and the\n        edge does not exist."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ElementNotFoundException If no edge matches the identifier and strict checking is\n            enabled."
    },
    {
        "oracle": ";",
        "javadocTag": "@param time A numerical value that may give a timestamp to track the\n           evolution of the graph over the time."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the set of {@link AttributeSink} under the form of an iterable\n        object."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the list of {@link ElementSink} under the form of an iterable\n        object."
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename The graph filename (or URL)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ElementNotFoundException If the file cannot be found or if the format is not\n            recognized."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws GraphParseException If there is a parsing error while reading the file."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an input output error occurs during the graph reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@param input An appropriate reader for the filename."
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename The graph filename (or URL)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ElementNotFoundException If the file cannot be found or if the format is not\n            recognised."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws GraphParseException If there is a parsing error while reading the file."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an input/output error occurs during the graph reading."
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename The file that will contain the saved graph (or URL)."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an input/output error occurs during the graph writing."
    },
    {
        "oracle": ";",
        "javadocTag": "@param filename The file that will contain the saved graph (or URL)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param output The output format to use."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException If an input/output error occurs during the graph writing."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a graph viewer that allows to command the viewer (it often run in\n        another thread)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param autoLayout If true a layout algorithm is launched in its own thread to\n           compute best node positions."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a graph viewer that allows to command the viewer (it often run in\n        another thread)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index Index of the node to find."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The node with the given index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException If the index is negative or greater than {@code\n            getNodeCount() - 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index The index of the edge to find."
    },
    {
        "oracle": ";",
        "javadocTag": "@return The edge with the given index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is less than 0 or greater than {@code\n            getNodeCount() - 1}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique and arbitrary string identifying the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param index1 The first node index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index2 The second node index"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The newly created edge, an existing edge or {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException If node indices are negative or greater than {@code\n            getNodeCount() - 1}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IdAlreadyInUseException If an edge with the same id already exists and strict\n            checking is enabled."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws EdgeRejectedException If strict checking is enabled and the edge is not accepted."
    },
    {
        "oracle": ";",
        "javadocTag": "@param id Unique and arbitrary string identifying the edge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param toIndex The first node index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fromIndex The second node index"
    },
    {
        "oracle": ";",
        "javadocTag": "@param directed Is the edge directed?"
    },
    {
        "oracle": ";",
        "javadocTag": "@return The newly created edge, an existing edge or {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException If node indices are negative or greater than {@code\n            getNodeCount() - 1}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param exact whether the probability should be calculated exact using\n       {@link org.apache.commons.math3.fraction.BigFraction} everywhere at the expense of\n       very slow execution time, or if {@code double} should be used convenient places to\n       gain speed. Almost never choose {@code true} in real applications unless you are very\n       sure; {@code true} is almost solely for verification purposes."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if algorithm fails to convert {@code h} to a\n        {@link org.apache.commons.math3.fraction.BigFraction} in expressing {@code d} as \\((k\n        - h) / m\\) for integer {@code k, m} and \\(0 \\le h < 1\\)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the two-sided probability of \\(P(D_n < d)\\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if algorithm fails to convert {@code h} to a\n        {@link org.apache.commons.math3.fraction.BigFraction} in expressing {@code d} as \\((k\n        - h) / m\\) for integer {@code k, m} and \\(0 \\le h < 1\\)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@return \\(P(D_n < d)\\)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d value of d-statistic (x in [2])"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@return H matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if fractional part is greater than 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FractionConversionException if algorithm fails to convert {@code h} to a\n        {@link org.apache.commons.math3.fraction.BigFraction} in expressing {@code d} as \\((k\n        - h) / m\\) for integer {@code k, m} and \\(0 <= h < 1\\)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param d statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@return H matrix"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooLargeException if fractional part is greater than 1"
    },
    {
        "oracle": ";",
        "javadocTag": "@param array array to test"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws InsufficientDataException if array is too short"
    },
    {
        "oracle": ";",
        "javadocTag": "@param t argument"
    },
    {
        "oracle": ";",
        "javadocTag": "@param tolerance Cauchy criterion for partial sums"
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations maximum number of partial sums to compute"
    },
    {
        "oracle": ";",
        "javadocTag": "@return Kolmogorov sum evaluated at t"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws TooManyIterationsException if the series does not converge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d a d-statistic in the range [0, 1]"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n first sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m second sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param strict whether the returned value divided by (n*m) is allowed to be equal to d"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the integral d-statistic in the range [0, n*m]"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d D-statistic value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n first sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m second sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param strict whether or not the probability to compute is expressed as a strict inequality"
    },
    {
        "oracle": ";",
        "javadocTag": "@return probability that a randomly selected m-n partition of m + n generates \\(D_{n,m}\\)\n        greater than (resp. greater than or equal to) {@code d}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d D-statistic value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n first sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m second sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@return approximate probability that a randomly selected m-n partition of m + n generates\n        \\(D_{n,m}\\) greater than {@code d}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param b boolean array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param numberOfTrueValues number of {@code true} values the boolean array should finally have"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng random data generator"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d D-statistic value"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n first sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m second sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterations number of random partitions to generate"
    },
    {
        "oracle": ";",
        "javadocTag": "@param strict whether or not the probability to compute is expressed as a strict inequality"
    },
    {
        "oracle": ";",
        "javadocTag": "@return proportion of randomly generated m-n partitions of m + n that result in \\(D_{n,m}\\)\n        greater than (resp. greater than or equal to) {@code d}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param d integral D-statistic"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n first sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m second sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param iterations number of random partitions to generate"
    },
    {
        "oracle": ";",
        "javadocTag": "@return proportion of randomly generated m-n partitions of m + n that result in \\(D_{n,m}\\)\n        greater than or equal to {@code d/(n*m))}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param x first sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@param y second sample"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if x and y together contain ties"
    },
    {
        "oracle": ";",
        "javadocTag": "@param data input/output data array - entries overwritten by the method"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dist probability distribution to sample for jitter values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if either of the parameters is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i first path parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param j second path paramter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m first sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n second sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cmn integral D-statistic (see {@link #calculateIntegralD(double, int, int, boolean)})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param strict whether or not the null hypothesis uses strict inequality"
    },
    {
        "oracle": ";",
        "javadocTag": "@return C(i,j) for given m, n, c"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i first path parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param j second path parameter"
    },
    {
        "oracle": ";",
        "javadocTag": "@param m first sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param n second sample size"
    },
    {
        "oracle": ";",
        "javadocTag": "@param cnm integral D-statistic (see {@link #calculateIntegralD(double, int, int, boolean)})"
    },
    {
        "oracle": ";",
        "javadocTag": "@param strict whether or not the null hypothesis uses strict inequality"
    },
    {
        "oracle": ";",
        "javadocTag": "@return number or paths to (i, j) from (0,0) representing D-values as large as c for given m, n"
    },
    {
        "oracle": ";",
        "javadocTag": "@param rng random data generator used by {@link #monteCarloP(double, int, int, boolean, int)}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values data array to store (may be null to remove stored data)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return copy of the stored data array (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return reference to the stored data array (may be null)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values data array to store"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin the index of the first element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the value of the statistic applied to the stored data"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the parameters are valid and designate a subarray of positive length"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the indices are invalid or the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param length the number of elements to include"
    },
    {
        "oracle": ";",
        "javadocTag": "@param allowEmpty if <code>true</code> then zero length arrays are allowed"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if the parameters are valid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalArgumentException if the indices are invalid or the array is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param values the input array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param weights the weights array"
    },
    {
        "oracle": ";",
        "javadocTag": "@param begin index of the first array element to include"
    },
    {
        "oracle": "keyTransformer==null;",
        "javadocTag": "@param keyTransformer the transformer to use for key conversion, null means no conversion"
    },
    {
        "oracle": "valueTransformer==null;",
        "javadocTag": "@param valueTransformer the transformer to use for value conversion, null means no conversion"
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException if the key is null and null keys are invalid"
    },
    {
        "oracle": "key==null;",
        "javadocTag": "@throws NullPointerException if the key is null and null keys are invalid"
    },
    {
        "oracle": "true ? methodResultID==null : true;",
        "javadocTag": "@return the {@code Set} of values removed, implementations should\n  return null for no mapping found, but may return an empty collection"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "true;",
        "javadocTag": "@throws UnsupportedOperationException always"
    },
    {
        "oracle": "initialCapacity<0;",
        "javadocTag": "@throws IllegalArgumentException if the initial capacity is negative"
    },
    {
        "oracle": "initialCapacity<0;",
        "javadocTag": "@throws IllegalArgumentException if the initial capacity is negative"
    },
    {
        "oracle": "loadFactor<0;",
        "javadocTag": "@throws IllegalArgumentException if the load factor is less than zero"
    },
    {
        "oracle": "map==null;",
        "javadocTag": "@throws NullPointerException if the map is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to check, not cloned, not null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates array is null"
    },
    {
        "oracle": "Arrays.stream(predicates).anyMatch(jdVar -> jdVar==null);",
        "javadocTag": "@throws NullPointerException if any predicate in the array is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to check, cloned, not null"
    },
    {
        "oracle": "predicates==null;",
        "javadocTag": "@throws NullPointerException if the predicates array is null"
    },
    {
        "oracle": "(predicates==null) == false;",
        "javadocTag": "@param predicates the predicates to check, cloned, not null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if iterator is null"
    },
    {
        "oracle": "offset<0 || max<0;",
        "javadocTag": "@throws IllegalArgumentException if either offset or max is negative"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "start<0;",
        "javadocTag": "@throws IndexOutOfBoundsException if start is less than zero or greater\n  than the length of the array"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "start<0;",
        "javadocTag": "@throws IndexOutOfBoundsException if start is less than zero or greater\n  than the length of the array"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "start<0;",
        "javadocTag": "@throws IndexOutOfBoundsException if start is less than zero"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "start<0;",
        "javadocTag": "@throws IndexOutOfBoundsException if start is less than zero"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "array==null;",
        "javadocTag": "@throws NullPointerException if array is null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "max<0;",
        "javadocTag": "@throws IllegalArgumentException if max is negative"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "offset<0 || max<0;",
        "javadocTag": "@throws IllegalArgumentException if either offset or max is negative"
    },
    {
        "oracle": "iterator1==null || iterator2==null;",
        "javadocTag": "@throws NullPointerException if either iterator is null"
    },
    {
        "oracle": "(iterator1==null) == false;",
        "javadocTag": "@param iterator1 the first iterator to use, not null"
    },
    {
        "oracle": "(iterator2==null) == false;",
        "javadocTag": "@param iterator2 the second iterator to use, not null"
    },
    {
        "oracle": "iterators==null;",
        "javadocTag": "@throws NullPointerException if iterators array is null or contains a null"
    },
    {
        "oracle": "(iterators==null) == false && iterators.length > 0 && Arrays.stream(iterators).noneMatch(jdVar -> jdVar == null);",
        "javadocTag": "@param iterators the iterators to use, not null or empty or contain nulls"
    },
    {
        "oracle": "iterators==null || ((iterators==null)==false) && (iterators.contains(null));",
        "javadocTag": "@throws NullPointerException if iterators collection is null or contains a null"
    },
    {
        "oracle": "(iterators==null) == false || ((iterators==null)==false) && (iterators.isEmpty()) || ((iterators==null)==false) && (iterators.contains(null));",
        "javadocTag": "@param iterators the iterators to use, not null or empty or contain nulls"
    },
    {
        "oracle": "iterator1==null || iterator2==null;",
        "javadocTag": "@throws NullPointerException if either iterator is null"
    },
    {
        "oracle": "(iterator1==null) == false;",
        "javadocTag": "@param iterator1 the first iterators to use, not null"
    },
    {
        "oracle": "(iterator2==null) == false;",
        "javadocTag": "@param iterator2 the first iterators to use, not null"
    },
    {
        "oracle": "iterators==null;",
        "javadocTag": "@throws NullPointerException if iterators array is null or contains a null value"
    },
    {
        "oracle": "(iterators==null) == false && iterators.length > 0 && Arrays.stream(iterators).noneMatch(jdVar -> jdVar == null);",
        "javadocTag": "@param iterators the iterators to use, not null or empty or contain nulls"
    },
    {
        "oracle": "iterators==null || ((iterators==null)==false) && (iterators.contains(null));",
        "javadocTag": "@throws NullPointerException if iterators collection is null or contains a null"
    },
    {
        "oracle": "(iterators==null) == false || ((iterators==null)==false) && (iterators.isEmpty()) || ((iterators==null)==false) && (iterators.contains(null));",
        "javadocTag": "@param iterators the iterators to use, not null or empty or contain nulls"
    },
    {
        "oracle": "transformer==null;",
        "javadocTag": "@param transformer the transformer to use, see above, null uses no effect transformer"
    },
    {
        "oracle": "iterator==null || transform==null;",
        "javadocTag": "@throws NullPointerException if either parameter is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to use, not null"
    },
    {
        "oracle": "(transform==null) == false;",
        "javadocTag": "@param transform the transform to use, not null"
    },
    {
        "oracle": "iterator==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if either parameter is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to use, not null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use as a filter, not null"
    },
    {
        "oracle": "listIterator==null || predicate==null;",
        "javadocTag": "@throws NullPointerException if either parameter is null"
    },
    {
        "oracle": "(listIterator==null) == false;",
        "javadocTag": "@param listIterator the list iterator to use, not null"
    },
    {
        "oracle": "(predicate==null) == false;",
        "javadocTag": "@param predicate the predicate to use as a filter, not null"
    },
    {
        "oracle": "coll==null;",
        "javadocTag": "@throws NullPointerException if the collection is null"
    },
    {
        "oracle": "(coll==null) == false;",
        "javadocTag": "@param coll the collection to iterate over, not null"
    },
    {
        "oracle": "list==null;",
        "javadocTag": "@throws NullPointerException if the list is null"
    },
    {
        "oracle": "(list==null) == false;",
        "javadocTag": "@param list the list to iterate over, not null"
    },
    {
        "oracle": "nodeList==null;",
        "javadocTag": "@throws NullPointerException if nodeList is null"
    },
    {
        "oracle": "(nodeList==null) == false;",
        "javadocTag": "@param nodeList the node list to use, may not be null"
    },
    {
        "oracle": "node==null;",
        "javadocTag": "@throws NullPointerException if node is null"
    },
    {
        "oracle": "(node==null) == false;",
        "javadocTag": "@param node the node to use, may not be null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to decorate, not null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to decorate, not null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if the iterator is null"
    },
    {
        "oracle": "offset<0;",
        "javadocTag": "@throws IllegalArgumentException if offset is negative"
    },
    {
        "oracle": "a==null || b==null;",
        "javadocTag": "@throws NullPointerException if any iterator is null"
    },
    {
        "oracle": "true ? methodResultID.equals(a) : true;",
        "javadocTag": "@return an iterator, interleaving the decorated iterators"
    },
    {
        "oracle": "a==null || b==null || c==null;",
        "javadocTag": "@throws NullPointerException if any iterator is null"
    },
    {
        "oracle": "true ? methodResultID.equals(a) : true;",
        "javadocTag": "@return an iterator, interleaving the decorated iterators"
    },
    {
        "oracle": "iterators==null;",
        "javadocTag": "@throws NullPointerException if any iterator is null"
    },
    {
        "oracle": "enumeration==null;",
        "javadocTag": "@throws NullPointerException if enumeration is null"
    },
    {
        "oracle": "(enumeration==null) == false;",
        "javadocTag": "@param enumeration the enumeration to use, may not be null"
    },
    {
        "oracle": "enumeration==null || removeCollection==null;",
        "javadocTag": "@throws NullPointerException if enumeration or removeCollection is null"
    },
    {
        "oracle": "(enumeration==null) == false;",
        "javadocTag": "@param enumeration the enumeration to use, may not be null"
    },
    {
        "oracle": "(removeCollection==null) == false;",
        "javadocTag": "@param removeCollection the collection to remove elements from, may not be null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if iterator is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to use, may not be null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if iterator is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to use, may not be null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if iterator is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to use, may not be null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if iterator parameter is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to use, may not be null"
    },
    {
        "oracle": "iterator==null;",
        "javadocTag": "@throws NullPointerException if iterator parameter is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to use, not null"
    },
    {
        "oracle": "iterator==null || arrayClass==null;",
        "javadocTag": "@throws NullPointerException if iterator parameter or arrayClass is null"
    },
    {
        "oracle": "(iterator==null) == false;",
        "javadocTag": "@param iterator the iterator to use, not null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param max Upper bound of the range."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an initializer such that the features will be initialized with\nvalues within the given range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param f Function."
    },
    {
        "oracle": ";",
        "javadocTag": "@param init Initial value."
    },
    {
        "oracle": ";",
        "javadocTag": "@param inc Increment"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initializer."
    },
    {
        "oracle": ";",
        "javadocTag": "@param random Random variable distribution."
    },
    {
        "oracle": ";",
        "javadocTag": "@param orig Original initializer."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an initializer whose {@link FeatureInitializer#value() value}\nmethod will return {@code orig.value() + random.sample()}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance with the same state as this instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the identifier."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of features."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a copy of the neuron's features."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expect Current values of the features, as assumed by the caller.\nUpdate will never succeed if the contents of this array does not match\nthe values returned by {@link #getFeatures()}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param update Features's new values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the update was successful, {@code false}\notherwise."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of {@code update} is\nnot the same as specified in the {@link #Neuron(long,double[])\nconstructor}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of update attempts."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of successful updates."
    },
    {
        "oracle": ";",
        "javadocTag": "@param current Current values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param expect Expected values."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws DimensionMismatchException if the length of {@code expected}\nis not the same as specified in the {@link #Neuron(long,double[])\nconstructor}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return {@code true} if the arrays contain the same values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in Input stream."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the proxy instance that will be actually serialized."
    },
    {
        "oracle": ";",
        "javadocTag": "@param identifier Identifier (assigned by the {@link Network})."
    },
    {
        "oracle": ";",
        "javadocTag": "@param features Initial values of the feature set."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the initial value."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the network."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of neurons."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i Neuron index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the features of the neuron at index {@code i}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code i} is out of range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in Input stream."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the proxy instance that will be actually serialized."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrap Whether to wrap the dimension (i.e the first and last\nneurons will be linked together)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param featuresList Arrays that will initialize the features sets of\nthe network's neurons."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code num < 2}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param num Number of neurons."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrap Whether to wrap the dimension (i.e the first and last\nneurons will be linked together)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param featureInit Arrays that will initialize the features sets of\nthe network's neurons."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new instance with the same state as this instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the network."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of rows."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the number of column."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i Row index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param j Column index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the neuron at {@code (i, j)}."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws OutOfRangeException if {@code i} or {@code j} is\nout of range."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param col Column index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param alongRowDir Direction along the given {@code row} (i.e. an\noffset will be added to the given <em>column</em> index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param alongColDir Direction along the given {@code col} (i.e. an\noffset will be added to the given <em>row</em> index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the neuron at the requested location, or {@code null} if\nthe location is not on the map."
    },
    {
        "oracle": ";",
        "javadocTag": "@param row Row index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param col Column index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param alongRowDir Direction along the given {@code row} (i.e. an\noffset will be added to the given <em>column</em> index."
    },
    {
        "oracle": ";",
        "javadocTag": "@param alongColDir Direction along the given {@code col} (i.e. an\noffset will be added to the given <em>row</em> index."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an array of length 2 containing the indices of the requested\nlocation, or {@code null} if that location is not part of the map."
    },
    {
        "oracle": ";",
        "javadocTag": "@param in Input stream."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the proxy instance that will be actually serialized."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrapRowDim Whether to wrap the first dimension (i.e the first\nand last neurons will be linked together)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrapColDim Whether to wrap the second dimension (i.e the first\nand last neurons will be linked together)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neighbourhoodType Neighbourhood type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param featuresList Arrays that will initialize the features sets of\nthe network's neurons."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if {@code numRows < 2} or\n{@code numCols < 2}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numRows Number of neurons in the first dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrapRowDim Whether to wrap the first dimension (i.e the first\nand last neurons will be linked together)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numCols Number of neurons in the second dimension."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrapColDim Whether to wrap the second dimension (i.e the first\nand last neurons will be linked together)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neighbourhoodType Neighbourhood type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param featureInit Array of functions that will initialize the\ncorresponding element of the features set of each newly created\nneuron. In particular, the size of this array defines the size of\nfeature set."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrapRowDim Whether to wrap the first dimension (i.e the first\nand last neurons will be linked together)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param wrapColDim Whether to wrap the second dimension (i.e the first\nand last neurons will be linked together)."
    },
    {
        "oracle": ";",
        "javadocTag": "@param neighbourhoodType Neighbourhood type."
    },
    {
        "oracle": ";",
        "javadocTag": "@param net Underlying network."
    },
    {
        "oracle": ";",
        "javadocTag": "@param idGrid Neuron identifiers."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NumberIsTooSmallException if the size of the {@code map}\nis smaller than the number of {@link #SmoothedDataHistogram(int,DistanceMeasure)\nsmoothing bins}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param smoothingBins Number of bins."
    },
    {
        "oracle": ";",
        "javadocTag": "@param distance Distance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param map Map."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an image representing the individual distances."
    },
    {
        "oracle": ";",
        "javadocTag": "@param map Map."
    },
    {
        "oracle": ";",
        "javadocTag": "@return an image representing the average distances."
    },
    {
        "oracle": ";",
        "javadocTag": "@param individualDistances If {@code true}, the 8 individual\ninter-units distances will be {@link #computeImage(NeuronSquareMesh2D)\ncomputed}.  They will be stored in additional pixels around each of\nthe original units of the 2D-map.  The additional pixels that lie\nalong a \"diagonal\" are shared by <em>two</em> pairs of units: their\nvalue will be set to the average distance between the units belonging\nto each of the pairs.  The value zero will be stored in the pixel\ncorresponding to the location of a unit of the 2D-map.\n<br>\nIf {@code false}, only the average distance between a unit and all its\nneighbours will be computed (and stored in the pixel corresponding to\nthat unit of the 2D-map).  In that case, the number of neighbours taken\ninto account depends on the network's\n{@link org.apache.commons.math3.ml.neuralnet.SquareNeighbourhood\nneighbourhood type}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param distance Distance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param map Map."
    },
    {
        "oracle": ";",
        "javadocTag": "@param data Data."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a 2D-array (in row major order) representing the metrics."
    },
    {
        "oracle": ";",
        "javadocTag": "@param map Map."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a 2D-array (in row major order) representing the property."
    },
    {
        "oracle": ";",
        "javadocTag": "@param n Neuron."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the (row, column) coordinates of {@code n}, or {@code null}\nif no such neuron belongs to the {@link #LocationFinder(NeuronSquareMesh2D)\nmap used to build this instance}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param map Map."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathIllegalStateException if the network contains non-unique\nidentifiers.  This indicates an inconsistent state due to a bug in\nthe construction code of the underlying\n{@link org.apache.commons.math3.ml.neuralnet.Network network}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param normalizeCount Whether to compute relative bin counts.\nIf {@code true}, the data count in each bin will be divided by the total\nnumber of samples."
    },
    {
        "oracle": ";",
        "javadocTag": "@param distance Distance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param distance Distance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param relativeCount Whether to compute relative bin counts.\nIf {@code true}, the data count in each bin will be divided by the total\nnumber of samples mapped to the neuron represented by that bin."
    },
    {
        "oracle": ";",
        "javadocTag": "@param distance Distance."
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the dummy value type in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new map backed set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <V> the dummy value type in the map"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dummyValue the dummy value to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new map backed set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param map the map to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param dummyValue the dummy value to use"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if map is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new unmodifiable {@link SortedSet}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if set is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new predicated sorted set."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the set contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated sorted set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the set contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a decorated set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the set contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated set"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the set contains invalid elements"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new unmodifiable {@link NavigableSet}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param out the output stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param in the input stream"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IOException "
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ClassNotFoundException "
    },
    {
        "oracle": ";",
        "javadocTag": "@param set the set to decorate, must not be null"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullPointerException if set is null"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed {@link SortedSet}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new transformed {@link SortedSet}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the decorated set"
    },
    {
        "oracle": ";",
        "javadocTag": "@param e the enumeration to get a value from"
    },
    {
        "oracle": ";",
        "javadocTag": "@param index the index to get"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <T> the type of object in the {@link Enumeration}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object at the specified index"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IndexOutOfBoundsException if the index is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if the object type is invalid"
    },
    {
        "oracle": ";",
        "javadocTag": "@param <E> the element type"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list containing all elements of the given enumeration"
    },
    {
        "oracle": ";",
        "javadocTag": "@param stringTokenizer the tokenizer to convert to a {@link List}&lt;{@link String}&gt;"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a list containing all tokens of the given StringTokenizer"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be accepted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object of the first sequence that should be deleted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param skipped number of tokens skipped since the last call (i.e. number of\n  tokens that were in both sequences), this number should be strictly positive\n  except on the very first call where it can be zero (if the first object of\n  the two sequences are different)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param from sub-sequence of objects coming from the first sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param to sub-sequence of objects coming from the second sequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be accepted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object of the second sequence that should be inserted"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the edit script resulting from the comparison of the two\n        sequences"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start the value of the start of the snake"
    },
    {
        "oracle": ";",
        "javadocTag": "@param diag the value of the diagonal of the snake"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end1 the value of the end of the first sequence to be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end2 the value of the end of the second sequence to be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the snake built"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start1 the begin of the first sequence to be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end1 the end of the first sequence to be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start2 the begin of the second sequence to be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end2 the end of the second sequence to be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the middle snake"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start1 the begin of the first sequence to be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end1 the end of the first sequence to be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@param start2 the begin of the second sequence to be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@param end2 the end of the second sequence to be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@param script the edited script"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence1 first sequence to be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence2 second sequence to be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence1 first sequence to be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@param sequence2 second sequence to be compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@param equator the equator to use for testing object equality"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object object to insert"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object synchronization object detected"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object object to delete"
    },
    {
        "oracle": ";",
        "javadocTag": "@param handler handler to call when synchronized sequences are found"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be accepted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object the object belonging to both sequences (the object is a\n  reference to the instance in the first sequence which is known\n  to be equal to an instance in the second sequence)"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the object on which the command is applied"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor to be accepted"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object reference to the object associated with this command, this\n  refers to an element of one of the sequences being compared"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object object to insert (this object comes from the second sequence)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object object to keep (this object comes from the first sequence)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param object object to delete (this object comes from the first sequence)"
    },
    {
        "oracle": ";",
        "javadocTag": "@param command command to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param command command to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param command command to add"
    },
    {
        "oracle": ";",
        "javadocTag": "@param visitor the visitor that will visit all commands in turn"
    },
    {
        "oracle": ";",
        "javadocTag": "@return length of the Longest Common Subsequence"
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if two fractions are equal, false if object is\n        {@code null}, not an instance of {@link Fraction}, or not equal\n        to this fraction instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fraction as a {@code float}"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the numerator."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code value for this object"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the whole number fraction part"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the whole number fraction part"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the negation of this fraction."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the reciprocal fraction"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code Fraction} instance with the resulting values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the resulting numerator or denominator exceeds\n {@code Integer.MAX_VALUE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the {@code integer} to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this + i"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code Fraction} instance with the resulting values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the resulting numerator or denominator\n  cannot be represented in an {@code int}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the {@code integer} to subtract."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this - i"
    },
    {
        "oracle": ";",
        "javadocTag": "@param fraction the fraction to subtract, must not be {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param isAdd true to add, false to subtract"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code Fraction} instance with the resulting values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws NullArgumentException if the fraction is {@code null}"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the resulting numerator or denominator\n  cannot be represented in an {@code int}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code Fraction} instance with the resulting values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the resulting numerator or denominator exceeds\n {@code Integer.MAX_VALUE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the {@code integer} to multiply by."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this * i"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code Fraction} instance with the resulting values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the fraction to divide by is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the resulting numerator or denominator exceeds\n {@code Integer.MAX_VALUE}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the {@code integer} to divide by."
    },
    {
        "oracle": ";",
        "javadocTag": "@return this * i"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fraction percentage as a {@code double}."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numerator the numerator, for example the three in 'three sevenths'"
    },
    {
        "oracle": ";",
        "javadocTag": "@param denominator the denominator, for example the seven in 'three sevenths'"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new fraction instance, with the numerator and denominator reduced"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a string representation of the fraction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the double value to convert to a fraction."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FractionConversionException if the continued fraction failed to\n        converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the double value to convert to a fraction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon maximum error allowed.  The resulting fraction is within\n       {@code epsilon} of {@code value}, in absolute terms."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations maximum number of convergents"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FractionConversionException if the continued fraction failed to\n        converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the double value to convert to a fraction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxDenominator The maximum allowed value for denominator"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FractionConversionException if the continued fraction failed to\n        converge"
    },
    {
        "oracle": ";",
        "javadocTag": "@param value the double value to convert to a fraction."
    },
    {
        "oracle": ";",
        "javadocTag": "@param epsilon maximum error allowed.  The resulting fraction is within\n       {@code epsilon} of {@code value}, in absolute terms."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxDenominator maximum denominator value allowed."
    },
    {
        "oracle": ";",
        "javadocTag": "@param maxIterations maximum number of convergents"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws FractionConversionException if the continued fraction failed to\n        converge."
    },
    {
        "oracle": ";",
        "javadocTag": "@param num the numerator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param num the numerator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param den the denominator."
    },
    {
        "oracle": ";",
        "javadocTag": "@param numerator the numerator, for example the three in 'three sevenths'."
    },
    {
        "oracle": ";",
        "javadocTag": "@param denominator the denominator, for example the seven in 'three sevenths'."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a new fraction instance, with the numerator and denominator\n        reduced."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the absolute value as a {@link BigFraction}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a <code>BigFraction</code> instance with the resulting values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the {@code integer} to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a <code>BigFraction</code> instance with the resulting values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the {@code long} to add."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a <code>BigFraction</code> instance with the resulting values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link BigFraction} instance with the resulting values."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fraction as a <code>BigDecimal</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws ArithmeticException if the exact quotient does not have a terminating decimal\n            expansion."
    },
    {
        "oracle": ";",
        "javadocTag": "@param roundingMode rounding mode to apply. see {@link BigDecimal} constants."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fraction as a <code>BigDecimal</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws IllegalArgumentException if {@code roundingMode} does not represent a valid rounding\n            mode."
    },
    {
        "oracle": ";",
        "javadocTag": "@param scale scale of the <code>BigDecimal</code> quotient to be returned.\n           see {@link BigDecimal} for more information."
    },
    {
        "oracle": ";",
        "javadocTag": "@param roundingMode rounding mode to apply. see {@link BigDecimal} constants."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fraction as a <code>BigDecimal</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@return -1 if this is less than {@code object}, +1 if this is greater\n        than {@code object}, 0 if they are equal."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link BigFraction} instance with the resulting values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the fraction to divide by is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the {@code int} to divide by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link BigFraction} instance with the resulting values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the fraction to divide by is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the {@code long} to divide by"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link BigFraction} instance with the resulting values"
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the fraction to divide by is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link BigFraction} instance with the resulting values."
    },
    {
        "oracle": ";",
        "javadocTag": "@throws MathArithmeticException if the fraction to divide by is zero"
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fraction as a {@code double}"
    },
    {
        "oracle": ";",
        "javadocTag": "@param other fraction to test for equality to this fraction, can be\n           <code>null</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@return true if two fractions are equal, false if object is\n        <code>null</code>, not an instance of {@link BigFraction}, or not\n        equal to this fraction instance."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the fraction as a {@code float}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the denominator as a <code>BigInteger</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the denominator as a {@code int}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the denominator as a {@code long}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the numerator as a <code>BigInteger</code>."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the numerator as a {@code int}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the numerator as a {@code long}."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a hash code value for this object."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the whole number fraction part."
    },
    {
        "oracle": ";",
        "javadocTag": "@return the whole number fraction part."
    },
    {
        "oracle": ";",
        "javadocTag": "@param bg the {@code BigInteger} to multiply by."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@code BigFraction} instance with the resulting values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param i the {@code int} to multiply by."
    },
    {
        "oracle": ";",
        "javadocTag": "@return a {@link BigFraction} instance with the resulting values."
    },
    {
        "oracle": ";",
        "javadocTag": "@param l the {@code long} to multiply by."
    }
]