"output = [\n  {\n    'tag': '@return this',\n    'alternatives': []\n  },\n  {\n    'tag': '@throws IllegalStateException if the service is not {@link State#NEW}',\n    'alternatives': []\n  },\n  {\n    'tag': '@return this',\n    'alternatives': []\n  },\n  {\n    'tag': '@throws IllegalStateException if the service reaches a state from which it is not possible to\\n    enter the {@link State#RUNNING} state. e.g. if the {@code state} is \\n    {@code State#TERMINATED} when this method is called then this will throw an \\n    IllegalStateException.',\n    'alternatives': []\n  },\n  {\n    'tag': '@param timeout the maximum time to wait',\n    'alternatives': [\n      '@param timeout the maximum waiting time',\n      '@param timeout the longest time to wait',\n      '@param timeout the maximum waiting duration',\n      '@param timeout the maximum time allowed for waiting',\n      '@param timeout the time limit for waiting'\n    ]\n  },\n  {\n    'tag': '@param unit the time unit of the timeout argument',\n    'alternatives': [\n      '@param unit the unit of time for the timeout argument',\n      '@param unit the time measurement for the timeout argument',\n      '@param unit the duration unit for the timeout parameter',\n      '@param unit the time duration associated with the timeout argument',\n      '@param unit the time scale of the timeout argument'\n    ]\n  },\n  {\n    'tag': '@throws TimeoutException if the service has not reached the given state within the deadline',\n    'alternatives': []\n  },\n  {\n    'tag': '@throws IllegalStateException if the service reaches a state from which it is not possible to\\n    enter the {@link State#RUNNING RUNNING} state. e.g. if the {@code state} is \\n    {@code State#TERMINATED} when this method is called then this will throw an \\n    IllegalStateException.',\n    'alternatives': []\n  },\n  {\n    'tag': '@throws IllegalStateException if the service {@linkplain State#FAILED fails}.',\n    'alternatives': []\n  },\n  {\n    'tag': '@param timeout the maximum time to wait',\n    'alternatives': [\n      '@param timeout the maximum waiting time',\n      '@param timeout the longest time to wait',\n      '@param timeout the maximum waiting duration',\n      '@param timeout the maximum time allowed for waiting',\n      '@param timeout the time limit for waiting'\n    ]\n  },\n  {\n    'tag': '@param unit the time unit of the timeout argument',\n    'alternatives': [\n      '@param unit the unit of time for the timeout argument',\n      '@param unit the time measurement for the timeout argument',\n      '@param unit the duration unit for the timeout parameter',\n      '@param unit the time duration associated with the timeout argument',\n      '@param unit the time scale of the timeout argument'\n    ]\n  },\n  {\n    'tag': '@throws TimeoutException if the service has not reached the given state within the deadline',\n    'alternatives': []\n  },\n  {\n    'tag': '@throws IllegalStateException if the service {@linkplain State#FAILED fails}.',\n    'alternatives': []\n  },\n  {\n    'tag': \"@throws IllegalStateException if this service's state isn't {@linkplain State#FAILED FAILED}.\",\n    'alternatives': []\n  },\n  {\n    'tag': '@param listener the listener to run when the service changes state is complete',\n    'alternatives': [\n      '@param listener the listener to execute when the service completes state change',\n      '@param listener the callback function to invoke when the service finishes state transition',\n      '@param listener the handler to execute when the service changes its state to complete',\n      '@param listener the function to call when the service's state change is complete',\n      '@param listener the action to perform when the service reaches a complete state'\n    ]\n  },\n  {\n    'tag': '@param executor the executor in which the listeners callback methods will be run. For fast,\\n    lightweight listeners that would be safe to execute in any thread, consider \\n    {@link MoreExecutors#directExecutor}.',\n    'alternatives': [\n      '@param executor the executor that will run the listeners callback methods. If the listeners are fast and lightweight and can be executed in any thread, you may consider using {@link MoreExecutors#directExecutor}',\n      '@param executor the executor that executes the callback methods of the listeners. If the listeners are fast and lightweight and can be safely executed in any thread, you may consider using {@link MoreExecutors#directExecutor}',\n      '@param executor the executor used to run the callback methods of the listeners. For listeners that are fast and lightweight and can be safely run in any thread, it is recommended to use {@link MoreExecutors#directExecutor}',\n      '@param executor the executor that will execute the callback functions of the listeners. If the listeners are fast and lightweight and can be executed in any thread without any issues, you may consider using {@link MoreExecutors#directExecutor}',\n      '@param executor the executor in which the callback methods of the listeners will be executed. For listeners that are fast and lightweight and don\\'t have any thread-safety concerns, it is recommended to use {@link MoreExecutors#directExecutor}'\n    ]\n  },\n  {\n    'tag': '@param callable The callable to wrap',\n    'alternatives': [\n      '@param callable The function to encapsulate',\n      '@param callable The method to encapsulate',\n      '@param callable The task to encapsulate',\n      '@param callable The operation to enclose',\n      '@param callable The code block to wrap'\n    ]\n  },\n  {\n    'tag': '@param nameSupplier The supplier of thread names, {@link Supplier#get get} will be called once\\n    for each invocation of the wrapped callable.',\n    'alternatives': [\n      '@param nameSupplier The provider of thread names, {@link Supplier#get get} will be invoked once\\n    for every invocation of the wrapped callable.',\n      '@param nameSupplier The source of thread names, {@link Supplier#get get} will be triggered once\\n    for each invocation of the wrapped callable.',\n      '@param nameSupplier The generator of thread names, {@link Supplier#get get} will be executed once\\n    for every invocation of the wrapped callable.',\n      '@param nameSupplier The supplier that provides the thread names, {@link Supplier#get get} will be used once\\n    for each call to the wrapped callable.',\n      '@param nameSupplier The supplier responsible for providing the thread names, {@link Supplier#get get} will be invoked once\\n    for every call to the wrapped callable.'\n    ]\n  },\n  {\n    'tag': '@param task The Runnable to wrap',\n    'alternatives': [\n      '@param task The Runnable to encapsulate',\n      '@param task The Runnable to enclose',\n      '@param task The Runnable to include',\n      '@param task The Runnable to envelop',\n      '@param task The Runnable to surround'\n    ]\n  },\n  {\n    'tag': '@param nameSupplier The supplier of thread names, {@link Supplier#get get} will be called once\\n    for each invocation of the wrapped callable.',\n    'alternatives': [\n      '@param nameSupplier The provider of thread names, {@link Supplier#get get} will be invoked once\\n    for every invocation of the wrapped callable.',\n      '@param nameSupplier The source of thread names, {@link Supplier#get get} will be triggered once\\n    for each invocation of the wrapped callable.',\n      '@param nameSupplier The generator of thread names, {@link Supplier#get get} will be executed once\\n    for every invocation of the wrapped callable.',\n      '@param nameSupplier The supplier that provides the thread names, {@link Supplier#get get} will be used once\\n    for each call to the wrapped callable.',\n      '@param nameSupplier The supplier responsible for providing the thread names, {@link Supplier#get get} will be invoked once\\n    for every call to the wrapped callable.'\n    ]\n  },\n  {\n    'tag': \"@param t the exception that made the future fail. If the future's {@link Future#get() get}\\n    method throws an {@link ExecutionException}, then the cause is passed to this method. Any\\n    other thrown object is passed unaltered.\",\n    'alternatives': [\n      \"@param t the exception that caused the future to fail. If the {@link Future#get() get}\\n    method of the future throws an {@link ExecutionException}, the cause will be passed to this method. Any\\n    other thrown object will be passed without modification.\",\n      \"@param t the exception that resulted in the failure of the future. If the {@link Future#get() get}\\n    method throws an {@link ExecutionException}, then the cause will be provided to this method. Any\\n    other thrown object will be provided as is.\",\n      \"@param t the exception that led to the failure of the future. If the {@link Future#get() get}\\n    method throws an {@link ExecutionException}, the cause will be passed to this method. Any\\n    other thrown object will be passed unaltered.\",\n      \"@param t the exception that caused the future to be unsuccessful. If the {@link Future#get() get}\\n    method throws an {@link ExecutionException}, the cause is passed to this method. Any\\n    other thrown object is passed without modification.\",\n      \"@param t the exception that resulted in the failure of the future. If the {@link Future#get() get}\\n    method throws an {@link ExecutionException}, then the cause will be provided to this method. Any\\n    other thrown object will be provided as is.\"\n    ]\n  },\n  {\n    'tag': '@param key an arbitrary, non-null key',\n    'alternatives': [\n      '@param key a random, non-null key',\n      '@param key any non-null, arbitrary key',\n      '@param key a non-null key of any kind',\n      '@param key an arbitrary, non-empty key',\n      '@param key a non-null key with no specific constraints'\n    ]\n  },\n  {\n    'tag': '@return the stripe that the passed key corresponds to',\n    'alternatives': [\n      '@return the stripe associated with the provided key',\n      '@return the stripe corresponding to the given key',\n      '@return the stripe that corresponds to the supplied key',\n      '@return the stripe related to the given key',\n      '@return the stripe linked to the provided key'\n    ]\n  },\n  {\n    'tag': '@param index the index of the stripe to return; must be in {@code [0...size())}',\n    'alternatives': [\n      '@param index the index of the stripe to get; must be within the range of {@code [0...size())}',\n      '@param index the stripe index to retrieve; must be in the {@code [0...size())} range',\n      '@param index the index of the stripe to obtain; should be between {@code 0} and {@code size() - 1} inclusive',\n      '@param index the stripe position to fetch; must be a valid index within the range of {@code [0...size())}',\n      '@param index the index of the stripe to fetch; must fall within the bounds of {@code [0...size())}'\n    ]\n  },\n  {\n    'tag': '@return the stripe at the specified index',\n    'alternatives': [\n      '@return the stripe located at the given index',\n      '@return the stripe found at the specified index',\n      '@return the stripe corresponding to the provided index',\n      '@return the stripe identified by the given index',\n      '@return the stripe positioned at the index given'\n    ]\n  }\n]"