"output = [\n  {\n    'tag': '@throws MathIllegalStateException if data has already been added\\n (i.e if n > 0)',\n    'alternatives': [\n      '@throws MathIllegalStateException if data has been previously added\\n (i.e if n > 0)',\n      '@throws MathIllegalStateException if data has already been included\\n (i.e if n > 0)',\n      '@throws MathIllegalStateException if the data has been added before\\n (i.e if n > 0)',\n      '@throws MathIllegalStateException if there is existing data added\\n (i.e if n > 0)',\n      '@throws MathIllegalStateException if the data has been already added\\n (i.e if n > 0)'\n    ]\n  },\n  {\n    'tag': '@return the StorelessUnivariateStatistic implementing the log sum',\n    'alternatives': [\n      '@return the StorelessUnivariateStatistic that implements the log sum',\n      '@return the log sum implemented by the StorelessUnivariateStatistic',\n      '@return the log sum computed by the StorelessUnivariateStatistic',\n      '@return the log sum that is implemented by the StorelessUnivariateStatistic',\n      '@return the StorelessUnivariateStatistic that calculates the log sum'\n    ]\n  },\n  {\n    'tag': '@param sumLogImpl the StorelessUnivariateStatistic instance to use\\nfor computing the log sum',\n    'alternatives': [\n      '@param sumLogImpl the instance of StorelessUnivariateStatistic to be used\\nfor calculating the log sum',\n      '@param sumLogImpl the instance of StorelessUnivariateStatistic to use\\nin order to compute the log sum',\n      '@param sumLogImpl the instance of StorelessUnivariateStatistic that will be utilized\\nfor the computation of the log sum',\n      '@param sumLogImpl the StorelessUnivariateStatistic instance for computing the log sum',\n      '@param sumLogImpl the StorelessUnivariateStatistic instance used to calculate the log sum'\n    ]\n  },\n  {\n    'tag': '@throws DimensionMismatchException if the array dimension\\ndoes not match the one used at construction',\n    'alternatives': [\n      '@throws DimensionMismatchException if the dimension of the array\\ndoes not correspond to the one used during construction',\n      '@throws DimensionMismatchException if the array dimension\\nis not equal to the dimension used at initialization',\n      '@throws DimensionMismatchException if the dimension of the array\\ndoes not match the one provided during construction',\n      '@throws DimensionMismatchException if the array size\\nis different from the one used at creation',\n      '@throws DimensionMismatchException if the dimension of the array\\nis incompatible with the one used at construction'\n    ]\n  },\n  {\n    'tag': '@return the StorelessUnivariateStatistic implementing the geometric mean',\n    'alternatives': [\n      '@return the StorelessUnivariateStatistic that implements the geometric mean',\n      '@return the geometric mean implemented by the StorelessUnivariateStatistic',\n      '@return the geometric mean calculated by the StorelessUnivariateStatistic',\n      '@return the geometric mean that is implemented by the StorelessUnivariateStatistic',\n      '@return the StorelessUnivariateStatistic that computes the geometric mean'\n    ]\n  },\n  {\n    'tag': '@param geoMeanImpl the StorelessUnivariateStatistic instance to use\\nfor computing the geometric mean',\n    'alternatives': [\n      '@param geoMeanImpl the instance of StorelessUnivariateStatistic to be used\\nfor calculating the geometric mean',\n      '@param geoMeanImpl the instance of StorelessUnivariateStatistic to use\\nin order to compute the geometric mean',\n      '@param geoMeanImpl the instance of StorelessUnivariateStatistic that will be utilized\\nfor the computation of the geometric mean',\n      '@param geoMeanImpl the StorelessUnivariateStatistic instance for computing the geometric mean',\n      '@param geoMeanImpl the StorelessUnivariateStatistic instance used to calculate the geometric mean'\n    ]\n  },\n  {\n    'tag': '@throws DimensionMismatchException if the array dimension\\ndoes not match the one used at construction',\n    'alternatives': [\n      '@throws DimensionMismatchException if the dimension of the array\\nis different from the one used during construction',\n      '@throws DimensionMismatchException if the array dimension\\nis not equal to the dimension used at initialization',\n      '@throws DimensionMismatchException if the dimension of the array\\ndoes not correspond to the one provided during construction',\n      '@throws DimensionMismatchException if the array size\\nis incompatible with the one used at creation',\n      '@throws DimensionMismatchException if the dimension of the array\\nis not the same as the one used at construction'\n    ]\n  },\n  {\n    'tag': '@throws MathIllegalStateException if data has already been added\\n (i.e if n > 0)',\n    'alternatives': [\n      '@throws MathIllegalStateException if data has been previously added\\n (i.e if n > 0)',\n      '@throws MathIllegalStateException if data has already been included\\n (i.e if n > 0)',\n      '@throws MathIllegalStateException if the data has been added before\\n (i.e if n > 0)',\n      '@throws MathIllegalStateException if there is existing data added\\n (i.e if n > 0)',\n      '@throws MathIllegalStateException if the data has been already added\\n (i.e if n > 0)'\n    ]\n  },\n  {\n    'tag': '@return the StorelessUnivariateStatistic implementing the mean',\n    'alternatives': [\n      '@return the StorelessUnivariateStatistic that implements the mean',\n      '@return the mean implemented by the StorelessUnivariateStatistic',\n      '@return the mean computed by the StorelessUnivariateStatistic',\n      '@return the mean that is implemented by the StorelessUnivariateStatistic',\n      '@return the StorelessUnivariateStatistic that calculates the mean'\n    ]\n  },\n  {\n    'tag': '@param meanImpl the StorelessUnivariateStatistic instance to use\\nfor computing the mean',\n    'alternatives': [\n      '@param meanImpl the instance of StorelessUnivariateStatistic to be used\\nfor calculating the mean',\n      '@param meanImpl the instance of StorelessUnivariateStatistic to use\\nin order to compute the mean',\n      '@param meanImpl the instance of StorelessUnivariateStatistic that will be utilized\\nfor the computation of the mean',\n      '@param meanImpl the StorelessUnivariateStatistic instance for computing the mean',\n      '@param meanImpl the StorelessUnivariateStatistic instance used to calculate the mean'\n    ]\n  },\n  {\n    'tag': '@throws DimensionMismatchException if the array dimension\\ndoes not match the one used at construction',\n    'alternatives': [\n      '@throws DimensionMismatchException if the dimension of the array\\nis different from the one used during construction',\n      '@throws DimensionMismatchException if the array dimension\\nis not equal to the dimension used at initialization',\n      '@throws DimensionMismatchException if the dimension of the array\\ndoes not correspond to the one provided during construction',\n      '@throws DimensionMismatchException if the array size\\nis incompatible with the one used at creation',\n      '@throws DimensionMismatchException if the dimension of the array\\nis not the same as the one used at construction'\n    ]\n  },\n  {\n    'tag': '@throws MathIllegalStateException if data has already been added\\n (i.e if n > 0)',\n    'alternatives': [\n      '@throws MathIllegalStateException if data has been previously added\\n (i.e if n > 0)',\n      '@throws MathIllegalStateException if data has already been included\\n (i.e if n > 0)',\n      '@throws MathIllegalStateException if the data has been added before\\n (i.e if n > 0)',\n      '@throws MathIllegalStateException if there is existing data added\\n (i.e if n > 0)',\n      '@throws MathIllegalStateException if the data has been already added\\n (i.e if n > 0)'\n    ]\n  },\n  {\n    'tag': '@throws MathIllegalStateException if n > 0.',\n    'alternatives': [\n      '@throws MathIllegalStateException if n is greater than 0.',\n      '@throws MathIllegalStateException if n is larger than 0.',\n      '@throws MathIllegalStateException if n exceeds 0.',\n      '@throws MathIllegalStateException if n is above 0.',\n      '@throws MathIllegalStateException if n goes beyond 0.'\n    ]\n  },\n  {\n    'tag': '@param dimension dimension to check',\n    'alternatives': [\n      '@param dimension the dimension to verify',\n      '@param dimension the dimension to validate',\n      '@param dimension the dimension to examine',\n      '@param dimension the dimension to test',\n      '@param dimension the dimension to assess'\n    ]\n  },\n  {\n    'tag': '@throws DimensionMismatchException if dimension != k',\n    'alternatives': [\n      '@throws DimensionMismatchException if the dimension is not equal to k',\n      '@throws DimensionMismatchException if the dimension does not match k',\n      '@throws DimensionMismatchException if dimension is different from k',\n      '@throws DimensionMismatchException if dimension does not equal k',\n      '@throws DimensionMismatchException if the dimension is unequal to k'\n    ]\n  },\n  {\n    'tag': '@param k dimension of the data',\n    'alternatives': [\n      '@param k the dimension of the data',\n      '@param k the size of the data',\n      '@param k the number of elements in the data',\n      '@param k the length of the data',\n      '@param k the count of the data'\n    ]\n  },\n  {\n    'tag': '@param isCovarianceBiasCorrected if true, the unbiased sample\\ncovariance is computed, otherwise the biased population covariance\\nis computed',\n    'alternatives': [\n      '@param isCovarianceBiasCorrected if true, calculate the unbiased sample\\ncovariance, otherwise compute the biased population covariance',\n      '@param isCovarianceBiasCorrected if true, compute the corrected sample\\ncovariance, otherwise evaluate the uncorrected population covariance',\n      '@param isCovarianceBiasCorrected if true, determine the bias-corrected sample\\ncovariance, otherwise derive the biased population covariance',\n      '@param isCovarianceBiasCorrected if true, derive the unbiased sample\\ncovariance, otherwise obtain the biased population covariance',\n      '@param isCovarianceBiasCorrected if true, obtain the corrected sample\\ncovariance, otherwise calculate the biased population covariance'\n    ]\n  },\n  {\n    'tag': '@param source SecondMoment to copy',\n    'alternatives': [\n      '@param source the SecondMoment to be copied',\n      '@param source the SecondMoment to duplicate',\n      '@param source the SecondMoment to replicate',\n      '@param source the SecondMoment to clone',\n      '@param source the SecondMoment to imitate'\n    ]\n  },\n  {\n    'tag': '@param dest SecondMoment to copy to',\n    'alternatives': [\n      '@param dest the SecondMoment to copy to',\n      '@param dest the SecondMoment to be copied to',\n      '@param dest the SecondMoment to transfer to',\n      '@param dest the SecondMoment to duplicate to',\n      '@param dest the SecondMoment to replicate to'\n    ]\n  },\n  {\n    'tag': '@param original the {@code SecondMoment} instance to copy',\n    'alternatives': [\n      '@param original the {@code SecondMoment} instance to be copied',\n      '@param original the {@code SecondMoment} instance to duplicate',\n      '@param original the {@code SecondMoment} instance to replicate',\n      '@param original the {@code SecondMoment} instance to clone',\n      '@param original the {@code SecondMoment} instance to imitate'\n    ]\n  },\n  {\n    'tag': '@param values the input array',\n    'alternatives': [\n      '@param values the array of values',\n      '@param values the array of input',\n      '@param values the input data',\n      '@param values the data values',\n      '@param values the array of elements'\n    ]\n  },\n  {\n    'tag': '@param begin index of the first array element to include',\n    'alternatives': [\n      '@param begin the starting index of the array element to be included',\n      '@param begin the index of the first array element to incorporate',\n      '@param begin the position of the initial array element to contain',\n      '@param begin the index of the beginning array element to encompass',\n      '@param begin the location of the starting array element to include'\n    ]\n  },\n  {\n    'tag': '@param length the number of elements to include',\n    'alternatives': [\n      '@param length the count of elements to be included',\n      '@param length the quantity of elements to incorporate',\n      '@param length the size of elements to contain',\n      '@param length the number of elements to encompass',\n      '@param length the length of the range of elements to include'\n    ]\n  },\n  {\n    'tag': '@return the mean of the values or Double.NaN if length = 0',\n    'alternatives': [\n      '@return the average of the values or Double.NaN if length is 0',\n      '@return the mean of the values or Double.NaN if the length is zero',\n      '@return the average value of the data or Double.NaN if the length equals 0',\n      '@return the mean of the values or Double.NaN if the length is equal to zero',\n      '@return the average or Double.NaN if length = 0'\n    ]\n  }\n]"