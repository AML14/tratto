"[\n    {\n        'tag': '@throws IllegalStateException if an initial capacity was already set',\n        'alternatives': [\n            '@throws IllegalStateException if a capacity was already set for the initial state',\n            '@throws IllegalStateException if an initial capacity has already been specified',\n            '@throws IllegalStateException if a previous initial capacity has been set',\n            '@throws IllegalStateException if the initial capacity has already been set'\n        ]\n    },\n    {\n        'tag': '@param size the maximum size of the map',\n        'alternatives': [\n            '@param size the map\\'s maximum size',\n            '@param size the maximum number of elements the map can hold',\n            '@param size the maximum number of entries the map can contain',\n            '@param size the upper limit for the map\\'s size'\n        ]\n    },\n    {\n        'tag': '@throws IllegalStateException if a maximum size was already set',\n        'alternatives': [\n            '@throws IllegalStateException if a size limit has already been specified',\n            '@throws IllegalStateException if a maximum size limit has been set',\n            '@throws IllegalStateException if a previous maximum size has been set',\n            '@throws IllegalStateException if the maximum size has already been set'\n        ]\n    },\n    {\n        'tag': '@throws IllegalStateException if a concurrency level was already set',\n        'alternatives': [\n            '@throws IllegalStateException if a concurrency level has already been specified',\n            '@throws IllegalStateException if a previous concurrency level has been set',\n            '@throws IllegalStateException if the concurrency level has already been set',\n            '@throws IllegalStateException if a degree of parallelism has already been set'\n        ]\n    },\n    {\n        'tag': '@throws IllegalStateException if the key strength was already set',\n        'alternatives': [\n            '@throws IllegalStateException if a key strength has already been specified',\n            '@throws IllegalStateException if a previous key strength has been set',\n            '@throws IllegalStateException if the strength of the key has already been set',\n            '@throws IllegalStateException if the key's strength has already been defined'\n        ]\n    },\n    {\n        'tag': '@throws IllegalStateException if the value strength was already set',\n        'alternatives': [\n            '@throws IllegalStateException if a value strength has already been specified',\n            '@throws IllegalStateException if a previous value strength has been set',\n            '@throws IllegalStateException if the strength of the value has already been set',\n            '@throws IllegalStateException if the value's strength has already been defined'\n        ]\n    },\n    {\n        'tag': '@throws IllegalStateException if the value strength was already set',\n        'alternatives': [\n            '@throws IllegalStateException if a value strength has already been specified',\n            '@throws IllegalStateException if a previous value strength has been set',\n            '@throws IllegalStateException if the strength of the value has already been set',\n            '@throws IllegalStateException if the value's strength has already been defined'\n        ]\n    },\n    {\n        'tag': '@param duration the length of time after an entry is created that it should be automatically\\n    removed',\n        'alternatives': [\n            '@param duration the time span after an entry is created when it should be automatically\\n    eliminated',\n            '@param duration the time interval from the entry\\'s creation in which it should be automatically\\n    removed',\n            '@param duration the amount of time after an entry is created that triggers its automatic\\n    removal',\n            '@param duration the period of time after an entry is created that leads to its automatic\\n    removal'\n        ]\n    },\n    {\n        'tag': '@param unit the unit that {@code duration} is expressed in',\n        'alternatives': [\n            '@param unit the time unit in which {@code duration} is measured',\n            '@param unit the time interval unit used for {@code duration}',\n            '@param unit the measurement unit for the time duration specified by {@code duration}',\n            '@param unit the time scale for the parameter {@code duration}'\n        ]\n    },\n    {\n        'tag': '@throws IllegalStateException if the time to live or time to idle was already set',\n        'alternatives': [\n            '@throws IllegalStateException if the TTL or TTI has already been specified',\n            '@throws IllegalStateException if a previous time to live or time to idle has been set',\n            '@throws IllegalStateException if the time duration for expiration or idle time has already been set',\n            '@throws IllegalStateException if the expiration or idle time has already been defined'\n        ]\n    },\n    {\n        'tag': '@param duration the length of time after an entry is last accessed that it should be\\n    automatically removed',\n        'alternatives': [\n            '@param duration the time span after the entry\\'s last access when it should be\\n    automatically eliminated',\n            '@param duration the time interval from the entry\\'s last access in which it should be\\n    removed automatically',\n            '@param duration the amount of time after the entry\\'s last access that triggers its automatic\\n    removal',\n            '@param duration the period of time after the entry\\'s last access that leads to its automatic\\n    removal'\n        ]\n    },\n    {\n        'tag': '@param unit the unit that {@code duration} is expressed in',\n        'alternatives': [\n            '@param unit the time unit in which the parameter {@code duration} is measured',\n            '@param unit the time interval unit used for the parameter {@code duration}',\n            '@param unit the measurement unit for the time duration specified by {@code duration}',\n            '@param unit the time scale for the duration indicated by {@code duration}'\n        ]\n    },\n    {\n        'tag': '@throws IllegalStateException if the time to idle or time to live was already set',\n        'alternatives': [\n            '@throws IllegalStateException if the TTI or TTL has already been specified',\n            '@throws IllegalStateException if a previous time to idle or time to live has been set',\n            '@throws IllegalStateException if the time duration for idle or expiration has already been set',\n            '@throws IllegalStateException if the idle or expiration time has already been defined'\n        ]\n    },\n    {\n        'tag': '@throws IllegalStateException if a removal listener was already set',\n        'alternatives': [\n            '@throws IllegalStateException if a prior removal listener has been established',\n            '@throws IllegalStateException if a removal listener has already been registered',\n            '@throws IllegalStateException if a previous removal listener has been set',\n            '@throws IllegalStateException if an existing removal listener has already been supplied'\n        ]\n    },\n    {\n        'tag': '@return a serializable concurrent map having the requested features',\n        'alternatives': [\n            '@return a concurrent map that supports serialization and possesses the desired features',\n            '@return a concurrent map that is both serializable and contains the specified features',\n            '@return a concurrent map with the specified characteristics that can also be serialized',\n            '@return a serializable concurrent map with the requested attributes'\n        ]\n    },\n    {\n        'tag': '@param computingFunction the function used to compute new values',\n        'alternatives': [\n            '@param computingFunction the function that calculates fresh values',\n            '@param computingFunction the function responsible for generating new values',\n            '@param computingFunction the function employed to compute updated values',\n            '@param computingFunction the function that derives new values'\n        ]\n    },\n    {\n        'tag': '@return a serializable concurrent map having the requested features',\n        'alternatives': [\n            '@return a concurrent map that supports serialization and possesses the desired features',\n            '@return a concurrent map that is both serializable and contains the specified features',\n            '@return a concurrent map with the specified characteristics that can also be serialized',\n            '@return a serializable concurrent map with the requested attributes'\n        ]\n    },\n    {\n        'tag': '@return an empty collection of values',\n        'alternatives': [\n            '@return a collection of values that is empty',\n            '@return a collection of values with no elements',\n            '@return a collection that contains no values',\n            '@return an empty collection of elements'\n        ]\n    },\n    {\n        'tag': '@param key key to associate with values in the collection',\n        'alternatives': [\n            '@param key the key that will be associated with the values in the collection',\n            '@param key the key used to link the values in the collection',\n            '@param key the identifier used to connect the values in the collection',\n            '@param key the unique identifier for the values in the collection'\n        ]\n    },\n    {\n        'tag': '@return an empty collection of values',\n        'alternatives': [\n            '@return a collection of values that is empty',\n            '@return a collection of values with no elements',\n            '@return a collection that contains no values',\n            '@return an empty collection of elements'\n        ]\n    },\n    {\n        'tag': '@return an iterator across map entries',\n        'alternatives': [\n            '@return an iterator that traverses through the entries of the map',\n            '@return an iterator that allows access to the map\\'s entries',\n            '@return an iterator that goes through the entries of the map',\n            '@return an iterator for iterating over the map\\'s entries'\n        ]\n    },\n    {\n        'tag': '@param map place to store the mapping from each key to its corresponding\\n    values',\n        'alternatives': [\n            '@param map the destination for storing the mapping from each key to its associated\\n    values',\n            '@param map the target where the mapping from each key to its corresponding\\n    values will be stored',\n            '@param map the container for keeping the mapping from each key to its related\\n    values',\n            '@param map the place to hold the mapping from each key to its respective\\n    values'\n        ]\n    },\n    {\n        'tag': '@param object object whose subscriber methods should be registered.',\n        'alternatives': [\n            '@param object the object that contains the methods to be registered as subscribers',\n            '@param object the object whose subscriber methods are to be added',\n            '@param object the object that holds the subscriber methods to be registered',\n            '@param object the object with the subscriber methods to be included'\n        ]\n    },\n    {\n        'tag': '@param object object whose subscriber methods should be unregistered.',\n        'alternatives': [\n            '@param object the object that contains the methods to be unregistered as subscribers',\n            '@param object the object whose subscriber methods are to be removed',\n            '@param object the object that holds the subscriber methods to be unregistered',\n            '@param object the object with the subscriber methods to be excluded'\n        ]\n    },\n    {\n        'tag': '@throws IllegalArgumentException if the object was not previously registered.',\n        'alternatives': [\n            '@throws IllegalArgumentException if the object has not been registered before',\n            '@throws IllegalArgumentException if the provided object was not registered previously',\n            '@throws IllegalArgumentException if the object has not been previously registered',\n            '@throws IllegalArgumentException if the object was not already registered'\n        ]\n    }\n]"