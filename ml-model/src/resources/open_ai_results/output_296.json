"output = [\n  {\n    'tag': '@param globalCurrentState end of the global step',\n    'alternatives': [\n      '@param globalCurrentState end of the global phase',\n      '@param globalCurrentState endpoint of the global step',\n      '@param globalCurrentState final point of the overall step'\n    ]\n  },\n  {\n    'tag': '@param softPreviousState start of the restricted step',\n    'alternatives': [\n      '@param softPreviousState beginning of the limited step',\n      '@param softPreviousState initial point of the restricted step',\n      '@param softPreviousState onset of the constrained phase'\n    ]\n  },\n  {\n    'tag': '@param softCurrentState end of the restricted step',\n    'alternatives': [\n      '@param softCurrentState endpoint of the constrained step',\n      '@param softCurrentState final point of the limited phase',\n      '@param softCurrentState termination of the restricted step'\n    ]\n  },\n  {\n    'tag': '@param mapper equations mapper for the all equations',\n    'alternatives': [\n      '@param mapper equations converter for all the equations',\n      '@param mapper equations mapper for every equation',\n      '@param mapper equations transformer for all equations'\n    ]\n  },\n  {\n    'tag': \"@param highOrder high order scaled derivatives\\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\",\n    'alternatives': [\n      \"@param highOrder high order scaled derivatives\\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\",\n      \"@param highOrder high order scaled derivatives\\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\",\n      \"@param highOrder high order scaled derivatives\\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\",\n    ]\n  },\n  {\n    'tag': '@param start first order scaled derivatives at step start',\n    'alternatives': [\n      '@param start first order scaled derivatives at start of step',\n      '@param start initial point derivatives of first order at step start',\n      '@param start scaled derivatives of first order at step start'\n    ]\n  },\n  {\n    'tag': '@param end first order scaled derivatives at step end',\n    'alternatives': [\n      '@param end first order scaled derivatives at end of step',\n      '@param end final point derivatives of first order at step end',\n      '@param end scaled derivatives of first order at step end'\n    ]\n  },\n  {\n    'tag': \"@param highOrder high order scaled derivatives, will be modified\\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\",\n    'alternatives': [\n      \"@param highOrder high order scaled derivatives, will be altered\\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\",\n      \"@param highOrder high order scaled derivatives, will change\\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\",\n      \"@param highOrder high order scaled derivatives, will be adjusted\\n(h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\"\n    ]\n  },\n  {\n    'tag': '@param name name of the method',\n    'alternatives': [\n      '@param name method name',\n      '@param name identifier of the method',\n      '@param name title of the method'\n    ]\n  },\n  {\n    'tag': '@param nSteps number of steps of the method excluding the one being computed',\n    'alternatives': [\n      '@param nSteps number of steps in the method excluding the current one',\n      '@param nSteps total steps in the method excluding the current one',\n      '@param nSteps count of steps in the method except for the current one'\n    ]\n  },\n  {\n    'tag': '@param order order of the method',\n    'alternatives': [\n      '@param order method order',\n      '@param order rank of the method',\n      '@param order level of the method'\n    ]\n  },\n  {\n    'tag': '@param minStep minimal step (sign is irrelevant, regardless of\\nintegration direction, forward or backward), the last step can\\nbe smaller than this',\n    'alternatives': [\n      '@param minStep smallest step (sign does not matter, independent of\\nintegration direction, forward or backward). The final step can\\nbe smaller than this',\n      '@param minStep minimum step size (sign does not matter, regardless of\\nintegration direction, forward or backward). The last step can be smaller than this',\n      '@param minStep lowest step size (sign is irrelevant, regardless of\\nintegration direction, forward or backward). The last step may\\nbe smaller than this'\n    ]\n  },\n  {\n    'tag': '@param maxStep maximal step (sign is irrelevant, regardless of\\nintegration direction, forward or backward), the last step can\\nbe smaller than this',\n    'alternatives': [\n      '@param maxStep largest step (sign does not matter, independent of\\nintegration direction, forward or backward). The final step can\\nbe smaller than this',\n      '@param maxStep maximum step size (sign does not matter, regardless of\\nintegration direction, forward or backward). The last step can be smaller than this',\n      '@param maxStep highest step size (sign is irrelevant, regardless of\\nintegration direction, forward or backward). The last step may\\nbe smaller than this'\n    ]\n  },\n  {\n    'tag': '@param scalAbsoluteTolerance allowed absolute error',\n    'alternatives': [\n      '@param scalAbsoluteTolerance permitted absolute discrepancy',\n      '@param scalAbsoluteTolerance acceptable absolute deviation',\n      '@param scalAbsoluteTolerance tolerated absolute difference'\n    ]\n  },\n  {\n    'tag': '@param scalRelativeTolerance allowed relative error',\n    'alternatives': [\n      '@param scalRelativeTolerance permitted relative discrepancy',\n      '@param scalRelativeTolerance acceptable relative deviation',\n      '@param scalRelativeTolerance tolerated relative difference'\n    ]\n  },\n  {\n    'tag': '@param name name of the method',\n    'alternatives': [\n      '@param name method name',\n      '@param name identifier of the method',\n      '@param name title of the method'\n    ]\n  },\n  {\n    'tag': '@param nSteps number of steps of the method excluding the one being computed',\n    'alternatives': [\n      '@param nSteps number of steps in the method excluding the current one',\n      '@param nSteps total steps in the method excluding the current one',\n      '@param nSteps count of steps in the method except for the current one'\n    ]\n  },\n  {\n    'tag': '@param order order of the method',\n    'alternatives': [\n      '@param order method order',\n      '@param order rank of the method',\n      '@param order level of the method'\n    ]\n  },\n  {\n    'tag': '@param minStep minimal step (sign is irrelevant, regardless of\\nintegration direction, forward or backward), the last step can\\nbe smaller than this',\n    'alternatives': [\n      '@param minStep smallest step (sign does not matter, independent of\\nintegration direction, forward or backward). The final step can\\nbe smaller than this',\n      '@param minStep minimum step size (sign does not matter, regardless of\\nintegration direction, forward or backward). The last step can be smaller than this',\n      '@param minStep lowest step size (sign is irrelevant, regardless of\\nintegration direction, forward or backward). The last step may\\nbe smaller than this'\n    ]\n  },\n  {\n    'tag': '@param maxStep maximal step (sign is irrelevant, regardless of\\nintegration direction, forward or backward), the last step can\\nbe smaller than this',\n    'alternatives': [\n      '@param maxStep largest step (sign does not matter, independent of\\nintegration direction, forward or backward). The final step can\\nbe smaller than this',\n      '@param maxStep maximum step size (sign does not matter, regardless of\\nintegration direction, forward or backward). The last step can be smaller than this',\n      '@param maxStep highest step size (sign is irrelevant, regardless of\\nintegration direction, forward or backward). The last step may\\nbe smaller than this'\n    ]\n  },\n  {\n    'tag': '@param vecAbsoluteTolerance allowed absolute error',\n    'alternatives': [\n      '@param vecAbsoluteTolerance permitted absolute discrepancy',\n      '@param vecAbsoluteTolerance acceptable absolute deviation',\n      '@param vecAbsoluteTolerance tolerated absolute difference'\n    ]\n  },\n  {\n    'tag': '@param vecRelativeTolerance allowed relative error',\n    'alternatives': [\n      '@param vecRelativeTolerance permitted relative discrepancy',\n      '@param vecRelativeTolerance acceptable relative deviation',\n      '@param vecRelativeTolerance tolerated relative difference'\n    ]\n  },\n  {\n    'tag': '@param field field to which the time and state vector elements belong',\n    'alternatives': [\n      '@param field field of the time and state vector elements',\n      '@param field domain to which the time and state vector elements relate',\n      '@param field area that the time and state vector elements pertain to'\n    ]\n  },\n  {\n    'tag': '@param step integration step',\n    'alternatives': [\n      '@param step step of integration',\n      '@param step integration increment',\n      '@param step integration time step'\n    ]\n  },\n  {\n    'tag': '@param interpolator interpolator to copy from. The copy is a deep\\ncopy: its arrays are separated from the original arrays of the\\ninstance',\n    'alternatives': [\n      '@param interpolator interpolation function to duplicate from. The duplication is a deep\\nreproduction: its arrays are unattached from the original arrays of the\\ninstance',\n      '@param interpolator interpolator to replicate from. The replication is a deep\\ncopy: its arrays are distinct from the original arrays of the\\ninstance',\n      '@param interpolator interpolator to imitate from. The imitation is a deep\\ncopy: its arrays are separate from the original arrays of the\\ninstance'\n    ]\n  }\n]"