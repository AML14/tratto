"output=[\n    {'tag': '@param x Argument', 'alternatives': [\n        '@param x Parameter',\n        '@param x Input',\n        '@param x Value'\n    ]},\n    {'tag': '@return Value of the Bessel function at x', 'alternatives': [\n        '@return Result of the Bessel function at x',\n        '@return Bessel function value at x',\n        '@return The value of the Bessel function evaluated at x'\n    ]},\n    {'tag': '@throws MathIllegalArgumentException if {@code x} is too large relative to {@code order}', 'alternatives': [\n        '@throws MathIllegalArgumentException if {@code x} exceeds {@code order}',\n        '@throws MathIllegalArgumentException if the value of {@code x} is disproportionately large compared to the {@code order}',\n        '@throws MathIllegalArgumentException if {@code x} is significantly larger than {@code order}'\n    ]},\n    {'tag': '@throws ConvergenceException if the algorithm fails to converge', 'alternatives': [\n        '@throws ConvergenceException if the algorithm does not converge',\n        '@throws ConvergenceException if convergence fails',\n        '@throws ConvergenceException if the algorithm fails to reach convergence'\n    ]},\n    {'tag': '@param order Order of the Bessel function', 'alternatives': [\n        '@param order The order of the Bessel function',\n        '@param order The function order',\n        '@param order The Bessel function order'\n    ]},\n    {'tag': '@return Value of the Bessel function of the first kind, \\\\(J_{order}(x)\\\\)', 'alternatives': [\n        '@return Value of the Bessel function of the first kind, denoted as \\\\(J_{order}(x)\\\\)',\n        '@return Value of Bessel function of the first kind, \\\\(J_{order}(x)\\\\)',\n        '@return The value of Bessel function of the first kind, denoted as \\\\(J_{order}(x)\\\\)'\n    ]},\n    {'tag': '@throws MathIllegalArgumentException if {@code x} is too large relative to {@code order}', 'alternatives': [\n        '@throws MathIllegalArgumentException if {@code x} is considerably greater than {@code order}',\n        '@throws MathIllegalArgumentException if the magnitude of {@code x} relative to {@code order} is too high',\n        '@throws MathIllegalArgumentException if the difference between {@code x} and {@code order} is large'\n    ]},\n    {'tag': '@throws ConvergenceException if the algorithm fails to converge', 'alternatives': [\n        '@throws ConvergenceException if the algorithm fails to reach convergence',\n        '@throws ConvergenceException if convergence cannot be achieved',\n        '@throws ConvergenceException if the algorithm does not converge'\n    ]},\n    {'tag': \"@param x non-negative real argument for which J's are to be calculated\", 'alternatives': [\n        \"@param x Non-negative real value that needs Bessel function calculations\",\n        \"@param x Non-negative argument for Bessel function calculations\",\n        \"@param x Non-negative real number used to calculate Bessel functions\"\n    ]},\n    {'tag': '@param alpha fractional part of order for which J's or exponentially\\nscaled J's (\\\\(J\\\\cdot e^{x}\\\\)) are to be calculated. 0 <= alpha < 1.0.', 'alternatives': [\n        '@param alpha Fractional part of order for calculating Bessel functions or exponentially\\nscaled J functions (\\\\(J\\\\cdot e^{x}\\\\)). 0 <= alpha < 1.0',\n        '@param alpha Fractional part of order used in the calculation of Bessel functions or exponentially\\nscaled J functions (\\\\(J\\\\cdot e^{x}\\\\)). 0 <= alpha < 1.0',\n        '@param alpha Fractional part of the order, determining the calculation of Bessel functions or exponentially\\nscaled J functions (\\\\(J\\\\cdot e^{x}\\\\)). 0 <= alpha < 1.0'\n    ]},\n    {'tag': '@param nb integer number of functions to be calculated, nb > 0. The first\\nfunction calculated is of order alpha, and the last is of order\\nnb - 1 + alpha.', 'alternatives': [\n        '@param nb Integer value representing the number of functions to be computed, where nb > 0. The initial\\ncomputed function has an order of alpha, and the final function has an order of\\nnb - 1 + alpha',\n        '@param nb Integer value indicating the count of functions that will be computed, with nb > 0. The first\\nfunction to be computed has an order of alpha, while the last function has an order of\\nnb - 1 + alpha',\n        '@param nb Number of functions to be calculated, represented as an integer, where nb > 0. The order of the first\\nfunction calculated is alpha, and the order of the last function calculated is nb - 1 + alpha'\n    ]},\n    {'tag': '@return BesselJResult a vector of the functions\\n\\\\(J_{alpha}(x)\\\\) through \\\\(J_{nb-1+alpha}(x)\\\\), or the corresponding exponentially\\nscaled functions and an integer output variable indicating possible errors', 'alternatives': [\n        '@return BesselJResult a vector containing the functions\\n\\\\(J_{alpha}(x)\\\\) to \\\\(J_{nb-1+alpha}(x)\\\\), or the corresponding exponentially\\nscaled functions along with an integer output variable indicating potential errors',\n        '@return BesselJResult a vector that includes the functions\\n\\\\(J_{alpha}(x)\\\\) through \\\\(J_{nb-1+alpha}(x)\\\\), or the corresponding exponentially\\nscaled functions with an integer output variable indicating possible errors',\n        '@return BesselJResult a vector holding the functions\\n\\\\(J_{alpha}(x)\\\\) to \\\\(J_{nb-1+alpha}(x)\\\\), or the corresponding exponentially\\nscaled functions, along with an integer output variable indicating potential errors'\n    ]},\n    {'tag': '@param order order of the function computed when using {@link #value(double)}.', 'alternatives': [\n        '@param order The order of the function computed when using the {@link #value(double)} method',\n        '@param order The computed function order when using the {@link #value(double)}',\n        '@param order The order of the function resulting from the usage of the {@link #value(double)} method'\n    ]},\n    {'tag': '@param x Argument.', 'alternatives': [\n        '@param x Input.',\n        '@param x Value.',\n        '@param x Parameter.'\n    ]},\n    {'tag': '@return the value of {@code log(Gamma(x))}, {@code Double.NaN} if\\n{@code x <= 0.0}.', 'alternatives': [\n        '@return the result of {@code log(Gamma(x))}, or {@code Double.NaN} if\\n{@code x <= 0.0}',\n        '@return the value of computing {@code log(Gamma(x))}, with {@code Double.NaN} when\\n{@code x <= 0.0}',\n        '@return the calculated value of {@code log(Gamma(x))}, or {@code Double.NaN} if the\\nvalue of {@code x} is less than or equal to 0.0'\n    ]},\n    {'tag': '@param a Parameter.', 'alternatives': [\n        '@param a Input.',\n        '@param a Value.',\n        '@param a Argument.'\n    ]},\n    {'tag': '@param x Value.', 'alternatives': [\n        '@param x Argument.',\n        '@param x Parameter.',\n        '@param x Input.'\n    ]},\n    {'tag': '@return the regularized gamma function P(a, x).', 'alternatives': [\n        '@return the regularized gamma function represented as P(a, x)',\n        '@return the value of the regularized gamma function P(a, x)',\n        '@return the result of the regularized gamma function P(a, x)'\n    ]},\n    {'tag': '@throws MaxCountExceededException if the algorithm fails to converge.', 'alternatives': [\n        '@throws MaxCountExceededException if convergence is not achieved by the algorithm',\n        '@throws MaxCountExceededException if the algorithm does not converge',\n        '@throws MaxCountExceededException if the algorithm fails to reach convergence'\n    ]},\n    {'tag': '@param a the a parameter.', 'alternatives': [\n        '@param a the parameter a.',\n        '@param a the parameter value.',\n        '@param a the value of a.'\n    ]},\n    {'tag': '@param x the value.', 'alternatives': [\n        '@param x the input value.',\n        '@param x the parameter.',\n        '@param x the argument.'\n    ]},\n    {'tag': '@param epsilon When the absolute value of the nth item in the\\nseries is less than epsilon the approximation ceases to calculate\\nfurther elements in the series.', 'alternatives': [\n        '@param epsilon Calculation terminates when the absolute value of the nth\\nitem in the series falls below epsilon',\n        '@param epsilon The calculation stops when the absolute value of the nth\\nelement in the series is less than epsilon',\n        '@param epsilon The approximation ends when the absolute value of the nth\\nitem in the series becomes smaller than epsilon'\n    ]},\n    {'tag': '@param maxIterations Maximum number of \"iterations\" to complete.', 'alternatives': [\n        '@param maxIterations Max number of iterations to perform.',\n        '@param maxIterations The maximum number of iterations to be executed.',\n        '@param maxIterations The maximum allowable number of \"iterations\" to finish.'\n    ]},\n    {'tag': '@return the regularized gamma function P(a, x)', 'alternatives': [\n        '@return the regularized gamma function P(a, x)',\n        '@return the value of the regularized gamma function P(a, x)',\n        '@return the result of the regularized gamma function P(a, x)'\n    ]}\n]"