"output = [\r\n  {\r\n    'tag': '@param keyType the type of reference to use for keys;\\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}',\r\n    'alternatives': [\r\n      '@param keyType the reference type to be used for keys;\\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}',\r\n      '@param keyType specifies the reference type to be used for keys;\\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}',\r\n      '@param keyType determines the reference type for keys to be used;\\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param valueType the type of reference to use for values;\\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}',\r\n    'alternatives': [\r\n      '@param valueType the reference type to be used for values;\\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}',\r\n      '@param valueType specifies the reference type to be used for values;\\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}',\r\n      '@param valueType determines the reference type for values to be used;\\n  must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\\n  {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\\n  {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param capacity the initial capacity for the map',\r\n    'alternatives': [\r\n      '@param capacity the map\\'s initial capacity',\r\n      '@param capacity the initial size of the map',\r\n      '@param capacity specifies the initial capacity for the map'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param loadFactor the load factor for the map',\r\n    'alternatives': [\r\n      '@param loadFactor the map\\'s load factor',\r\n      '@param loadFactor the factor used for map resizing',\r\n      '@param loadFactor specifies the load factor for the map'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param purgeValues should the value be automatically purged when the\\n  key is garbage collected',\r\n    'alternatives': [\r\n      '@param purgeValues specifies automatic purging of values when the\\n  key is garbage collected',\r\n      '@param purgeValues determines if the value should be automatically purged when the\\n  key is garbage collected',\r\n      '@param purgeValues controls whether the value should be automatically purged when the\\n  key is garbage collected'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param <K> the key type',\r\n    'alternatives': [\r\n      '@param <K> the type of key',\r\n      '@param <K> specifies the key type',\r\n      '@param <K> represents the type of keys'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param <V> the value type',\r\n    'alternatives': [\r\n      '@param <V> the type of value',\r\n      '@param <V> specifies the value type',\r\n      '@param <V> represents the type of values'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return a new transformed map',\r\n    'alternatives': [\r\n      '@return a new map obtained through transformation',\r\n      '@return a newly created transformed map',\r\n      '@return a map that has been transformed and is new'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param <K> the key type',\r\n    'alternatives': [\r\n      '@param <K> the type of key',\r\n      '@param <K> specifies the key type',\r\n      '@param <K> represents the type of keys'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param <V> the value type',\r\n    'alternatives': [\r\n      '@param <V> the type of value',\r\n      '@param <V> specifies the value type',\r\n      '@param <V> represents the type of values'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return a new transformed map',\r\n    'alternatives': [\r\n      '@return a new map obtained through transformation',\r\n      '@return a newly created transformed map',\r\n      '@return a map that has been transformed and is new'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param out the output stream',\r\n    'alternatives': [\r\n      '@param out the stream for output',\r\n      '@param out the output stream to be used',\r\n      '@param out specifies the output stream'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@throws IOException ',\r\n    'alternatives': [\r\n      '@throws IOException when an I/O exception occurs',\r\n      '@throws IOException if an I/O error occurs',\r\n      '@throws IOException in case of an I/O problem'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param in the input stream',\r\n    'alternatives': [\r\n      '@param in the stream for input',\r\n      '@param in the input stream to be used',\r\n      '@param in specifies the input stream'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@throws IOException ',\r\n    'alternatives': [\r\n      '@throws IOException when an I/O exception occurs',\r\n      '@throws IOException if an I/O error occurs',\r\n      '@throws IOException in case of an I/O problem'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@throws ClassNotFoundException ',\r\n    'alternatives': [\r\n      '@throws ClassNotFoundException when the expected class is not found',\r\n      '@throws ClassNotFoundException if the specified class is not found',\r\n      '@throws ClassNotFoundException if the required class cannot be found'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return a vector containing {@code this[i] * v[i]} for all {@code i}',\r\n    'alternatives': [\r\n      '@return a vector with the element-wise product of {@code this} and {@code v} for all {@code i}',\r\n      '@return a vector that contains the element-wise multiplication of {@code this[i]} and {@code v[i]} for all {@code i}',\r\n      '@return a vector including the result of element-wise multiplication of {@code this[i]} and {@code v[i]} for all {@code i}'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@throws DimensionMismatchException if {@code v} is not the same size as {@code this}',\r\n    'alternatives': [\r\n      '@throws DimensionMismatchException when the size of {@code v} does not match {@code this}',\r\n      '@throws DimensionMismatchException if {@code v} and {@code this} have different sizes',\r\n      '@throws DimensionMismatchException in case the size of {@code v} differs from the size of {@code this}'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param v vector by which instance elements must be divided',\r\n    'alternatives': [\r\n      '@param v vector with which to divide instance elements',\r\n      '@param v vector used to divide instance elements',\r\n      '@param v specifies the vector by which instance elements are to be divided'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return a vector containing {@code this[i] / v[i]} for all {@code i}',\r\n    'alternatives': [\r\n      '@return a vector with the element-wise division of {@code this} and {@code v} for all {@code i}',\r\n      '@return a vector that contains the element-wise division of {@code this[i]} and {@code v[i]} for all {@code i}',\r\n      '@return a vector including the result of element-wise division of {@code this[i]} and {@code v[i]} for all {@code i}'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@throws DimensionMismatchException if {@code v} is not the same size as {@code this}',\r\n    'alternatives': [\r\n      '@throws DimensionMismatchException when the size of {@code v} does not match {@code this}',\r\n      '@throws DimensionMismatchException if {@code v} and {@code this} have different sizes',\r\n      '@throws DimensionMismatchException in case the size of {@code v} differs from the size of {@code this}'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@throws MathArithmeticException if one entry of {@code v} is zero.',\r\n    'alternatives': [\r\n      '@throws MathArithmeticException when one element of {@code v} is zero.',\r\n      '@throws MathArithmeticException if any element of {@code v} equals zero.',\r\n      '@throws MathArithmeticException if a value in {@code v} is zero.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return T array of entries',\r\n    'alternatives': [\r\n      '@return an array of entries of type T',\r\n      '@return an array that contains entries of type T',\r\n      '@return an array holding entries of type T'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param v vector with which dot product should be computed',\r\n    'alternatives': [\r\n      '@param v vector used to compute the dot product',\r\n      '@param v specifies the vector for dot product computation',\r\n      '@param v vector for calculating the dot product'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return the scalar dot product of {@code this} and {@code v}',\r\n    'alternatives': [\r\n      '@return the dot product of {@code this} and {@code v} as a scalar',\r\n      '@return the scalar result of the dot product of {@code this} and {@code v}',\r\n      '@return the dot product of {@code this} and {@code v} represented as a scalar'\r\n    ]\r\n  }\r\n]\r\n"