"output=[\n  {\n    \"tag\": \"@return the TiesStrategy\",\n    \"alternatives\": [\n      \"@return the TiesStrategy\",\n      \"@return the strategy for handling ties\",\n      \"@return the strategy used for resolving ties\"\n    ]\n  },\n  {\n    \"tag\": \"@param data array to be ranked\",\n    \"alternatives\": [\n      \"@param data input array to be ranked\",\n      \"@param data the array that needs to be ranked\",\n      \"@param data the array that will be sorted\"\n    ]\n  },\n  {\n    \"tag\": \"@param region region to check against the instance\",\n    \"alternatives\": [\n      \"@param region the region to compare with the instance\",\n      \"@param region the region that will be validated against the instance\",\n      \"@param region the region used for checking the instance\"\n    ]\n  },\n  {\n    \"tag\": \"@return true if the instance contains the specified tree\",\n    \"alternatives\": [\n      \"@return true if the instance includes the provided tree\",\n      \"@return true if the specified tree exists within the instance\",\n      \"@return true if the instance contains the given tree\"\n    ]\n  },\n  {\n    \"tag\": \"@param point point to check\",\n    \"alternatives\": [\n      \"@param point the point to verify\",\n      \"@param point the point that needs to be checked\",\n      \"@param point the point to be validated\"\n    ]\n  },\n  {\n    \"tag\": \"@return a code representing the point status: either {@link\\nLocation#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}\",\n    \"alternatives\": [\n      \"@return a code indicating the status of the point: either {@link\\nLocation#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}\",\n      \"@return a code that represents the position of the point: either {@link\\nLocation#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}\",\n      \"@return a code that describes the point's status: either {@link\\nLocation#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}\"\n    ]\n  },\n  {\n    \"tag\": \"@param includeBoundaryAttributes if true, the boundary attributes\\nat internal nodes are guaranteed to be included (they may be\\nincluded even if the argument is false, if they have already been\\ncomputed due to a previous call)\",\n    \"alternatives\": [\n      \"@param includeBoundaryAttributes whether to include the boundary attributes\\nat internal nodes (they can still be included even if the argument is false, if they were already computed during a previous call)\",\n      \"@param includeBoundaryAttributes indicating if the boundary attributes\\nat internal nodes should be included (they might still be included even if the argument is false, if they were previously computed)\",\n      \"@param includeBoundaryAttributes set to true to guarantee the inclusion of boundary attributes\\nat internal nodes (they might also be included if the argument is false, depending on any previous computations)\"\n    ]\n  },\n  {\n    \"tag\": \"@return underlying BSP tree\",\n    \"alternatives\": [\n      \"@return the underlying BSP tree\",\n      \"@return the BSP tree that serves as the foundation\",\n      \"@return the deep structure of the BSP tree\"\n    ]\n  },\n  {\n    \"tag\": \"@return the size of the instance (this is a length in 1D, an area\\nin 2D, a volume in 3D ...)\",\n    \"alternatives\": [\n      \"@return the size of the instance (measured as a length in 1D, an area\\nin 2D, a volume in 3D ...)\",\n      \"@return the dimension of the instance (1D for length, 2D for area, 3D for volume, ...)\",\n      \"@return the measure of the instance (1D for length, 2D for area, 3D for volume, ...)\"\n    ]\n  },\n  {\n    \"tag\": \"@return an object representing the barycenter\",\n    \"alternatives\": [\n      \"@return an object that represents the centroid\",\n      \"@return an object that symbolizes the average location\",\n      \"@return an object that denotes the center of mass\"\n    ]\n  },\n  {\n    \"tag\": \"@param hyperplane reference hyperplane\",\n    \"alternatives\": [\n      \"@param hyperplane the reference hyperplane\",\n      \"@param hyperplane the hyperplane being referred to\",\n      \"@param hyperplane the hyperplane used as reference\"\n    ]\n  },\n  {\n    \"tag\": \"@return one of {@link Side#PLUS Side.PLUS}, {@link Side#MINUS\\nSide.MINUS}, {@link Side#BOTH Side.BOTH} or {@link Side#HYPER\\nSide.HYPER} (the latter result can occur only if the tree\\ncontains only one cut hyperplane)\",\n    \"alternatives\": [\n      \"@return one of {@link Side#PLUS Side.PLUS}, {@link Side#MINUS\\nSide.MINUS}, {@link Side#BOTH Side.BOTH} or {@link Side#HYPER\\nSide.HYPER} (the last option can only occur when the tree\\ncontains a single cut hyperplane)\",\n      \"@return one of the following: {@link Side#PLUS Side.PLUS}, {@link Side#MINUS\\nSide.MINUS}, {@link Side#BOTH Side.BOTH}, or {@link Side#HYPER\\nSide.HYPER} (the last option is only possible if the tree\\nhas only one cut hyperplane)\",\n      \"@return either {@link Side#PLUS Side.PLUS}, {@link Side#MINUS\\nSide.MINUS}, {@link Side#BOTH Side.BOTH}, or {@link Side#HYPER\\nSide.HYPER} (the final option can only occur if the tree\\ncontains only a single cut hyperplane)\"\n    ]\n  },\n  {\n    \"tag\": \"@param sub sub-hyperplane traversing the region\",\n    \"alternatives\": [\n      \"@param sub the sub-hyperplane that crosses the region\",\n      \"@param sub the sub-hyperplane that cuts through the specified region\",\n      \"@param sub the sub-hyperplane that intersects the region\"\n    ]\n  },\n  {\n    \"tag\": \"@return filtered sub-hyperplane\",\n    \"alternatives\": [\n      \"@return the filtered sub-hyperplane\",\n      \"@return the sub-hyperplane after applying the filtering\",\n      \"@return the sub-hyperplane that has been refined\"\n    ]\n  },\n  {\n    \"tag\": \"@param point point to transform\",\n    \"alternatives\": [\n      \"@param point the point to be transformed\",\n      \"@param point the point that requires transformation\",\n      \"@param point the point that needs to undergo transformation\"\n    ]\n  },\n  {\n    \"tag\": \"@return a new object representing the transformed point\",\n    \"alternatives\": [\n      \"@return a new object that represents the transformed point\",\n      \"@return a new object that symbolizes the point after transformation\",\n      \"@return a new object that denotes the transformed point\"\n    ]\n  },\n  {\n    \"tag\": \"@param hyperplane hyperplane to transform\",\n    \"alternatives\": [\n      \"@param hyperplane the hyperplane to be transformed\",\n      \"@param hyperplane the hyperplane that requires transformation\",\n      \"@param hyperplane the hyperplane to undergo transformation\"\n    ]\n  },\n  {\n    \"tag\": \"@return a new object representing the transformed hyperplane\",\n    \"alternatives\": [\n      \"@return a new object that represents the transformed hyperplane\",\n      \"@return a new object that symbolizes the hyperplane after transformation\",\n      \"@return a new object that denotes the transformed hyperplane\"\n    ]\n  },\n  {\n    \"tag\": \"@param sub sub-hyperplane to transform\",\n    \"alternatives\": [\n      \"@param sub the sub-hyperplane to be transformed\",\n      \"@param sub the sub-hyperplane that requires transformation\",\n      \"@param sub the sub-hyperplane to undergo transformation\"\n    ]\n  },\n  {\n    \"tag\": \"@param original hyperplane in which the sub-hyperplane is\\ndefined (this is the original hyperplane, the transform has\\n<em>not</em> been applied to it)\",\n    \"alternatives\": [\n      \"@param original the original hyperplane in which the sub-hyperplane is\\ndefined (this is the original hyperplane, and the transform has\\n<em>not</em> been applied to it)\",\n      \"@param original the hyperplane in which the sub-hyperplane is originally\\ndefined (this is the untransformed hyperplane)\",\n      \"@param original the hyperplane that defines the sub-hyperplane (this is\\nthe original hyperplane, without any transformations)\"\n    ]\n  },\n  {\n    \"tag\": \"@param transformed hyperplane in which the sub-hyperplane is\\ndefined (this is the transformed hyperplane, the transform\\n<em>has</em> been applied to it)\",\n    \"alternatives\": [\n      \"@param transformed the transformed hyperplane in which the sub-hyperplane is\\ndefined (this is the hyperplane after the transformation has\\nbeen applied)\",\n      \"@param transformed the hyperplane in which the sub-hyperplane is now\\ndefined (this is the hyperplane after the transformation)\",\n      \"@param transformed the hyperplane that defines the sub-hyperplane after\\nthe transformation (this is the transformed hyperplane)\"\n    ]\n  },\n  {\n    \"tag\": \"@return a new object representing the transformed sub-hyperplane\",\n    \"alternatives\": [\n      \"@return a new object that represents the transformed sub-hyperplane\",\n      \"@return a new object that symbolizes the sub-hyperplane after transformation\",\n      \"@return a new object that denotes the transformed sub-hyperplane\"\n    ]\n  },\n  {\n    \"tag\": \"@param node node to add\",\n    \"alternatives\": [\n      \"@param node the node to be added\",\n      \"@param node the node that needs to be included\",\n      \"@param node the node that should be appended\"\n    ]\n  }\n]"