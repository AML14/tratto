"output = [\n  {\n    'tag': '@param typeParam the parameter type variable',\n    'alternatives': [\n      '@param typeParam the variable representing the type of the parameter',\n      '@param typeParam the variable that represents the type of the parameter',\n      '@param typeParam the type variable for the parameter'\n    ]\n  },\n  {\n    'tag': '@param typeArg the actual type to substitute',\n    'alternatives': [\n      '@param typeArg the real type to replace',\n      '@param typeArg the concrete type to use instead',\n      '@param typeArg the type that should be substituted'\n    ]\n  },\n  {\n    'tag': '@return the value previously associated with this class (possibly {@code null}),\\n        or {@code null} if there was no previous entry.',\n    'alternatives': [\n      '@return the previously associated value for this class (may be {@code null}),\\n        or {@code null} if there was no previous entry.',\n      '@return the value that was previously linked to this class (maybe {@code null}),\\n        or {@code null} if there was no previous entry.',\n      '@return the value that was associated with this class earlier (possibly {@code null}),\\n        or {@code null} if there was no previous entry.'\n    ]\n  },\n  {\n    'tag': '@return the value previously associated with this type (possibly {@code null}),\\n        or {@code null} if there was no previous entry.',\n    'alternatives': [\n      '@return the previously associated value for this type (may be {@code null}),\\n        or {@code null} if there was no previous entry.',\n      '@return the value that was previously linked to this type (maybe {@code null}),\\n        or {@code null} if there was no previous entry.',\n      '@return the value that was associated with this type earlier (possibly {@code null}),\\n        or {@code null} if there was no previous entry.'\n    ]\n  },\n  {\n    'tag': \"@param formal The type whose type variables or itself is mapped to other type(s). It's almost\\n       always a bug if {@code formal} isn't a type variable and contains no type variable. Make\\n       sure you are passing the two parameters in the right order.\",\n    'alternatives': [\n      \"@param formal The type that has its type variables or itself mapped to other type(s). It is usually\\n       an error if {@code formal} is not a type variable and does not contain any type variable. Make\\n       sure you pass the two parameters in the correct sequence.\",\n      \"@param formal The type that has its type variables or itself mapped to different type(s). It is almost\\n       always a bug if {@code formal} is not a type variable and does not contain any type variable. Ensure\\n       that you pass the two parameters in the correct order.\",\n      \"@param formal The type that has its type variables or itself mapped to some other type(s). It's usually\\n       a mistake if {@code formal} is not a type variable and doesn't contain any type variables. Make\\n       sure you pass the two parameters in the right order.\"\n    ]\n  },\n  {\n    'tag': \"@param actual The type that the formal type variable(s) are mapped to. It can be or contain yet\\n       other type variables, in which case these type variables will be further resolved if\\n       corresponding mappings exist in the current {@code TypeResolver} instance.\",\n    'alternatives': [\n      \"@param actual The type to which the formal type variable(s) are mapped. It can also be or include additional\\n       type variables, in which case the resolution of these type variables depends on the presence of\\n       corresponding mappings in the current {@code TypeResolver} instance.\",\n      \"@param actual The type to which the formal type variable(s) are mapped. It can also be or contain additional\\n       type variables, and in such cases, the resolution of these type variables depends on the existence\\n       of corresponding mappings in the current {@code TypeResolver} instance.\",\n      \"@param actual The type to which the formal type variable(s) are mapped. It can also be or include more\\n       type variables, and in these cases, the resolution of those type variables is subject to the presence\\n       of corresponding mappings in the current {@code TypeResolver} instance.\"\n    ]\n  },\n  {\n    'tag': '@throws IOException if an I/O error occurs in the process of opening the reader',\n    'alternatives': [\n      '@throws IOException if an I/O error happens when opening the reader',\n      '@throws IOException if there is an I/O error while opening the reader',\n      '@throws IOException if a problem occurs during the process of opening the reader'\n    ]\n  },\n  {\n    'tag': '@throws IOException if an I/O error occurs in the process of reading the length of this source',\n    'alternatives': [\n      '@throws IOException if there is an I/O error when reading the length of this source',\n      '@throws IOException if an I/O error occurs while reading the length of this source',\n      '@throws IOException if a problem occurs while trying to read the length of this source'\n    ]\n  },\n  {\n    'tag': '@throws IOException if an I/O error occurs in the process of reading from this source or\\n    writing to {@code appendable}',\n    'alternatives': [\n      '@throws IOException if there is an I/O error when reading from this source or\\n    writing to {@code appendable}',\n      '@throws IOException if an I/O error occurs while reading from this source or\\n    writing to {@code appendable}',\n      '@throws IOException if a problem occurs while trying to read from this source or\\n    write to {@code appendable}'\n    ]\n  },\n  {\n    'tag': '@throws IOException if an I/O error occurs in the process of reading from this source or\\n    writing to {@code sink}',\n    'alternatives': [\n      '@throws IOException if there is an I/O error when reading from this source or\\n    writing to {@code sink}',\n      '@throws IOException if an I/O error occurs while reading from this source or\\n    writing to {@code sink}',\n      '@throws IOException if a problem occurs while trying to read from this source or\\n    write to {@code sink}'\n    ]\n  },\n  {\n    'tag': '@throws IOException if an I/O error occurs in the process of reading from this source',\n    'alternatives': [\n      '@throws IOException if there is an I/O error when reading from this source',\n      '@throws IOException if an I/O error occurs while reading from this source',\n      '@throws IOException if a problem occurs while trying to read from this source'\n    ]\n  },\n  {\n    'tag': '@throws IOException if an I/O error occurs in the process of reading from this source or if\\n    {@code processor} throws an {@code IOException}',\n    'alternatives': [\n      '@throws IOException if there is an I/O error when reading from this source or\\n    if {@code processor} throws an {@code IOException}',\n      '@throws IOException if an I/O error occurs while reading from this source or\\n    if {@code processor} throws an {@code IOException}',\n      '@throws IOException if a problem occurs while trying to read from this source or\\n    if {@code processor} throws an {@code IOException}'\n    ]\n  },\n  {\n    'tag': '@throws IOException if an I/O error occurs',\n    'alternatives': [\n      '@throws IOException if there is an I/O error',\n      '@throws IOException if an I/O error happens',\n      '@throws IOException if a problem occurs during I/O'\n    ]\n  },\n  {\n    'tag': '@param sources the sources to concatenate',\n    'alternatives': [\n      '@param sources the sources that need to be concatenated',\n      '@param sources the sources that should be joined together',\n      '@param sources the sources that are to be combined'\n    ]\n  },\n  {\n    'tag': '@return a {@code CharSource} containing the concatenated data',\n    'alternatives': [\n      '@return a {@code CharSource} that holds the concatenated data',\n      '@return a {@code CharSource} that contains the merged data',\n      '@return a {@code CharSource} with the concatenated data'\n    ]\n  },\n  {\n    'tag': '@throws IOException if an I/O error occurs in the process of opening the writer',\n    'alternatives': [\n      '@throws IOException if there is an I/O error when opening the writer',\n      '@throws IOException if an I/O error happens while opening the writer',\n      '@throws IOException if a problem occurs during the process of opening the writer'\n    ]\n  },\n  {\n    'tag': '@throws IOException if an I/O error in the process of writing to this sink',\n    'alternatives': [\n      '@throws IOException if there is an I/O error when writing to this sink',\n      '@throws IOException if an I/O error occurs while writing to this sink',\n      '@throws IOException if a problem occurs while trying to write to this sink'\n    ]\n  }\n]"