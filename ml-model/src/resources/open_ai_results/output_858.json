"output=[\n  {\n    'tag': '@param maxIter Maximum number of algorithm iterations.',\n    'alternatives': [\n      '@param maxIter Maximum number of iterations that the algorithm will perform.',\n      '@param maxIter Maximum number of iterations for the algorithm to run.',\n      '@param maxIter The maximum number of iterations allowed for the algorithm.'\n    ]\n  },\n  {\n    'tag': '@return an array containing the optima sorted from best to worst.',\n    'alternatives': [\n      '@return an array of optima, sorted from the best to the worst.',\n      '@return a sorted array of optima, ranked from the best to the worst.',\n      '@return a sorted array that contains the optima, arranged from the best to the worst.'\n    ]\n  },\n  {\n    'tag': '@throws MathIllegalStateException if {@code optData} does not contain an\\ninstance of {@link MaxEval} or {@link InitialGuess}.',\n    'alternatives': [\n      '@throws MathIllegalStateException if the {@code optData} does not have an\\ninstance of {@link MaxEval} or {@link InitialGuess}.',\n      '@throws MathIllegalStateException if the {@code optData} does not contain a valid\\ninstance of {@link MaxEval} or {@link InitialGuess}.',\n      '@throws MathIllegalStateException if {@code optData} does not include an\\ninstance of either {@link MaxEval} or {@link InitialGuess}.'\n    ]\n  },\n  {\n    'tag': '@param optimum Result of an optimization run.',\n    'alternatives': [\n      '@param optimum The result obtained from the optimization process.',\n      '@param optimum The outcome of performing an optimization run.',\n      '@param optimum The final result produced by the optimization run.'\n    ]\n  },\n  {\n    'tag': '@param optimizer Single-start optimizer to wrap.',\n    'alternatives': [\n      '@param optimizer The single-start optimizer that needs to be wrapped.',\n      '@param optimizer The optimizer to be wrapped as a single-start optimizer.',\n      '@param optimizer The optimizer that will be used as a single-start wrap.'\n    ]\n  },\n  {\n    'tag': '@param generator Random vector generator to use for restarts.',\n    'alternatives': [\n      '@param generator The random vector generator used for restarts.',\n      '@param generator The generator of random vectors used for restarts.',\n      '@param generator The random vector generator that will be used for restarts.'\n    ]\n  },\n  {\n    'tag': '@return an array containing the optima.',\n    'alternatives': [\n      '@return an array that contains the optima.',\n      '@return an array with the optima.',\n      '@return a list of optima.'\n    ]\n  },\n  {\n    'tag': '@throws MathIllegalStateException if {@link #optimize(OptimizationData[])\\noptimize} has not been called.',\n    'alternatives': [\n      '@throws MathIllegalStateException if the method {@link #optimize(OptimizationData[])\\noptimize} has not been invoked.',\n      '@throws MathIllegalStateException if the {@link #optimize(OptimizationData[])\\noptimize} method has not been called.',\n      '@throws MathIllegalStateException if the {@link #optimize(OptimizationData[])\\noptimize} operation has not been performed.'\n    ]\n  },\n  {\n    'tag': '@throws MathIllegalStateException if {@code optData} does not contain an\\ninstance of {@link MaxEval} or {@link SearchInterval}.',\n    'alternatives': [\n      '@throws MathIllegalStateException if the {@code optData} does not have an\\ninstance of {@link MaxEval} or {@link SearchInterval}.',\n      '@throws MathIllegalStateException if the {@code optData} does not contain a valid\\ninstance of {@link MaxEval} or {@link SearchInterval}.',\n      '@throws MathIllegalStateException if {@code optData} does not include an\\ninstance of either {@link MaxEval} or {@link SearchInterval}.'\n    ]\n  },\n  {\n    'tag': '@param goal Goal type.',\n    'alternatives': [\n      '@param goal The type of the goal.',\n      '@param goal The type of objective to be achieved.',\n      '@param goal The type of desired outcome.'\n    ]\n  },\n  {\n    'tag': '@param generator Random generator to use for restarts.',\n    'alternatives': [\n      '@param generator The random generator used for restarts.',\n      '@param generator The generator of random values used for restarts.',\n      '@param generator The random generator that will be used for restarts.'\n    ]\n  },\n  {\n    'tag': '@param a Point and value.',\n    'alternatives': [\n      '@param a The point and its corresponding value.',\n      '@param a The combination of a point and its value.',\n      '@param a The point along with its associated value.'\n    ]\n  },\n  {\n    'tag': '@param b Point and value.',\n    'alternatives': [\n      '@param b The point and its corresponding value.',\n      '@param b The combination of a point and its value.',\n      '@param b The point along with its associated value.'\n    ]\n  },\n  {\n    'tag': '@param isMinim {@code true} if the selected point must be the one with\\nthe lowest value.',\n    'alternatives': [\n      '@param isMinim {@code true} if the chosen point should have the\\nsmallest value.',\n      '@param isMinim {@code true} if the desired point must be the one\\nwith the lowest value.',\n      '@param isMinim {@code true} if the selected point needs to be the\\none with the lowest value.'\n    ]\n  },\n  {\n    'tag': '@return the best point, or {@code null} if {@code a} and {@code b} are\\nboth {@code null}. When {@code a} and {@code b} have the same function\\nvalue, {@code a} is returned.',\n    'alternatives': [\n      '@return the optimal point, or {@code null} if both {@code a} and {@code b}\\nare {@code null}. In case {@code a} and {@code b} have the same function value,\\n{@code a} will be returned.',\n      '@return the point with the highest value, or {@code null} if both {@code a}\\nand {@code b} are {@code null}. If {@code a} and {@code b} have the same function\\nvalue, {@code a} will be returned.',\n      '@return the best point available, or {@code null} if both {@code a} and {@code b}\\nare {@code null}. When {@code a} and {@code b} have the same function value,\\n{@code a} is returned.'\n    ]\n  },\n  {\n    'tag': '@param rel Relative threshold.',\n    'alternatives': [\n      '@param rel The relative threshold.',\n      '@param rel The threshold value relative to a reference.',\n      '@param rel The ratio used as the threshold.'\n    ]\n  },\n  {\n    'tag': '@param abs Absolute threshold.',\n    'alternatives': [\n      '@param abs The absolute threshold.',\n      '@param abs The constant threshold value.',\n      '@param abs The fixed threshold value.'\n    ]\n  },\n  {\n    'tag': '@param checker Additional, user-defined, convergence checking\\nprocedure.',\n    'alternatives': [\n      '@param checker An additional procedure defined by the user for\\nchecking convergence.',\n      '@param checker A user-defined convergence checking procedure\\nthat is added.',\n      '@param checker A convergence checking procedure supplied by\\nthe user.'\n    ]\n  },\n  {\n    'tag': '@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.',\n    'alternatives': [\n      '@throws NumberIsTooSmallException if the value of {@code rel} is smaller than twice\\nthe smallest positive value representable by a floating-point number.',\n      '@throws NumberIsTooSmallException if the value of {@code rel} is less than twice\\nthe smallest positive increment by which a floating-point number can differ from 1.0.',\n      '@throws NumberIsTooSmallException if the {@code rel} value is below 2 times the minimum\\npositive value representable by a floating-point number.'\n    ]\n  },\n  {\n    'tag': '@param rel Relative threshold.',\n    'alternatives': [\n      '@param rel The relative threshold.',\n      '@param rel The ratio used as the threshold.',\n      '@param rel The threshold value relative to a reference.'\n    ]\n  },\n  {\n    'tag': '@param abs Absolute threshold.',\n    'alternatives': [\n      '@param abs The absolute threshold.',\n      '@param abs The fixed threshold value.',\n      '@param abs The constant threshold value.'\n    ]\n  },\n  {\n    'tag': '@throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.',\n    'alternatives': [\n      '@throws NumberIsTooSmallException if the value of {@code rel} is smaller than twice\\nthe smallest positive value representable by a floating-point number.',\n      '@throws NumberIsTooSmallException if the value of {@code rel} is less than twice\\nthe smallest positive increment by which a floating-point number can differ from 1.0.',\n      '@throws NumberIsTooSmallException if the {@code rel} value is below 2 times the minimum\\npositive value representable by a floating-point number.'\n    ]\n  },\n  {\n    'tag': '@return the objective function.',\n    'alternatives': [\n      '@return the function being optimized.',\n      '@return the target objective function.',\n      '@return the function that is being optimized.'\n    ]\n  },\n  {\n    'tag': '@param f Function to be optimized.',\n    'alternatives': [\n      '@param f The function that will be optimized.',\n      '@param f The function subject to optimization.',\n      '@param f The function being targeted for optimization.'\n    ]\n  }\n]"