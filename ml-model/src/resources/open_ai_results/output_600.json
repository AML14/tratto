"output = [\n  {\n    'tag': '@param point point to add',\n    'alternatives': [\n      '@param point point to insert',\n      '@param point the point to include',\n      '@param point the point to append',\n      '@param point the point to incorporate',\n      '@param point the point to place'\n    ]\n  },\n  {\n    'tag': '@return points contained in the cluster',\n    'alternatives': [\n      '@return points that are part of the cluster',\n      '@return the cluster's contained points',\n      '@return the points present in the cluster',\n      '@return the cluster's included points',\n      '@return points comprising the cluster'\n    ]\n  },\n  {\n    'tag': '@return the embedded clusterer',\n    'alternatives': [\n      '@return the clusterer embedded within',\n      '@return the clusterer that is integrated',\n      '@return the internally incorporated clusterer',\n      '@return the clusterer that is encapsulated',\n      '@return the embedded clusterer object'\n    ]\n  },\n  {\n    'tag': '@return the number of trials',\n    'alternatives': [\n      '@return total count of attempts',\n      '@return the count of trial runs',\n      '@return the number of experiments',\n      '@return the quantity of trials',\n      '@return the total number of attempts'\n    ]\n  },\n  {\n    'tag': '@return the used {@link ClusterEvaluator}',\n    'alternatives': [\n      '@return the employed {@link ClusterEvaluator}',\n      '@return the utilized {@link ClusterEvaluator}',\n      '@return the {@link ClusterEvaluator} in use',\n      '@return the {@link ClusterEvaluator} being used',\n      '@return the {@link ClusterEvaluator} that is used'\n    ]\n  },\n  {\n    'tag': '@param points the points to cluster',\n    'alternatives': [\n      '@param points the points for clustering',\n      '@param points the data points to group',\n      '@param points the points to be clustered',\n      '@param points the points to categorize',\n      '@param points the points to group together'\n    ]\n  },\n  {\n    'tag': '@return a list of clusters containing the points',\n    'alternatives': [\n      '@return a list of point-containing clusters',\n      '@return a list of clusters with the points',\n      '@return a list of clusters that include the points',\n      '@return a list of points-packed clusters',\n      '@return a list of clusters that contain the points'\n    ]\n  },\n  {\n    'tag': '@throws ConvergenceException if an empty cluster is encountered and the\\n  underlying {@link KMeansPlusPlusClusterer} has its\\n  {@link KMeansPlusPlusClusterer.EmptyClusterStrategy} is set to {@code ERROR}.',\n    'alternatives': [\n      '@throws ConvergenceException in case an empty cluster is found and the\\n  underlying {@link KMeansPlusPlusClusterer} has its\\n  {@link KMeansPlusPlusClusterer.EmptyClusterStrategy} set to {@code ERROR}.',\n      '@throws ConvergenceException if a void cluster is found and the\\n  underlying {@link KMeansPlusPlusClusterer} has its\\n  {@link KMeansPlusPlusClusterer.EmptyClusterStrategy} set to {@code ERROR}.',\n      '@throws ConvergenceException when an empty cluster is encountered and the\\n  underlying {@link KMeansPlusPlusClusterer} has its\\n  {@link KMeansPlusPlusClusterer.EmptyClusterStrategy} set to {@code ERROR}.',\n      '@throws ConvergenceException in the event of an empty cluster being encountered and the\\n  underlying {@link KMeansPlusPlusClusterer} has its\\n  {@link KMeansPlusPlusClusterer.EmptyClusterStrategy} set to {@code ERROR}.',\n      '@throws ConvergenceException if a cluster is found empty and the\\n  underlying {@link KMeansPlusPlusClusterer} has its\\n  {@link KMeansPlusPlusClusterer.EmptyClusterStrategy} set to {@code ERROR}.'\n    ]\n  },\n  {\n    'tag': '@param clusterer the k-means clusterer to use',\n    'alternatives': [\n      '@param clusterer the clusterer of k-means to utilize',\n      '@param clusterer the clusterer for k-means to employ',\n      '@param clusterer the k-means clusterer to apply',\n      '@param clusterer the k-means clusterer to be used',\n      '@param clusterer the k-means clusterer to utilize'\n    ]\n  },\n  {\n    'tag': '@param numTrials number of trial runs',\n    'alternatives': [\n      '@param numTrials the count of trial runs',\n      '@param numTrials number of experimental attempts',\n      '@param numTrials the total number of trials',\n      '@param numTrials the number of test runs',\n      '@param numTrials the quantity of trial runs'\n    ]\n  },\n  {\n    'tag': '@param evaluator the cluster evaluator to use',\n    'alternatives': [\n      '@param evaluator the evaluator of the cluster to utilize',\n      '@param evaluator the evaluator for the cluster to employ',\n      '@param evaluator the cluster evaluator to apply',\n      '@param evaluator the cluster evaluator to be used',\n      '@param evaluator the cluster evaluator to utilize'\n    ]\n  },\n  {\n    'tag': '@return the point array',\n    'alternatives': [\n      '@return the array of points',\n      '@return an array containing the points',\n      '@return the array that holds the points',\n      '@return an array of the points',\n      '@return the array that includes the points'\n    ]\n  },\n  {\n    'tag': '@return the number of clusters',\n    'alternatives': [\n      '@return total count of clusters',\n      '@return the count of clusters',\n      '@return the number of groupings',\n      '@return the quantity of clusters',\n      '@return the total number of clusters'\n    ]\n  },\n  {\n    'tag': '@return the fuzziness factor',\n    'alternatives': [\n      '@return the factor of fuzziness',\n      '@return the fuzzification factor',\n      '@return the fuzzy factor',\n      '@return the degree of fuzziness',\n      '@return the factor that determines fuzziness'\n    ]\n  },\n  {\n    'tag': '@return the maximum number of iterations, or -1 if no maximum is set',\n    'alternatives': [\n      '@return the maximum iterations count, or -1 if no maximum is specified',\n      '@return the maximum number of cycles, or -1 if no maximum is determined',\n      '@return the maximum count of iterations, or -1 if no maximum is assigned',\n      '@return the maximum number of repetitions, or -1 if no maximum is defined',\n      '@return the maximum iterations number, or -1 if no maximum is established'\n    ]\n  },\n  {\n    'tag': '@return the convergence criteria',\n    'alternatives': [\n      '@return the criteria for convergence',\n      '@return the conditions for convergence',\n      '@return the convergence requirements',\n      '@return the convergence specifications',\n      '@return the rules for convergence'\n    ]\n  },\n  {\n    'tag': '@return the random generator',\n    'alternatives': [\n      '@return the random number generator',\n      '@return the generator of random values',\n      '@return the random value generator',\n      '@return the random number producer',\n      '@return the generator that produces random values'\n    ]\n  },\n  {\n    'tag': '@return the membership matrix',\n    'alternatives': [\n      '@return the matrix of memberships',\n      '@return the matrix that represents memberships',\n      '@return the membership matrix array',\n      '@return the matrix holding the memberships',\n      '@return the matrix showing the memberships'\n    ]\n  },\n  {\n    'tag': '@throws MathIllegalStateException if {@link #cluster(Collection)} has not been called before',\n    'alternatives': [\n      '@throws MathIllegalStateException if {@link #cluster(Collection)} has never been invoked',\n      '@throws MathIllegalStateException if {@link #cluster(Collection)} hasn't been called previously',\n      '@throws MathIllegalStateException if the {@link #cluster(Collection)} has not been invoked yet',\n      '@throws MathIllegalStateException if {@link #cluster(Collection)} hasn't been called before',\n      '@throws MathIllegalStateException if the {@link #cluster(Collection)} method has not been called before'\n    ]\n  },\n  {\n    'tag': '@return the list of data points, or {@code null} if {@link #cluster(Collection)} has\\n  not been called before.',\n    'alternatives': [\n      '@return the list of data points, or {@code null} if {@link #cluster(Collection)} hasn't been invoked yet.',\n      '@return the list of data points, or {@code null} if the {@link #cluster(Collection)} hasn't been called previously.',\n      '@return the list of data points, or {@code null} if the {@link #cluster(Collection)} method has not been called before.',\n      '@return the list of data points, or {@code null} if {@link #cluster(Collection)} has never been invoked.',\n      '@return the list of data points, or {@code null} if {@link #cluster(Collection)} hasn't been called before.'\n    ]\n  },\n  {\n    'tag': '@return the list of clusters, or {@code null} if {@link #cluster(Collection)} has\\n  not been called before.',\n    'alternatives': [\n      '@return the list of clusters, or {@code null} if the {@link #cluster(Collection)} hasn't been invoked yet.',\n      '@return the list of clusters, or {@code null} if {@link #cluster(Collection)} hasn't been called previously.',\n      '@return the list of clusters, or {@code null} if the {@link #cluster(Collection)} method has not been called before.',\n      '@return the list of clusters, or {@code null} if {@link #cluster(Collection)} has never been invoked.',\n      '@return the list of clusters, or {@code null} if {@link #cluster(Collection)} hasn't been called before.'\n    ]\n  },\n  {\n    'tag': '@return the objective function evaluation as double value',\n    'alternatives': [\n      '@return the outcome function evaluation as double value',\n      '@return the value of the objective function evaluation',\n      '@return the assessment of the objective function as double',\n      '@return the double value representing the objective function evaluation',\n      '@return the double value that corresponds to the objective function evaluation'\n    ]\n  },\n  {\n    'tag': '@throws MathIllegalStateException if {@link #cluster(Collection)} has not been called before',\n    'alternatives': [\n      '@throws MathIllegalStateException if {@link #cluster(Collection)} has never been invoked',\n      '@throws MathIllegalStateException if {@link #cluster(Collection)} hasn't been called previously',\n      '@throws MathIllegalStateException if the {@link #cluster(Collection)} has not been invoked yet',\n      '@throws MathIllegalStateException if {@link #cluster(Collection)} hasn't been called before',\n      '@throws MathIllegalStateException if the {@link #cluster(Collection)} method has not been called before'\n    ]\n  }\n]"