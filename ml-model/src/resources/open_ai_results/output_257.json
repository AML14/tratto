"output=[\n  {\n    'tag': '@param <J> the input key type',\n    'alternatives': [\n      '@param <J> type of the input key',\n      '@param <J> the type of the key input',\n      '@param <J> the type of the input key',\n      '@param <J> specifies the type of the input key',\n      '@param <J> defines the input key type'\n    ]\n  },\n  {\n    'tag': '@param <K> the output key type',\n    'alternatives': [\n      '@param <K> type of the output key',\n      '@param <K> the type of the key output',\n      '@param <K> the type of the output key',\n      '@param <K> specifies the type of the output key',\n      '@param <K> defines the output key type'\n    ]\n  },\n  {\n    'tag': '@param <U> the input value type',\n    'alternatives': [\n      '@param <U> type of the input value',\n      '@param <U> the type of the value input',\n      '@param <U> the type of the input value',\n      '@param <U> specifies the type of the input value',\n      '@param <U> defines the input value type'\n    ]\n  },\n  {\n    'tag': '@param <V> the output value type',\n    'alternatives': [\n      '@param <V> type of the output value',\n      '@param <V> the type of the value output',\n      '@param <V> the type of the output value',\n      '@param <V> specifies the type of the output value',\n      '@param <V> defines the output value type'\n    ]\n  },\n  {\n    'tag': '@return a new transformed map',\n    'alternatives': [\n      '@return a newly transformed map',\n      '@return a map that has been transformed',\n      '@return a new map after transformation',\n      '@return a transformed map instance',\n      '@return the transformed map'\n    ]\n  },\n  {\n    'tag': '@param out the output stream',\n    'alternatives': [\n      '@param out output stream',\n      '@param out stream for output',\n      '@param out the stream to write to',\n      '@param out the target output stream',\n      '@param out the output to write'\n    ]\n  },\n  {\n    'tag': '@throws IOException ',\n    'alternatives': [\n      '@throws IOException if an error occurs',\n      '@throws IOException in case of an error',\n      '@throws IOException when an error happens',\n      '@throws IOException if there is an error',\n      '@throws IOException if a problem occurs'\n    ]\n  },\n  {\n    'tag': '@param in the input stream',\n    'alternatives': [\n      '@param in input stream',\n      '@param in stream for input',\n      '@param in the stream to read from',\n      '@param in the input source',\n      '@param in the input to read'\n    ]\n  },\n  {\n    'tag': '@throws IOException ',\n    'alternatives': [\n      '@throws IOException if an error occurs',\n      '@throws IOException in case of an error',\n      '@throws IOException when an error happens',\n      '@throws IOException if there is an error',\n      '@throws IOException if a problem occurs'\n    ]\n  },\n  {\n    'tag': '@throws ClassNotFoundException ',\n    'alternatives': [\n      '@throws ClassNotFoundException if the class is not found',\n      '@throws ClassNotFoundException in case the class is not found',\n      '@throws ClassNotFoundException if class is not found',\n      '@throws ClassNotFoundException when the class could not be found',\n      '@throws ClassNotFoundException if the desired class is missing'\n    ]\n  },\n  {\n    'tag': '@param object the object to transform',\n    'alternatives': [\n      '@param object the input object to transform',\n      '@param object the target object for transformation',\n      '@param object the source object to be transformed',\n      '@param object the input for the transformation',\n      '@param object the original object to be modified'\n    ]\n  },\n  {\n    'tag': '@return the transformed object',\n    'alternatives': [\n      '@return the resulting transformed object',\n      '@return the object after transformation',\n      '@return the modified object',\n      '@return the transformed version of the object',\n      '@return the object that has been transformed'\n    ]\n  },\n  {\n    'tag': '@param object the object to transform',\n    'alternatives': [\n      '@param object the input object to transform',\n      '@param object the target object for transformation',\n      '@param object the source object to be transformed',\n      '@param object the input for the transformation',\n      '@param object the original object to be modified'\n    ]\n  },\n  {\n    'tag': '@return the transformed object',\n    'alternatives': [\n      '@return the resulting transformed object',\n      '@return the object after transformation',\n      '@return the modified object',\n      '@return the transformed version of the object',\n      '@return the object that has been transformed'\n    ]\n  },\n  {\n    'tag': '@param map the map to transform',\n    'alternatives': [\n      '@param map the input map to transform',\n      '@param map the target map for transformation',\n      '@param map the source map to be transformed',\n      '@param map the input for the map transformation',\n      '@param map the original map to be modified'\n    ]\n  },\n  {\n    'tag': '@param value the value to transform',\n    'alternatives': [\n      '@param value the input value to transform',\n      '@param value the target value for transformation',\n      '@param value the source value to be transformed',\n      '@param value the input for the value transformation',\n      '@param value the original value to be modified'\n    ]\n  },\n  {\n    'tag': '@return {@code true} if the variables are restricted to non-negative values.',\n    'alternatives': [\n      '@return {@code true} if the variables are limited to non-negative values.',\n      '@return {@code true} if the variables are constrained to non-negative values.',\n      '@return {@code true} if the variables are bounded to non-negative values.',\n      '@return {@code true} if the variables are exclusively non-negative.',\n      '@return {@code true} if the variables are only non-negative.'\n    ]\n  },\n  {\n    'tag': '@return the optimization type.',\n    'alternatives': [\n      '@return the type of optimization.',\n      '@return the kind of optimization.',\n      '@return the optimization category.',\n      '@return the optimization mode.',\n      '@return the optimization style.'\n    ]\n  },\n  {\n    'tag': '@return the optimization type.',\n    'alternatives': [\n      '@return the type of optimization.',\n      '@return the kind of optimization.',\n      '@return the optimization category.',\n      '@return the optimization mode.',\n      '@return the optimization style.'\n    ]\n  },\n  {\n    'tag': '@param optData Optimization data. In addition to those documented in\\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\\nMultivariateOptimizer}, this method will register the following data:\\n<ul>\\n <li>{@link LinearObjectiveFunction}</li>\\n <li>{@link LinearConstraintSet}</li>\\n <li>{@link NonNegativeConstraint}</li>\\n</ul>',\n    'alternatives': [\n      '@param optData Optimization data. Additionally to the ones described in\\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\\nMultivariateOptimizer}, this method will also include the following data:\\n<ul>\\n <li>{@link LinearObjectiveFunction}</li>\\n <li>{@link LinearConstraintSet}</li>\\n <li>{@link NonNegativeConstraint}</li>\\n</ul>',\n      '@param optData Optimization data. Apart from the documented ones in\\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\\nMultivariateOptimizer}, this method will record the following data:\\n<ul>\\n <li>{@link LinearObjectiveFunction}</li>\\n <li>{@link LinearConstraintSet}</li>\\n <li>{@link NonNegativeConstraint}</li>\\n</ul>',\n      '@param optData Optimization data. In addition to what is documented in\\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\\nMultivariateOptimizer}, this method will store the following data:\\n<ul>\\n <li>{@link LinearObjectiveFunction}</li>\\n <li>{@link LinearConstraintSet}</li>\\n <li>{@link NonNegativeConstraint}</li>\\n</ul>',\n      '@param optData Optimization data. In addition to those specified in\\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\\nMultivariateOptimizer}, this method will add the following data:\\n<ul>\\n <li>{@link LinearObjectiveFunction}</li>\\n <li>{@link LinearConstraintSet}</li>\\n <li>{@link NonNegativeConstraint}</li>\\n</ul>',\n      '@param optData Optimization data. In addition to the ones documented in\\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\\nMultivariateOptimizer}, this method will include the following data:\\n<ul>\\n <li>{@link LinearObjectiveFunction}</li>\\n <li>{@link LinearConstraintSet}</li>\\n <li>{@link NonNegativeConstraint}</li>\\n</ul>'\n    ]\n  },\n  {\n    'tag': '@return {@inheritDoc}',\n    'alternatives': [\n      '@return the same as the parent method',\n      '@return the result of the parent method',\n      '@return the value based on the parent method',\n      '@return the inherited value',\n      '@return the output from the parent method'\n    ]\n  },\n  {\n    'tag': '@throws TooManyIterationsException if the maximal number of\\niterations is exceeded.',\n    'alternatives': [\n      '@throws TooManyIterationsException when the maximum number of\\niterations is surpassed.',\n      '@throws TooManyIterationsException if the number of iterations exceeds the maximum.',\n      '@throws TooManyIterationsException in case the maximum number of\\niterations is surpassed.',\n      '@throws TooManyIterationsException if the maximum number of\\niterations is exceeded.',\n      '@throws TooManyIterationsException if the number of iterations surpasses the maximum.'\n    ]\n  },\n  {\n    'tag': '@param optData Optimization data.\\nThe following data will be looked for:\\n<ul>\\n <li>{@link LinearObjectiveFunction}</li>\\n <li>{@link LinearConstraintSet}</li>\\n <li>{@link NonNegativeConstraint}</li>\\n</ul>',\n    'alternatives': [\n      '@param optData Optimization data.\\nThe method will search for the following data:\\n<ul>\\n <li>{@link LinearObjectiveFunction}</li>\\n <li>{@link LinearConstraintSet}</li>\\n <li>{@link NonNegativeConstraint}</li>\\n</ul>',\n      '@param optData Optimization data.\\nThe method will check for the following data:\\n<ul>\\n <li>{@link LinearObjectiveFunction}</li>\\n <li>{@link LinearConstraintSet}</li>\\n <li>{@link NonNegativeConstraint}</li>\\n</ul>',\n      '@param optData Optimization data.\\nThe method will examine the following data:\\n<ul>\\n <li>{@link LinearObjectiveFunction}</li>\\n <li>{@link LinearConstraintSet}</li>\\n <li>{@link NonNegativeConstraint}</li>\\n</ul>',\n      '@param optData Optimization data.\\nThe method will look for the following data:\\n<ul>\\n <li>{@link LinearObjectiveFunction}</li>\\n <li>{@link LinearConstraintSet}</li>\\n <li>{@link NonNegativeConstraint}</li>\\n</ul>',\n      '@param optData Optimization data.\\nThe method will locate the following data:\\n<ul>\\n <li>{@link LinearObjectiveFunction}</li>\\n <li>{@link LinearConstraintSet}</li>\\n <li>{@link NonNegativeConstraint}</li>\\n</ul>'\n    ]\n  },\n  {\n    'tag': '@param maximize if true, goal is to maximize the objective function',\n    'alternatives': [\n      '@param maximize if set to true, the objective function is maximized',\n      '@param maximize when true, the objective function is to be maximized',\n      '@param maximize determines if the objective function should be maximized',\n      '@param maximize if set to true, the goal is to maximize the objective function',\n      '@param maximize indicates whether the goal is to maximize the objective function'\n    ]\n  },\n  {\n    'tag': '@return created tableau',\n    'alternatives': [\n      '@return the tableau that has been created',\n      '@return the newly created tableau',\n      '@return the newly generated tableau',\n      '@return the tableau object that is created',\n      '@return the recently created tableau'\n    ]\n  }\n]"