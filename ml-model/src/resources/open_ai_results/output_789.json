"output = [\n  {\n    'tag': '@param f Objective function.',\n    'alternatives': [\n      '@param f Input function.',\n      '@param f Function to optimize.',\n      '@param f Function being optimized.',\n      '@param f Function to be optimized.',\n      '@param f Target function.'\n    ]\n  },\n  {\n    'tag': '@param goalType Type of optimization goal: either\\n{@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.',\n    'alternatives': [\n      '@param goalType Optimization goal type: either\\n{@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.',\n      '@param goalType Optimization objective type: {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.',\n      '@param goalType Type of optimization objective: either\\n{@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.',\n      '@param goalType Type of optimization objective: either\\nmaximization or minimization.',\n      '@param goalType Type of optimization goal: maximize or minimize.'\n    ]\n  },\n  {\n    'tag': '@param startPoint Start point for optimization.',\n    'alternatives': [\n      '@param startPoint Initial point for optimization.',\n      '@param startPoint Starting point for optimization.',\n      '@param startPoint Optimization starting point.',\n      '@param startPoint Initial value for optimization.',\n      '@param startPoint Beginning point for optimization.'\n    ]\n  },\n  {\n    'tag': '@param maxEval Maximum number of function evaluations.',\n    'alternatives': [\n      '@param maxEval Maximum evaluation count.',\n      '@param maxEval Maximum function call limit.',\n      '@param maxEval Maximum number of evaluations allowed.',\n      '@param maxEval Maximum function evaluation threshold.',\n      '@param maxEval Maximum evaluation limit.'\n    ]\n  },\n  {\n    'tag': '@return the point/value pair giving the optimal value for objective\\nfunction.',\n    'alternatives': [\n      '@return optimal value of objective function.',\n      '@return optimum point/value pair for objective function.',\n      '@return best point/value pair for objective function.',\n      '@return optimal point/value for objective function.',\n      '@return the point/value combination that gives the best objective function value.'\n    ]\n  },\n  {\n    'tag': '@throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong.',\n    'alternatives': [\n      '@throws org.apache.commons.math3.exception.DimensionMismatchException if the dimension of the starting point is incorrect.',\n      '@throws org.apache.commons.math3.exception.DimensionMismatchException if the dimension of the start point is invalid.',\n      '@throws org.apache.commons.math3.exception.DimensionMismatchException if the size of the start point is incorrect.',\n      '@throws org.apache.commons.math3.exception.DimensionMismatchException if the dimension of the starting point is not valid.',\n      '@throws org.apache.commons.math3.exception.DimensionMismatchException if the dimension of the initial point is incorrect.'\n    ]\n  },\n  {\n    'tag': '@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded.',\n    'alternatives': [\n      '@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximum number of evaluations is surpassed.',\n      '@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the number of evaluations exceeds the maximum.',\n      '@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximum evaluation count is exceeded.',\n      '@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the number of evaluations surpasses the limit.',\n      '@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the evaluation count goes beyond the maximum.'\n    ]\n  },\n  {\n    'tag': '@param iteration Current iteration.',\n    'alternatives': [\n      '@param iteration Current loop iteration.',\n      '@param iteration Current loop count.',\n      '@param iteration Current cycle number.',\n      '@param iteration Current step iteration.',\n      '@param iteration Current iteration index.'\n    ]\n  },\n  {\n    'tag': '@param previous Best point in the previous iteration.',\n    'alternatives': [\n      '@param previous Previous iteration best point.',\n      '@param previous Best point from the previous iteration.',\n      '@param previous Optimal point in the previous iteration.',\n      '@param previous Best point obtained in the preceding iteration.',\n      '@param previous The point that was found to be the best in the previous iteration.'\n    ]\n  },\n  {\n    'tag': '@param current Best point in the current iteration.',\n    'alternatives': [\n      '@param current Current iteration best point.',\n      '@param current Best point in the ongoing iteration.',\n      '@param current Optimal point in the current iteration.',\n      '@param current Best point obtained in the current iteration.',\n      '@param current The point that is currently considered the best.'\n    ]\n  },\n  {\n    'tag': '@return {@code true} if the algorithm is considered to have converged.',\n    'alternatives': [\n      '@return {@code true} if the algorithm has reached convergence.',\n      '@return {@code true} if the algorithm has achieved convergence.',\n      '@return {@code true} if the algorithm has converged.',\n      '@return {@code true} if the algorithm reached a converged state.',\n      '@return {@code true} if the algorithm achieved a state of convergence.'\n    ]\n  },\n  {\n    'tag': '@return an array containing the optima.',\n    'alternatives': [\n      '@return an array of the optimal values.',\n      '@return an array that holds the optimum values.',\n      '@return an array consisting of the optimal values.',\n      '@return an array comprising the optimum values.',\n      '@return an array containing the optimal results.'\n    ]\n  },\n  {\n    'tag': '@throws MathIllegalStateException if {@link\\n#optimize(int,MultivariateFunction,GoalType,double[]) optimize}\\nhas not been called.',\n    'alternatives': [\n      '@throws MathIllegalStateException if the method {@link\\n#optimize(int,MultivariateFunction,GoalType,double[]) optimize}\\nhas not been invoked.',\n      '@throws MathIllegalStateException if the operation {@link\\n#optimize(int,MultivariateFunction,GoalType,double[]) optimize}\\nhas not been performed.',\n      '@throws MathIllegalStateException if the function {@link\\n#optimize(int,MultivariateFunction,GoalType,double[]) optimize}\\nhas not yet been called.',\n      '@throws MathIllegalStateException if the invocation of {@link\\n#optimize(int,MultivariateFunction,GoalType,double[]) optimize}\\nhas not taken place.',\n      '@throws MathIllegalStateException if the call to {@link\\n#optimize(int,MultivariateFunction,GoalType,double[]) optimize}\\nhas not been made.'\n    ]\n  },\n  {\n    'tag': '@param goal Goal type.',\n    'alternatives': [\n      '@param goal Objective type.',\n      '@param goal Optimization goal.',\n      '@param goal Optimization objective.',\n      '@param goal Type of optimization objective.',\n      '@param goal Type of objective for optimization.'\n    ]\n  },\n  {\n    'tag': '@param optimizer Single-start optimizer to wrap.',\n    'alternatives': [\n      '@param optimizer Single optimizer to wrap.',\n      '@param optimizer Optimizer to wrap for single-start.',\n      '@param optimizer Wrapper for single-start optimizer.',\n      '@param optimizer Single-start optimization wrapper.',\n      '@param optimizer Single-start optimization algorithm to encapsulate.'\n    ]\n  },\n  {\n    'tag': '@param generator Random vector generator to use for restarts.',\n    'alternatives': [\n      '@param generator Random vector generator for restarts.',\n      '@param generator Random vector generator used for restarts.',\n      '@param generator Generator of random vectors for restarts.',\n      '@param generator Random vector generator utilized for restarts.',\n      '@param generator Random vector generator employed for restarts.'\n    ]\n  },\n  {\n    'tag': '@return the initial guess.',\n    'alternatives': [\n      '@return the starting estimate.',\n      '@return the initial approximation.',\n      '@return the initial guess value.',\n      '@return the initial estimation.',\n      '@return the initial value assumption.'\n    ]\n  },\n  {\n    'tag': '@param observations Target values.',\n    'alternatives': [\n      '@param observations Observed values.',\n      '@param observations Measured data.',\n      '@param observations Recorded points.',\n      '@param observations Input data.',\n      '@param observations Data points.'\n    ]\n  },\n  {\n    'tag': '@return the initial guess.',\n    'alternatives': [\n      '@return the initial estimate.',\n      '@return the initial approximation.',\n      '@return the initial guess value.',\n      '@return the initial estimation.',\n      '@return the initial value assumption.'\n    ]\n  },\n  {\n    'tag': '@param weight List of the values of the diagonal.',\n    'alternatives': [\n      '@param weight Vector of diagonal entries.',\n      '@param weight Diagonal element list.',\n      '@param weight Array of diagonal values.',\n      '@param weight List of diagonal coefficients.',\n      '@param weight Diagonal value collection.'\n    ]\n  },\n  {\n    'tag': '@param weight Weight matrix.',\n    'alternatives': [\n      '@param weight Matrix of weights.',\n      '@param weight Weight coefficient matrix.',\n      '@param weight Coefficient weight matrix.',\n      '@param weight Matrix representing the weights.',\n      '@param weight Matrix encoding the weights.'\n    ]\n  },\n  {\n    'tag': '@throws NonSquareMatrixException if the argument is not\\na square matrix.',\n    'alternatives': [\n      '@throws NonSquareMatrixException if the input is not\\na square matrix.',\n      '@throws NonSquareMatrixException if the parameter is not\\na square matrix.',\n      '@throws NonSquareMatrixException if the argument is not\\na matrix with equal dimensions.',\n      '@throws NonSquareMatrixException if the input is not\\na matrix with equal dimensions.',\n      '@throws NonSquareMatrixException if the parameter is not\\na matrix with equal dimensions.'\n    ]\n  },\n  {\n    'tag': '@param optimizer Single-start optimizer to wrap.',\n    'alternatives': [\n      '@param optimizer Single optimizer to wrap.',\n      '@param optimizer Optimizer to wrap for single-start.',\n      '@param optimizer Wrapper for single-start optimizer.',\n      '@param optimizer Single-start optimization wrapper.',\n      '@param optimizer Single-start optimization algorithm to encapsulate.'\n    ]\n  },\n  {\n    'tag': '@param starts Number of starts to perform (including the\\nfirst one), multi-start is disabled if value is less than or\\nequal to 1.',\n    'alternatives': [\n      '@param starts Number of repetitions (including the\\ninitial one), multi-start is disabled if value is less than or\\nequal to 1.',\n      '@param starts Number of iterations to execute (including the\\nfirst one), multi-start is disabled if value is less than or\\nequal to 1.',\n      '@param starts Number of restarts to carry out (including the\\nfirst one), multi-start is disabled if value is less than or\\nequal to 1.',\n      '@param starts Number of iterations to perform (including the\\ninitial one), multi-start is disabled if value is less than or\\nequal to 1.',\n      '@param starts Number of cycles to run (including the\\nfirst one), multi-start is disabled if value is less than or\\nequal to 1.'\n    ]\n  },\n  {\n    'tag': '@param generator Random vector generator to use for restarts.',\n    'alternatives': [\n      '@param generator Random vector generator for restarts.',\n      '@param generator Random vector generator used for restarts.',\n      '@param generator Generator of random vectors for restarts.',\n      '@param generator Random vector generator utilized for restarts.',\n      '@param generator Random vector generator utilized for restarts.'\n    ]\n  }\n]"