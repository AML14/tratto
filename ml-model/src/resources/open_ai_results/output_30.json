"[\n  {\n    \"tag\": \"@param sequence the character sequence to examine, possibly empty\",\n    \"alternatives\": [\n      \"@param sequence the character string to investigate, potentially empty\",\n      \"@param sequence a string of characters to analyze, which may be empty\"\n    ]\n  },\n  {\n    \"tag\": \"@param sequence the character sequence to examine from the beginning\",\n    \"alternatives\": [\n      \"@param sequence the character string to examine from the start\",\n      \"@param sequence the string of characters to inspect starting from the beginning\"\n    ]\n  },\n  {\n    \"tag\": \"@return an index, or {@code -1} if no character matches\",\n    \"alternatives\": [\n      \"@return the index value or {@code -1} if no character matches\",\n      \"@return the position of the character, or {@code -1} if no match is found\"\n    ]\n  },\n  {\n    \"tag\": \"@param sequence the character sequence to examine\",\n    \"alternatives\": [\n      \"@param sequence the character string to analyze\",\n      \"@param sequence the string of characters to investigate\"\n    ]\n  },\n  {\n    \"tag\": \"@param start the first index to examine; must be nonnegative and no greater than {@code\\n       sequence.length()}\",\n    \"alternatives\": [\n      \"@param start the initial index to check; must be a non-negative value and not exceed the length of {@code sequence}\",\n      \"@param start the starting index to inspect; it must be a non-negative integer and cannot exceed the length of the {@code sequence}\"\n    ]\n  },\n  {\n    \"tag\": \"@return the index of the first matching character, guaranteed to be no less than {@code start},\\n        or {@code -1} if no character matches\",\n    \"alternatives\": [\n      \"@return the index of the first matching character, always greater than or equal to {@code start}, or {@code -1} if no character matches\",\n      \"@return the position of the first matching character, which is guaranteed to be equal to or greater than {@code start}, or {@code -1} if no match is found\"\n    ]\n  },\n  {\n    \"tag\": \"@param sequence the character sequence to examine from the end\",\n    \"alternatives\": [\n      \"@param sequence the character string to examine from the last position\",\n      \"@param sequence the string of characters to investigate starting from the end\"\n    ]\n  },\n  {\n    \"tag\": \"@param sequence the character sequence to replace matching characters in\",\n    \"alternatives\": [\n      \"@param sequence the character string to substitute matching characters\",\n      \"@param sequence the string of characters to modify when finding matches\"\n    ]\n  },\n  {\n    \"tag\": \"@param replacement the character to append to the result string in place of each matching\\n       character in {@code sequence}\",\n    \"alternatives\": [\n      \"@param replacement the character to add to the resulting string instead of each matching character in {@code sequence}\",\n      \"@param replacement the character to attach to the resulting string instead of each occurrence of a matching character in {@code sequence}\"\n    ]\n  },\n  {\n    \"tag\": \"@return the new string\",\n    \"alternatives\": [\n      \"@return the updated string\",\n      \"@return the modified string\"\n    ]\n  },\n  {\n    \"tag\": \"@param sequence the character sequence to replace matching characters in\",\n    \"alternatives\": [\n      \"@param sequence the character string to substitute matching characters\",\n      \"@param sequence the string of characters to modify when finding matches\"\n    ]\n  },\n  {\n    \"tag\": \"@param replacement the characters to append to the result string in place of each matching\\n       character in {@code sequence}\",\n    \"alternatives\": [\n      \"@param replacement the characters to add to the resulting string instead of each matching character in {@code sequence}\",\n      \"@param replacement the characters to attach to the resulting string instead of each occurrence of a matching character in {@code sequence}\"\n    ]\n  },\n  {\n    \"tag\": \"@return the new string\",\n    \"alternatives\": [\n      \"@return the updated string\",\n      \"@return the modified string\"\n    ]\n  },\n  {\n    \"tag\": \"@param sequence the character sequence to replace matching groups of characters in\",\n    \"alternatives\": [\n      \"@param sequence the character string to substitute matching groups of characters\",\n      \"@param sequence the string of characters to modify when finding groups of matches\"\n    ]\n  },\n  {\n    \"tag\": \"@param replacement the character to append to the result string in place of each group of\\n       matching characters in {@code sequence}\",\n    \"alternatives\": [\n      \"@param replacement the character to add to the resulting string instead of each group of matching characters in {@code sequence}\",\n      \"@param replacement the character to attach to the resulting string instead of each group of characters that match in {@code sequence}\"\n    ]\n  },\n  {\n    \"tag\": \"@return the new string\",\n    \"alternatives\": [\n      \"@return the updated string\",\n      \"@return the modified string\"\n    ]\n  },\n  {\n    \"tag\": \"@param target the collection that may contain the function input\",\n    \"alternatives\": [\n      \"@param target the collection that might hold the function input\",\n      \"@param target the collection that could potentially have the function input\"\n    ]\n  },\n  {\n    \"tag\": \"@return the composition of the provided function and predicate\",\n    \"alternatives\": [\n      \"@return the combination of the given function and predicate\",\n      \"@return the result of combining the provided function and predicate\"\n    ]\n  },\n  {\n    \"tag\": \"@throws java.util.regex.PatternSyntaxException if the pattern is invalid\",\n    \"alternatives\": [\n      \"@throws java.util.regex.PatternSyntaxException when the pattern is not valid\",\n      \"@throws java.util.regex.PatternSyntaxException if the pattern is malformed\"\n    ]\n  },\n  {\n    \"tag\": \"@param expression a boolean expression\",\n    \"alternatives\": [\n      \"@param expression a boolean condition\",\n      \"@param expression a boolean statement\"\n    ]\n  },\n  {\n    \"tag\": \"@param errorMessageTemplate a template for the exception message should the\\n    check fail. The message is formed by replacing each {@code %s}\\n    placeholder in the template with an argument. These are matched by\\n    position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.\\n    Unmatched arguments will be appended to the formatted message in square\\n    braces. Unmatched placeholders will be left as-is.\",\n    \"alternatives\": [\n      \"@param errorMessageTemplate a template for the error message if the\\n    check fails. The message is created by replacing every {@code %s}\\n    placeholder in the template with an argument. The argument order is\\n    determined by position - the first {@code %s} is replaced by\\n    {@code errorMessageArgs[0]}, etc. Extra arguments will be added\\n    to the message in square brackets. Unmatched placeholders will remain.\",\n      \"@param errorMessageTemplate a template for the error message in case the\\n    check fails. The message is generated by substituting each {@code %s}\\n    placeholder in the template with an argument. The arguments are\\n    matched by position - the first {@code %s} will be replaced\\n    by {@code errorMessageArgs[0]}, and so on. Any extra arguments will\\n    be appended in square brackets. Unmatched placeholders will be kept as-is.\"\n    ]\n  },\n  {\n    \"tag\": \"@param errorMessageArgs the arguments to be substituted into the message\\n    template. Arguments are converted to strings using\\n    {@link String#valueOf(Object)}.\",\n    \"alternatives\": [\n      \"@param errorMessageArgs the arguments to be replaced within the message\\n    template. Arguments will be converted to strings using\\n    {@link String#valueOf(Object)}.\",\n      \"@param errorMessageArgs the arguments that will be inserted into the message\\n    template. The arguments will be converted to strings using\\n    {@link String#valueOf(Object)}.\"\n    ]\n  },\n  {\n    \"tag\": \"@param errorMessageTemplate a template for the exception message should the\\n    check fail. The message is formed by replacing each {@code %s}\\n    placeholder in the template with an argument. These are matched by\\n    position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.\\n    Unmatched arguments will be appended to the formatted message in square\\n    braces. Unmatched placeholders will be left as-is.\",\n    \"alternatives\": [\n      \"@param errorMessageTemplate a template for the error message if the\\n    check fails. The message is created by replacing every {@code %s}\\n    placeholder in the template with an argument. The argument order is\\n    determined by position - the first {@code %s} is replaced by\\n    {@code errorMessageArgs[0]}, etc. Extra arguments will be added\\n    to the message in square brackets. Unmatched placeholders will remain.\",\n      \"@param errorMessageTemplate a template for the error message in case the\\n    check fails. The message is generated by substituting each {@code %s}\\n    placeholder in the template with an argument. The arguments are\\n    matched by position - the first {@code %s} will be replaced\\n    by {@code errorMessageArgs[0]}, and so on. Any extra arguments will\\n    be appended in square brackets. Unmatched placeholders will be kept as-is.\"\n    ]\n  },\n  {\n    \"tag\": \"@param errorMessageArgs the arguments to be substituted into the message\\n    template. Arguments are converted to strings using\\n    {@link String#valueOf(Object)}.\",\n    \"alternatives\": [\n      \"@param errorMessageArgs the arguments to be replaced within the message\\n    template. Arguments will be converted to strings using\\n    {@link String#valueOf(Object)}.\",\n      \"@param errorMessageArgs the arguments that will be inserted into the message\\n    template. The arguments will be converted to strings using\\n    {@link String#valueOf(Object)}.\"\n    ]\n  }\n]"