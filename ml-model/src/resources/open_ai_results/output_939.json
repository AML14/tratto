"[\n  {\n    'tag': '@param maxCheckInterval maximal time interval between switching\\nfunction checks (this interval prevents missing sign changes in\\ncase the integration steps becomes very large)',\n    'alternatives': [\n      '@param maxCheckInterval maximum time interval between checks of the switching\\nfunction (this interval prevents missing sign changes\\nin case the integration steps become very large).',\n      '@param maxCheckInterval maximum interval of time between function checks\\n(this interval prevents missing sign changes\\nin the event that the integration steps become very large).',\n      '@param maxCheckInterval maximum interval of time between checking the function\\n(this interval prevents missing sign changes\\nif the integration steps become very large).'\n    ]\n  },\n  {\n    'tag': '@param convergence convergence threshold in the event time search',\n    'alternatives': [\n      '@param convergence threshold for the convergence in the search for event time.',\n      '@param convergence threshold for event time search convergence.',\n      '@param convergence convergence threshold for the search of event time.'\n    ]\n  },\n  {\n    'tag': '@param maxIterationCount upper limit of the iteration count in\\nthe event time search',\n    'alternatives': [\n      '@param maxIterationCount maximum number of iterations in the search for event time.',\n      '@param maxIterationCount maximum limit of iterations for event time search.',\n      '@param maxIterationCount upper bound on the number of iterations in the search for event time.'\n    ]\n  },\n  {\n    'tag': '@param solver Root-finding algorithm to use to detect state events',\n    'alternatives': [\n      '@param solver algorithm for root-finding to detect state events.',\n      '@param solver method to use for detecting state events through root-finding.',\n      '@param solver algorithm to be used to identify state events through root-finding.'\n    ]\n  },\n  {\n    'tag': '@param rawHandler event handler to wrap',\n    'alternatives': [\n      '@param rawHandler handler for the event to be wrapped.',\n      '@param rawHandler event handler for wrapping.',\n      '@param rawHandler event handler that needs to be wrapped.'\n    ]\n  },\n  {\n    'tag': '@param filter filter to use',\n    'alternatives': [\n      '@param filter the filter to be used.',\n      '@param filter the filter that will be used.',\n      '@param filter filter that should be utilized.'\n    ]\n  },\n  {\n    'tag': '@return true if triggered events are increasing events',\n    'alternatives': [\n      '@return true if the triggered events are events of increasing nature.',\n      '@return true if the triggered events are events that are increasing.',\n      '@return true if the events triggered are increasing events.'\n    ]\n  },\n  {\n    'tag': '@param previous transformer active on the previous point with respect\\nto integration direction (may be null if no previous point is known)',\n    'alternatives': [\n      '@param previous transformer active on the previous point with respect\\nto integration direction (null if no previous point is known).',\n      '@param previous transformer in effect at the previous point in relation to\\nthe direction of integration (null if the previous point is not known).',\n      '@param previous transformer that was active at the previous point relative\\nto the direction of integration (null if no previous point is known).'\n    ]\n  },\n  {\n    'tag': '@param g current value of the g function',\n    'alternatives': [\n      '@param g value of the g function at present.',\n      '@param g current value of the g function.',\n      '@param g value of the g function at the moment.'\n    ]\n  },\n  {\n    'tag': '@return next transformer transformer',\n    'alternatives': [\n      '@return the next transformer of the transformer.',\n      '@return transformer next in line.',\n      '@return the transformer that follows.'\n    ]\n  },\n  {\n    'tag': '@param name parameter name',\n    'alternatives': [\n      '@param name name of the parameter.',\n      '@param name the name of the parameter.',\n      '@param name the name assigned to the parameter.'\n    ]\n  },\n  {\n    'tag': '@return parameter value',\n    'alternatives': [\n      '@return value of the parameter.',\n      '@return parameter value.',\n      '@return the value of the parameter.'\n    ]\n  },\n  {\n    'tag': '@param name parameter name',\n    'alternatives': [\n      '@param name name of the parameter.',\n      '@param name the name of the parameter.',\n      '@param name the name assigned to the parameter.'\n    ]\n  },\n  {\n    'tag': '@param value parameter value',\n    'alternatives': [\n      '@param value value assigned to the parameter.',\n      '@param value the value of the parameter.',\n      '@param value parameter value.'\n    ]\n  },\n  {\n    'tag': '@param equations differential equations to integrate',\n    'alternatives': [\n      '@param equations differential equations to be integrated.',\n      '@param equations differential equations for integration.',\n      '@param equations equations to integrate differentially.'\n    ]\n  },\n  {\n    'tag': '@param t0 initial time',\n    'alternatives': [\n      '@param t0 start point in time.',\n      '@param t0 initial point in time.',\n      '@param t0 the beginning time.'\n    ]\n  },\n  {\n    'tag': '@param y0 initial value of the state vector at t0',\n    'alternatives': [\n      '@param y0 initial value of the state vector at t0.',\n      '@param y0 state vector's initial value at t0.',\n      '@param y0 state vector's initial value when t0.'\n    ]\n  },\n  {\n    'tag': '@param t target time for the integration\\n(can be set to a value smaller than <code>t0</code> for backward integration)',\n    'alternatives': [\n      '@param t target time for integration\\n(can be set to a value smaller than <code>t0</code> for backward integration).',\n      '@param t target time for the integration process\\n(can be set to a value smaller than <code>t0</code> for backward integration).',\n      '@param t desired time for integration\\n(can be set to a value smaller than <code>t0</code> for backward integration).'\n    ]\n  },\n  {\n    'tag': '@param y placeholder where to put the state vector at each successful\\n step (and hence at the end of integration), can be the same object as y0',\n    'alternatives': [\n      '@param y placeholder for placing the state vector at each successful step\\n(and therefore at the end of integration)\\ncan be the same object as y0.',\n      '@param y holder to store the state vector at each successful step\\n(and consequently at the end of integration),\\nwhich may be the same object as y0.',\n      '@param y placeholder where to put the state vector at each successful step\\n(and at the end of integration), can be the same object as y0.'\n    ]\n  },\n  {\n    'tag': '@return stop time, will be the same as target time if integration reached its\\ntarget, but may be different if some {@link\\norg.apache.commons.math3.ode.events.EventHandler} stops it at some point.',\n    'alternatives': [\n      '@return stop time, which will be the same as the target time if integration reached its target,\\nbut may be different if {@link org.apache.commons.math3.ode.events.EventHandler} stops it at some point.',\n      '@return stop time, it will be the same as target time if integration reached its\\nobjective, but may be different if stopped by some\\n{@link org.apache.commons.math3.ode.events.EventHandler} at some stage.',\n      '@return stop time, which will be the same as target time if the integration reached its target,\\nbut may be different if an {@link org.apache.commons.math3.ode.events.EventHandler} stops it at some point.'\n    ]\n  },\n  {\n    'tag': '@throws DimensionMismatchException if arrays dimension do not match equations settings',\n    'alternatives': [\n      '@throws DimensionMismatchException if the dimension of the arrays does not correspond to the equations settings.',\n      '@throws DimensionMismatchException if the dimension of the arrays does not match the equations settings.',\n      '@throws DimensionMismatchException if the dimensions of the arrays do not match the equations settings.'\n    ]\n  },\n  {\n    'tag': '@throws NumberIsTooSmallException if integration step is too small',\n    'alternatives': [\n      '@throws NumberIsTooSmallException if the integration step is excessively small.',\n      '@throws NumberIsTooSmallException if the integration step is too small.',\n      '@throws NumberIsTooSmallException if the integration step is smaller than needed.'\n    ]\n  },\n  {\n    'tag': '@throws MaxCountExceededException if the number of functions evaluations is exceeded',\n    'alternatives': [\n      '@throws MaxCountExceededException if the number of function evaluations has surpassed the limit.',\n      '@throws MaxCountExceededException if the number of function evaluations exceeds the maximum.',\n      '@throws MaxCountExceededException if the maximum limit of function evaluations is exceeded.'\n    ]\n  },\n  {\n    'tag': '@throws NoBracketingException if the location of an event cannot be bracketed',\n    'alternatives': [\n      '@throws NoBracketingException if it is not possible to bracket the location of an event.',\n      '@throws NoBracketingException if the position of an event cannot be bracketed.',\n      '@throws NoBracketingException if the bracketing of an event position is not possible.'\n    ]\n  },\n  {\n    'tag': '@return returns the NaNStrategy',\n    'alternatives': [\n      '@return returns the NaNStrategy.',\n      '@return returns the strategy for handling NaNs.',\n      '@return returns the strategy for NaN handling.'\n    ]\n  }\n]"