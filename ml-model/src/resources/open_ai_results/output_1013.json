"output=[\n  {\n    'tag': '@return the List of neighbors',\n    'alternatives': [\n      '@return the neighbor List',\n      '@return list of adjacent nodes',\n      '@return a list containing the neighboring elements',\n      '@return the list of nearby elements',\n      '@return a list that contains the adjacent items'\n    ]\n  },\n  {\n    'tag': '@param one first list',\n    'alternatives': [\n      '@param one the initial list',\n      '@param firstList the first list',\n      '@param one the primary list',\n      '@param one the list to be used as the first argument',\n      '@param listOne the first specified list'\n    ]\n  },\n  {\n    'tag': '@param two second list',\n    'alternatives': [\n      '@param two the secondary list',\n      '@param secondList the second list',\n      '@param two the additional list',\n      '@param two the list to be used as the second argument',\n      '@param listTwo the second specified list'\n    ]\n  },\n  {\n    'tag': '@return merged lists',\n    'alternatives': [\n      '@return the combined lists',\n      '@return the merged result',\n      '@return the merged list',\n      '@return the amalgamated lists',\n      '@return the unified lists'\n    ]\n  },\n  {\n    'tag': '@param eps maximum radius of the neighborhood to be considered',\n    'alternatives': [\n      '@param eps the maximum range to consider for the neighborhood',\n      '@param eps the upper limit of the range to be examined for the neighborhood',\n      '@param eps the maximum distance within which elements are considered neighbors',\n      '@param eps the maximum boundary within which elements are regarded as neighbors',\n      '@param eps the highest value that defines the boundary for the neighborhood'\n    ]\n  },\n  {\n    'tag': '@param minPts minimum number of points needed for a cluster',\n    'alternatives': [\n      '@param minPts the minimum required points for a cluster',\n      '@param minPts the smallest number of points necessary for forming a cluster',\n      '@param minPts the minimum count of points required to create a cluster',\n      '@param minPts the least number of points needed for a cluster',\n      '@param minPts the minimum threshold of points for forming a cluster'\n    ]\n  },\n  {\n    'tag': '@return a reference (not a copy!) to the wrapped array',\n    'alternatives': [\n      '@return the wrapped array as a reference (not a copy!)',\n      '@return a reference to the encapsulated array (not a copy!)',\n      '@return the array that is wrapped, without making a copy',\n      '@return a reference to the underlying array without duplication',\n      '@return a pointer to the wrapped array, not a duplicate'\n    ]\n  },\n  {\n    'tag': '@param point the n-dimensional point in integer space',\n    'alternatives': [\n      '@param point the nD point in integer space',\n      '@param point an n-dimensional point represented in integer space',\n      '@param point the point with n dimensions in integer space',\n      '@param point an integer-based point in the n-dimensional space',\n      '@param point the point defined in integer space with multiple dimensions'\n    ]\n  },\n  {\n    'tag': '@param point point to add',\n    'alternatives': [\n      '@param point the point to include',\n      '@param point the item to append',\n      '@param point the element to insert',\n      '@param point the object to add',\n      '@param point the value to include'\n    ]\n  },\n  {\n    'tag': '@return points contained in the cluster',\n    'alternatives': [\n      '@return the points within the cluster',\n      '@return the elements that are part of the cluster',\n      '@return the points that belong to the cluster',\n      '@return the contained points within the cluster',\n      '@return the collection of points that form the cluster'\n    ]\n  },\n  {\n    'tag': '@param center the point which is to be the center of this cluster',\n    'alternatives': [\n      '@param center the point that will serve as the cluster center',\n      '@param center the point around which the cluster is formed',\n      '@param center the central point of the cluster',\n      '@param center the point to be designated as the cluster centroid',\n      '@param center the point that acts as the cluster midpoint'\n    ]\n  },\n  {\n    'tag': '@return a reference (not a copy!) to the wrapped array',\n    'alternatives': [\n      '@return the wrapped array as a reference (not a copy!)',\n      '@return a reference to the encapsulated array (not a copy!)',\n      '@return the array that is wrapped, without making a copy',\n      '@return a reference to the underlying array without duplication',\n      '@return a pointer to the wrapped array, not a duplicate'\n    ]\n  },\n  {\n    'tag': '@param point the n-dimensional point in integer space',\n    'alternatives': [\n      '@param point the nD point in integer space',\n      '@param point an n-dimensional point represented in integer space',\n      '@param point the point with n dimensions in integer space',\n      '@param point an integer-based point in the n-dimensional space',\n      '@param point the point defined in integer space with multiple dimensions'\n    ]\n  },\n  {\n    'tag': '@param p the point to compute the distance from',\n    'alternatives': [\n      '@param p the point from which the distance is calculated',\n      '@param p the point used to determine the distance',\n      '@param p the point to measure the distance from',\n      '@param p the point that serves as the starting point for the distance calculation',\n      '@param p the origin point for calculating the distance'\n    ]\n  },\n  {\n    'tag': '@return the distance from the given point',\n    'alternatives': [\n      '@return the distance starting from the provided point',\n      '@return the computed distance from the given point',\n      '@return the quantity that represents the distance from the specified point',\n      '@return the distance measured from the given point',\n      '@return the length of the distance from the provided point'\n    ]\n  },\n  {\n    'tag': '@param p the Collection of points to compute the centroid of',\n    'alternatives': [\n      '@param p the Collection of points used for calculating the centroid',\n      '@param p the set of points to determine the centroid from',\n      '@param p the collection of points from which the centroid is derived',\n      '@param p the array of points for computing the centroid',\n      '@param p the group of points to calculate the centroid of'\n    ]\n  },\n  {\n    'tag': '@return the centroid of the given Collection of Points',\n    'alternatives': [\n      '@return the centroid derived from the provided Collection of Points',\n      '@return the calculated center of mass of the given Collection of Points',\n      '@return the center point representing the average location of the given Collection of Points',\n      '@return the geometric center of the given Collection of Points',\n      '@return the central point obtained from the provided Collection of Points'\n    ]\n  },\n  {\n    'tag': '@param points the points to cluster',\n    'alternatives': [\n      '@param points the elements to be grouped into a cluster',\n      '@param points the items to be organized into clusters',\n      '@param points the objects to form clusters',\n      '@param points the data points for clustering',\n      '@param points the set of elements to be placed in clusters'\n    ]\n  },\n  {\n    'tag': '@param k the number of clusters to split the data into',\n    'alternatives': [\n      '@param k the number of groups to divide the data into',\n      '@param k the count of clusters to separate the data into',\n      '@param k the quantity of clusters to divide the data into',\n      '@param k the total number of subgroups to distribute the data into',\n      '@param k the number of partitions to allocate the data into'\n    ]\n  },\n  {\n    'tag': '@param numTrials number of trial runs',\n    'alternatives': [\n      '@param numTrials the count of experimental attempts',\n      '@param numTrials the quantity of test runs',\n      '@param numTrials the number of experimental trials',\n      '@param numTrials the total attempts in the trial',\n      '@param numTrials the quantity of iterations for testing purposes'\n    ]\n  },\n  {\n    'tag': '@param maxIterationsPerTrial the maximum number of iterations to run the algorithm\\n    for at each trial run.  If negative, no maximum will be used',\n    'alternatives': [\n      '@param maxIterationsPerTrial the upper limit of iterations to execute the algorithm for each trial run. If negative, no limit will be considered',\n      '@param maxIterationsPerTrial the highest number of iterations per trial run for executing the algorithm. If negative, there will be no imposed maximum',\n      '@param maxIterationsPerTrial the maximum count of iterations for running the algorithm at every trial. If negative, there will be no set maximum',\n      '@param maxIterationsPerTrial the highest limit of iterations performed in the algorithm for each trial run. If negative, it means no maximum is placed',\n      '@param maxIterationsPerTrial the maximum number of algorithm iterations to be executed in each trial run. If negative, there is no specified maximum limit'\n    ]\n  },\n  {\n    'tag': '@return a list of clusters containing the points',\n    'alternatives': [\n      '@return a list of clusters that hold the points',\n      '@return a list containing the clusters with included points',\n      '@return a list that consists of clusters comprising the points',\n      '@return a list composed of the clusters that contain the points',\n      '@return a list of clusters storing the given points'\n    ]\n  },\n  {\n    'tag': '@throws ConvergenceException if an empty cluster is encountered and the\\n{@link #emptyStrategy} is set to {@code ERROR}',\n    'alternatives': [\n      '@throws ConvergenceException when an empty cluster is found and the\\n{@link #emptyStrategy} is set to {@code ERROR}',\n      '@throws ConvergenceException if there is an empty cluster and the\\n{@link #emptyStrategy} is set to {@code ERROR}',\n      '@throws ConvergenceException in case of an empty cluster found and the\\n{@link #emptyStrategy} is set to {@code ERROR}',\n      '@throws ConvergenceException if an empty cluster is discovered and the\\n{@link #emptyStrategy} is set to {@code ERROR}',\n      '@throws ConvergenceException when the {@link #emptyStrategy} is set to {@code ERROR} and an empty cluster occurs'\n    ]\n  },\n  {\n    'tag': '@param points the points to cluster',\n    'alternatives': [\n      '@param points the elements to be grouped into a cluster',\n      '@param points the items to be organized into clusters',\n      '@param points the objects to form clusters',\n      '@param points the data points for clustering',\n      '@param points the set of elements to be placed in clusters'\n    ]\n  },\n  {\n    'tag': '@param k the number of clusters to split the data into',\n    'alternatives': [\n      '@param k the number of groups to divide the data into',\n      '@param k the count of clusters to separate the data into',\n      '@param k the quantity of clusters to divide the data into',\n      '@param k the total number of subgroups to distribute the data into',\n      '@param k the number of partitions to allocate the data into'\n    ]\n  }\n]"