"output = [\r\n  {\r\n    'tag': '@return a matrix X that minimizes the two norm of A &times; X - B',\r\n    'alternatives': [\r\n      '@return a matrix X that minimizes the two norm of A &times; X - B',\r\n      '@return a matrix X that minimizes the Euclidean norm of A &times; X - B',\r\n      '@return a matrix X that minimizes the Frobenius norm of A &times; X - B',\r\n      '@return a matrix X that achieves the minimum two norm of A &times; X - B',\r\n      '@return a matrix X that yields the smallest two norm of A &times; X - B'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@throws org.apache.commons.math3.exception.DimensionMismatchException if the matrices dimensions do not match.',\r\n    'alternatives': [\r\n      '@throws org.apache.commons.math3.exception.DimensionMismatchException if the matrices dimensions do not match.',\r\n      '@throws org.apache.commons.math3.exception.DimensionMismatchException if the dimensions of the matrices do not match.',\r\n      '@throws org.apache.commons.math3.exception.DimensionMismatchException if the sizes of the matrices do not match.',\r\n      '@throws org.apache.commons.math3.exception.DimensionMismatchException if the dimensions of the matrices are incompatible.',\r\n      '@throws org.apache.commons.math3.exception.DimensionMismatchException if the matrices have incompatible sizes.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@throws SingularMatrixException if the decomposed matrix is singular.',\r\n    'alternatives': [\r\n      '@throws SingularMatrixException if the decomposed matrix is singular.',\r\n      '@throws SingularMatrixException if the matrix after decomposition is singular.',\r\n      '@throws SingularMatrixException if the matrix being decomposed is singular.',\r\n      '@throws SingularMatrixException if the matrix undergoing decomposition is singular.',\r\n      '@throws SingularMatrixException if the decomposed matrix is found to be singular.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return true if the decomposed matrix is non-singular.',\r\n    'alternatives': [\r\n      '@return true if the decomposed matrix is non-singular.',\r\n      '@return true if the matrix after decomposition is non-singular.',\r\n      '@return true if the matrix being decomposed is non-singular.',\r\n      '@return true if the matrix undergoing decomposition is non-singular.',\r\n      '@return true if the decomposed matrix is found to be non-singular.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return pseudo-inverse matrix (which is the inverse, if it exists),\\nif the decomposition can pseudo-invert the decomposed matrix',\r\n    'alternatives': [\r\n      '@return pseudo-inverse matrix (which is the inverse, if it exists),\\nif the decomposition can pseudo-invert the decomposed matrix',\r\n      '@return pseudo-inverse matrix (which is the reciprocal, if available),\\nif the decomposition has the capability to pseudo-invert the decomposed matrix',\r\n      '@return pseudo-inverse matrix (which is the inverted form, if available),\\nif the decomposition has the ability to pseudo-invert the decomposed matrix',\r\n      '@return pseudo-inverse matrix (which is the reverse, if it is possible),\\nif the decomposition can pseudo-invert the decomposed matrix',\r\n      '@return pseudo-inverse matrix (which is the mirrored version, if it exists),\\nif the decomposition can pseudo-invert the decomposed matrix'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@throws SingularMatrixException if the decomposed matrix is singular and the decomposition\\ncan not compute a pseudo-inverse',\r\n    'alternatives': [\r\n      '@throws SingularMatrixException if the decomposed matrix is singular and the decomposition\\ncan not compute a pseudo-inverse',\r\n      '@throws SingularMatrixException if the decomposed matrix is singular and the decomposition\\ncannot calculate a pseudo-inverse',\r\n      '@throws SingularMatrixException if the decomposed matrix is singular and the decomposition\\ncan not compute an approximate inverse',\r\n      '@throws SingularMatrixException if the decomposed matrix is singular and the decomposition\\ncannot compute a pseudo-inverse',\r\n      '@throws SingularMatrixException if the decomposed matrix is singular and the decomposition\\ncan not calculate a pseudo-inverse'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return the L matrix (or null if decomposed matrix is singular)',\r\n    'alternatives': [\r\n      '@return the L matrix (or null if decomposed matrix is singular)',\r\n      '@return the L matrix (or null if the decomposed matrix is singular)',\r\n      '@return the L matrix (or null if the matrix being decomposed is singular)',\r\n      '@return the L matrix (or null if the matrix after decomposition is singular)',\r\n      '@return the L matrix (or null if the matrix undergoing decomposition is singular)'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return the U matrix (or null if decomposed matrix is singular)',\r\n    'alternatives': [\r\n      '@return the U matrix (or null if decomposed matrix is singular)',\r\n      '@return the U matrix (or null if the decomposed matrix is singular)',\r\n      '@return the U matrix (or null if the matrix being decomposed is singular)',\r\n      '@return the U matrix (or null if the matrix after decomposition is singular)',\r\n      '@return the U matrix (or null if the matrix undergoing decomposition is singular)'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return the P rows permutation matrix (or null if decomposed matrix is singular)',\r\n    'alternatives': [\r\n      '@return the P rows permutation matrix (or null if decomposed matrix is singular)',\r\n      '@return the P rows permutation matrix (or null if the decomposed matrix is singular)',\r\n      '@return the P rows permutation matrix (or null if the matrix being decomposed is singular)',\r\n      '@return the P rows permutation matrix (or null if the matrix after decomposition is singular)',\r\n      '@return the P rows permutation matrix (or null if the matrix undergoing decomposition is singular)'\r\n    ]\r\n  },\r\n   {\r\n    'tag': '@return the pivot permutation vector',\r\n    'alternatives': [\r\n      '@return the pivot permutation vector',\r\n      '@return the vector containing the permutation of pivot elements',\r\n      '@return the vector representing the permutation of pivot elements',\r\n      '@return the vector that describes the permutation of pivot elements',\r\n      '@return the vector holding the permutation of pivot elements'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return determinant of the matrix',\r\n    'alternatives': [\r\n      '@return determinant of the matrix',\r\n      '@return the determinant of the given matrix',\r\n      '@return the value of the determinant for the matrix',\r\n      '@return the determinant value of the matrix',\r\n      '@return the computed determinant of the matrix'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return a solver',\r\n    'alternatives': [\r\n      '@return a solver',\r\n      '@return a solver object',\r\n      '@return an instance of a solver',\r\n      '@return a solver implementation',\r\n      '@return a solver class'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param matrix Matrix to decompose.',\r\n    'alternatives': [\r\n      '@param matrix Matrix to decompose.',\r\n      '@param matrix Input matrix for decomposition.',\r\n      '@param matrix The matrix to perform decomposition on.',\r\n      '@param matrix The matrix that needs to be decomposed.',\r\n      '@param matrix The input matrix to decompose.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param matrix The matrix to decompose.',\r\n    'alternatives': [\r\n      '@param matrix The matrix to decompose.',\r\n      '@param matrix The matrix to use for decomposition.',\r\n      '@param matrix The matrix that needs to be decomposed.',\r\n      '@param matrix Input matrix for decomposition.',\r\n      '@param matrix The matrix that is subjected to decomposition.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param singularityThreshold threshold (based on partial row norm)\\nunder which a matrix is considered singular',\r\n    'alternatives': [\r\n      '@param singularityThreshold threshold (based on partial row norm)\\nunder which a matrix is considered singular',\r\n      '@param singularityThreshold the threshold (based on partial row norm)\\nfor considering a matrix as singular',\r\n      '@param singularityThreshold the threshold (based on the norm of some rows)\\nbelow which a matrix is singular',\r\n      '@param singularityThreshold a threshold (based on the norm of specific rows)\\nto determine if a matrix is singular',\r\n      '@param singularityThreshold the threshold (based on the norm of certain rows)\\ndetermining if a matrix is singular'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return {@code true} if the tests are to be performed',\r\n    'alternatives': [\r\n      '@return {@code true} if the tests are to be performed',\r\n      '@return {@code true} if the checks need to be carried out',\r\n      '@return {@code true} if the validations should be executed',\r\n      '@return {@code true} if the examinations are to be conducted',\r\n      '@return {@code true} if the verifications are to be done'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@throws NonPositiveDefiniteOperatorException if {@code a} or {@code m} is\\nnot positive definite',\r\n    'alternatives': [\r\n      '@throws NonPositiveDefiniteOperatorException if {@code a} or {@code m} is\\nnot positive definite',\r\n      '@throws NonPositiveDefiniteOperatorException if {@code a} or {@code m} is\\nnot positive-definite',\r\n      '@throws NonPositiveDefiniteOperatorException if either {@code a} or {@code m} is\\nnot positive definite',\r\n      '@throws NonPositiveDefiniteOperatorException if either {@code a} or {@code m} is\\nnot positive-definite',\r\n      '@throws NonPositiveDefiniteOperatorException if the matrix {@code a} or {@code m} is\\nnot positive definite'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param maxIterations the maximum number of iterations',\r\n    'alternatives': [\r\n      '@param maxIterations the maximum number of iterations',\r\n      '@param maxIterations the maximum amount of iterations',\r\n      '@param maxIterations the highest number of iterations',\r\n      '@param maxIterations the maximum iteration count',\r\n      '@param maxIterations the maximum number of allowed iterations'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param delta the &delta; parameter for the default stopping criterion',\r\n    'alternatives': [\r\n      '@param delta the &delta; parameter for the default stopping criterion',\r\n      '@param delta the &delta; value used for the default stopping criterion',\r\n      '@param delta the &delta; parameter to apply the default stopping criterion',\r\n      '@param delta the &delta; threshold for the default stopping criterion',\r\n      '@param delta the &delta; value for the default stopping criterion'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param check {@code true} if positive definiteness of both matrix and\\npreconditioner should be checked',\r\n    'alternatives': [\r\n      '@param check {@code true} if positive definiteness of both matrix and\\npreconditioner should be checked',\r\n      '@param check {@code true} if both matrix and preconditioner must be checked for positive definiteness',\r\n      '@param check {@code true} if it is necessary to verify the positive definiteness of both matrix and\\npreconditioner',\r\n      '@param check {@code true} if the positive definiteness of both matrix and\\npreconditioner needs to be verified',\r\n      '@param check {@code true} if the positivity of both matrix and preconditioner should be examined'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param manager the custom iteration manager',\r\n    'alternatives': [\r\n      '@param manager the custom iteration manager',\r\n      '@param manager the user-defined iteration manager',\r\n      '@param manager the iteration manager provided by the user',\r\n      '@param manager the customized iteration manager',\r\n      '@param manager the iteration manager specified by the user'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@return {@code true} if the tests are to be performed',\r\n    'alternatives': [\r\n      '@return {@code true} if the tests are to be performed',\r\n      '@return {@code true} if the checks need to be carried out',\r\n      '@return {@code true} if the validations should be executed',\r\n      '@return {@code true} if the examinations are to be conducted',\r\n      '@return {@code true} if the verifications are to be done'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@throws NumberIsTooLargeException if the total number of entries of the\\nmatrix is larger than {@code Integer.MAX_VALUE}.',\r\n    'alternatives': [\r\n      '@throws NumberIsTooLargeException if the total number of entries of the\\nmatrix is larger than {@code Integer.MAX_VALUE}.',\r\n      '@throws NumberIsTooLargeException if the matrix has more entries than {@code Integer.MAX_VALUE}.',\r\n      '@throws NumberIsTooLargeException if the number of matrix entries exceeds {@code Integer.MAX_VALUE}.',\r\n      '@throws NumberIsTooLargeException if the matrix contains more elements than {@code Integer.MAX_VALUE}.',\r\n      '@throws NumberIsTooLargeException if the total entries of the matrix are greater than {@code Integer.MAX_VALUE}.'\r\n    ]\r\n  },\r\n  {\r\n    'tag': '@param m Matrix to be added.',\r\n    'alternatives': [\r\n      '@param m Matrix to be added.',\r\n      '@param m The matrix to add.',\r\n      '@param m Input matrix to perform addition.',\r\n      '@param m The matrix to include.',\r\n      '@param m The input matrix for addition.'\r\n    ]\r\n  }\r\n]"