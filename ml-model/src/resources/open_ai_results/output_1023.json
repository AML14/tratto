"output = [\n  {\n    'tag': '@param observations observations to be compared to objective function to compute residuals',\n    'alternatives': [\n      '@param observations data points to be compared with objective function to calculate residuals',\n      '@param observations input used for comparing with objective function to determine residuals',\n      '@param observations set of observations to compare with objective function and calculate residuals'\n    ]\n  },\n  {\n    'tag': '@param scale scaling matrix',\n    'alternatives': [\n      '@param scale matrix used for scaling',\n      '@param scale matrix for scaling purposes',\n      '@param scale matrix for the purpose of scaling'\n    ]\n  },\n  {\n    'tag': '@throws DimensionMismatchException if the observations vector and the scale\\nmatrix dimensions do not match (objective function dimension is checked only when\\nthe {@link #value(double[])} method is called)',\n    'alternatives': [\n      '@throws DimensionMismatchException if the dimensions of the observations vector and the scaling matrix do not match (the dimension of the objective function is only checked when calling the {@link #value(double[])} method)',\n      '@throws DimensionMismatchException if the dimensions of the observations vector and the scale matrix do not match (the dimension of the objective function is checked only when the {@link #value(double[])} method is invoked)',\n      '@throws DimensionMismatchException if the size of the observations vector and the scale matrix do not match (the size of the objective function is verified only when invoking the {@link #value(double[])} method)'\n    ]\n  },\n  {\n    'tag': '@param params Point at which the gradient must be evaluated.',\n    'alternatives': [\n      '@param params Point where the gradient should be calculated.',\n      '@param params Location where the gradient needs to be evaluated.',\n      '@param params The point at which the gradient should be determined.'\n    ]\n  },\n  {\n    'tag': '@return the gradient at the specified point.',\n    'alternatives': [\n      '@return the gradient value at the given point.',\n      '@return the gradient calculated for the specified point.',\n      '@return the gradient obtained at the indicated point.'\n    ]\n  },\n  {\n    'tag': '@param optData Optimization data. In addition to those documented in\\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\\nMultivariateOptimizer}, this method will register the following data:\\n<ul>\\n <li>{@link ObjectiveFunctionGradient}</li>\\n</ul>',\n    'alternatives': [\n      '@param optData Optimization data. Besides the ones documented in\\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\\nMultivariateOptimizer}, this method will add the following data:\\n<ul>\\n <li>{@link ObjectiveFunctionGradient}</li>\\n</ul>',\n      '@param optData Optimization data. This method will include the following data in addition to the ones explained in\\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\\nMultivariateOptimizer}:\\n<ul>\\n <li>{@link ObjectiveFunctionGradient}</li>\\n</ul>',\n      '@param optData Optimization data. In addition to those already documented in\\n{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\\nMultivariateOptimizer}, this method will record the following data:\\n<ul>\\n <li>{@link ObjectiveFunctionGradient}</li>\\n</ul>'\n    ]\n  },\n  {\n    'tag': '@return {@inheritDoc}',\n    'alternatives': [\n      '@return {@inheritDoc}',\n      '@return inherit from the superclass',\n      '@return inherited from the superclass'\n    ]\n  },\n  {\n    'tag': '@throws TooManyEvaluationsException if the maximal number of\\nevaluations (of the objective function) is exceeded.',\n    'alternatives': [\n      '@throws TooManyEvaluationsException when the maximum number of objective function evaluations is surpassed.',\n      '@throws TooManyEvaluationsException if the objective function evaluations reach the maximum allowed.',\n      '@throws TooManyEvaluationsException when the number of evaluations for the objective function exceeds the limit.'\n    ]\n  },\n  {\n    'tag': '@param optData Optimization data.\\nThe following data will be looked for:\\n<ul>\\n <li>{@link ObjectiveFunctionGradient}</li>\\n</ul>',\n    'alternatives': [\n      '@param optData Optimization data.\\nThe following data will be searched for:\\n<ul>\\n <li>{@link ObjectiveFunctionGradient}</li>\\n</ul>',\n      '@param optData Optimization data.\\nThe following data will be checked:\\n<ul>\\n <li>{@link ObjectiveFunctionGradient}</li>\\n</ul>',\n      '@param optData Optimization data.\\nThe following data will be examined:\\n<ul>\\n <li>{@link ObjectiveFunctionGradient}</li>\\n</ul>'\n    ]\n  },\n  {\n    'tag': '@param checker Convergence checker.',\n    'alternatives': [\n      '@param checker Checker for convergence.',\n      '@param checker Convergence verification tool.',\n      '@param checker Convergence detection mechanism.'\n    ]\n  },\n  {\n    'tag': '@param point Unbounded values.',\n    'alternatives': [\n      '@param point Values without bounds.',\n      '@param point Values not limited by boundaries.',\n      '@param point Values that are not bound.'\n    ]\n  },\n  {\n    'tag': '@return the bounded values.',\n    'alternatives': [\n      '@return the values with bounds.',\n      '@return the values limited by boundaries.',\n      '@return the values that have bounds.'\n    ]\n  },\n  {\n    'tag': '@param point Bounded values.',\n    'alternatives': [\n      '@param point Values with bounds.',\n      '@param point Values limited by boundaries.',\n      '@param point Values that are bound.'\n    ]\n  },\n  {\n    'tag': '@return the unbounded values.',\n    'alternatives': [\n      '@return the values without bounds.',\n      '@return the values not limited by boundaries.',\n      '@return the values that have no bounds.'\n    ]\n  },\n  {\n    'tag': '@param point unbounded value',\n    'alternatives': [\n      '@param point value without bounds',\n      '@param point value not limited by boundaries',\n      '@param point value with no bounds'\n    ]\n  },\n  {\n    'tag': '@return underlying function value',\n    'alternatives': [\n      '@return value of the underlying function',\n      '@return value returned by the underlying function',\n      '@return value of the function underneath'\n    ]\n  },\n  {\n    'tag': '@param bounded bounded function',\n    'alternatives': [\n      '@param bounded function',\n      '@param function limited by boundaries',\n      '@param function with bounds'\n    ]\n  },\n  {\n    'tag': '@param lower lower bounds for each element of the input parameters array\\n(some elements may be set to {@code Double.NEGATIVE_INFINITY} for\\nunbounded values)',\n    'alternatives': [\n      '@param lower lower limits for each element of the input parameters array\\n(some elements may be assigned {@code Double.NEGATIVE_INFINITY} for\\nunbounded values)',\n      '@param lower lower boundaries for each element of the input parameters array\\n(some elements may be specified as {@code Double.NEGATIVE_INFINITY} for\\nunbounded values)',\n      '@param lower lower bounds for every element of the input parameters array\\n(some elements may be set to {@code Double.NEGATIVE_INFINITY} for\\nunbounded values)'\n    ]\n  },\n  {\n    'tag': '@param upper upper bounds for each element of the input parameters array\\n(some elements may be set to {@code Double.POSITIVE_INFINITY} for\\nunbounded values)',\n    'alternatives': [\n      '@param upper upper limits for each element of the input parameters array\\n(some elements may be assigned {@code Double.POSITIVE_INFINITY} for\\nunbounded values)',\n      '@param upper upper boundaries for each element of the input parameters array\\n(some elements may be specified as {@code Double.POSITIVE_INFINITY} for\\nunbounded values)',\n      '@param upper upper bounds for every element of the input parameters array\\n(some elements may be set to {@code Double.POSITIVE_INFINITY} for\\nunbounded values)'\n    ]\n  },\n  {\n    'tag': '@throws DimensionMismatchException if lower and upper bounds are not\\nconsistent, either according to dimension or to values',\n    'alternatives': [\n      '@throws DimensionMismatchException if the lower and upper bounds are not\\nconsistent, either dimensionally or in terms of values',\n      '@throws DimensionMismatchException if the lower and upper boundaries are not\\nconsistent, either in dimension or value',\n      '@throws DimensionMismatchException if the lower and upper bounds are not\\nconsistent, either in terms of dimension or values'\n    ]\n  },\n  {\n    'tag': '@param startPoint Starting point.',\n    'alternatives': [\n      '@param startPoint Initial point.',\n      '@param startPoint Initial location.',\n      '@param startPoint Starting position.'\n    ]\n  },\n  {\n    'tag': '@param direction Search direction.',\n    'alternatives': [\n      '@param direction Direction of search.',\n      '@param direction Direction for searching.',\n      '@param direction Search orientation.'\n    ]\n  },\n  {\n    'tag': '@return the optimum.',\n    'alternatives': [\n      '@return the best solution.',\n      '@return the optimal value.',\n      '@return the optimal outcome.'\n    ]\n  },\n  {\n    'tag': '@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the number of evaluations is exceeded.',\n    'alternatives': [\n      '@throws org.apache.commons.math3.exception.TooManyEvaluationsException when the maximum number of evaluations is surpassed.',\n      '@throws org.apache.commons.math3.exception.TooManyEvaluationsException if the number of evaluations exceeds the limit.',\n      '@throws org.apache.commons.math3.exception.TooManyEvaluationsException when the evaluation count exceeds the maximum.'\n    ]\n  },\n  {\n    'tag': '@param optimizer Optimizer on behalf of which the line search\\nbe performed.\\nIts {@link MultivariateOptimizer#computeObjectiveValue(double[])\\ncomputeObjectiveValue} method will be called by the\\n{@link #search(double[],double[]) search} method.',\n    'alternatives': [\n      '@param optimizer Optimizer for which the line search will be conducted.\\nThe {@link MultivariateOptimizer#computeObjectiveValue(double[])\\ncomputeObjectiveValue} method of this optimizer will be invoked by the\\n{@link #search(double[],double[]) search} method.',\n      '@param optimizer Optimizer that will execute the line search.\\nFor this optimization, the {@link MultivariateOptimizer#computeObjectiveValue(double[])\\ncomputeObjectiveValue} method of the optimizer will be used by the\\n{@link #search(double[],double[]) search} method.',\n      '@param optimizer Optimizer that requests the line search to be executed.\\nThe line search method {@link #search(double[],double[]) search} will take the\\n{@link MultivariateOptimizer#computeObjectiveValue(double[]) computeObjectiveValue} method from this optimizer.'\n    ]\n  }\n]"