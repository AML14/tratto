"output = [\n  {\n    'tag': '@param keyPredicate the predicate to validate the keys, null means no check',\n    'alternatives': [\n      '@param keyPred the predicate to validate the keys, null means no verification',\n      '@param predicateForKey the predicate to validate the keys, null means no check',\n      '@param keyPredicate the predicate to check the validity of keys, null means no verification',\n      '@param thePredicateForKey the predicate to validate the keys, null means no check',\n      '@param keyPredicate the predicate to validate the keys, null indicates no verification'\n    ]\n  },\n  {\n    'tag': '@param valuePredicate the predicate to validate to values, null means no check',\n    'alternatives': [\n      '@param valuePred the predicate to validate the values, null means no verification',\n      '@param predicateForValue the predicate to validate the values, null means no check',\n      '@param valuePredicate the predicate to check the validity of values, null means no verification',\n      '@param thePredicateForValue the predicate to validate the values, null means no check',\n      '@param valuePredicate the predicate to validate the values, null indicates no verification'\n    ]\n  },\n  {\n    'tag': '@param index the index to increment',\n    'alternatives': [\n      '@param theIndex the index to increment',\n      '@param index the index that needs to be incremented',\n      '@param index the index that should be incremented',\n      '@param index the index to increase',\n      '@param incrementIndex the index to increment'\n    ]\n  },\n  {\n    'tag': '@return the updated index',\n    'alternatives': [\n      '@return the modified index',\n      '@return the index after modification',\n      '@return the updated value of the index',\n      '@return the new value of the index',\n      '@return the index that has been updated'\n    ]\n  },\n  {\n    'tag': '@param index the index to decrement',\n    'alternatives': [\n      '@param theIndex the index to decrement',\n      '@param index the index that needs to be decremented',\n      '@param index the index that should be decremented',\n      '@param index the index to decrease',\n      '@param decrementIndex the index to decrement'\n    ]\n  },\n  {\n    'tag': '@return the updated index',\n    'alternatives': [\n      '@return the modified index',\n      '@return the index after modification',\n      '@return the updated value of the index',\n      '@return the new value of the index',\n      '@return the index that has been updated'\n    ]\n  },\n  {\n    'tag': \"@return an iterator over this queue's elements\",\n    'alternatives': [\n      '@return an iterator that iterates over the elements of this queue',\n      '@return an iterator for the elements of this queue',\n      '@return an iterator that provides access to the elements of this queue',\n      '@return an iterator that traverses the elements of this queue',\n      '@return an iterator that can be used to iterate over the elements of this queue'\n    ]\n  },\n  {\n    'tag': '@param size the size of the queue (cannot be changed)',\n    'alternatives': [\n      '@param size the queue size (unchangeable)',\n      '@param size the size of the queue (unmodifiable)',\n      '@param size the queue size (not modifiable)',\n      '@param size the size of the queue (immutable)',\n      '@param size the size of the queue (cannot be modified)'\n    ]\n  },\n  {\n    'tag': '@param <E> the type of the elements in the queue',\n    'alternatives': [\n      '@param <E> the element type in the queue',\n      '@param <E> the type of elements in the queue',\n      '@param <E> the type of items in the queue',\n      '@param <E> the elements\\' type in the queue',\n      '@param <E> the type of objects in the queue'\n    ]\n  },\n  {\n    'tag': '@return a new predicated queue',\n    'alternatives': [\n      '@return a new queue with predicates',\n      '@return a new queue with conditions',\n      '@return a new queue that follows specific rules',\n      '@return a new queue with restrictions',\n      '@return a new queue controlled by predicates'\n    ]\n  },\n  {\n    'tag': '@throws IllegalArgumentException if the queue contains invalid elements',\n    'alternatives': [\n      '@throws IllegalArgumentException if the queue has invalid elements',\n      '@throws IllegalArgumentException if the queue includes invalid elements',\n      '@throws IllegalArgumentException if the elements of the queue are not valid',\n      '@throws IllegalArgumentException if the queue holds invalid elements',\n      '@throws IllegalArgumentException if the queue has elements that are not valid'\n    ]\n  },\n  {\n    'tag': '@return the decorated queue',\n    'alternatives': [\n      '@return the decorated version of the queue',\n      '@return the queue that has been decorated',\n      '@return the modified queue',\n      '@return the queue after decoration',\n      '@return the queue with added decorations'\n    ]\n  },\n  {\n    'tag': '@param object the object being added',\n    'alternatives': [\n      '@param objectToBeAdded the object being added',\n      '@param obj the object being inserted',\n      '@param object the object to insert',\n      '@param addingObject the object being added',\n      '@param theObject the object to be added'\n    ]\n  },\n  {\n    'tag': '@return the result of adding to the underlying queue',\n    'alternatives': [\n      '@return the outcome of inserting into the underlying queue',\n      '@return the result obtained by adding to the base queue',\n      '@return the output after adding to the original queue',\n      '@return the outcome of appending to the underlying queue',\n      '@return the result of including in the base queue'\n    ]\n  },\n  {\n    'tag': '@throws IllegalArgumentException if the add is invalid',\n    'alternatives': [\n      '@throws IllegalArgumentException if the addition is not valid',\n      '@throws IllegalArgumentException if the add operation is not valid',\n      '@throws IllegalArgumentException if the addition is invalid',\n      '@throws IllegalArgumentException if the add is not allowed',\n      '@throws IllegalArgumentException if the adding operation is invalid'\n    ]\n  },\n  {\n    'tag': '@throws IllegalArgumentException if the Queue contains invalid elements',\n    'alternatives': [\n      '@throws IllegalArgumentException if the Queue has invalid elements',\n      '@throws IllegalArgumentException if the Queue includes invalid elements',\n      '@throws IllegalArgumentException if the elements of the Queue are not valid',\n      '@throws IllegalArgumentException if the Queue holds invalid elements',\n      '@throws IllegalArgumentException if the Queue has elements that are not valid'\n    ]\n  },\n  {\n    'tag': '@param <T> the element type',\n    'alternatives': [\n      '@param <T> the type of elements',\n      '@param <T> the type of the items',\n      '@param <T> the type of objects',\n      '@param <T> the elements\\' type',\n      '@param <T> the object type'\n    ]\n  },\n  {\n    'tag': '@return a new empty FluentIterable',\n    'alternatives': [\n      '@return a new FluentIterable that is empty',\n      '@return a fresh empty FluentIterable',\n      '@return an empty FluentIterable',\n      '@return a newly created empty FluentIterable',\n      '@return a new FluentIterable with no elements'\n    ]\n  },\n  {\n    'tag': '@param <T> the element type',\n    'alternatives': [\n      '@param <T> the type of the item',\n      '@param <T> the type of elements',\n      '@param <T> the type of objects',\n      '@param <T> the elements\\' type',\n      '@param <T> the object type'\n    ]\n  },\n  {\n    'tag': '@param singleton the singleton element',\n    'alternatives': [\n      '@param singletonElement the singleton element',\n      '@param single the single element',\n      '@param one the one and only element',\n      '@param element the element that is a singleton',\n      '@param unique the unique element'\n    ]\n  },\n  {\n    'tag': '@return a new FluentIterable containing the singleton',\n    'alternatives': [\n      '@return a new FluentIterable that holds the singleton',\n      '@return a fresh FluentIterable containing the single element',\n      '@return a FluentIterable containing only the singleton',\n      '@return a new FluentIterable with the single element',\n      '@return a new FluentIterable that contains the unique element'\n    ]\n  },\n  {\n    'tag': '@param <T> the element type',\n    'alternatives': [\n      '@param <T> the type of elements',\n      '@param <T> the type of the items',\n      '@param <T> the type of objects',\n      '@param <T> the elements\\' type',\n      '@param <T> the object type'\n    ]\n  },\n  {\n    'tag': '@param elements the elements to be contained in the FluentIterable',\n    'alternatives': [\n      '@param elementsToInclude the elements to be contained in the FluentIterable',\n      '@param inputElements the elements that should be inside the FluentIterable',\n      '@param setOfElements the elements that are part of the FluentIterable',\n      '@param includedElements the elements to include in the FluentIterable',\n      '@param providedElements the elements that are provided for the FluentIterable'\n    ]\n  },\n  {\n    'tag': '@return a new FluentIterable containing the provided elements',\n    'alternatives': [\n      '@return a new FluentIterable that holds the given elements',\n      '@return a fresh FluentIterable containing the provided items',\n      '@return a FluentIterable containing the provided elements',\n      '@return a new FluentIterable with the given elements',\n      '@return a new FluentIterable that contains the provided objects'\n    ]\n  },\n  {\n    'tag': '@param <T> the element type',\n    'alternatives': [\n      '@param <T> the type of items',\n      '@param <T> the type of elements',\n      '@param <T> the type of objects',\n      '@param <T> the elements\\' type',\n      '@param <T> the object type'\n    ]\n  }\n]"