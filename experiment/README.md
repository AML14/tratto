# Experiment

## Setup

### EvoSuite

We use EvoSuite to generate test prefixes, which is written in Java 8. However, the experiment module uses Java 17, such that the user must configure a home directory for a local JDK 8. See [Oracle](https://www.oracle.com/java/technologies/downloads/#java8-linux) for JDK downloads. Afterward, configure the path to the JDK Home directory in [`evosuite.sh`](generator/evosuite.sh). By default, this path is set to the `resources` subdirectory in the `generator` directory.

### JDoctor

To set up JDoctor for analysis, visit the [ToRaDoCu](https://github.com/albertogoffi/toradocu) GitHub page, and follow instructions to build the `toradocu-1.0-all.jar` file. Then, add the file to the `experiment/generator/resources` directory.

## Overview

This module automates the experimental analysis of a test oracle generator (TOG) for the task of automated test generation. 

A unit test is composed of two parts: **the prefix** and **the oracle**. 

```agsl
// prefix
int a = 5;
int b = 1;
// oracle
assert sum(a, b) == (a + b)
```

To generate test prefixes, we use [EvoSuite](https://www.evosuite.org/), which generates complete unit tests (including the oracle), and remove the generated oracles (assertions) using [JavaParser](https://javaparser.org/). Then, we generate new oracles using an arbitrary TOG, and add these assertions to the test prefixes. Finally, we use [PITest](https://pitest.org/) to report mutation score of the generated tests, and also record the number of positive/negative (failing/passing) test cases.

To analyze a TOG, run
```
experiment.sh [tog] [target-class] [source-dir] [bin-dir]
```
where,

- `[tog]` is a test oracle generator
- `[target-class]` is the fully qualified name of the class under test
- `[source-dir]` is the path to the project source directory 
- `[bin-dir]` is the path to the project binary files

For example,
```
experiment.sh tratto example.Stack ../path/to/src ../path/to/target/classes
```

## Research Questions

As a precursor, we define an "axiomatic" oracle, as a self-evident and unquestionable oracle (e.g. `methodResult != null`). Axiomatic oracles are very general and not specific to individual test prefixes. An example of a non-axiomatic oracle is `sum(5, 1) == 6`.

In our experimental analysis, we seek to answer the following research questions:

1. What is the effectiveness (precision and FPR) of `Tratto` for generating axiomatic oracles?
2. How does `Tratto` enhance test suites when combined with tools such as `EvoSuite` or `Randoop` in terms of bug-finding ability and mutation score?
3. Is `Tratto` able to recreate all (or more) axiomatic oracles generated by `JDoctor`? Is `Tratto` able to synthesize all oracles (and fix incorrect oracles) generated by `TOGA`?

[comment]: <> (4. How does `Tratto` compare with `ChatGPT` for axiomatic oracle generation?)

## Metrics

To answer the above research questions, we perform two experiments: [Classification](#classification) (RQ 1, 3) and [Mutation](#mutation) (RQ 2).

### Classification

We say an oracle <span style="color:red">"fails"</span> the code if its corresponding test assertion fails using the current implementation. We say an oracle <span style="color:green">"passes"</span> the specification if the assertion *should* pass according to the specification.

|                     | Code                                  | Specification                         |
|---------------------|---------------------------------------|---------------------------------------|
| True Positive (TP)  | <span style="color:red">Fail</span>   | <span style="color:green">Pass</span> |
| False Positive (FP) | <span style="color:red">Fail</span>   | <span style="color:red">Fail</span>   |
| True Negative (TN)  | <span style="color:green">Pass</span> | <span style="color:green">Pass</span> |
| False Negative (FN) | <span style="color:green">Pass</span> | <span style="color:red">Fail</span>   |

For clarification, consider the following (buggy) code snippet:

```agsl
/**
 * @param a an integer
 * @param b an integer
 * @returns the sum of the two integer values
 */
int sum(int a, int b) {
    return a - b;
}
```

We provide an example of each class of oracle below:
- True Positive: `sum(a, b) == (a + b)`
- False Positive: `sum(a, b) == null`
- True Negative: `sum(a, b) != null`
- False Negative: `sum(a, b) == (a - b)`

Intuitively, we hope to maximize True Positives and True Negatives, and minimize False Positives and False Negatives. This corresponds to a high precision and a low FPR.

### Mutation

To analyze the "effectiveness" of the generated oracles, we compute the mutation score of the generated test suite. Consider the previous example, `sum`, and two corresponding oracles: `sum(a, b) == (a + b)` and `sum(a, b) != null`. We say the first assertion (1) is more "effective" than the second assertion (2). We quantify "effective"-ness via mutation score, which indicates how robust the test suite is to changes in source code. Intuitively, because (1) implies (2), we know that (1) will always kill more mutants than (2) and have a better mutation score.

## Implementation

The user provides two arguments as input: the TOG and the source path. For reference, we provide an overview of the experimental pipeline.

![experiment pipeline](./doc/experiment-pipeline.png)

We provide a brief description of the relevant files:

- `generator`: this package contains scripts for generating test prefixes and test oracles 
  - `evosuite.sh`: a script that invokes EvoSuite for a given source file
  - `jdoctor.sh`: a script that invokes JDoctor for a given source file
  - `toga.sh`: a script that invokes TOGA for a given source file and test prefix
  - `tratto.sh`: a script that invokes Tratto for a given source file
- `src/main/java`: this package contains all Java functionality, including mutation testing, file IO, JavaParser utilities, etc.
  - `FileUtils.java`: a class with all necessary utilities to read and write to files 
  - `TestAnalyzer.java`: a class for reporting the statistics of a test suite. Includes the number of passing/failing tests and mutation score.
  - `TestUtils.java`: a class for test suite utilities, such as removing/adding assertions
  - `TestOutput.java`: a record for storing a test case and its contextual information
- `experiment.sh`: the end-to-end script which performs the experiment

### Prefix

We run `evosuite.sh` to generate a test suite using EvoSuite. These full test cases include both the test prefix and the test oracle, and are saved in `experiment/output/evosuite-tests/`. Then, we use `TestUtils.java` to remove the oracles (assertions) using JavaParser. These test prefixes are saved as separate files in `experiment/output/evosuite-prefixes/`.

### Oracle

We use the EvoSuite prefixes to generate oracles using the specified TOG. Each TOG has a corresponding script invoking the TOG (as a jar file).  

Then, we use `TestUtils.java` to insert the new oracles, using JavaParser, as assertions in the test prefixes. Our method for inserting oracles varies based on whether the TOG generates [axiomatic](#axiomatic) or [non-axiomatic](#non-axiomatic) oracles. 

Then, the new tests are saved as separate files in `experiment/output/tog-test/[tog]/`, where `[tog]` is the given TOG.

#### Axiomatic

If the oracles are axiomatic, then we insert the oracles wherever they are applicable. Consider the following oracles for the aforementioned `sum` example method: `sum(a, b) != null` and `a != null`. We may interpret these oracles as "method output must not be null" and "first method argument must not be null". Consequently, we should add the assertions after every appearance of the method output or first method argument, respectively. Consider the following test prefixes generated by EvoSuite.

```agsl
void sumTest() {
    int a = 2;
    int b = 5;
}

void sumNegativeTest() {
    int a = -1;
    int b = 7;
}
```

For axiomatic oracles, we use JavaParser to insert assertions wherever possible, yielding the following test suite,

```agsl
void sumTest() {
    int a = 2;
    assert a != null;  // first method argument must not be null
    int b = 5;
    assert sum(a, b) != null;  // method output must not be null
}

void sumNegativeTest() {
    int a = -1;
    assert a != null;  // first method argument must not be null
    int b = 7;
    sum(a, b) != null;  // method output must not be null
}
```

Consequently, each test case may have multiple oracles, and each oracle may be used more than once. Therefore, the number of oracles may not equal the number of prefixes.

#### Non-Axiomatic

If the oracles are non-axiomatic, meaning they correspond to a test prefix, then we simply insert the oracle into its corresponding test prefix. In contrast to the axiomatic oracles, each test case contains precisely one oracle, and each oracle is used exactly once. Therefore, we will have an equal number of oracles and prefixes.

### Analysis

We use the generated tests in `experiment/output/tog-test/[tog]/` and report statistics using `TestAnalyzer.java`. The class `TestAnalyzer.java` computes the mutation score using PITest, and invokes each test case to determine the number of positive/negative samples by the number of failing/passing tests, respectively.

## Output

We save the output as a JSON file. The output follows the format,

```json lines
{
  "tog": "tratto",
  "source": "path/to/source/File.java",
  "positive": 10,
  "negative": 24,
  "mutation-score": 85.42,
  "tests": [
    {
      "class": "File",
      "methodSignature": "sum(int a, int b)",
      "isPositive": false,
      "test": "int a = 2;\nassert a != null; ..."
    },
    ...,
    {
      "class": "File",
      "methodSignature": "sum(int a, int b)",
      "isPositive": false,
      "test": "int a = -1;\nassert != null; ..."
    }
  ]
}
```

We report the TOG, the source path, the number of failing tests (positive), the number of passing test (negative), the mutation score, and information for each test case. For each test case, we report the class under test, the method under test, whether the test passes or fails (`isPositive` is `true` if the test fails), and the test case as a String (see `TestOutput.java` for further detail).

## Related Resources

[`TestAnalyzer` and `TestUtils` README.md](./src/README.md): Further description of how test suites are modified and analyzed

[`generator` README.md](./generator/README.md): Brief descriptions of each shell script involved with generating EvoSuite tests and TOG oracles. 

