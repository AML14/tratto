# Experiment

## Overview

This module experimentally evaluates a test oracle generator (TOG).

A unit test is composed of two parts: **the prefix** and **the oracle**.

```java
// prefix
int a = 5;
int b = 1;
// oracle
assert sum(a, b) == (a + b)
```

 * To generate test prefixes, see ["Prefix"](#Prefix) below.
 * For each test prefix, we generate new oracles/assertion using a TOG.
 * We use [PITest](https://pitest.org/) to report mutation score of the generated tests, and also record the number of positive/negative (failing/passing) test cases.

To analyze a TOG, run
```
experiment.sh [tog] [target-class] [source-dir] [bin-dir]
```

For example,
```
experiment.sh tratto example.Stack ../path/to/src ../path/to/target/classes
```

## Research Questions

An "axiomatic" oracle does not depend on specific input values or test prefixes.  For example, `methodResult != null` or `methodResult > formalParameter`.
An example of a non-axiomatic oracle is `sum(5, 1) == 6`.

Our experimental analysis addresses the following research questions:

1. What is the effectiveness (precision and FPR) of Tratto for generating axiomatic oracles?
2. How does Tratto enhance test suites when combined with tools such as EvoSuite or Randoop in terms of bug-finding ability and mutation score?
3. Is Tratto able to recreate all (or more) axiomatic oracles generated by JDoctor? Is Tratto able to synthesize all oracles (and fix incorrect oracles) generated by TOGA?

[comment]: <> (4. How does Tratto compare with ChatGPT for axiomatic oracle generation?)

## Metrics

To answer the above research questions, we perform two experiments: [Classification](#classification) (RQ 1, 3) and [Mutation](#mutation) (RQ 2).

### Classification

We say an oracle <span style="color:red">"fails"</span> the code if its corresponding test assertion fails using the current implementation.
We say an oracle <span style="color:green">"passes"</span> the specification if the assertion *should* pass according to the specification.

|                     | Code                                  | Specification                         |
|---------------------|---------------------------------------|---------------------------------------|
| True Positive (TP)  | <span style="color:red">Fail</span>   | <span style="color:green">Pass</span> |
| False Positive (FP) | <span style="color:red">Fail</span>   | <span style="color:red">Fail</span>   |
| True Negative (TN)  | <span style="color:green">Pass</span> | <span style="color:green">Pass</span> |
| False Negative (FN) | <span style="color:green">Pass</span> | <span style="color:red">Fail</span>   |

As an example, consider the following (buggy) code snippet:

```java
/**
 * @param a an integer
 * @param b an integer
 * @returns the sum of the two integer values
 */
int sum(int a, int b) {
    return a - b;
}
```

Here is an example of each class of oracle:
- True Positive: `sum(a, b) == (a + b)`
- False Positive: `sum(a, b) == null`
- True Negative: `sum(a, b) != null`
- False Negative: `sum(a, b) == (a - b)`

Intuitively, we hope to maximize True Positives and True Negatives, and minimize False Positives and False Negatives. This corresponds to a high precision and a low FPR.

### Mutation

Mutation score is a proxy for the quality of the generated oracles, in terms of their effectiveness in alarming about incorrect code or their sensitivity to changes in source code.
The oracle `sum(a, b) == (a + b)` has a higher mutatation score than `sum(a, b) != null`.

## Implementation

The user provides, as input, the TOG and the source path.

Here is the experimental pipeline:

![experiment pipeline](./doc/experiment-pipeline.png)

We provide a brief description of the relevant files:

- `generator`: this package contains scripts for generating test prefixes and test oracles
  - `evosuite.sh`: a script that invokes EvoSuite for a given source file
  - `jdoctor.sh`: a script that invokes JDoctor for a given source file
  - `tog.sh`: invokes a TOG such as TOGA or Tratto
- `src/main/java`: this package contains all Java functionality, including mutation testing, file IO, JavaParser utilities, etc.
  - `FileUtils.java`: a class with all necessary utilities to read and write to files
  - `TestAnalyzer.java`: a class for reporting the statistics of a test suite. Includes the number of passing/failing tests and mutation score.
  - `TestUtils.java`: a class for test suite utilities, such as removing/adding assertions
  - `TestOutput.java`: a record for storing a test case and its contextual information
- `experiment.sh`: the end-to-end script which performs the experiment

### Prefix

EvoSuite (which is run via `evosuite.sh`) generates complete unit tests (including the oracle) in `experiment/output/evosuite-tests/`.

`TestUtils.java` removes the oracles (assertions) using [JavaParser](https://javaparser.org/).

The test prefixes are saved as separate files in `experiment/output/evosuite-prefixes/`.

### Oracle insertion

Each TOG has a corresponding script invoking the TOG (as a jar file).
The EvoSuite prefixes are an optional input to the TOG.

Then `TestUtils.java` inserts the new oracles, using JavaParser, as assertions in the test prefixes.

The new tests are saved as separate files in `experiment/output/tog-test/[tog]/`, where `[tog]` is the given TOG.

#### Axiomatic oracle insertion

If the oracles are axiomatic, then we insert the oracles wherever they are applicable. Consider the following oracles for the aforementioned `sum` example method: `sum(a, b) != null` and `a != null`. We may interpret these oracles as "method output must not be null" and "first method argument must not be null". Consequently, we should add the assertions after every appearance of the method output or first method argument, respectively. Consider the following test prefixes generated by EvoSuite.

```java
void sumTest() {
    int a = 2;
    int b = 5;
}

void sumNegativeTest() {
    int a = -1;
    int b = 7;
}
```

For axiomatic oracles, we use JavaParser to insert assertions wherever possible, yielding the following test suite,

```java
void sumTest() {
    int a = 2;
    assert a != null;  // first method argument must not be null
    int b = 5;
    assert sum(a, b) != null;  // method output must not be null
}

void sumNegativeTest() {
    int a = -1;
    assert a != null;  // first method argument must not be null
    int b = 7;
    sum(a, b) != null;  // method output must not be null
}
```

Consequently, each test case may have multiple oracles, and each oracle may be used more than once. Therefore, the number of oracles may not equal the number of prefixes.

#### Non-Axiomatic oracle insertion

If the oracles are non-axiomatic, meaning they correspond to a test prefix, then we simply insert the oracle into its corresponding test prefix. In contrast to the axiomatic oracles, each test case contains precisely one oracle, and each oracle is used exactly once. Therefore, we will have an equal number of oracles and prefixes.

### Analysis

We use the generated tests in `experiment/output/tog-test/[tog]/` and report statistics using `TestAnalyzer.java`. The class `TestAnalyzer.java` computes the mutation score using PITest, and invokes each test case to determine the number of positive/negative samples by the number of failing/passing tests, respectively.

## Output

We save the output as a JSON file. The output follows the format,

```json lines
{
  "tog": "tratto",
  "source": "path/to/source/File.java",
  "positive": 10,
  "negative": 24,
  "mutation-score": 85.42,
  "tests": [
    {
      "class": "File",
      "methodSignature": "sum(int a, int b)",
      "isPositive": false,
      "test": "int a = 2;\nassert a != null; ..."
    },
    ...,
    {
      "class": "File",
      "methodSignature": "sum(int a, int b)",
      "isPositive": false,
      "test": "int a = -1;\nassert != null; ..."
    }
  ]
}
```

- "positive" is the number of failing tests
- "negative" is the number of passing tests
- "isPositive" is `true` if the test fails
