# Experiment

This module has all scripts necessary to reproduce the experimental results described in the paper "Tratto: A Neuro-Symbolic Approach to Deriving Axiomatic Test Oracles".

[//]: # (Add link to paper when available)

# 1. Setup

Set environment variable `JAVA8_HOME` to the `JAVA_HOME` for a JDK 8 installation.
(Rationale: EvoSuite and JDoctor are written in Java 8.)

Set up [Git Large File Storage (Git LFS)](https://git-lfs.com/).
(Rationale: Toga uses Git LFS.)

Toga and Tratto use Python.  A package management system, such as conda, is recommended (but not required) to create an isolated environment to run the Toga experiments (and debug any potential errors). See the [Miniconda homepage](https://docs.conda.io/projects/miniconda/en/latest/) for setup instructions.

To set up JDoctor, visit the [ToRaDoCu](https://github.com/albertogoffi/toradocu) GitHub page, and follow the setup
instructions to build the `toradocu-1.0-all.jar` file (may take a few minutes). Then, move the jar file to the `./generator/resources` directory.


# 2. Overview

This module automates the experimental analysis of a test oracle generator (TOG) for the task of automated test generation.

A unit test is composed of two parts: **the prefix** and **the oracle**.

```java
public class Example {
    public void exampleTest() {
        // prefix
        int a = 5;
        int b = 1;
        // oracle
        assertTrue(sum(a, b) == (a + b));
    }
}
```

To generate test prefixes, we use [EvoSuite](https://www.evosuite.org/), which generates complete unit tests (including oracles), and removes the generated oracles (assertions) using [JavaParser](https://javaparser.org/). Then, we generate new oracles using an arbitrary TOG, and add these assertions to the test prefixes. Finally, we run the tests using EvoSuite and record the number of passing/failing tests. Additionally, we use [Defects4J](https://github.com/rjust/defects4j) to compute the precision and FPR of a TOG. 

As a running example, we consider the following toy method:
```java
public class Example {
    /**
     * @param a an integer
     * @param b an integer
     * @return the sum of the two integer values
     */
    int sum(int a, int b) {
        return a - b;
    }
}
```

## 2.1. Research Questions

As a precursor, we define an "axiomatic" oracle, as a self-evident and unquestionable oracle (e.g. `methodResult != null`). Axiomatic oracles are very general and not specific to individual test prefixes. An example of a non-axiomatic oracle is `sum(5, 1) == 6`.

In our experimental analysis, we seek to answer the following research questions:

1. What is the effectiveness (precision and FPR) of Tratto for generating axiomatic oracles?
2. How does Tratto enhance test suites when combined with tools such as EvoSuite or Randoop in terms of bug-finding ability and mutation score?
3. Is Tratto able to recreate all (or more) axiomatic oracles generated by JDoctor? Is Tratto able to synthesize all oracles (and fix incorrect oracles) generated by TOGA?

[comment]: <> (4. How does Tratto compare with ChatGPT for axiomatic oracle generation?)

## 2.2. Experimental Pipeline

For reference, we provide a simplified graphic of the experimental pipeline:

![experiment pipeline](./doc/experiment-pipeline.png)

and a brief description of the relevant files:

- `defects4j`: this directory contains python scripts for running the Defects4J analysis
  - `defects4j.py`: a script that analyzes all bugs in all projects of Defects4J
  - `setup.py`: a script that sets up a Defects4J project bug for analysis 
- `generator`: this directory contains scripts for generating test prefixes and test oracles
  - `evosuite.sh`: a script that creates a test suite using EvoSuite for a given class
  - `jdoctor.sh`: a script that creates oracles using JDoctor
  - `toga.sh`: a script that creates oracles using TOGA
  - `tratto.sh`: a script that creates oracles using Tratto
- `src/main/java`: this directory contains all Java functionality for the end-to-end experimental pipeline
  - `data`: a package with records for representing input and output
  - `FileUtils.java`: a class with all necessary utilities to read, write, and move files
  - `TestUtils.java`: a class for test suite utilities, such as removing/inserting oracles
  - `Tog.java`: the main file for the `experiment.jar` build
  - `TogUtils.java`: a class for tog utilities, such as preprocessing input and postprocessing output
- `experiment.sh`: the end-to-end script which performs the experiment
- `runner.sh`: a script that compiles and runs a test suite

Note that in the previous diagram, the script `tog.sh` is a placeholder for the user-specified tog (e.g. `jdoctor.sh`, `toga.sh`, `tratto.sh`).

### 2.2.1. Prefix

We run `evosuite.sh` to generate a test suite using EvoSuite. These full test cases include both the test prefix and the test oracle, and are saved in `experiment/output/evosuite-tests/`. The EvoSuite tests are split such that each test contains exactly one assertion per test. These single-assertion tests are saved in `experiment/output/evosuite-simple-tests`. Then, we remove the oracles (assertions) and save the test prefixes in `experiment/output/evosuite-prefixes`. If an original EvoSuite test has 4 assertions, then we create 4 corresponding simple tests, and 4 test prefixes.

### 2.2.2. Oracle

After creating test prefixes, we generate oracles using each supported TOG: `jdoctor`, `toga`, and `tratto`. Each TOG has a corresponding script invoking the TOG (as a JAR or python script). Then, the new oracles are inserted into the test prefixes as assertions. The new tests are saved as separate files in `experiment/output/tog-tests/[tog]`.

Our method for inserting oracles varies based on whether the TOG generates [axiomatic](#a-axiomatic) or [non-axiomatic](#b-non-axiomatic) oracles.

#### A. Axiomatic

If the oracles are axiomatic, then we insert the oracles wherever they are applicable. Consider the following oracles for the
aforementioned `sum` example method: `sum(a, b) != null` and `a != null`. We may interpret these oracles as "method
output must not be null" and "first method argument must not be null". Consequently, we should add the assertions after
every appearance of the method output or first method argument, respectively. 

Consider the following test prefixes
generated by EvoSuite.

```java
public class ExampleTest {
    void sumTest() {
        int a = 2;
        int b = 5;
    }

    void sumNegativeTest() {
        int a = -1;
        int b = 7;
    }
}
```

After inserting the example axiomatic oracles, we get the following test suite,

```java
public class ExampleTest {
    void sumTest() {
        int a = 2;
        // first method argument must not be null
        assertTrue(a != null);
        int b = 5;
        // method output must not be null
        assertTrue(sum(a, b) != null);
    }

    void sumNegativeTest() {
        int a = -1;
        // first method argument must not be null
        assertTrue(a != null);
        int b = 7;
        // method output must not be null
        assertTrue(sum(a, b) != null);
    }
}
```

For simplicity, all axiomatic oracles are inserted as `assertTrue` method calls.

Consequently, each test case may have multiple oracles, and each oracle may be used more than once. Therefore, the number
of oracles may not equal the number of prefixes.

#### B. Non-Axiomatic

If the oracles are non-axiomatic, meaning that they correspond to a test prefix, then we simply insert the oracle into its
corresponding test prefix. In contrast to the axiomatic oracles, each test case contains at most one oracle (the TOG may be unable to generate an oracle for a given prefix), and each
oracle is used exactly once.

## 2.3. Metrics

We use Defects4J to evaluate the precision and FPR of a TOG. Defects4J is a database of real-world buggy Java projects, with corresponding single-commit fixes. We use the test suite generated by a TOG (with prefixes from EvoSuite) and classify each test as a True Positive, False Positive, True Negative, or False Negative. A test is considered "Positive" (uncovers a bug) if it <span style="color:red">fails</span> on the buggy implementation and "Negative" (does not uncover a bug) if it <span style="color:green">passes</span> on the buggy implementation. Similarly, a test is considered "False" (incorrectly uncovered bug) if it <span style="color:red">fails</span> on the fixed implementation and "True" (correctly uncovered bug) if it <span style="color:green">passes</span> on the fixed implementation.

|                     | Buggy                                 | Fixed                                 |
|---------------------|---------------------------------------|---------------------------------------|
| True Positive (TP)  | <span style="color:red">Fail</span>   | <span style="color:green">Pass</span> |
| False Positive (FP) | <span style="color:red">Fail</span>   | <span style="color:red">Fail</span>   |
| True Negative (TN)  | <span style="color:green">Pass</span> | <span style="color:green">Pass</span> |
| False Negative (FN) | <span style="color:green">Pass</span> | <span style="color:red">Fail</span>   |

For clarification, consider the following (buggy) code snippet:

We provide an example of each class of oracle below:
- True Positive: `sum(a, b) == (a + b)`
- False Positive: `sum(a, b) == null`
- True Negative: `sum(a, b) != null`
- False Negative: `sum(a, b) == (a - b)`

Intuitively, we hope to maximize True Positives and True Negatives, and minimize False Positives and False Negatives.
This corresponds to a high precision and a low FPR.


## 2.4. Output

We store three primary output records: [OracleOutput](#241-OracleOutput), [TestOutput](#242-testoutput), and [Defects4JOutput](#243-defects4joutput). All outputs generated during the experimental pipeline are saved in the `experiment/output` directory. This directory has various subdirectories, including:

- `output`:
  - `evosuite-tests`: a test suite generated by EvoSuite
  - `evosuite-simple-tests`: the test suite generated by EvoSuite, with each test split to have one assertion
  - `evosuite-prefixes`: the EvoSuite simple tests with all assertions and try/catch blocks removed
  - `[tog]`: a tog-specific directory for various intermediate outputs
    - `input`: pre-processed input to be passed to the tog 
    - `oracle`: the `OracleOutput` generated by a tog
    - `test`: the `TestOutput` generated by a tog
  - `tog-tests`: a test suite generated by each tog (with subdirectories for each tog)
  - `defects4j`: a directory for storing Defects4J experiment output
    - `[tog]`: a directory with all individual `Defects4JOutput` records generated by a tog
    - `[tog].json`: the final combined Defects4J output including all bugs for all projects

### 2.4.1. `OracleOutput`

An `OracleOutput` record corresponds to an oracle generated by a TOG, with the following features:

- `className`: the fully qualified name of the class under test
- `methodSignature`: the method under test
- `oracleType`: the type of oracle generated
  - If axiomatic, could be `PRE`, `NORMAL_POST`, or `EXCEPT_POST`
  - If non-axiomatic, must be `NON_AXIOMATIC`
- `exception`: the type of exception expected (empty string if non-exceptional oracle)
- `testName`: the name of the test corresponding to the oracle (empty string if non-axiomatic oracle)


We provide the following example of such a record,

```json lines
{
  "className": "com.example.MyClass",
  "methodSignature": "myMethod(java.lang.String s)",
  "oracleType": "OracleType.PRE",
  "oracle": "s != null",
  "exception": "",
  "testName": ""
}
```

### 2.4.2. `TestOutput`

A `TestOutput` record corresponds to a test suite generated by a TOG, with the following features:

- `tog`: the TOG that generated the test suite
- `className`: the fully qualified name of the class under test
- `sourceDir`: the source directory of the project under test
- `binDir`: the system binaries of the project under test
- `numPass`: the number of tests that pass
- `numFail`: the number of tests that fail
- `tests`: a list of all test cases generated by the TOG and whether they pass or fail

We provide the following example of such a record,

```json lines
{
  "tog": "jdoctor",
  "className": "com.example.MyClass",
  "sourceDir": "path/to/src",
  "binDir": "path/to/target/classes",
  "numPass": 1,
  "numFail": 1,
  "tests": [
    {
      "testName": "test0",
      "testBody": ...,
      "testResult": "PASS"
    },
    {
      "testName": "test1",
      "testBody": ...,
      "testResult": "FAIL"
    }
  ]
}
```

### 2.4.3. `Defects4JOutput`

A `Defects4JOutput` records corresponds to a summary of all tests generated by a TOG, with the following features:

- `tog`: the TOG that generated the test suite
- `numTruePositive`: the number of True Positive test cases
- `numFalsePositive`: the number of False Positive test cases
- `numTrueNegative`: the number of True Negative test cases
- `numFalseNegative`: the number of False Negative test cases

We provide the following example of such a record,

```json lines
{
  "tog": "tratto",
  "numTruePositive": 253,
  "numFalsePositive": 2,
  "numTrueNegative": 834,
  "numFalseNegative": 0
}
```

# 3. Run the experiments

**NOTE:** Check that all steps in [Section 1](#1-setup) have been complete before running an experiment.

## 3.1. Experiment

To run an experiment on an arbitrary project, run:

```shell
bash experiment.sh [fully-qualified-name] [source-dir] [bin-dir] [project-jar]
```

providing...
1. ...the fully qualified name of the class under test
2. ...the path to the source directory of the project under test
3. ...the path to the system binaries of the project under test
4. ...the path to the project jar

We provide a toy example of a project with a single class (`Stack.java`) in the directory `experiment/src/test/resources/project`. To invoke `experiment.sh` using this project, run,
```shell
bash experiment.sh \
  tutorial.Stack \
  ./src/test/resources/project/src/main/java \
  ./src/test/resources/project/target/classes \
  ./src/test/resources/project/target/Tutorial_Stack-1.0-SNAPSHOT.jar
```

## 3.2. Defects4J

To recreate the Defects4J experiment, run:

```shell
python ./defects4j/defects4j.py
```
