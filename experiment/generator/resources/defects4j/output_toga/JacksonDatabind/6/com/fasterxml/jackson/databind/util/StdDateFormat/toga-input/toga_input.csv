focal_method,test_prefix,docstring
"@Override
public StdDateFormat clone() {
    /* Although there is that much state to share, we do need to
         * orchestrate a bit, mostly since timezones may be changed
         */
    return new StdDateFormat(_timezone, _locale);
}","public void test000() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    StdDateFormat stdDateFormat1 = stdDateFormat0.clone();
    assertNotSame(stdDateFormat1, stdDateFormat0);
}",""
"public StdDateFormat withTimeZone(TimeZone tz) {
    if (tz == null) {
        tz = DEFAULT_TIMEZONE;
    }
    if (tz.equals(_timezone)) {
        return this;
    }
    return new StdDateFormat(tz, _locale);
}","public void test055() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    StdDateFormat stdDateFormat1 = stdDateFormat0.withTimeZone((TimeZone) null);
    assertNotSame(stdDateFormat1, stdDateFormat0);
}","/**
 * Method used for creating a new instance with specified timezone;
 * if no timezone specified, defaults to the default timezone (UTC).
 */"
"public StdDateFormat withTimeZone(TimeZone tz) {
    if (tz == null) {
        tz = DEFAULT_TIMEZONE;
    }
    if (tz.equals(_timezone)) {
        return this;
    }
    return new StdDateFormat(tz, _locale);
}","public void test066() throws Throwable {
    TimeZone timeZone0 = StdDateFormat.getDefaultTimeZone();
    StdDateFormat stdDateFormat0 = new StdDateFormat(timeZone0);
    StdDateFormat stdDateFormat1 = stdDateFormat0.withTimeZone(timeZone0);
    assertSame(stdDateFormat1, stdDateFormat0);
}","/**
 * Method used for creating a new instance with specified timezone;
 * if no timezone specified, defaults to the default timezone (UTC).
 */"
"public StdDateFormat withLocale(Locale loc) {
    if (loc.equals(_locale)) {
        return this;
    }
    return new StdDateFormat(_timezone, loc);
}","public void test077() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    Locale locale0 = Locale.CHINESE;
    StdDateFormat stdDateFormat1 = stdDateFormat0.withLocale(locale0);
    assertNotSame(stdDateFormat1, stdDateFormat0);
}",""
"public StdDateFormat withLocale(Locale loc) {
    if (loc.equals(_locale)) {
        return this;
    }
    return new StdDateFormat(_timezone, loc);
}","public void test088() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    Locale locale0 = Locale.US;
    StdDateFormat stdDateFormat1 = stdDateFormat0.withLocale(locale0);
    assertSame(stdDateFormat1, stdDateFormat0);
}",""
"@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date result = parse(dateStr, pos);
    if (result != null) {
        return result;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test1010() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    try {
        stdDateFormat0.parse(""5925-@T/5DmV\"";-"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Can not parse date \""5925-@T/5DmV\"";-\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date result = parse(dateStr, pos);
    if (result != null) {
        return result;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test1212() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    // Undeclared exception!
    try {
        stdDateFormat0.parse(""-"");
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // For input string: \""-\""
        //
        verifyException(""java.lang.NumberFormatException"", e);
    }
}",""
"@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date result = parse(dateStr, pos);
    if (result != null) {
        return result;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test1313() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    try {
        stdDateFormat0.parse(""WBls:#1akgiqB"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Can not parse date \""WBls:#1akgiqB\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date result = parse(dateStr, pos);
    if (result != null) {
        return result;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test1414() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    try {
        stdDateFormat0.parse("".000"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Can not parse date \"".000\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"/*
    /**********************************************************
    /* Std overrides
    /**********************************************************
     */
@Override
public String toString() {
    String str = ""DateFormat "" + getClass().getName();
    TimeZone tz = _timezone;
    if (tz != null) {
        str += "" (timezone: "" + tz + "")"";
    }
    str += ""(locale: "" + _locale + "")"";
    return str;
}","public void test1616() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    String string0 = stdDateFormat0.instance.toString();
    assertEquals(""DateFormat com.fasterxml.jackson.databind.util.StdDateFormat(locale: en_US)"", string0);
}",""
"@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date result = parse(dateStr, pos);
    if (result != null) {
        return result;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test1717() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    try {
        stdDateFormat0.parse(""1hM_S~:tb("");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Can not parse date \""1hM_S~:tb(\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date result = parse(dateStr, pos);
    if (result != null) {
        return result;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test1818() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    try {
        stdDateFormat0.parse(""2.25073858507202e-08"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Can not parse date \""2.25073858507202e-08\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos) {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""GMT"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * GMT, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    // [JACKSON-200]: need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        if (df == null) {
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
        }
        // [JACKSON-334]: may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            c = dateStr.charAt(len - 9);
            if (Character.isDigit(c)) {
                StringBuilder sb = new StringBuilder(dateStr);
                sb.insert(len - 5, "".000"");
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);
            }
        } else {
            // If not, plain date. Easiest to just patch 'Z' in the end?
            StringBuilder sb = new StringBuilder(dateStr);
            // And possible also millisecond part if missing
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            if (timeLen <= 8) {
                sb.append("".000"");
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            if (df == null) {
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
            }
        }
    }
    return df.parse(dateStr, pos);
}","public void test1919() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    ParsePosition parsePosition0 = new ParsePosition((-2408));
    // Undeclared exception!
    try {
        stdDateFormat0.instance.parseAsISO8601(""4"", parsePosition0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos) {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""GMT"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * GMT, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    // [JACKSON-200]: need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        if (df == null) {
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
        }
        // [JACKSON-334]: may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            c = dateStr.charAt(len - 9);
            if (Character.isDigit(c)) {
                StringBuilder sb = new StringBuilder(dateStr);
                sb.insert(len - 5, "".000"");
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);
            }
        } else {
            // If not, plain date. Easiest to just patch 'Z' in the end?
            StringBuilder sb = new StringBuilder(dateStr);
            // And possible also millisecond part if missing
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            if (timeLen <= 8) {
                sb.append("".000"");
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            if (df == null) {
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
            }
        }
    }
    return df.parse(dateStr, pos);
}","public void test2020() throws Throwable {
    ParsePosition parsePosition0 = new ParsePosition(1722);
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""T+@9:^c"", parsePosition0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos) {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""GMT"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * GMT, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    // [JACKSON-200]: need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        if (df == null) {
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
        }
        // [JACKSON-334]: may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            c = dateStr.charAt(len - 9);
            if (Character.isDigit(c)) {
                StringBuilder sb = new StringBuilder(dateStr);
                sb.insert(len - 5, "".000"");
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);
            }
        } else {
            // If not, plain date. Easiest to just patch 'Z' in the end?
            StringBuilder sb = new StringBuilder(dateStr);
            // And possible also millisecond part if missing
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            if (timeLen <= 8) {
                sb.append("".000"");
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            if (df == null) {
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
            }
        }
    }
    return df.parse(dateStr, pos);
}","public void test2121() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    ParsePosition parsePosition0 = new ParsePosition(18);
    Date date0 = stdDateFormat0.parseAsISO8601(""j7N\""O2Vs`: 9pMZ"", parsePosition0);
    assertNull(date0);
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos) {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""GMT"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * GMT, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    // [JACKSON-200]: need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        if (df == null) {
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
        }
        // [JACKSON-334]: may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            c = dateStr.charAt(len - 9);
            if (Character.isDigit(c)) {
                StringBuilder sb = new StringBuilder(dateStr);
                sb.insert(len - 5, "".000"");
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);
            }
        } else {
            // If not, plain date. Easiest to just patch 'Z' in the end?
            StringBuilder sb = new StringBuilder(dateStr);
            // And possible also millisecond part if missing
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            if (timeLen <= 8) {
                sb.append("".000"");
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            if (df == null) {
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
            }
        }
    }
    return df.parse(dateStr, pos);
}","public void test2222() throws Throwable {
    ParsePosition parsePosition0 = new ParsePosition(1959);
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    Date date0 = stdDateFormat0.parseAsISO8601(""j7N\""O*Rs`: MZ"", parsePosition0);
    assertNull(date0);
}",""
"@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date result = parse(dateStr, pos);
    if (result != null) {
        return result;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test2323() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    try {
        stdDateFormat0.parse(""5925-T/5mU-V\""S-"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Can not parse date \""5925-T/5mU-V\""S-\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos) {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""GMT"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * GMT, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    // [JACKSON-200]: need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        if (df == null) {
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
        }
        // [JACKSON-334]: may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            c = dateStr.charAt(len - 9);
            if (Character.isDigit(c)) {
                StringBuilder sb = new StringBuilder(dateStr);
                sb.insert(len - 5, "".000"");
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);
            }
        } else {
            // If not, plain date. Easiest to just patch 'Z' in the end?
            StringBuilder sb = new StringBuilder(dateStr);
            // And possible also millisecond part if missing
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            if (timeLen <= 8) {
                sb.append("".000"");
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            if (df == null) {
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
            }
        }
    }
    return df.parse(dateStr, pos);
}","public void test2424() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    ParsePosition parsePosition0 = new ParsePosition((-1241));
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""tqmBfIRC}5\"" IQu+zx"", parsePosition0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos) {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""GMT"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * GMT, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    // [JACKSON-200]: need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        if (df == null) {
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
        }
        // [JACKSON-334]: may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            c = dateStr.charAt(len - 9);
            if (Character.isDigit(c)) {
                StringBuilder sb = new StringBuilder(dateStr);
                sb.insert(len - 5, "".000"");
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);
            }
        } else {
            // If not, plain date. Easiest to just patch 'Z' in the end?
            StringBuilder sb = new StringBuilder(dateStr);
            // And possible also millisecond part if missing
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            if (timeLen <= 8) {
                sb.append("".000"");
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            if (df == null) {
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
            }
        }
    }
    return df.parse(dateStr, pos);
}","public void test2525() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""2.25073858507202e-08"", (ParsePosition) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date result = parse(dateStr, pos);
    if (result != null) {
        return result;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test2626() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    try {
        stdDateFormat0.parse(""5925-T/5mV\""S-"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Can not parse date \""5925-T/5mV\""S-\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos) {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""GMT"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * GMT, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    // [JACKSON-200]: need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        if (df == null) {
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
        }
        // [JACKSON-334]: may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            c = dateStr.charAt(len - 9);
            if (Character.isDigit(c)) {
                StringBuilder sb = new StringBuilder(dateStr);
                sb.insert(len - 5, "".000"");
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);
            }
        } else {
            // If not, plain date. Easiest to just patch 'Z' in the end?
            StringBuilder sb = new StringBuilder(dateStr);
            // And possible also millisecond part if missing
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            if (timeLen <= 8) {
                sb.append("".000"");
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            if (df == null) {
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
            }
        }
    }
    return df.parse(dateStr, pos);
}","public void test2727() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""#'/ta"", (ParsePosition) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos) {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""GMT"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * GMT, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    // [JACKSON-200]: need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        if (df == null) {
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
        }
        // [JACKSON-334]: may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            c = dateStr.charAt(len - 9);
            if (Character.isDigit(c)) {
                StringBuilder sb = new StringBuilder(dateStr);
                sb.insert(len - 5, "".000"");
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);
            }
        } else {
            // If not, plain date. Easiest to just patch 'Z' in the end?
            StringBuilder sb = new StringBuilder(dateStr);
            // And possible also millisecond part if missing
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            if (timeLen <= 8) {
                sb.append("".000"");
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            if (df == null) {
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
            }
        }
    }
    return df.parse(dateStr, pos);
}","public void test2828() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    ParsePosition parsePosition0 = new ParsePosition(18);
    Date date0 = stdDateFormat0.parseAsISO8601(""qM-k)nY~Jibri+F|\"""", parsePosition0);
    assertNull(date0);
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos) {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""GMT"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * GMT, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    // [JACKSON-200]: need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        if (df == null) {
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
        }
        // [JACKSON-334]: may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            c = dateStr.charAt(len - 9);
            if (Character.isDigit(c)) {
                StringBuilder sb = new StringBuilder(dateStr);
                sb.insert(len - 5, "".000"");
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);
            }
        } else {
            // If not, plain date. Easiest to just patch 'Z' in the end?
            StringBuilder sb = new StringBuilder(dateStr);
            // And possible also millisecond part if missing
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            if (timeLen <= 8) {
                sb.append("".000"");
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            if (df == null) {
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);
            }
        }
    }
    return df.parse(dateStr, pos);
}","public void test2929() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""4>J?2-NrF="", (ParsePosition) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
