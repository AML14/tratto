focal_method,test_prefix,docstring
"@Override
public SerializerFactory withConfig(SerializerFactoryConfig config) {
    if (_factoryConfig == config) {
        return this;
    }
    /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;
         *    and we pretty much have to here either choose between losing subtype instance
         *    when registering additional serializers, or losing serializers.
         *    Instead, let's actually just throw an error if this method is called when subtype
         *    has not properly overridden this method; this to indicate problem as soon as possible.
         */
    if (getClass() != BeanSerializerFactory.class) {
        throw new IllegalStateException(""Subtype of BeanSerializerFactory ("" + getClass().getName() + "") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with "" + ""additional serializer definitions"");
    }
    return new BeanSerializerFactory(config);
}","public void test000() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    SerializerFactory serializerFactory0 = beanSerializerFactory0.withConfig((SerializerFactoryConfig) null);
    assertNotSame(serializerFactory0, beanSerializerFactory0);
}","/**
 * Method used by module registration functionality, to attach additional
 * serializer providers into this serializer factory. This is typically
 * handled by constructing a new instance with additional serializers,
 * to ensure thread-safe access.
 */"
"@SuppressWarnings(""resource"")
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {
    ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());
    try {
        _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);
    } catch (JsonProcessingException e) {
        // to support [JACKSON-758]
        throw e;
    } catch (IOException e) {
        // shouldn't really happen, but is declared as possibility so:
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    byte[] result = bb.toByteArray();
    bb.release();
    return result;
}","public void test011() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    // Undeclared exception!
    try {
        objectMapper0.writeValueAsBytes(objectMapper0);
        fail(""Expecting exception: NoClassDefFoundError"");
    } catch (NoClassDefFoundError e) {
        //
        // Could not initialize class com.fasterxml.jackson.databind.JsonMappingException
        //
        verifyException(""com.fasterxml.jackson.databind.ser.std.BeanSerializerBase"", e);
    }
}","/**
 *  Method that can be used to serialize any Java value as
 *  a byte array. Functionally equivalent to calling
 *  {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}
 *  and getting bytes, but more efficient.
 *  Encoding used will be UTF-8.
 * <p>
 *  Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
 */"
"protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews) {
    return FilteredBeanPropertyWriter.constructViewBased(writer, inViews);
}","public void test022() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    Class<BeanSerializerFactory>[] classArray0 = (Class<BeanSerializerFactory>[]) Array.newInstance(Class.class, 0);
    // Undeclared exception!
    try {
        beanSerializerFactory0.instance.constructFilteredBeanWriter((BeanPropertyWriter) null, classArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.BeanPropertyWriter"", e);
    }
}","/**
 * Method called to construct a filtered writer, for given view
 * definitions. Default implementation constructs filter that checks
 * active view type to views property is to be included in.
 */"
"@Override
public SerializerFactory withConfig(SerializerFactoryConfig config) {
    if (_factoryConfig == config) {
        return this;
    }
    /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;
         *    and we pretty much have to here either choose between losing subtype instance
         *    when registering additional serializers, or losing serializers.
         *    Instead, let's actually just throw an error if this method is called when subtype
         *    has not properly overridden this method; this to indicate problem as soon as possible.
         */
    if (getClass() != BeanSerializerFactory.class) {
        throw new IllegalStateException(""Subtype of BeanSerializerFactory ("" + getClass().getName() + "") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with "" + ""additional serializer definitions"");
    }
    return new BeanSerializerFactory(config);
}","public void test033() throws Throwable {
    SerializerFactoryConfig serializerFactoryConfig0 = new SerializerFactoryConfig();
    BeanSerializerFactory beanSerializerFactory0 = new BeanSerializerFactory(serializerFactoryConfig0);
    SerializerFactory serializerFactory0 = beanSerializerFactory0.withConfig(serializerFactoryConfig0);
    assertSame(serializerFactory0, beanSerializerFactory0);
}","/**
 * Method used by module registration functionality, to attach additional
 * serializer providers into this serializer factory. This is typically
 * handled by constructing a new instance with additional serializers,
 * to ensure thread-safe access.
 */"
"@SuppressWarnings(""resource"")
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {
    ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());
    try {
        _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);
    } catch (JsonProcessingException e) {
        // to support [JACKSON-758]
        throw e;
    } catch (IOException e) {
        // shouldn't really happen, but is declared as possibility so:
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    byte[] result = bb.toByteArray();
    bb.release();
    return result;
}","public void test044() throws Throwable {
    Class<String> class0 = String.class;
    SimpleType simpleType0 = SimpleType.construct(class0);
    ObjectMapper objectMapper0 = new ObjectMapper();
    byte[] byteArray0 = objectMapper0.writeValueAsBytes(simpleType0);
    assertEquals(18, byteArray0.length);
}","/**
 *  Method that can be used to serialize any Java value as
 *  a byte array. Functionally equivalent to calling
 *  {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}
 *  and getting bytes, but more efficient.
 *  Encoding used will be UTF-8.
 * <p>
 *  Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
 */"
"protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {
    // Then JsonSerializable, @JsonValue etc:
    JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);
    if (ser != null) {
        return ser;
    }
    final SerializationConfig config = prov.getConfig();
    // Container types differ from non-container types
    // (note: called method checks for module-provided serializers)
    if (type.isContainerType()) {
        if (!staticTyping) {
            staticTyping = usesStaticTyping(config, beanDesc, null);
            // [Issue#23]: Need to figure out how to force passed parameterization
            //  to stick...
            /*
                if (property == null) {
                    JavaType t = origType.getContentType();
                    if (t != null && !t.hasRawClass(Object.class)) {
                        staticTyping = true;
                    }
                }
                */
        }
        // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...
        ser = buildContainerSerializer(prov, type, beanDesc, staticTyping);
        // Will return right away, since called method does post-processing:
        if (ser != null) {
            return ser;
        }
    } else {
        // Modules may provide serializers of POJO types:
        for (Serializers serializers : customSerializers()) {
            ser = serializers.findSerializer(config, type, beanDesc);
            if (ser != null) {
                break;
            }
        }
    }
    // Otherwise, we will check ""primary types""; both marker types that
    // indicate specific handling (JsonSerializable), or main types that have
    // precedence over container types
    if (ser == null) {
        ser = findSerializerByLookup(type, config, beanDesc, staticTyping);
        if (ser == null) {
            ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);
            if (ser == null) {
                // And this is where this class comes in: if type is not a
                // known ""primary JDK type"", perhaps it's a bean? We can still
                // get a null, if we can't find a single suitable bean property.
                ser = findBeanSerializer(prov, type, beanDesc);
                // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?
                if (ser == null) {
                    ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);
                    // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get
                    //   'unknown' serializer assigned earlier, here, so that it gets properly
                    //   post-processed
                    if (ser == null) {
                        ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());
                    }
                }
            }
        }
    }
    if (ser != null) {
        // [Issue#120]: Allow post-processing
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                ser = mod.modifySerializer(config, beanDesc, ser);
            }
        }
    }
    return ser;
}","public void test055() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<HashMap> class0 = HashMap.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class0);
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedMethod) null).when(pOJOPropertiesCollector0).getAnySetterMethod();
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((Set) null).when(pOJOPropertiesCollector0).getIgnoredPropertyNames();
    doReturn((Map) null).when(pOJOPropertiesCollector0).getInjectables();
    doReturn((AnnotatedMethod) null).when(pOJOPropertiesCollector0).getJsonValueMethod();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((List) null).when(pOJOPropertiesCollector0).getProperties();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    // Undeclared exception!
    try {
        beanSerializerFactory0._createSerializer2(defaultSerializerProvider_Impl0, mapType0, basicBeanDescription0, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.BasicSerializerFactory"", e);
    }
}",""
"protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {
    // Then JsonSerializable, @JsonValue etc:
    JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);
    if (ser != null) {
        return ser;
    }
    final SerializationConfig config = prov.getConfig();
    // Container types differ from non-container types
    // (note: called method checks for module-provided serializers)
    if (type.isContainerType()) {
        if (!staticTyping) {
            staticTyping = usesStaticTyping(config, beanDesc, null);
            // [Issue#23]: Need to figure out how to force passed parameterization
            //  to stick...
            /*
                if (property == null) {
                    JavaType t = origType.getContentType();
                    if (t != null && !t.hasRawClass(Object.class)) {
                        staticTyping = true;
                    }
                }
                */
        }
        // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...
        ser = buildContainerSerializer(prov, type, beanDesc, staticTyping);
        // Will return right away, since called method does post-processing:
        if (ser != null) {
            return ser;
        }
    } else {
        // Modules may provide serializers of POJO types:
        for (Serializers serializers : customSerializers()) {
            ser = serializers.findSerializer(config, type, beanDesc);
            if (ser != null) {
                break;
            }
        }
    }
    // Otherwise, we will check ""primary types""; both marker types that
    // indicate specific handling (JsonSerializable), or main types that have
    // precedence over container types
    if (ser == null) {
        ser = findSerializerByLookup(type, config, beanDesc, staticTyping);
        if (ser == null) {
            ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);
            if (ser == null) {
                // And this is where this class comes in: if type is not a
                // known ""primary JDK type"", perhaps it's a bean? We can still
                // get a null, if we can't find a single suitable bean property.
                ser = findBeanSerializer(prov, type, beanDesc);
                // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?
                if (ser == null) {
                    ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);
                    // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get
                    //   'unknown' serializer assigned earlier, here, so that it gets properly
                    //   post-processed
                    if (ser == null) {
                        ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());
                    }
                }
            }
        }
    }
    if (ser != null) {
        // [Issue#120]: Allow post-processing
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                ser = mod.modifySerializer(config, beanDesc, ser);
            }
        }
    }
    return ser;
}","public void test066() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<HashMap> class0 = HashMap.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class0);
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedMethod) null).when(pOJOPropertiesCollector0).getAnySetterMethod();
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((Set) null).when(pOJOPropertiesCollector0).getIgnoredPropertyNames();
    doReturn((Map) null).when(pOJOPropertiesCollector0).getInjectables();
    doReturn((AnnotatedMethod) null).when(pOJOPropertiesCollector0).getJsonValueMethod();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((List) null).when(pOJOPropertiesCollector0).getProperties();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    // Undeclared exception!
    try {
        beanSerializerFactory0._createSerializer2(defaultSerializerProvider_Impl0, mapType0, basicBeanDescription0, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.BasicSerializerFactory"", e);
    }
}",""
"public boolean usesObjectId() {
    return false;
}","public void test077() throws Throwable {
    Class<String> class0 = String.class;
    SimpleType simpleType0 = SimpleType.construct(class0);
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedMethod) null).when(pOJOPropertiesCollector0).getAnySetterMethod();
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((Set) null).when(pOJOPropertiesCollector0).getIgnoredPropertyNames();
    doReturn((Map) null).when(pOJOPropertiesCollector0).getInjectables();
    doReturn((AnnotatedMethod) null).when(pOJOPropertiesCollector0).getJsonValueMethod();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((List) null).when(pOJOPropertiesCollector0).getProperties();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    SerializerFactoryConfig serializerFactoryConfig0 = new SerializerFactoryConfig();
    SimpleSerializers simpleSerializers0 = new SimpleSerializers();
    SerializerFactoryConfig serializerFactoryConfig1 = serializerFactoryConfig0.withAdditionalSerializers(simpleSerializers0);
    BeanSerializerFactory beanSerializerFactory0 = new BeanSerializerFactory(serializerFactoryConfig1);
    JsonSerializer<?> jsonSerializer0 = beanSerializerFactory0._createSerializer2(defaultSerializerProvider_Impl0, simpleType0, basicBeanDescription0, true);
    assertFalse(jsonSerializer0.usesObjectId());
}","/**
 * Method that can be called to see whether this serializer instance
 * will use Object Id to handle cyclic references.
 */"
"@SuppressWarnings(""resource"")
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {
    ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());
    try {
        _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);
    } catch (JsonProcessingException e) {
        // to support [JACKSON-758]
        throw e;
    } catch (IOException e) {
        // shouldn't really happen, but is declared as possibility so:
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    byte[] result = bb.toByteArray();
    bb.release();
    return result;
}","public void test088() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS;
    byte[] byteArray0 = objectMapper0.writeValueAsBytes(serializationFeature0);
    assertEquals(31, byteArray0.length);
}","/**
 *  Method that can be used to serialize any Java value as
 *  a byte array. Functionally equivalent to calling
 *  {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}
 *  and getting bytes, but more efficient.
 *  Encoding used will be UTF-8.
 * <p>
 *  Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
 */"
"@SuppressWarnings(""resource"")
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {
    ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());
    try {
        _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);
    } catch (JsonProcessingException e) {
        // to support [JACKSON-758]
        throw e;
    } catch (IOException e) {
        // shouldn't really happen, but is declared as possibility so:
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    byte[] result = bb.toByteArray();
    bb.release();
    return result;
}","public void test099() throws Throwable {
    SerializerFactoryConfig serializerFactoryConfig0 = new SerializerFactoryConfig();
    Iterable<Serializers> iterable0 = serializerFactoryConfig0.keySerializers();
    ObjectMapper objectMapper0 = new ObjectMapper();
    byte[] byteArray0 = objectMapper0.writeValueAsBytes(iterable0);
    assertEquals(2, byteArray0.length);
}","/**
 *  Method that can be used to serialize any Java value as
 *  a byte array. Functionally equivalent to calling
 *  {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}
 *  and getting bytes, but more efficient.
 *  Encoding used will be UTF-8.
 * <p>
 *  Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
 */"
"protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {
    // Then JsonSerializable, @JsonValue etc:
    JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);
    if (ser != null) {
        return ser;
    }
    final SerializationConfig config = prov.getConfig();
    // Container types differ from non-container types
    // (note: called method checks for module-provided serializers)
    if (type.isContainerType()) {
        if (!staticTyping) {
            staticTyping = usesStaticTyping(config, beanDesc, null);
            // [Issue#23]: Need to figure out how to force passed parameterization
            //  to stick...
            /*
                if (property == null) {
                    JavaType t = origType.getContentType();
                    if (t != null && !t.hasRawClass(Object.class)) {
                        staticTyping = true;
                    }
                }
                */
        }
        // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...
        ser = buildContainerSerializer(prov, type, beanDesc, staticTyping);
        // Will return right away, since called method does post-processing:
        if (ser != null) {
            return ser;
        }
    } else {
        // Modules may provide serializers of POJO types:
        for (Serializers serializers : customSerializers()) {
            ser = serializers.findSerializer(config, type, beanDesc);
            if (ser != null) {
                break;
            }
        }
    }
    // Otherwise, we will check ""primary types""; both marker types that
    // indicate specific handling (JsonSerializable), or main types that have
    // precedence over container types
    if (ser == null) {
        ser = findSerializerByLookup(type, config, beanDesc, staticTyping);
        if (ser == null) {
            ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);
            if (ser == null) {
                // And this is where this class comes in: if type is not a
                // known ""primary JDK type"", perhaps it's a bean? We can still
                // get a null, if we can't find a single suitable bean property.
                ser = findBeanSerializer(prov, type, beanDesc);
                // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?
                if (ser == null) {
                    ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);
                    // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get
                    //   'unknown' serializer assigned earlier, here, so that it gets properly
                    //   post-processed
                    if (ser == null) {
                        ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());
                    }
                }
            }
        }
    }
    if (ser != null) {
        // [Issue#120]: Allow post-processing
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                ser = mod.modifySerializer(config, beanDesc, ser);
            }
        }
    }
    return ser;
}","public void test1010() throws Throwable {
    SerializerFactoryConfig serializerFactoryConfig0 = new SerializerFactoryConfig();
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedMethod) null).when(pOJOPropertiesCollector0).getAnySetterMethod();
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((Set) null).when(pOJOPropertiesCollector0).getIgnoredPropertyNames();
    doReturn((Map) null).when(pOJOPropertiesCollector0).getInjectables();
    doReturn((AnnotatedMethod) null).when(pOJOPropertiesCollector0).getJsonValueMethod();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((List) null).when(pOJOPropertiesCollector0).getProperties();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    BeanSerializerModifier beanSerializerModifier0 = mock(BeanSerializerModifier.class, new ViolatedAssumptionAnswer());
    doReturn((JsonSerializer) null).when(beanSerializerModifier0).modifySerializer(any(com.fasterxml.jackson.databind.SerializationConfig.class), any(com.fasterxml.jackson.databind.BeanDescription.class), any(com.fasterxml.jackson.databind.JsonSerializer.class));
    SerializerFactoryConfig serializerFactoryConfig1 = serializerFactoryConfig0.withSerializerModifier(beanSerializerModifier0);
    BeanSerializerFactory beanSerializerFactory0 = new BeanSerializerFactory(serializerFactoryConfig1);
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProvider();
    Class<String> class0 = String.class;
    SimpleType simpleType0 = SimpleType.construct(class0);
    JsonSerializer<?> jsonSerializer0 = beanSerializerFactory0._createSerializer2(serializerProvider0, simpleType0, basicBeanDescription0, true);
    assertNull(jsonSerializer0);
}",""
"/*
    /**********************************************************
    /* Overridable non-public introspection methods
    /**********************************************************
     */
/**
 *  Helper method used to skip processing for types that we know
 *  can not be (i.e. are never consider to be) beans:
 *  things like primitives, Arrays, Enums, and proxy types.
 * <p>
 *  Note that usually we shouldn't really be getting these sort of
 *  types anyway; but better safe than sorry.
 */
protected boolean isPotentialBeanType(Class<?> type) {
    return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type);
}","public void test1111() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    Class<MatchStrength> class0 = MatchStrength.class;
    boolean boolean0 = beanSerializerFactory0.isPotentialBeanType(class0);
    assertFalse(boolean0);
}",""
