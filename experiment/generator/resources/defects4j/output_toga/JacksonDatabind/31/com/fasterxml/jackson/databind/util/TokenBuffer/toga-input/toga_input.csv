focal_method,test_prefix,docstring
"@Override
public void writeRaw(char c) throws IOException {
    _reportUnsupportedOperation();
}","public void test0000() throws Throwable {
    FileSystemHandling.createFolder((EvoSuiteFile) null);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    byte byte0 = (byte) (-59);
    Double double0 = new Double((byte) (-59));
    // Undeclared exception!
    try {
        tokenBuffer0.writeRaw('\""');
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test0011() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test0012() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
    if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {
        copyCurrentStructure(p);
        return this;
    }
    /* 28-Oct-2014, tatu: As per [databind#592], need to support a special case of starting from
         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need
         *    to assume one did exist.
         */
    JsonToken t;
    writeStartObject();
    do {
        copyCurrentStructure(p);
    } while ((t = p.nextToken()) == JsonToken.FIELD_NAME);
    if (t != JsonToken.END_OBJECT) {
        throw ctxt.mappingException(""Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got "" + t);
    }
    writeEndObject();
    return this;
}","public void test0024() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    TokenBuffer tokenBuffer2 = new TokenBuffer(tokenBuffer_Parser0, deserializationContext0);
    // Undeclared exception!
    try {
        tokenBuffer2.deserialize(tokenBuffer_Parser0, deserializationContext0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Helper method used by standard deserializer.
 *
 * @since 2.3
 */"
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test0035() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.ESCAPE_NON_ASCII;
    tokenBuffer0.disable(jsonGenerator_Feature0);
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw((byte) (-59), double0);
    tokenBuffer0.toString();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test0036() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.ESCAPE_NON_ASCII;
    tokenBuffer0.disable(jsonGenerator_Feature0);
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw((byte) (-59), double0);
    tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteObjectId());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test0037() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.ESCAPE_NON_ASCII;
    tokenBuffer0.disable(jsonGenerator_Feature0);
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw((byte) (-59), double0);
    tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteTypeId());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test0038() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.ESCAPE_NON_ASCII;
    tokenBuffer0.disable(jsonGenerator_Feature0);
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw((byte) (-59), double0);
    tokenBuffer0.toString();
    assertEquals(JsonToken.FIELD_NAME, tokenBuffer0.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test00611() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeEndObject();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test00612() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeEndObject();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test00613() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeEndObject();
    String string0 = tokenBuffer0.toString();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test00614() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeEndObject();
    String string0 = tokenBuffer0.toString();
    assertEquals(""[TokenBuffer: END_OBJECT]"", string0);
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test00615() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeEndObject();
    String string0 = tokenBuffer0.toString();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public void copyCurrentStructure(JsonParser jp) throws IOException {
    JsonToken t = jp.getCurrentToken();
    // Let's handle field-name separately first
    if (t == JsonToken.FIELD_NAME) {
        if (_mayHaveNativeIds) {
            _checkNativeIds(jp);
        }
        writeFieldName(jp.getCurrentName());
        t = jp.nextToken();
        // fall-through to copy the associated value
    }
    if (_mayHaveNativeIds) {
        _checkNativeIds(jp);
    }
    switch(t) {
        case START_ARRAY:
            writeStartArray();
            while (jp.nextToken() != JsonToken.END_ARRAY) {
                copyCurrentStructure(jp);
            }
            writeEndArray();
            break;
        case START_OBJECT:
            writeStartObject();
            while (jp.nextToken() != JsonToken.END_OBJECT) {
                copyCurrentStructure(jp);
            }
            writeEndObject();
            break;
        default:
            // others are simple:
            copyCurrentEvent(jp);
    }
}","public void test00716() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser0);
    // Undeclared exception!
    try {
        tokenBuffer0.copyCurrentStructure(tokenBuffer_Parser0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test00817() throws Throwable {
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, (ObjectCodec) null, false, false);
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser0);
    String string0 = tokenBuffer0.toString();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test00818() throws Throwable {
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, (ObjectCodec) null, false, false);
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser0);
    String string0 = tokenBuffer0.toString();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test00819() throws Throwable {
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, (ObjectCodec) null, false, false);
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser0);
    String string0 = tokenBuffer0.toString();
    assertEquals(""[TokenBuffer: ]"", string0);
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test00820() throws Throwable {
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, (ObjectCodec) null, false, false);
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser0);
    String string0 = tokenBuffer0.toString();
    assertFalse(tokenBuffer0.canWriteTypeId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test00921() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectMapper objectMapper1 = objectMapper0.findAndRegisterModules();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ObjectMapper objectMapper2 = objectMapper1.setTypeFactory(typeFactory0);
    MapperFeature mapperFeature0 = MapperFeature.USE_STD_BEAN_NAMING;
    ObjectMapper objectMapper3 = objectMapper2.configure(mapperFeature0, true);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper3);
    ObjectCodec objectCodec0 = tokenBuffer0.getCodec();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test00922() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectMapper objectMapper1 = objectMapper0.findAndRegisterModules();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ObjectMapper objectMapper2 = objectMapper1.setTypeFactory(typeFactory0);
    MapperFeature mapperFeature0 = MapperFeature.USE_STD_BEAN_NAMING;
    ObjectMapper objectMapper3 = objectMapper2.configure(mapperFeature0, true);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper3);
    ObjectCodec objectCodec0 = tokenBuffer0.getCodec();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public ObjectCodec getCodec() {
    return _objectCodec;
}","public void test00923() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectMapper objectMapper1 = objectMapper0.findAndRegisterModules();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ObjectMapper objectMapper2 = objectMapper1.setTypeFactory(typeFactory0);
    MapperFeature mapperFeature0 = MapperFeature.USE_STD_BEAN_NAMING;
    ObjectMapper objectMapper3 = objectMapper2.configure(mapperFeature0, true);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper3);
    ObjectCodec objectCodec0 = tokenBuffer0.getCodec();
    assertNotNull(objectCodec0);
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01024() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    int int0 = tokenBuffer_Parser0.getTextLength();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test01028() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    int int0 = tokenBuffer_Parser0.getTextLength();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01129() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.getTextCharacters();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test01132() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.getTextCharacters();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01233() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    BigInteger bigInteger0 = BigInteger.TEN;
    tokenBuffer0.writeNumber(bigInteger0);
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test01234() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    BigInteger bigInteger0 = BigInteger.TEN;
    tokenBuffer0.writeNumber(bigInteger0);
    assertEquals(JsonToken.VALUE_NUMBER_INT, tokenBuffer0.firstToken());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test01235() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    BigInteger bigInteger0 = BigInteger.TEN;
    tokenBuffer0.writeNumber(bigInteger0);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01441() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    tokenBuffer0.writeNumber(1L);
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test01442() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    tokenBuffer0.writeNumber(1L);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01545() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory((DeserializerFactoryConfig) null);
    BigInteger bigInteger0 = BigInteger.ZERO;
    TokenBuffer tokenBuffer1 = tokenBuffer0.append(tokenBuffer0);
    assertEquals(31, tokenBuffer1.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test01546() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory((DeserializerFactoryConfig) null);
    BigInteger bigInteger0 = BigInteger.ZERO;
    TokenBuffer tokenBuffer1 = tokenBuffer0.append(tokenBuffer0);
    assertFalse(tokenBuffer1.canWriteObjectId());
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test01748() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    tokenBuffer0.writeRawValue((SerializableString) serializedString0);
    String string0 = tokenBuffer0.toString();
    assertEquals(""[TokenBuffer: VALUE_EMBEDDED_OBJECT]"", string0);
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01749() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    tokenBuffer0.writeRawValue((SerializableString) serializedString0);
    String string0 = tokenBuffer0.toString();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test01750() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    tokenBuffer0.writeRawValue((SerializableString) serializedString0);
    String string0 = tokenBuffer0.toString();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test01952() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.AUTO_CLOSE_SOURCE;
    ObjectReader objectReader1 = objectReader0.with(jsonParser_Feature0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectReader1);
    tokenBuffer0.writeBoolean(true);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test01953() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.AUTO_CLOSE_SOURCE;
    ObjectReader objectReader1 = objectReader0.with(jsonParser_Feature0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectReader1);
    tokenBuffer0.writeBoolean(true);
    assertEquals(JsonToken.VALUE_TRUE, tokenBuffer0.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test01954() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.AUTO_CLOSE_SOURCE;
    ObjectReader objectReader1 = objectReader0.with(jsonParser_Feature0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectReader1);
    tokenBuffer0.writeBoolean(true);
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test02056() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    boolean boolean0 = tokenBuffer_Segment0.hasIds();
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    tokenBuffer0.writeStartObject();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test02057() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    boolean boolean0 = tokenBuffer_Segment0.hasIds();
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    tokenBuffer0.writeStartObject();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test02259() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    objectMapper0.getDateFormat();
    tokenBuffer0.writeEndObject();
    tokenBuffer0.writeEndObject();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test02260() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    objectMapper0.getDateFormat();
    tokenBuffer0.writeEndObject();
    tokenBuffer0.writeEndObject();
    assertEquals(JsonToken.END_OBJECT, tokenBuffer0.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test02261() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    objectMapper0.getDateFormat();
    tokenBuffer0.writeEndObject();
    tokenBuffer0.writeEndObject();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test02362() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer0.writeStringField(""dv0Qyw"", ""dv0Qyw"");
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test02363() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer0.writeStringField(""dv0Qyw"", ""dv0Qyw"");
    assertEquals(JsonToken.FIELD_NAME, tokenBuffer0.firstToken());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test02364() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer0.writeStringField(""dv0Qyw"", ""dv0Qyw"");
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: write methods for POJOs/trees
    /***********************************************************
     */
@Override
public void writeObject(Object value) throws IOException {
    if (value == null) {
        writeNull();
        return;
    }
    Class<?> raw = value.getClass();
    if (raw == byte[].class || (value instanceof RawValue)) {
        _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);
        return;
    }
    if (_objectCodec == null) {
        /* 28-May-2014, tatu: Tricky choice here; if no codec, should we
             *   err out, or just embed? For now, do latter.
             */
        //          throw new JsonMappingException(""No ObjectCodec configured for TokenBuffer, writeObject() called"");
        _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);
    } else {
        _objectCodec.writeValue(this, value);
    }
}","public void test02465() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    // Undeclared exception!
    try {
        tokenBuffer0.writeObject(objectMapper0);
        fail(""Expecting exception: NoClassDefFoundError"");
    } catch (NoClassDefFoundError e) {
        //
        // com/fasterxml/jackson/databind/JsonMappingException$Reference
        //
        verifyException(""com.fasterxml.jackson.databind.ser.std.BeanSerializerBase"", e);
    }
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test02566() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer0._appendRaw(16, objectMapper0);
    String string0 = tokenBuffer0.toString();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test02567() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer0._appendRaw(16, objectMapper0);
    String string0 = tokenBuffer0.toString();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test02568() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer0._appendRaw(16, objectMapper0);
    String string0 = tokenBuffer0.toString();
    assertEquals(""[TokenBuffer: ]"", string0);
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test02770() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer0.writeNumber(bigDecimal0);
    tokenBuffer0.writeStringField(""Unrecognized value type for VALUE_NUMBER_FLOAT: "", ""Unrecognized value type for VALUE_NUMBER_FLOAT: "");
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test02771() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer0.writeNumber(bigDecimal0);
    tokenBuffer0.writeStringField(""Unrecognized value type for VALUE_NUMBER_FLOAT: "", ""Unrecognized value type for VALUE_NUMBER_FLOAT: "");
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test02772() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer0.writeNumber(bigDecimal0);
    tokenBuffer0.writeStringField(""Unrecognized value type for VALUE_NUMBER_FLOAT: "", ""Unrecognized value type for VALUE_NUMBER_FLOAT: "");
    assertEquals(JsonToken.VALUE_NUMBER_FLOAT, tokenBuffer0.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test02974() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0, false);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    boolean boolean0 = tokenBuffer_Parser0.hasTextCharacters();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test02975() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0, false);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    boolean boolean0 = tokenBuffer_Parser0.hasTextCharacters();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test03079() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    RawValue rawValue0 = new RawValue(""vmG"");
    tokenBuffer0.writeNumber(""vmG"");
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.appendRaw(515, 16, (Object) rawValue0);
    JsonToken jsonToken0 = JsonToken.START_ARRAY;
    tokenBuffer_Segment1.append(515, jsonToken0, (Object) ""vmG"", (Object) ""vmG"", (Object) ""vmG"");
    assertEquals(JsonToken.VALUE_NUMBER_FLOAT, tokenBuffer0.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test03080() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    RawValue rawValue0 = new RawValue(""vmG"");
    tokenBuffer0.writeNumber(""vmG"");
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.appendRaw(515, 16, (Object) rawValue0);
    JsonToken jsonToken0 = JsonToken.START_ARRAY;
    tokenBuffer_Segment1.append(515, jsonToken0, (Object) ""vmG"", (Object) ""vmG"", (Object) ""vmG"");
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test03181() throws Throwable {
    FileSystemHandling.createFolder((EvoSuiteFile) null);
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeBooleanField(""RkZH,s h8S_ ula."", false);
    tokenBuffer0.writeTypeId(objectMapper0);
    tokenBuffer0.writeEndObject();
    assertEquals(JsonToken.FIELD_NAME, tokenBuffer0.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test03182() throws Throwable {
    FileSystemHandling.createFolder((EvoSuiteFile) null);
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeBooleanField(""RkZH,s h8S_ ula."", false);
    tokenBuffer0.writeTypeId(objectMapper0);
    tokenBuffer0.writeEndObject();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test03183() throws Throwable {
    FileSystemHandling.createFolder((EvoSuiteFile) null);
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeBooleanField(""RkZH,s h8S_ ula."", false);
    tokenBuffer0.writeTypeId(objectMapper0);
    tokenBuffer0.writeEndObject();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public void writeRaw(String text, int offset, int len) throws IOException {
    _reportUnsupportedOperation();
}","public void test03385() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    // Undeclared exception!
    try {
        tokenBuffer0.writeRaw("", "", 4, 56320);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test03487() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer0.writeEndArray();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.getCurrentName();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test03488() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer0.writeEndArray();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.getCurrentName();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {
    // could add support for buffering if we really want it...
    _reportUnsupportedOperation();
}","public void test03592() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    boolean boolean0 = false;
    byte[] byteArray0 = new byte[0];
    // Undeclared exception!
    try {
        tokenBuffer0.writeRawUTF8String(byteArray0, 16, 555);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test03693() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    Double double0 = new Double((byte) (-59));
    tokenBuffer0.writeNumber(0.0F);
    tokenBuffer0._appendRaw((byte) (-59), double0);
    tokenBuffer0.toString();
    assertEquals(JsonToken.VALUE_NUMBER_FLOAT, tokenBuffer0.firstToken());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test03794() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.firstToken();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test03795() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.firstToken();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test03896() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    Double double0 = new Double(16);
    tokenBuffer0._appendRaw(16, double0);
    JsonGenerator jsonGenerator0 = tokenBuffer0.overrideStdFeatures(16, 100);
    jsonGenerator0.writeEndObject();
    assertEquals(27, tokenBuffer0.getFeatureMask());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test03997() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer0._hasNativeId = true;
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw((byte) (-59), double0);
    tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteTypeId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test03998() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer0._hasNativeId = true;
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw((byte) (-59), double0);
    tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteObjectId());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test03999() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer0._hasNativeId = true;
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw((byte) (-59), double0);
    tokenBuffer0.toString();
    assertEquals(JsonToken.FIELD_NAME, tokenBuffer0.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test039100() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer0._hasNativeId = true;
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw((byte) (-59), double0);
    tokenBuffer0.toString();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"//public JsonGenerator configure(SerializationFeature f, boolean state) { }
@Override
public boolean isEnabled(Feature f) {
    return (_generatorFeatures & f.getMask()) != 0;
}","public void test041103() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM;
    boolean boolean0 = tokenBuffer0.isEnabled(jsonGenerator_Feature0);
    assertTrue(boolean0);
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test041104() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM;
    boolean boolean0 = tokenBuffer0.isEnabled(jsonGenerator_Feature0);
    tokenBuffer0.writeEndObject();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test041105() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM;
    boolean boolean0 = tokenBuffer0.isEnabled(jsonGenerator_Feature0);
    tokenBuffer0.writeEndObject();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test042106() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    Double double0 = new Double((byte) (-60));
    tokenBuffer0._appendRaw((byte) (-60), double0);
    String string0 = tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteTypeId());
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test042107() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    Double double0 = new Double((byte) (-60));
    tokenBuffer0._appendRaw((byte) (-60), double0);
    String string0 = tokenBuffer0.toString();
    assertEquals(""[TokenBuffer: END_ARRAY, VALUE_NULL]"", string0);
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test042108() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    Double double0 = new Double((byte) (-60));
    tokenBuffer0._appendRaw((byte) (-60), double0);
    String string0 = tokenBuffer0.toString();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test043110() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumberField((String) null, 1554.2620651919);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer0.writeEndObject();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test043111() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumberField((String) null, 1554.2620651919);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer0.writeEndObject();
    assertEquals(JsonToken.FIELD_NAME, tokenBuffer0.firstToken());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test043112() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumberField((String) null, 1554.2620651919);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer0.writeEndObject();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"public void serialize(JsonGenerator gen) throws IOException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                gen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                gen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                gen.writeStartObject();
                break;
            case END_OBJECT:
                gen.writeEndObject();
                break;
            case START_ARRAY:
                gen.writeStartArray();
                break;
            case END_ARRAY:
                gen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeFieldName((SerializableString) ob);
                    } else {
                        gen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeString((SerializableString) ob);
                    } else {
                        gen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        gen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        gen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        gen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        gen.writeNumber((Short) n);
                    } else {
                        gen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        gen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        gen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        gen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        gen.writeNull();
                    } else if (n instanceof String) {
                        gen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                gen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                gen.writeBoolean(false);
                break;
            case VALUE_NULL:
                gen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                {
                    Object value = segment.get(ptr);
                    if (value instanceof RawValue) {
                        ((RawValue) value).serialize(gen);
                    } else {
                        gen.writeObject(value);
                    }
                }
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test044113() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer0.writeNumber(1L);
    // Undeclared exception!
    tokenBuffer0.serialize(tokenBuffer0);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test045114() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper1);
    tokenBuffer0.serialize(tokenBuffer0);
    tokenBuffer0.firstToken();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test045115() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper1);
    tokenBuffer0.serialize(tokenBuffer0);
    tokenBuffer0.firstToken();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public void copyCurrentStructure(JsonParser jp) throws IOException {
    JsonToken t = jp.getCurrentToken();
    // Let's handle field-name separately first
    if (t == JsonToken.FIELD_NAME) {
        if (_mayHaveNativeIds) {
            _checkNativeIds(jp);
        }
        writeFieldName(jp.getCurrentName());
        t = jp.nextToken();
        // fall-through to copy the associated value
    }
    if (_mayHaveNativeIds) {
        _checkNativeIds(jp);
    }
    switch(t) {
        case START_ARRAY:
            writeStartArray();
            while (jp.nextToken() != JsonToken.END_ARRAY) {
                copyCurrentStructure(jp);
            }
            writeEndArray();
            break;
        case START_OBJECT:
            writeStartObject();
            while (jp.nextToken() != JsonToken.END_OBJECT) {
                copyCurrentStructure(jp);
            }
            writeEndObject();
            break;
        default:
            // others are simple:
            copyCurrentEvent(jp);
    }
}","public void test046116() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser0);
    // Undeclared exception!
    try {
        tokenBuffer0.copyCurrentStructure(tokenBuffer_Parser0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"@Override
public void writeRawValue(char[] text, int offset, int len) throws IOException {
    _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));
}","public void test047117() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory(objectMapper0);
    JsonFactory jsonFactory1 = jsonFactory0.setRootValueSeparator(""b9fgc`7\"""");
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_YAML_COMMENTS;
    JsonFactory.Feature jsonFactory_Feature0 = JsonFactory.Feature.CANONICALIZE_FIELD_NAMES;
    jsonFactory1.isEnabled(jsonFactory_Feature0);
    JsonFactory jsonFactory2 = jsonFactory1.enable(jsonParser_Feature0);
    File file0 = MockFile.createTempFile(""JSON"", "";..kAOZ uw>C<dr+0"", (File) null);
    JsonParser jsonParser0 = jsonFactory2.createParser(file0);
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0, defaultDeserializationContext_Impl0);
    char[] charArray0 = new char[5];
    charArray0[0] = '\""';
    charArray0[1] = 'k';
    charArray0[2] = 'Z';
    charArray0[3] = '2';
    charArray0[4] = 'o';
    int int0 = (-1226);
    // Undeclared exception!
    try {
        tokenBuffer0.writeRawValue(charArray0, (-1226), (-1226));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test048121() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE;
    ObjectMapper objectMapper1 = objectMapper0.enableDefaultTypingAsProperty(objectMapper_DefaultTyping0, ""JSON"");
    ObjectMapper objectMapper2 = objectMapper1.setAnnotationIntrospectors((AnnotationIntrospector) null, (AnnotationIntrospector) null);
    Locale locale0 = Locale.CHINA;
    ObjectMapper objectMapper3 = objectMapper2.setLocale(locale0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper3, true, true);
    boolean boolean0 = tokenBuffer_Parser0.isClosed();
    Double double0 = new Double(46);
    Double double1 = new Double(16);
    tokenBuffer_Segment0.type((-437));
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test048122() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE;
    ObjectMapper objectMapper1 = objectMapper0.enableDefaultTypingAsProperty(objectMapper_DefaultTyping0, ""JSON"");
    ObjectMapper objectMapper2 = objectMapper1.setAnnotationIntrospectors((AnnotationIntrospector) null, (AnnotationIntrospector) null);
    Locale locale0 = Locale.CHINA;
    ObjectMapper objectMapper3 = objectMapper2.setLocale(locale0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper3, true, true);
    boolean boolean0 = tokenBuffer_Parser0.isClosed();
    Double double0 = new Double(46);
    Double double1 = new Double(16);
    tokenBuffer_Segment0.type((-437));
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public void copyCurrentStructure(JsonParser jp) throws IOException {
    JsonToken t = jp.getCurrentToken();
    // Let's handle field-name separately first
    if (t == JsonToken.FIELD_NAME) {
        if (_mayHaveNativeIds) {
            _checkNativeIds(jp);
        }
        writeFieldName(jp.getCurrentName());
        t = jp.nextToken();
        // fall-through to copy the associated value
    }
    if (_mayHaveNativeIds) {
        _checkNativeIds(jp);
    }
    switch(t) {
        case START_ARRAY:
            writeStartArray();
            while (jp.nextToken() != JsonToken.END_ARRAY) {
                copyCurrentStructure(jp);
            }
            writeEndArray();
            break;
        case START_OBJECT:
            writeStartObject();
            while (jp.nextToken() != JsonToken.END_OBJECT) {
                copyCurrentStructure(jp);
            }
            writeEndObject();
            break;
        default:
            // others are simple:
            copyCurrentEvent(jp);
    }
}","public void test051126() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    FloatNode floatNode0 = FloatNode.valueOf(0.0F);
    Long long0 = new Long(16);
    tokenBuffer_Segment0.appendRaw(169, 169, (Object) objectMapper0, (Object) floatNode0, (Object) long0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser0);
    // Undeclared exception!
    try {
        tokenBuffer0.copyCurrentStructure(tokenBuffer_Parser0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"//public JsonGenerator configure(SerializationFeature f, boolean state) { }
@Override
public boolean isEnabled(Feature f) {
    return (_generatorFeatures & f.getMask()) != 0;
}","public void test053129() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer1._objectCodec = null;
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.IGNORE_UNKNOWN;
    boolean boolean0 = tokenBuffer1.isEnabled(jsonGenerator_Feature0);
    assertFalse(boolean0);
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test053130() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer1._objectCodec = null;
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.IGNORE_UNKNOWN;
    boolean boolean0 = tokenBuffer1.isEnabled(jsonGenerator_Feature0);
    assertTrue(tokenBuffer1.canWriteTypeId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test053131() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer1._objectCodec = null;
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.IGNORE_UNKNOWN;
    boolean boolean0 = tokenBuffer1.isEnabled(jsonGenerator_Feature0);
    assertTrue(tokenBuffer1.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test053132() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer1._objectCodec = null;
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.IGNORE_UNKNOWN;
    boolean boolean0 = tokenBuffer1.isEnabled(jsonGenerator_Feature0);
    tokenBuffer0.writeEndObject();
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    tokenBuffer0._append(jsonToken0);
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test053133() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer1._objectCodec = null;
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.IGNORE_UNKNOWN;
    boolean boolean0 = tokenBuffer1.isEnabled(jsonGenerator_Feature0);
    tokenBuffer0.writeEndObject();
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    tokenBuffer0._append(jsonToken0);
    assertEquals(JsonToken.END_OBJECT, tokenBuffer0.firstToken());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test055136() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber("""");
    assertEquals(JsonToken.VALUE_NUMBER_FLOAT, tokenBuffer0.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test055137() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber("""");
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    tokenBuffer1.writeEndObject();
    tokenBuffer1.firstToken();
    assertEquals(31, tokenBuffer1.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test055138() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber("""");
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    tokenBuffer1.writeEndObject();
    tokenBuffer1.firstToken();
    assertFalse(tokenBuffer1.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test056139() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = objectNode0.deepCopy();
    ArrayNode arrayNode0 = objectNode1.withArray("" ^44}c"");
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonParser jsonParser0 = arrayNode0.traverse((ObjectCodec) objectMapper0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0);
    tokenBuffer0.firstToken();
    tokenBuffer0.setFeatureMask(4280);
    tokenBuffer0.writeObjectId(jsonParser0);
    byte[] byteArray0 = new byte[2];
    byteArray0[0] = (byte) (-40);
    byteArray0[1] = (byte) 117;
    BigInteger bigInteger0 = new BigInteger(byteArray0);
    tokenBuffer0.writeNumber(bigInteger0);
    assertEquals(4280, tokenBuffer0.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test057140() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeObjectId(""^F2q>xg"");
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"public void serialize(JsonGenerator gen) throws IOException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                gen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                gen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                gen.writeStartObject();
                break;
            case END_OBJECT:
                gen.writeEndObject();
                break;
            case START_ARRAY:
                gen.writeStartArray();
                break;
            case END_ARRAY:
                gen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeFieldName((SerializableString) ob);
                    } else {
                        gen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeString((SerializableString) ob);
                    } else {
                        gen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        gen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        gen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        gen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        gen.writeNumber((Short) n);
                    } else {
                        gen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        gen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        gen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        gen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        gen.writeNull();
                    } else if (n instanceof String) {
                        gen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                gen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                gen.writeBoolean(false);
                break;
            case VALUE_NULL:
                gen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                {
                    Object value = segment.get(ptr);
                    if (value instanceof RawValue) {
                        ((RawValue) value).serialize(gen);
                    } else {
                        gen.writeObject(value);
                    }
                }
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test058144() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    Double double0 = new Double(16);
    tokenBuffer0._appendRaw(40, double0);
    // Undeclared exception!
    tokenBuffer0.serialize(tokenBuffer0);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"/*
    /**********************************************************
    /* JsonGenerator implementation; pass-through copy
    /**********************************************************
     */
@Override
public void copyCurrentEvent(JsonParser p) throws IOException {
    if (_mayHaveNativeIds) {
        _checkNativeIds(p);
    }
    switch(p.getCurrentToken()) {
        case START_OBJECT:
            writeStartObject();
            break;
        case END_OBJECT:
            writeEndObject();
            break;
        case START_ARRAY:
            writeStartArray();
            break;
        case END_ARRAY:
            writeEndArray();
            break;
        case FIELD_NAME:
            writeFieldName(p.getCurrentName());
            break;
        case VALUE_STRING:
            if (p.hasTextCharacters()) {
                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());
            } else {
                writeString(p.getText());
            }
            break;
        case VALUE_NUMBER_INT:
            switch(p.getNumberType()) {
                case INT:
                    writeNumber(p.getIntValue());
                    break;
                case BIG_INTEGER:
                    writeNumber(p.getBigIntegerValue());
                    break;
                default:
                    writeNumber(p.getLongValue());
            }
            break;
        case VALUE_NUMBER_FLOAT:
            if (_forceBigDecimal) {
                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying
                 *   number is already decoded into a number (in which case might as well
                 *   access as number); or is still retained as text (in which case we
                 *   should further defer decoding that may not need BigDecimal):
                 */
                writeNumber(p.getDecimalValue());
            } else {
                switch(p.getNumberType()) {
                    case BIG_DECIMAL:
                        writeNumber(p.getDecimalValue());
                        break;
                    case FLOAT:
                        writeNumber(p.getFloatValue());
                        break;
                    default:
                        writeNumber(p.getDoubleValue());
                }
            }
            break;
        case VALUE_TRUE:
            writeBoolean(true);
            break;
        case VALUE_FALSE:
            writeBoolean(false);
            break;
        case VALUE_NULL:
            writeNull();
            break;
        case VALUE_EMBEDDED_OBJECT:
            writeObject(p.getEmbeddedObject());
            break;
        default:
            throw new RuntimeException(""Internal error: should never end up through this code path"");
    }
}","public void test060146() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    boolean boolean0 = false;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    // Undeclared exception!
    try {
        tokenBuffer0.copyCurrentEvent(tokenBuffer_Parser0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test062149() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    RawValue rawValue0 = new RawValue(""F"");
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.appendRaw(515, 515, (Object) rawValue0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment1, (ObjectCodec) null, true, true);
    tokenBuffer_Parser0.getCurrentLocation();
    tokenBuffer0.writeNumber((short) 2965);
    tokenBuffer_Parser0.nextFieldName();
    tokenBuffer0.firstToken();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test064152() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer0.serialize(tokenBuffer0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer0.firstToken();
    assertTrue(tokenBuffer0.canWriteTypeId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test064153() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer0.serialize(tokenBuffer0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer0.firstToken();
    assertTrue(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test064154() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer0.serialize(tokenBuffer0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer0.firstToken();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* JsonGenerator implementation; pass-through copy
    /**********************************************************
     */
@Override
public void copyCurrentEvent(JsonParser p) throws IOException {
    if (_mayHaveNativeIds) {
        _checkNativeIds(p);
    }
    switch(p.getCurrentToken()) {
        case START_OBJECT:
            writeStartObject();
            break;
        case END_OBJECT:
            writeEndObject();
            break;
        case START_ARRAY:
            writeStartArray();
            break;
        case END_ARRAY:
            writeEndArray();
            break;
        case FIELD_NAME:
            writeFieldName(p.getCurrentName());
            break;
        case VALUE_STRING:
            if (p.hasTextCharacters()) {
                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());
            } else {
                writeString(p.getText());
            }
            break;
        case VALUE_NUMBER_INT:
            switch(p.getNumberType()) {
                case INT:
                    writeNumber(p.getIntValue());
                    break;
                case BIG_INTEGER:
                    writeNumber(p.getBigIntegerValue());
                    break;
                default:
                    writeNumber(p.getLongValue());
            }
            break;
        case VALUE_NUMBER_FLOAT:
            if (_forceBigDecimal) {
                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying
                 *   number is already decoded into a number (in which case might as well
                 *   access as number); or is still retained as text (in which case we
                 *   should further defer decoding that may not need BigDecimal):
                 */
                writeNumber(p.getDecimalValue());
            } else {
                switch(p.getNumberType()) {
                    case BIG_DECIMAL:
                        writeNumber(p.getDecimalValue());
                        break;
                    case FLOAT:
                        writeNumber(p.getFloatValue());
                        break;
                    default:
                        writeNumber(p.getDoubleValue());
                }
            }
            break;
        case VALUE_TRUE:
            writeBoolean(true);
            break;
        case VALUE_FALSE:
            writeBoolean(false);
            break;
        case VALUE_NULL:
            writeNull();
            break;
        case VALUE_EMBEDDED_OBJECT:
            writeObject(p.getEmbeddedObject());
            break;
        default:
            throw new RuntimeException(""Internal error: should never end up through this code path"");
    }
}","public void test065155() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, (ObjectCodec) null, false, true);
    tokenBuffer_Parser0.getValueAsString();
    tokenBuffer_Parser0.getValueAsString();
    tokenBuffer_Parser0.nextFieldName();
    // Undeclared exception!
    try {
        tokenBuffer0.copyCurrentEvent(tokenBuffer_Parser0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test067157() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer tokenBuffer1 = tokenBuffer0.forceUseOfBigDecimal(true);
    tokenBuffer0.writeString((SerializableString) null);
    boolean boolean0 = tokenBuffer_Segment0.hasIds();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test067158() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer tokenBuffer1 = tokenBuffer0.forceUseOfBigDecimal(true);
    tokenBuffer0.writeString((SerializableString) null);
    boolean boolean0 = tokenBuffer_Segment0.hasIds();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test067160() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer tokenBuffer1 = tokenBuffer0.forceUseOfBigDecimal(true);
    tokenBuffer0.writeString((SerializableString) null);
    boolean boolean0 = tokenBuffer_Segment0.hasIds();
    assertEquals(JsonToken.VALUE_NULL, tokenBuffer0.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test068161() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer0.writeNumber("""");
    tokenBuffer0._appendRaw(8, objectMapper0);
    String string0 = tokenBuffer0.toString();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test068162() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer0.writeNumber("""");
    tokenBuffer0._appendRaw(8, objectMapper0);
    String string0 = tokenBuffer0.toString();
    assertEquals(""[TokenBuffer: VALUE_NUMBER_FLOAT, VALUE_NUMBER_INT]"", string0);
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test068163() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer0.writeNumber("""");
    tokenBuffer0._appendRaw(8, objectMapper0);
    String string0 = tokenBuffer0.toString();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {
    throw new UnsupportedOperationException();
}","public void test069164() throws Throwable {
    ObjectCodec objectCodec0 = null;
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    RawValue rawValue0 = new RawValue(""F~"");
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer0._last;
    JsonToken jsonToken0 = JsonToken.NOT_AVAILABLE;
    FloatNode floatNode0 = new FloatNode(16);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    tokenBuffer_Parser0.getEmbeddedObject();
    tokenBuffer_Segment1.append(16, jsonToken0);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    Enumeration<BufferedInputStream> enumeration0 = (Enumeration<BufferedInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    PushbackInputStream pushbackInputStream0 = new PushbackInputStream(sequenceInputStream0, 68);
    // Undeclared exception!
    try {
        tokenBuffer0.writeBinary((Base64Variant) null, (InputStream) sequenceInputStream0, 10);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}","/**
 * Although we could support this method, it does not necessarily make
 * sense: we can not make good use of streaming because buffer must
 * hold all the data. Because of this, currently this will simply
 * throw {@link UnsupportedOperationException}
 */"
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test071167() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw((byte) (-59), double0);
    tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteTypeId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test071168() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw((byte) (-59), double0);
    tokenBuffer0.toString();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test071169() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw((byte) (-59), double0);
    tokenBuffer0.toString();
    assertEquals(JsonToken.FIELD_NAME, tokenBuffer0.firstToken());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test071170() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw((byte) (-59), double0);
    tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test072171() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    assertEquals(31, tokenBuffer1.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test072172() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    assertFalse(tokenBuffer1.canWriteObjectId());
}",""
"@Override
public void writeRaw(char[] text, int offset, int len) throws IOException {
    _reportUnsupportedOperation();
}","public void test073175() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    char[] charArray0 = new char[4];
    charArray0[0] = 'o';
    charArray0[1] = '?';
    charArray0[2] = '(';
    charArray0[3] = 'N';
    // Undeclared exception!
    try {
        tokenBuffer0.writeRaw(charArray0, 16, 13);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"@Override
public void writeRaw(String text) throws IOException {
    _reportUnsupportedOperation();
}","public void test074176() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    FileSystemHandling.shouldAllThrowIOExceptions();
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM;
    tokenBuffer0.setCodec((ObjectCodec) null);
    tokenBuffer0.isEnabled(jsonGenerator_Feature0);
    tokenBuffer0.writeEndObject();
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    // Undeclared exception!
    try {
        tokenBuffer0.writeRaw((String) null);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test080183() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer_Segment0.next();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test080184() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer_Segment0.next();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* JsonGenerator implementation; pass-through copy
    /**********************************************************
     */
@Override
public void copyCurrentEvent(JsonParser p) throws IOException {
    if (_mayHaveNativeIds) {
        _checkNativeIds(p);
    }
    switch(p.getCurrentToken()) {
        case START_OBJECT:
            writeStartObject();
            break;
        case END_OBJECT:
            writeEndObject();
            break;
        case START_ARRAY:
            writeStartArray();
            break;
        case END_ARRAY:
            writeEndArray();
            break;
        case FIELD_NAME:
            writeFieldName(p.getCurrentName());
            break;
        case VALUE_STRING:
            if (p.hasTextCharacters()) {
                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());
            } else {
                writeString(p.getText());
            }
            break;
        case VALUE_NUMBER_INT:
            switch(p.getNumberType()) {
                case INT:
                    writeNumber(p.getIntValue());
                    break;
                case BIG_INTEGER:
                    writeNumber(p.getBigIntegerValue());
                    break;
                default:
                    writeNumber(p.getLongValue());
            }
            break;
        case VALUE_NUMBER_FLOAT:
            if (_forceBigDecimal) {
                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying
                 *   number is already decoded into a number (in which case might as well
                 *   access as number); or is still retained as text (in which case we
                 *   should further defer decoding that may not need BigDecimal):
                 */
                writeNumber(p.getDecimalValue());
            } else {
                switch(p.getNumberType()) {
                    case BIG_DECIMAL:
                        writeNumber(p.getDecimalValue());
                        break;
                    case FLOAT:
                        writeNumber(p.getFloatValue());
                        break;
                    default:
                        writeNumber(p.getDoubleValue());
                }
            }
            break;
        case VALUE_TRUE:
            writeBoolean(true);
            break;
        case VALUE_FALSE:
            writeBoolean(false);
            break;
        case VALUE_NULL:
            writeNull();
            break;
        case VALUE_EMBEDDED_OBJECT:
            writeObject(p.getEmbeddedObject());
            break;
        default:
            throw new RuntimeException(""Internal error: should never end up through this code path"");
    }
}","public void test081187() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) (-9);
    tokenBuffer0.writeBinary(byteArray0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    tokenBuffer_Parser0.getCurrentName();
    // Undeclared exception!
    try {
        tokenBuffer0.copyCurrentEvent(tokenBuffer_Parser0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
public void writeUTF8String(byte[] text, int offset, int length) throws IOException {
    // could add support for buffering if we really want it...
    _reportUnsupportedOperation();
}","public void test083189() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    RawValue rawValue0 = new RawValue(""F"");
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser1 = new TokenBuffer.Parser(tokenBuffer_Segment1, (ObjectCodec) null, false, false);
    tokenBuffer_Parser1.getEmbeddedObject();
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    tokenBuffer_Segment0.append(16, jsonToken0);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    tokenBuffer0.getOutputContext();
    tokenBuffer_Parser0.nextToken();
    tokenBuffer0.getFeatureMask();
    byte[] byteArray0 = new byte[6];
    byteArray0[0] = (byte) 96;
    byteArray0[1] = (byte) 64;
    byteArray0[2] = (byte) 2;
    byteArray0[3] = (byte) 64;
    byteArray0[4] = (byte) 0;
    byteArray0[5] = (byte) 31;
    // Undeclared exception!
    try {
        tokenBuffer0.writeUTF8String(byteArray0, (byte) 64, (byte) 64);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Called operation not supported for TokenBuffer
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"@Override
public void writeRawValue(String text, int offset, int len) throws IOException {
    if (offset > 0 || len != text.length()) {
        text = text.substring(offset, offset + len);
    }
    _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));
}","public void test084190() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    HashMap<String, RawValue> hashMap0 = new HashMap<String, RawValue>();
    FileSystemHandling.createFolder((EvoSuiteFile) null);
    SimpleFilterProvider simpleFilterProvider0 = new SimpleFilterProvider(hashMap0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0, true);
    // Undeclared exception!
    try {
        tokenBuffer0.writeRawValue(""[objectId="", 1721, 1721);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test086193() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    deserializerFactoryConfig0.abstractTypeResolvers();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    deserializerFactoryConfig0.keyDeserializers();
    deserializerFactoryConfig0.deserializerModifiers();
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer2 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer3 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer4 = tokenBuffer0.append(tokenBuffer2);
    assertEquals(31, tokenBuffer4.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test086194() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    deserializerFactoryConfig0.abstractTypeResolvers();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    deserializerFactoryConfig0.keyDeserializers();
    deserializerFactoryConfig0.deserializerModifiers();
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer2 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer3 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer4 = tokenBuffer0.append(tokenBuffer2);
    assertFalse(tokenBuffer4.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test087196() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test087197() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test088201() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.nextFieldName();
    tokenBuffer_Parser0.getEmbeddedObject();
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test088204() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.nextFieldName();
    tokenBuffer_Parser0.getEmbeddedObject();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test089206() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw(1848, double0);
    String string0 = tokenBuffer0.toString();
    assertEquals(""[TokenBuffer: VALUE_NUMBER_INT, START_ARRAY, VALUE_STRING]"", string0);
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test089207() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw(1848, double0);
    String string0 = tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteTypeId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test089208() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw(1848, double0);
    String string0 = tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test089209() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw(1848, double0);
    String string0 = tokenBuffer0.toString();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test090210() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    RawValue rawValue0 = new RawValue(""F"");
    JsonToken jsonToken0 = JsonToken.START_ARRAY;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(515, jsonToken0, (Object) null, (Object) null, (Object) ""vmG"");
    JsonToken jsonToken1 = JsonToken.END_ARRAY;
    tokenBuffer_Segment1.append(16, jsonToken1, (Object) null, (Object) jsonToken1);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    tokenBuffer_Parser0.getCurrentLocation();
    tokenBuffer_Parser0.nextFieldName();
    tokenBuffer0.writeEndArray();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test091214() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser("""");
    JsonParserSequence jsonParserSequence0 = JsonParserSequence.createFlattened(jsonParser0, jsonParser0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParserSequence0);
    tokenBuffer0.writeNumber((BigDecimal) null);
    tokenBuffer0.firstToken();
    TokenBuffer tokenBuffer1 = new TokenBuffer(jsonParserSequence0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertEquals(31, tokenBuffer2.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test091215() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser("""");
    JsonParserSequence jsonParserSequence0 = JsonParserSequence.createFlattened(jsonParser0, jsonParser0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParserSequence0);
    tokenBuffer0.writeNumber((BigDecimal) null);
    tokenBuffer0.firstToken();
    TokenBuffer tokenBuffer1 = new TokenBuffer(jsonParserSequence0);
    TokenBuffer tokenBuffer2 = tokenBuffer0.append(tokenBuffer1);
    assertEquals(JsonToken.VALUE_NULL, tokenBuffer0.firstToken());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test092220() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    RawValue rawValue0 = new RawValue(""F"");
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.appendRaw(515, 515, (Object) rawValue0);
    JsonToken jsonToken0 = JsonToken.START_ARRAY;
    TokenBuffer.Segment tokenBuffer_Segment2 = tokenBuffer_Segment1.append(515, jsonToken0, (Object) null, (Object) null, (Object) ""vmG"");
    JsonToken jsonToken1 = JsonToken.END_ARRAY;
    TokenBuffer.Segment tokenBuffer_Segment3 = tokenBuffer_Segment2.append(16, jsonToken1, (Object) null, (Object) jsonToken1);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment1, (ObjectCodec) null, true, true);
    int int0 = tokenBuffer_Segment0.rawType((-817));
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test092221() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    RawValue rawValue0 = new RawValue(""F"");
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.appendRaw(515, 515, (Object) rawValue0);
    JsonToken jsonToken0 = JsonToken.START_ARRAY;
    TokenBuffer.Segment tokenBuffer_Segment2 = tokenBuffer_Segment1.append(515, jsonToken0, (Object) null, (Object) null, (Object) ""vmG"");
    JsonToken jsonToken1 = JsonToken.END_ARRAY;
    TokenBuffer.Segment tokenBuffer_Segment3 = tokenBuffer_Segment2.append(16, jsonToken1, (Object) null, (Object) jsonToken1);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment1, (ObjectCodec) null, true, true);
    int int0 = tokenBuffer_Segment0.rawType((-817));
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test093222() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer0.forceUseOfBigDecimal(true);
    tokenBuffer0._appendRaw((-699), """");
    assertEquals(JsonToken.FIELD_NAME, tokenBuffer0.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test093223() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer0.forceUseOfBigDecimal(true);
    tokenBuffer0._appendRaw((-699), """");
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test093224() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer0.forceUseOfBigDecimal(true);
    tokenBuffer0._appendRaw((-699), """");
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
    if (p.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {
        copyCurrentStructure(p);
        return this;
    }
    /* 28-Oct-2014, tatu: As per [databind#592], need to support a special case of starting from
         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need
         *    to assume one did exist.
         */
    JsonToken t;
    writeStartObject();
    do {
        copyCurrentStructure(p);
    } while ((t = p.nextToken()) == JsonToken.FIELD_NAME);
    if (t != JsonToken.END_OBJECT) {
        throw ctxt.mappingException(""Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got "" + t);
    }
    writeEndObject();
    return this;
}","public void test095226() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    // Undeclared exception!
    try {
        tokenBuffer0.deserialize(tokenBuffer_Parser0, deserializationContext0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Helper method used by standard deserializer.
 *
 * @since 2.3
 */"
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test097228() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ArrayNode arrayNode0 = new ArrayNode(jsonNodeFactory0);
    tokenBuffer0.writeTree(arrayNode0);
    tokenBuffer0.writeObject((Object) null);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test097229() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ArrayNode arrayNode0 = new ArrayNode(jsonNodeFactory0);
    tokenBuffer0.writeTree(arrayNode0);
    tokenBuffer0.writeObject((Object) null);
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test097230() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ArrayNode arrayNode0 = new ArrayNode(jsonNodeFactory0);
    tokenBuffer0.writeTree(arrayNode0);
    tokenBuffer0.writeObject((Object) null);
    assertEquals(JsonToken.START_ARRAY, tokenBuffer0.firstToken());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test098231() throws Throwable {
    FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = jsonNodeFactory0.objectNode();
    objectNode1.path(1828);
    tokenBuffer0.writeTree(objectNode0);
    assertEquals(JsonToken.VALUE_EMBEDDED_OBJECT, tokenBuffer0.firstToken());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test098232() throws Throwable {
    FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = jsonNodeFactory0.objectNode();
    objectNode1.path(1828);
    tokenBuffer0.writeTree(objectNode0);
    assertFalse(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test098233() throws Throwable {
    FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = jsonNodeFactory0.objectNode();
    objectNode1.path(1828);
    tokenBuffer0.writeTree(objectNode0);
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test099235() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer0.append(tokenBuffer1);
    tokenBuffer0.writeNumber(1L);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer0.firstToken();
    assertTrue(tokenBuffer0.canWriteTypeId());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test099236() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer0.append(tokenBuffer1);
    tokenBuffer0.writeNumber(1L);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer0.firstToken();
    assertTrue(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test099237() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer0.append(tokenBuffer1);
    tokenBuffer0.writeNumber(1L);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer0.firstToken();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public void writeString(char[] text, int offset, int len) throws IOException {
    writeString(new String(text, offset, len));
}","public void test100238() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    byte byte0 = (byte) (-59);
    Double double0 = new Double((byte) (-59));
    // Undeclared exception!
    try {
        tokenBuffer0.writeString((char[]) null, 304, 304);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"public void serialize(JsonGenerator gen) throws IOException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                gen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                gen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                gen.writeStartObject();
                break;
            case END_OBJECT:
                gen.writeEndObject();
                break;
            case START_ARRAY:
                gen.writeStartArray();
                break;
            case END_ARRAY:
                gen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeFieldName((SerializableString) ob);
                    } else {
                        gen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeString((SerializableString) ob);
                    } else {
                        gen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        gen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        gen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        gen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        gen.writeNumber((Short) n);
                    } else {
                        gen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        gen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        gen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        gen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        gen.writeNull();
                    } else if (n instanceof String) {
                        gen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                gen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                gen.writeBoolean(false);
                break;
            case VALUE_NULL:
                gen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                {
                    Object value = segment.get(ptr);
                    if (value instanceof RawValue) {
                        ((RawValue) value).serialize(gen);
                    } else {
                        gen.writeObject(value);
                    }
                }
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test104243() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper1);
    tokenBuffer0.writeNumberField(""e$"", 9.223372E18F);
    Double double0 = new Double(9.223372E18F);
    // Undeclared exception!
    tokenBuffer0.serialize(tokenBuffer0);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test105244() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    String string0 = tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteTypeId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test105245() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    String string0 = tokenBuffer0.toString();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test105246() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    String string0 = tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteObjectId());
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test105247() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    String string0 = tokenBuffer0.toString();
    assertEquals(""[TokenBuffer: ]"", string0);
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test106248() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer_Segment0.next();
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    SimpleKeyDeserializers simpleKeyDeserializers0 = new SimpleKeyDeserializers();
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    Float float0 = new Float((float) 16);
    tokenBuffer1.writeObject(float0);
    assertFalse(tokenBuffer1.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test106249() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer_Segment0.next();
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    SimpleKeyDeserializers simpleKeyDeserializers0 = new SimpleKeyDeserializers();
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    Float float0 = new Float((float) 16);
    tokenBuffer1.writeObject(float0);
    assertEquals(31, tokenBuffer1.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test106250() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer_Segment0.next();
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    SimpleKeyDeserializers simpleKeyDeserializers0 = new SimpleKeyDeserializers();
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    Float float0 = new Float((float) 16);
    tokenBuffer1.writeObject(float0);
    assertEquals(JsonToken.VALUE_EMBEDDED_OBJECT, tokenBuffer1.firstToken());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test107251() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser("""");
    JsonParserSequence jsonParserSequence0 = JsonParserSequence.createFlattened(jsonParser0, jsonParser0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParserSequence0);
    tokenBuffer0.writeNumber((BigDecimal) null);
    JsonToken jsonToken0 = tokenBuffer0.firstToken();
    assertEquals(JsonToken.VALUE_NULL, jsonToken0);
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test107252() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser("""");
    JsonParserSequence jsonParserSequence0 = JsonParserSequence.createFlattened(jsonParser0, jsonParser0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParserSequence0);
    tokenBuffer0.writeNumber((BigDecimal) null);
    JsonToken jsonToken0 = tokenBuffer0.firstToken();
    TokenBuffer tokenBuffer1 = new TokenBuffer(jsonParserSequence0);
    tokenBuffer0.serialize(tokenBuffer1);
    assertEquals(31, tokenBuffer1.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test107253() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser("""");
    JsonParserSequence jsonParserSequence0 = JsonParserSequence.createFlattened(jsonParser0, jsonParser0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParserSequence0);
    tokenBuffer0.writeNumber((BigDecimal) null);
    JsonToken jsonToken0 = tokenBuffer0.firstToken();
    TokenBuffer tokenBuffer1 = new TokenBuffer(jsonParserSequence0);
    tokenBuffer0.serialize(tokenBuffer1);
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test108255() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    Integer integer0 = new Integer((-528));
    tokenBuffer_Segment0.appendRaw(0, 0, (Object) integer0, (Object) integer0, (Object) integer0);
    tokenBuffer_Segment0._tokenTypes = (-158L);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser((TokenBuffer.Segment) null, (ObjectCodec) null, false, false);
    tokenBuffer_Parser0.getParsingContext();
    TokenBuffer.Parser tokenBuffer_Parser1 = new TokenBuffer.Parser((TokenBuffer.Segment) null, (ObjectCodec) null, false, false);
    tokenBuffer_Parser1.nextTextValue();
    tokenBuffer_Parser1.getTextCharacters();
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer0.asParser((JsonParser) tokenBuffer_Parser1);
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test109256() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory(false);
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = objectNode0.put(""J~?x{N"", (byte[]) null);
    objectNode1.removeAll();
    Float float0 = new Float((-1.0F));
    objectNode1.path(48);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer1.setCharacterEscapes((CharacterEscapes) null);
    BigIntegerNode bigIntegerNode0 = new BigIntegerNode((BigInteger) null);
    bigIntegerNode0.get(500);
    tokenBuffer1.writeTree((TreeNode) null);
    assertEquals(JsonToken.VALUE_NULL, tokenBuffer1.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test109257() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory(false);
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = objectNode0.put(""J~?x{N"", (byte[]) null);
    objectNode1.removeAll();
    Float float0 = new Float((-1.0F));
    objectNode1.path(48);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer1.setCharacterEscapes((CharacterEscapes) null);
    BigIntegerNode bigIntegerNode0 = new BigIntegerNode((BigInteger) null);
    bigIntegerNode0.get(500);
    tokenBuffer1.writeTree((TreeNode) null);
    assertEquals(31, tokenBuffer1.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test109258() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory(false);
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = objectNode0.put(""J~?x{N"", (byte[]) null);
    objectNode1.removeAll();
    Float float0 = new Float((-1.0F));
    objectNode1.path(48);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null);
    tokenBuffer1.setCharacterEscapes((CharacterEscapes) null);
    BigIntegerNode bigIntegerNode0 = new BigIntegerNode((BigInteger) null);
    bigIntegerNode0.get(500);
    tokenBuffer1.writeTree((TreeNode) null);
    assertFalse(tokenBuffer1.canWriteObjectId());
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser p = other.asParser();
    while (p.nextToken() != null) {
        copyCurrentStructure(p);
    }
    return this;
}","public void test110259() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    BeanDeserializerFactory beanDeserializerFactory1 = new BeanDeserializerFactory((DeserializerFactoryConfig) null);
    beanDeserializerFactory1.withConfig((DeserializerFactoryConfig) null);
    BigInteger bigInteger0 = BigInteger.ZERO;
    tokenBuffer0.writeNumber(bigInteger0);
    // Undeclared exception!
    tokenBuffer0.append(tokenBuffer0);
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser p = other.asParser();
    while (p.nextToken() != null) {
        copyCurrentStructure(p);
    }
    return this;
}","public void test111260() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer1 = tokenBuffer0.forceUseOfBigDecimal(true);
    tokenBuffer_Segment0.hasIds();
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    tokenBuffer0.writeStartObject();
    // Undeclared exception!
    tokenBuffer1.append(tokenBuffer0);
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test113263() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer0.writeObjectFieldStart(""Unrecognized filter type ("");
    Double double0 = new Double((byte) (-88));
    tokenBuffer0._appendRaw((byte) (-88), double0);
    String string0 = tokenBuffer0.toString();
    assertEquals(""[TokenBuffer: FIELD_NAME(Unrecognized filter type (), START_OBJECT, VALUE_NUMBER_INT, VALUE_TRUE]"", string0);
}",""
"/*
    /***********************************************************
    /* JsonGenerator implementation: native ids
    /***********************************************************
     */
@Override
public boolean canWriteTypeId() {
    return _hasNativeTypeIds;
}","public void test113264() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer0.writeObjectFieldStart(""Unrecognized filter type ("");
    Double double0 = new Double((byte) (-88));
    tokenBuffer0._appendRaw((byte) (-88), double0);
    String string0 = tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteTypeId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test113265() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer0.writeObjectFieldStart(""Unrecognized filter type ("");
    Double double0 = new Double((byte) (-88));
    tokenBuffer0._appendRaw((byte) (-88), double0);
    String string0 = tokenBuffer0.toString();
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test113266() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer0.writeObjectFieldStart(""Unrecognized filter type ("");
    Double double0 = new Double((byte) (-88));
    tokenBuffer0._appendRaw((byte) (-88), double0);
    String string0 = tokenBuffer0.toString();
    assertTrue(tokenBuffer0.canWriteObjectId());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test114267() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.withExactBigDecimals(true);
    ArrayNode arrayNode0 = new ArrayNode(jsonNodeFactory0);
    JsonParser jsonParser0 = arrayNode0.traverse();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(jsonParser0, (TokenFilter) null, false, true);
    TokenBuffer tokenBuffer0 = new TokenBuffer(filteringParserDelegate0);
    tokenBuffer0.writeString("""");
    tokenBuffer0.writeRawValue(""}8BTrK\""D_s}M"", (-386), 12);
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test114268() throws Throwable {
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.withExactBigDecimals(true);
    ArrayNode arrayNode0 = new ArrayNode(jsonNodeFactory0);
    JsonParser jsonParser0 = arrayNode0.traverse();
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(jsonParser0, (TokenFilter) null, false, true);
    TokenBuffer tokenBuffer0 = new TokenBuffer(filteringParserDelegate0);
    tokenBuffer0.writeString("""");
    tokenBuffer0.writeRawValue(""}8BTrK\""D_s}M"", (-386), 12);
    assertEquals(JsonToken.VALUE_STRING, tokenBuffer0.firstToken());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test115269() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.AUTO_CLOSE_TARGET;
    TokenBuffer tokenBuffer1 = (TokenBuffer) tokenBuffer0.disable(jsonGenerator_Feature0);
    tokenBuffer1.serialize(tokenBuffer0);
    tokenBuffer0._objectCodec = null;
    tokenBuffer0.writeEndArray();
    tokenBuffer0.toString();
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    ObjectNode objectNode1 = jsonNodeFactory0.objectNode();
    objectNode1.path(1828);
    tokenBuffer0.writeTree(objectNode0);
    tokenBuffer0.version();
    assertEquals(30, tokenBuffer0.getFeatureMask());
}",""
"@Override
public boolean canWriteObjectId() {
    return _hasNativeObjectIds;
}","public void test116272() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    tokenBuffer1.writeString((SerializableString) serializedString0);
    tokenBuffer1.writeEndObject();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    objectMapper0.getDeserializationContext();
    tokenBuffer0.writeEndObject();
    JsonToken jsonToken0 = tokenBuffer1.firstToken();
    assertFalse(tokenBuffer1.canWriteObjectId());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test116273() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    tokenBuffer1.writeString((SerializableString) serializedString0);
    tokenBuffer1.writeEndObject();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    objectMapper0.getDeserializationContext();
    tokenBuffer0.writeEndObject();
    JsonToken jsonToken0 = tokenBuffer1.firstToken();
    assertEquals(JsonToken.VALUE_STRING, jsonToken0);
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test116274() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0);
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    tokenBuffer1.writeString((SerializableString) serializedString0);
    tokenBuffer1.writeEndObject();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    objectMapper0.getDeserializationContext();
    tokenBuffer0.writeEndObject();
    JsonToken jsonToken0 = tokenBuffer1.firstToken();
    assertEquals(31, tokenBuffer1.getFeatureMask());
}",""
"@Override
public int getFeatureMask() {
    return _generatorFeatures;
}","public void test117276() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    SerializedString serializedString0 = new SerializedString(""Internal error: should never end up through this code path"");
    tokenBuffer0.writeRawValue((SerializableString) serializedString0);
    tokenBuffer_Parser0.getValueAsString();
    tokenBuffer_Parser0.nextFieldName();
    tokenBuffer0.copyCurrentEvent(tokenBuffer_Parser0);
    assertEquals(31, tokenBuffer0.getFeatureMask());
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test119279() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer tokenBuffer1 = tokenBuffer0.forceUseOfBigDecimal(true);
    JsonToken jsonToken0 = JsonToken.START_OBJECT;
    Short short0 = new Short((short) 46);
    tokenBuffer_Segment0.append(15, jsonToken0, (Object) short0, (Object) null);
    tokenBuffer0.writeString((SerializableString) null);
    tokenBuffer_Segment0.hasIds();
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    BeanDeserializerFactory beanDeserializerFactory1 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    beanDeserializerFactory1.withConfig(deserializerFactoryConfig0);
    tokenBuffer1.append(tokenBuffer0);
    assertEquals(JsonToken.VALUE_NULL, tokenBuffer0.firstToken());
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test120280() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    TokenBuffer tokenBuffer0 = new TokenBuffer(tokenBuffer_Parser0, (DeserializationContext) null);
    tokenBuffer0.writeNumberField((String) null, (double) 16);
    Double double0 = new Double(65.2428724697);
    tokenBuffer0.setCurrentValue(double0);
    tokenBuffer0.writeNumber("""");
    Double double1 = new Double(Double.NaN);
    Byte byte0 = new Byte((byte) 100);
    tokenBuffer0._appendRaw((-402), byte0);
    // Undeclared exception!
    try {
        tokenBuffer0.toString();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.System"", e);
    }
}",""
"public void serialize(JsonGenerator gen) throws IOException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                gen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                gen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                gen.writeStartObject();
                break;
            case END_OBJECT:
                gen.writeEndObject();
                break;
            case START_ARRAY:
                gen.writeStartArray();
                break;
            case END_ARRAY:
                gen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeFieldName((SerializableString) ob);
                    } else {
                        gen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeString((SerializableString) ob);
                    } else {
                        gen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        gen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        gen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        gen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        gen.writeNumber((Short) n);
                    } else {
                        gen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        gen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        gen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        gen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        gen.writeNull();
                    } else if (n instanceof String) {
                        gen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                gen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                gen.writeBoolean(false);
                break;
            case VALUE_NULL:
                gen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                {
                    Object value = segment.get(ptr);
                    if (value instanceof RawValue) {
                        ((RawValue) value).serialize(gen);
                    } else {
                        gen.writeObject(value);
                    }
                }
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test124284() throws Throwable {
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer_Segment0._tokenTypes = 0L;
    TokenBuffer tokenBuffer1 = tokenBuffer0.forceUseOfBigDecimal(true);
    tokenBuffer_Segment0.hasIds();
    objectMapper0.disableDefaultTyping();
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    tokenBuffer0.toString();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    BeanDeserializerFactory beanDeserializerFactory1 = BeanDeserializerFactory.instance;
    tokenBuffer0.writeStartObject();
    // Undeclared exception!
    tokenBuffer1.serialize(tokenBuffer0);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"public void serialize(JsonGenerator gen) throws IOException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                gen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                gen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                gen.writeStartObject();
                break;
            case END_OBJECT:
                gen.writeEndObject();
                break;
            case START_ARRAY:
                gen.writeStartArray();
                break;
            case END_ARRAY:
                gen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeFieldName((SerializableString) ob);
                    } else {
                        gen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeString((SerializableString) ob);
                    } else {
                        gen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        gen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        gen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        gen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        gen.writeNumber((Short) n);
                    } else {
                        gen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        gen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        gen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        gen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        gen.writeNull();
                    } else if (n instanceof String) {
                        gen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                gen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                gen.writeBoolean(false);
                break;
            case VALUE_NULL:
                gen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                {
                    Object value = segment.get(ptr);
                    if (value instanceof RawValue) {
                        ((RawValue) value).serialize(gen);
                    } else {
                        gen.writeObject(value);
                    }
                }
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test125285() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer0.writeNumber(bigDecimal0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    tokenBuffer_Parser0.nextFieldName();
    tokenBuffer_Parser0.getBigIntegerValue();
    SerializedString serializedString0 = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;
    tokenBuffer_Parser0.peekNextToken();
    tokenBuffer0.copyCurrentStructure(tokenBuffer_Parser0);
    JsonGeneratorDelegate jsonGeneratorDelegate0 = new JsonGeneratorDelegate(tokenBuffer0);
    // Undeclared exception!
    tokenBuffer0.serialize(jsonGeneratorDelegate0);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test126286() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    tokenBuffer0.writeNumberField(""/go'+~ro:<"", (-1277.7366F));
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    tokenBuffer_Parser0.nextFieldName();
    tokenBuffer0.toString();
}",""
"@Override
public void copyCurrentStructure(JsonParser jp) throws IOException {
    JsonToken t = jp.getCurrentToken();
    // Let's handle field-name separately first
    if (t == JsonToken.FIELD_NAME) {
        if (_mayHaveNativeIds) {
            _checkNativeIds(jp);
        }
        writeFieldName(jp.getCurrentName());
        t = jp.nextToken();
        // fall-through to copy the associated value
    }
    if (_mayHaveNativeIds) {
        _checkNativeIds(jp);
    }
    switch(t) {
        case START_ARRAY:
            writeStartArray();
            while (jp.nextToken() != JsonToken.END_ARRAY) {
                copyCurrentStructure(jp);
            }
            writeEndArray();
            break;
        case START_OBJECT:
            writeStartObject();
            while (jp.nextToken() != JsonToken.END_OBJECT) {
                copyCurrentStructure(jp);
            }
            writeEndObject();
            break;
        default:
            // others are simple:
            copyCurrentEvent(jp);
    }
}","public void test127287() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, true);
    Double double0 = new Double((byte) (-59));
    tokenBuffer0._appendRaw((byte) (-59), double0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    tokenBuffer_Parser0.nextFieldName();
    // Undeclared exception!
    try {
        tokenBuffer0.copyCurrentStructure(tokenBuffer_Parser0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
@SuppressWarnings(""resource"")
public String toString() {
    // Let's print up to 100 first tokens...
    final int MAX_COUNT = 100;
    StringBuilder sb = new StringBuilder();
    sb.append(""[TokenBuffer: "");
    /*
sb.append(""NativeTypeIds="").append(_hasNativeTypeIds).append("","");
sb.append(""NativeObjectIds="").append(_hasNativeObjectIds).append("","");
*/
    JsonParser jp = asParser();
    int count = 0;
    final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;
    while (true) {
        JsonToken t;
        try {
            t = jp.nextToken();
            if (t == null)
                break;
            if (hasNativeIds) {
                _appendNativeIds(sb);
            }
            if (count < MAX_COUNT) {
                if (count > 0) {
                    sb.append("", "");
                }
                sb.append(t.toString());
                if (t == JsonToken.FIELD_NAME) {
                    sb.append('(');
                    sb.append(jp.getCurrentName());
                    sb.append(')');
                }
            }
        } catch (IOException ioe) {
            // should never occur
            throw new IllegalStateException(ioe);
        }
        ++count;
    }
    if (count >= MAX_COUNT) {
        sb.append("" ... (truncated "").append(count - MAX_COUNT).append("" entries)"");
    }
    sb.append(']');
    return sb.toString();
}","public void test129289() throws Throwable {
    FileSystemHandling.appendLineToFile((EvoSuiteFile) null, (String) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeStringField(""com.fasterxml.jackson.annotation.JsonCreator$Mode"", (String) null);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    tokenBuffer_Parser0.nextFieldName();
    tokenBuffer0.toString();
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test130290() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    FileSystemHandling.createFolder((EvoSuiteFile) null);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null, true);
    tokenBuffer1.serialize((JsonGenerator) null);
    tokenBuffer1.writeNumber(2142.82864046);
    tokenBuffer1.writeNumber(1L);
    tokenBuffer1.serialize(tokenBuffer0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.nextFieldName();
    JsonToken jsonToken0 = JsonToken.VALUE_STRING;
    tokenBuffer_Segment0.appendRaw(0, 0, (Object) null, (Object) ""! vUOMG_S"", (Object) null);
    tokenBuffer_Parser0.getNumberType();
    tokenBuffer1.firstToken();
}",""
"public void serialize(JsonGenerator gen) throws IOException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                gen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                gen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                gen.writeStartObject();
                break;
            case END_OBJECT:
                gen.writeEndObject();
                break;
            case START_ARRAY:
                gen.writeStartArray();
                break;
            case END_ARRAY:
                gen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeFieldName((SerializableString) ob);
                    } else {
                        gen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeString((SerializableString) ob);
                    } else {
                        gen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        gen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        gen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        gen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        gen.writeNumber((Short) n);
                    } else {
                        gen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        gen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        gen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        gen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        gen.writeNull();
                    } else if (n instanceof String) {
                        gen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                gen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                gen.writeBoolean(false);
                break;
            case VALUE_NULL:
                gen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                {
                    Object value = segment.get(ptr);
                    if (value instanceof RawValue) {
                        ((RawValue) value).serialize(gen);
                    } else {
                        gen.writeObject(value);
                    }
                }
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test131291() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    boolean boolean0 = false;
    SerializedString serializedString0 = new SerializedString(""]:/WH"");
    tokenBuffer0._appendRaw(7, serializedString0);
    tokenBuffer0.toString();
    JsonGenerator jsonGenerator0 = tokenBuffer0.setCodec(objectMapper0);
    // Undeclared exception!
    tokenBuffer0.serialize(jsonGenerator0);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"public void serialize(JsonGenerator gen) throws IOException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                gen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                gen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                gen.writeStartObject();
                break;
            case END_OBJECT:
                gen.writeEndObject();
                break;
            case START_ARRAY:
                gen.writeStartArray();
                break;
            case END_ARRAY:
                gen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeFieldName((SerializableString) ob);
                    } else {
                        gen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeString((SerializableString) ob);
                    } else {
                        gen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        gen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        gen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        gen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        gen.writeNumber((Short) n);
                    } else {
                        gen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        gen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        gen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        gen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        gen.writeNull();
                    } else if (n instanceof String) {
                        gen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                gen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                gen.writeBoolean(false);
                break;
            case VALUE_NULL:
                gen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                {
                    Object value = segment.get(ptr);
                    if (value instanceof RawValue) {
                        ((RawValue) value).serialize(gen);
                    } else {
                        gen.writeObject(value);
                    }
                }
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test133293() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    Byte byte0 = new Byte((byte) (-60));
    Class<Integer> class0 = Integer.TYPE;
    RawValue rawValue0 = new RawValue(""Internal error: SimpleType.widenContentsBy() should never be called"");
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.appendRaw(626, 626, (Object) byte0, (Object) class0, (Object) rawValue0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment1, (ObjectCodec) null, false, false);
    SerializedString serializedString0 = new SerializedString(""Internal error: SimpleType.widenContentsBy() should never be called"");
    tokenBuffer0.writeRawValue((SerializableString) serializedString0);
    // Undeclared exception!
    try {
        tokenBuffer0.serialize((JsonGenerator) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.RawValue"", e);
    }
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test135295() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    Double double0 = new Double(0.0);
    tokenBuffer0._appendRaw((-582), double0);
    JsonGenerator jsonGenerator0 = tokenBuffer0.overrideStdFeatures(16, 16);
    tokenBuffer0.serialize(jsonGenerator0);
    tokenBuffer0.writeEndObject();
    tokenBuffer0.firstToken();
}",""
"@Override
public void copyCurrentStructure(JsonParser jp) throws IOException {
    JsonToken t = jp.getCurrentToken();
    // Let's handle field-name separately first
    if (t == JsonToken.FIELD_NAME) {
        if (_mayHaveNativeIds) {
            _checkNativeIds(jp);
        }
        writeFieldName(jp.getCurrentName());
        t = jp.nextToken();
        // fall-through to copy the associated value
    }
    if (_mayHaveNativeIds) {
        _checkNativeIds(jp);
    }
    switch(t) {
        case START_ARRAY:
            writeStartArray();
            while (jp.nextToken() != JsonToken.END_ARRAY) {
                copyCurrentStructure(jp);
            }
            writeEndArray();
            break;
        case START_OBJECT:
            writeStartObject();
            while (jp.nextToken() != JsonToken.END_OBJECT) {
                copyCurrentStructure(jp);
            }
            writeEndObject();
            break;
        default:
            // others are simple:
            copyCurrentEvent(jp);
    }
}","public void test137297() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    BigDecimal bigDecimal0 = BigDecimal.ONE;
    tokenBuffer0.writeNumber(bigDecimal0);
    tokenBuffer0.toString();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    tokenBuffer_Parser0.nextTextValue();
    tokenBuffer_Parser0.getValueAsString();
    tokenBuffer0.copyCurrentStructure(tokenBuffer_Parser0);
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser p = other.asParser();
    while (p.nextToken() != null) {
        copyCurrentStructure(p);
    }
    return this;
}","public void test139299() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0, false);
    tokenBuffer1.writeNumber("" noJ#f1UP&1}3I8s"");
    tokenBuffer0.serialize(tokenBuffer1);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.nextFieldName();
    // Undeclared exception!
    try {
        tokenBuffer0.append(tokenBuffer1);
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // For input string: \"" noJ#f1UP&1}3I8s\""
        //
        verifyException(""java.lang.NumberFormatException"", e);
    }
}",""
"@Override
public void copyCurrentStructure(JsonParser jp) throws IOException {
    JsonToken t = jp.getCurrentToken();
    // Let's handle field-name separately first
    if (t == JsonToken.FIELD_NAME) {
        if (_mayHaveNativeIds) {
            _checkNativeIds(jp);
        }
        writeFieldName(jp.getCurrentName());
        t = jp.nextToken();
        // fall-through to copy the associated value
    }
    if (_mayHaveNativeIds) {
        _checkNativeIds(jp);
    }
    switch(t) {
        case START_ARRAY:
            writeStartArray();
            while (jp.nextToken() != JsonToken.END_ARRAY) {
                copyCurrentStructure(jp);
            }
            writeEndArray();
            break;
        case START_OBJECT:
            writeStartObject();
            while (jp.nextToken() != JsonToken.END_OBJECT) {
                copyCurrentStructure(jp);
            }
            writeEndObject();
            break;
        default:
            // others are simple:
            copyCurrentEvent(jp);
    }
}","public void test143303() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    tokenBuffer0.writeNumber(1L);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    tokenBuffer_Parser0.nextTextValue();
    tokenBuffer_Parser0.getValueAsString();
    tokenBuffer0.copyCurrentStructure(tokenBuffer_Parser0);
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test144304() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    SerializedString serializedString0 = new SerializedString(""OD}ia{mXpg,[vd;Juy"");
    tokenBuffer0.writeRawValue((SerializableString) serializedString0);
    tokenBuffer0.toString();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    tokenBuffer_Parser0.nextTextValue();
    tokenBuffer_Parser0.getValueAsString();
    tokenBuffer0.firstToken();
}",""
"/*
    /**********************************************************
    /* Additional accessors
    /**********************************************************
     */
public JsonToken firstToken() {
    if (_first != null) {
        return _first.type(0);
    }
    return null;
}","public void test145305() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    Byte byte0 = new Byte((byte) (-60));
    Class<Integer> class0 = Integer.TYPE;
    RawValue rawValue0 = new RawValue(""Internal error: SimpleType.widenContentsBy() should never be called"");
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.appendRaw(626, 626, (Object) byte0, (Object) class0, (Object) rawValue0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment1, (ObjectCodec) null, false, false);
    SerializedString serializedString0 = new SerializedString(""Internal error:VSimpleType.widenContentsBy() should never be called"");
    tokenBuffer0.writeRawValue((SerializableString) serializedString0);
    tokenBuffer0.toString();
    tokenBuffer_Parser0.nextTextValue();
    tokenBuffer_Parser0.getValueAsString();
    tokenBuffer_Parser0.nextFieldName();
    tokenBuffer0.copyCurrentEvent(tokenBuffer_Parser0);
    tokenBuffer0.firstToken();
}",""
"@Override
public void copyCurrentStructure(JsonParser jp) throws IOException {
    JsonToken t = jp.getCurrentToken();
    // Let's handle field-name separately first
    if (t == JsonToken.FIELD_NAME) {
        if (_mayHaveNativeIds) {
            _checkNativeIds(jp);
        }
        writeFieldName(jp.getCurrentName());
        t = jp.nextToken();
        // fall-through to copy the associated value
    }
    if (_mayHaveNativeIds) {
        _checkNativeIds(jp);
    }
    switch(t) {
        case START_ARRAY:
            writeStartArray();
            while (jp.nextToken() != JsonToken.END_ARRAY) {
                copyCurrentStructure(jp);
            }
            writeEndArray();
            break;
        case START_OBJECT:
            writeStartObject();
            while (jp.nextToken() != JsonToken.END_OBJECT) {
                copyCurrentStructure(jp);
            }
            writeEndObject();
            break;
        default:
            // others are simple:
            copyCurrentEvent(jp);
    }
}","public void test146306() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    SerializedString serializedString0 = new SerializedString(""O}ia{mXpg,T3[vd;Juy"");
    tokenBuffer0._appendRaw(7, tokenBuffer_Segment0);
    tokenBuffer0.toString();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, true);
    tokenBuffer_Parser0.nextTextValue();
    tokenBuffer_Parser0.getValueAsString();
    // Undeclared exception!
    try {
        tokenBuffer0.copyCurrentStructure((JsonParser) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
public void copyCurrentStructure(JsonParser jp) throws IOException {
    JsonToken t = jp.getCurrentToken();
    // Let's handle field-name separately first
    if (t == JsonToken.FIELD_NAME) {
        if (_mayHaveNativeIds) {
            _checkNativeIds(jp);
        }
        writeFieldName(jp.getCurrentName());
        t = jp.nextToken();
        // fall-through to copy the associated value
    }
    if (_mayHaveNativeIds) {
        _checkNativeIds(jp);
    }
    switch(t) {
        case START_ARRAY:
            writeStartArray();
            while (jp.nextToken() != JsonToken.END_ARRAY) {
                copyCurrentStructure(jp);
            }
            writeEndArray();
            break;
        case START_OBJECT:
            writeStartObject();
            while (jp.nextToken() != JsonToken.END_OBJECT) {
                copyCurrentStructure(jp);
            }
            writeEndObject();
            break;
        default:
            // others are simple:
            copyCurrentEvent(jp);
    }
}","public void test147307() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null, false);
    tokenBuffer0.writeNumber(1L);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, false, false);
    tokenBuffer_Parser0.nextFieldName();
    tokenBuffer0.copyCurrentStructure(tokenBuffer_Parser0);
}",""
"/*
    /**********************************************************
    /* JsonGenerator implementation; pass-through copy
    /**********************************************************
     */
@Override
public void copyCurrentEvent(JsonParser p) throws IOException {
    if (_mayHaveNativeIds) {
        _checkNativeIds(p);
    }
    switch(p.getCurrentToken()) {
        case START_OBJECT:
            writeStartObject();
            break;
        case END_OBJECT:
            writeEndObject();
            break;
        case START_ARRAY:
            writeStartArray();
            break;
        case END_ARRAY:
            writeEndArray();
            break;
        case FIELD_NAME:
            writeFieldName(p.getCurrentName());
            break;
        case VALUE_STRING:
            if (p.hasTextCharacters()) {
                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());
            } else {
                writeString(p.getText());
            }
            break;
        case VALUE_NUMBER_INT:
            switch(p.getNumberType()) {
                case INT:
                    writeNumber(p.getIntValue());
                    break;
                case BIG_INTEGER:
                    writeNumber(p.getBigIntegerValue());
                    break;
                default:
                    writeNumber(p.getLongValue());
            }
            break;
        case VALUE_NUMBER_FLOAT:
            if (_forceBigDecimal) {
                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying
                 *   number is already decoded into a number (in which case might as well
                 *   access as number); or is still retained as text (in which case we
                 *   should further defer decoding that may not need BigDecimal):
                 */
                writeNumber(p.getDecimalValue());
            } else {
                switch(p.getNumberType()) {
                    case BIG_DECIMAL:
                        writeNumber(p.getDecimalValue());
                        break;
                    case FLOAT:
                        writeNumber(p.getFloatValue());
                        break;
                    default:
                        writeNumber(p.getDoubleValue());
                }
            }
            break;
        case VALUE_TRUE:
            writeBoolean(true);
            break;
        case VALUE_FALSE:
            writeBoolean(false);
            break;
        case VALUE_NULL:
            writeNull();
            break;
        case VALUE_EMBEDDED_OBJECT:
            writeObject(p.getEmbeddedObject());
            break;
        default:
            throw new RuntimeException(""Internal error: should never end up through this code path"");
    }
}","public void test148308() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = new TokenBuffer.Segment();
    Byte byte0 = new Byte((byte) (-60));
    Class<Integer> class0 = Integer.TYPE;
    RawValue rawValue0 = new RawValue(""Internal error: SimpleType.widenContentsBy() should never be called"");
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.appendRaw(626, 626, (Object) byte0, (Object) class0, (Object) rawValue0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment1, (ObjectCodec) null, false, false);
    SerializedString serializedString0 = new SerializedString(""Internal error: SimpleType.widenContentsBy() should never be called"");
    tokenBuffer0.writeRawValue((SerializableString) serializedString0);
    tokenBuffer_Parser0.getValueAsString();
    tokenBuffer_Parser0.nextFieldName();
    tokenBuffer0.copyCurrentEvent(tokenBuffer_Parser0);
}",""
"@Override
public void copyCurrentStructure(JsonParser jp) throws IOException {
    JsonToken t = jp.getCurrentToken();
    // Let's handle field-name separately first
    if (t == JsonToken.FIELD_NAME) {
        if (_mayHaveNativeIds) {
            _checkNativeIds(jp);
        }
        writeFieldName(jp.getCurrentName());
        t = jp.nextToken();
        // fall-through to copy the associated value
    }
    if (_mayHaveNativeIds) {
        _checkNativeIds(jp);
    }
    switch(t) {
        case START_ARRAY:
            writeStartArray();
            while (jp.nextToken() != JsonToken.END_ARRAY) {
                copyCurrentStructure(jp);
            }
            writeEndArray();
            break;
        case START_OBJECT:
            writeStartObject();
            while (jp.nextToken() != JsonToken.END_OBJECT) {
                copyCurrentStructure(jp);
            }
            writeEndObject();
            break;
        default:
            // others are simple:
            copyCurrentEvent(jp);
    }
}","public void test149309() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonParser.Feature[] jsonParser_FeatureArray0 = new JsonParser.Feature[1];
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS;
    jsonParser_FeatureArray0[0] = jsonParser_Feature0;
    ObjectMapper objectMapper1 = objectMapper0.disable(jsonParser_FeatureArray0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;
    ObjectMapper objectMapper2 = objectMapper1.disable(deserializationFeature0);
    SimpleFilterProvider simpleFilterProvider0 = new SimpleFilterProvider();
    Class<Short>[] classArray0 = (Class<Short>[]) Array.newInstance(Class.class, 1);
    Class<Short> class0 = Short.class;
    classArray0[0] = class0;
    objectMapper2.registerSubtypes(classArray0);
    SimpleFilterProvider simpleFilterProvider1 = simpleFilterProvider0.setDefaultFilter((SimpleBeanPropertyFilter) null);
    ObjectMapper objectMapper3 = objectMapper2.setFilterProvider(simpleFilterProvider1);
    FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    objectMapper3.acceptJsonFormatVisitor((Class<?>) class0, (JsonFormatVisitorWrapper) jsonFormatVisitorWrapper_Base0);
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper3, true);
    POJONode pOJONode0 = new POJONode(simpleFilterProvider1);
    tokenBuffer0.writeTree(pOJONode0);
    JsonParser jsonParser0 = objectMapper3.treeAsTokens(pOJONode0);
    // Undeclared exception!
    try {
        tokenBuffer0.copyCurrentStructure(jsonParser0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.TokenBuffer"", e);
    }
}",""
"public void serialize(JsonGenerator gen) throws IOException {
    Segment segment = _first;
    int ptr = -1;
    final boolean checkIds = _mayHaveNativeIds;
    boolean hasIds = checkIds && (segment.hasIds());
    while (true) {
        if (++ptr >= Segment.TOKENS_PER_SEGMENT) {
            ptr = 0;
            segment = segment.next();
            if (segment == null)
                break;
            hasIds = checkIds && (segment.hasIds());
        }
        JsonToken t = segment.type(ptr);
        if (t == null)
            break;
        if (hasIds) {
            Object id = segment.findObjectId(ptr);
            if (id != null) {
                gen.writeObjectId(id);
            }
            id = segment.findTypeId(ptr);
            if (id != null) {
                gen.writeTypeId(id);
            }
        }
        // Note: copied from 'copyCurrentEvent'...
        switch(t) {
            case START_OBJECT:
                gen.writeStartObject();
                break;
            case END_OBJECT:
                gen.writeEndObject();
                break;
            case START_ARRAY:
                gen.writeStartArray();
                break;
            case END_ARRAY:
                gen.writeEndArray();
                break;
            case FIELD_NAME:
                {
                    // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeFieldName((SerializableString) ob);
                    } else {
                        gen.writeFieldName((String) ob);
                    }
                }
                break;
            case VALUE_STRING:
                {
                    Object ob = segment.get(ptr);
                    if (ob instanceof SerializableString) {
                        gen.writeString((SerializableString) ob);
                    } else {
                        gen.writeString((String) ob);
                    }
                }
                break;
            case VALUE_NUMBER_INT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Integer) {
                        gen.writeNumber((Integer) n);
                    } else if (n instanceof BigInteger) {
                        gen.writeNumber((BigInteger) n);
                    } else if (n instanceof Long) {
                        gen.writeNumber((Long) n);
                    } else if (n instanceof Short) {
                        gen.writeNumber((Short) n);
                    } else {
                        gen.writeNumber(((Number) n).intValue());
                    }
                }
                break;
            case VALUE_NUMBER_FLOAT:
                {
                    Object n = segment.get(ptr);
                    if (n instanceof Double) {
                        gen.writeNumber(((Double) n).doubleValue());
                    } else if (n instanceof BigDecimal) {
                        gen.writeNumber((BigDecimal) n);
                    } else if (n instanceof Float) {
                        gen.writeNumber(((Float) n).floatValue());
                    } else if (n == null) {
                        gen.writeNull();
                    } else if (n instanceof String) {
                        gen.writeNumber((String) n);
                    } else {
                        throw new JsonGenerationException(""Unrecognized value type for VALUE_NUMBER_FLOAT: "" + n.getClass().getName() + "", can not serialize"");
                    }
                }
                break;
            case VALUE_TRUE:
                gen.writeBoolean(true);
                break;
            case VALUE_FALSE:
                gen.writeBoolean(false);
                break;
            case VALUE_NULL:
                gen.writeNull();
                break;
            case VALUE_EMBEDDED_OBJECT:
                {
                    Object value = segment.get(ptr);
                    if (value instanceof RawValue) {
                        ((RawValue) value).serialize(gen);
                    } else {
                        gen.writeObject(value);
                    }
                }
                break;
            default:
                throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }
}","public void test150310() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeNumber((short) (-4757));
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._last;
    Double double0 = new Double(16);
    tokenBuffer0._appendRaw(40, double0);
    // Undeclared exception!
    tokenBuffer0.serialize(tokenBuffer0);
}","/**
 *  Helper method that will write all contents of this buffer
 *  using given {@link JsonGenerator}.
 * <p>
 *  Note: this method would be enough to implement
 *  <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;
 *  but we can not have upwards
 *  references (from core to mapper package); and as such we also
 *  can not take second argument.
 */"
"public final Base64Variant getBase64Variant() {
    return _config.getBase64Variant();
}","public void test154314() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    tokenBuffer0.writeStringField("",'~"", ""Z&;<`9O/`T"");
    SerializedString serializedString0 = new SerializedString("",'~"");
    tokenBuffer0.writeRawValue((SerializableString) serializedString0);
    tokenBuffer0.toString();
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    JsonToken jsonToken0 = JsonToken.VALUE_FALSE;
    BigInteger bigInteger0 = BigInteger.TEN;
    TokenBuffer.Segment tokenBuffer_Segment1 = tokenBuffer_Segment0.append(3101, jsonToken0, (Object) bigInteger0, (Object) tokenBuffer0);
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment1, objectMapper0, true, true);
    TokenBuffer.Parser tokenBuffer_Parser1 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, true, true);
    tokenBuffer_Parser1.nextTextValue();
    tokenBuffer_Parser0.getValueAsString();
    tokenBuffer_Parser0.nextFieldName();
    tokenBuffer0.copyCurrentEvent(tokenBuffer_Parser1);
    tokenBuffer0.firstToken();
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    // Undeclared exception!
    try {
        defaultDeserializationContext_Impl0.getBase64Variant();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}","/**
 *  Convenience method for accessing the default Base64 encoding
 *  used for decoding base64 encoded binary content.
 *  Same as calling:
 * <pre>
 *   getConfig().getBase64Variant();
 * </pre>
 */"
"@Override
public void copyCurrentStructure(JsonParser jp) throws IOException {
    JsonToken t = jp.getCurrentToken();
    // Let's handle field-name separately first
    if (t == JsonToken.FIELD_NAME) {
        if (_mayHaveNativeIds) {
            _checkNativeIds(jp);
        }
        writeFieldName(jp.getCurrentName());
        t = jp.nextToken();
        // fall-through to copy the associated value
    }
    if (_mayHaveNativeIds) {
        _checkNativeIds(jp);
    }
    switch(t) {
        case START_ARRAY:
            writeStartArray();
            while (jp.nextToken() != JsonToken.END_ARRAY) {
                copyCurrentStructure(jp);
            }
            writeEndArray();
            break;
        case START_OBJECT:
            writeStartObject();
            while (jp.nextToken() != JsonToken.END_OBJECT) {
                copyCurrentStructure(jp);
            }
            writeEndObject();
            break;
        default:
            // others are simple:
            copyCurrentEvent(jp);
    }
}","public void test156316() throws Throwable {
    FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer0.writeStringField(""dv0Qyw"", ""dv0Qyw"");
    SerializedString serializedString0 = new SerializedString(""O}ia{mXpg,T3[vd;Juy"");
    tokenBuffer0._appendRaw(708, ""dv0Qyw"");
    tokenBuffer0.toString();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, (ObjectCodec) null, true, true);
    tokenBuffer_Parser0.nextTextValue();
    tokenBuffer_Parser0.getText();
    tokenBuffer0.copyCurrentStructure(tokenBuffer_Parser0);
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser p = other.asParser();
    while (p.nextToken() != null) {
        copyCurrentStructure(p);
    }
    return this;
}","public void test157317() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    BigDecimal bigDecimal0 = new BigDecimal(16);
    tokenBuffer0.writeNumber(bigDecimal0);
    tokenBuffer0.writeStringField(""Unrecognized value type for VALUE_NUMBER_FLOAT: "", ""Unrecognized value type for VALUE_NUMBER_FLOAT: "");
    tokenBuffer0.writeNull();
    tokenBuffer0.writeNumber(bigDecimal0);
    tokenBuffer0.writeStartObject();
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    tokenBuffer0.writeNumber(16);
    beanDeserializerFactory0.withConfig((DeserializerFactoryConfig) null);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null, true);
    BigInteger bigInteger0 = BigInteger.ONE;
    tokenBuffer0.writeNumber(bigInteger0);
    // Undeclared exception!
    try {
        tokenBuffer1.append(tokenBuffer0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser p = other.asParser();
    while (p.nextToken() != null) {
        copyCurrentStructure(p);
    }
    return this;
}","public void test158318() throws Throwable {
    TokenBuffer tokenBuffer0 = new TokenBuffer((ObjectCodec) null);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer0.writeStringField(""dv0Qyw"", ""dv0Qyw"");
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    beanDeserializerFactory0.withConfig((DeserializerFactoryConfig) null);
    TokenBuffer tokenBuffer1 = new TokenBuffer((ObjectCodec) null, true);
    JsonToken jsonToken0 = JsonToken.START_OBJECT;
    tokenBuffer1._append(jsonToken0, (Object) null);
    BigInteger bigInteger0 = BigInteger.ZERO;
    tokenBuffer0.writeNumber(bigInteger0);
    tokenBuffer1.append(tokenBuffer0);
}",""
"/*
    /**********************************************************
    /* Other custom methods not needed for implementing interfaces
    /**********************************************************
     */
/**
 * Helper method that will append contents of given buffer into this
 * buffer.
 * Not particularly optimized; can be made faster if there is need.
 *
 * @return This buffer
 */
@SuppressWarnings(""resource"")
public TokenBuffer append(TokenBuffer other) throws IOException {
    // Important? If source has native ids, need to store
    if (!_hasNativeTypeIds) {
        _hasNativeTypeIds = other.canWriteTypeId();
    }
    if (!_hasNativeObjectIds) {
        _hasNativeObjectIds = other.canWriteObjectId();
    }
    _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;
    JsonParser p = other.asParser();
    while (p.nextToken() != null) {
        copyCurrentStructure(p);
    }
    return this;
}","public void test159319() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer tokenBuffer1 = new TokenBuffer(objectMapper0, false);
    tokenBuffer1.writeNumber("" noJ#f1UP&1}3I8s"");
    tokenBuffer0.serialize(tokenBuffer1);
    tokenBuffer1.serialize(tokenBuffer0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, false);
    tokenBuffer_Parser0.nextFieldName();
    // Undeclared exception!
    try {
        tokenBuffer0.append(tokenBuffer1);
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // For input string: \"" noJ#f1UP&1}3I8s\""
        //
        verifyException(""java.lang.NumberFormatException"", e);
    }
}",""
"@Override
public void copyCurrentStructure(JsonParser jp) throws IOException {
    JsonToken t = jp.getCurrentToken();
    // Let's handle field-name separately first
    if (t == JsonToken.FIELD_NAME) {
        if (_mayHaveNativeIds) {
            _checkNativeIds(jp);
        }
        writeFieldName(jp.getCurrentName());
        t = jp.nextToken();
        // fall-through to copy the associated value
    }
    if (_mayHaveNativeIds) {
        _checkNativeIds(jp);
    }
    switch(t) {
        case START_ARRAY:
            writeStartArray();
            while (jp.nextToken() != JsonToken.END_ARRAY) {
                copyCurrentStructure(jp);
            }
            writeEndArray();
            break;
        case START_OBJECT:
            writeStartObject();
            while (jp.nextToken() != JsonToken.END_OBJECT) {
                copyCurrentStructure(jp);
            }
            writeEndObject();
            break;
        default:
            // others are simple:
            copyCurrentEvent(jp);
    }
}","public void test160320() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenBuffer tokenBuffer0 = new TokenBuffer(objectMapper0);
    TokenBuffer.Segment tokenBuffer_Segment0 = tokenBuffer0._first;
    tokenBuffer0.writeArrayFieldStart(""#`g"");
    tokenBuffer0.writeStringField(""dv0Qyw"", ""dv0Qyw"");
    SerializedString serializedString0 = new SerializedString(""dv0Qyw"");
    tokenBuffer0.toString();
    TokenBuffer.Parser tokenBuffer_Parser0 = new TokenBuffer.Parser(tokenBuffer_Segment0, objectMapper0, false, true);
    tokenBuffer_Parser0.nextTextValue();
    tokenBuffer_Parser0.getValueAsString();
    // Undeclared exception!
    tokenBuffer0.copyCurrentStructure(tokenBuffer_Parser0);
}",""
