focal_method,test_prefix,docstring
"@SuppressWarnings(""resource"")
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {
    ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());
    try {
        _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);
    } catch (JsonProcessingException e) {
        // to support [JACKSON-758]
        throw e;
    } catch (IOException e) {
        // shouldn't really happen, but is declared as possibility so:
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    byte[] result = bb.toByteArray();
    bb.release();
    return result;
}","public void test000() throws Throwable {
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer((JavaType) null, (JsonDeserializer<Object>) null, (TypeDeserializer) null, jsonLocationInstantiator0);
    ObjectMapper objectMapper0 = new ObjectMapper();
    try {
        objectMapper0.writeValueAsBytes(collectionDeserializer0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // (was java.lang.NullPointerException) (through reference chain: com.fasterxml.jackson.databind.deser.std.CollectionDeserializer[\""contentType\""])
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Method that can be used to serialize any Java value as
 *  a byte array. Functionally equivalent to calling
 *  {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}
 *  and getting bytes, but more efficient.
 *  Encoding used will be UTF-8.
 * <p>
 *  Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
 */"
"@Override
public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {
    // In future could check current token... for now this should be enough:
    return typeDeserializer.deserializeTypedFromArray(jp, ctxt);
}","public void test011() throws Throwable {
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    ArrayNode arrayNode0 = new ArrayNode((JsonNodeFactory) null);
    JsonParser jsonParser0 = arrayNode0.traverse();
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer((JavaType) null, (JsonDeserializer<Object>) null, (TypeDeserializer) null, jsonLocationInstantiator0);
    // Undeclared exception!
    try {
        collectionDeserializer0.deserializeWithType(jsonParser0, (DeserializationContext) null, (TypeDeserializer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.CollectionDeserializer"", e);
    }
}",""
"// Important: do NOT cache if polymorphic values
// since 2.5
@Override
public boolean isCachable() {
    // 26-Mar-2015, tatu: As per [databind#735], need to be careful
    return (_valueDeserializer == null) && (_valueTypeDeserializer == null) && (_delegateDeserializer == null);
}","public void test022() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    Class<SettableBeanProperty> class0 = SettableBeanProperty.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer(resolvedRecursiveType0, (JsonDeserializer<Object>) null, (TypeDeserializer) null, jsonLocationInstantiator0);
    CollectionDeserializer collectionDeserializer1 = new CollectionDeserializer(collectionDeserializer0);
    assertTrue(collectionDeserializer1.isCachable());
}",""
"/*
    /**********************************************************
    /* Overrides
    /**********************************************************
     */
@Override
public SettableBeanProperty findBackReference(String refName) {
    JsonDeserializer<Object> valueDeser = getContentDeserializer();
    if (valueDeser == null) {
        throw new IllegalArgumentException(""Can not handle managed/back reference '"" + refName + ""': type: container deserializer of type "" + getClass().getName() + "" returned null for 'getContentDeserializer()'"");
    }
    return valueDeser.findBackReference(refName);
}","public void test033() throws Throwable {
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer((JavaType) null, (JsonDeserializer<Object>) null, (TypeDeserializer) null, jsonLocationInstantiator0);
    // Undeclared exception!
    try {
        collectionDeserializer0.findBackReference(""M}.Zg#SH!.h#p1YWd"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not handle managed/back reference 'M}.Zg#SH!.h#p1YWd': type: container deserializer of type com.fasterxml.jackson.databind.deser.std.CollectionDeserializer returned null for 'getContentDeserializer()'
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase"", e);
    }
}",""
"// since 2.7 -- will not retain ""unwrapSingle"" setting
@Deprecated
protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd) {
    return withResolved(dd, vd, vtd, _unwrapSingle);
}","public void test044() throws Throwable {
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer((JavaType) null, (JsonDeserializer<Object>) null, (TypeDeserializer) null, (ValueInstantiator) null);
    CollectionDeserializer collectionDeserializer1 = collectionDeserializer0.withResolved((JsonDeserializer<?>) null, (JsonDeserializer<?>) null, (TypeDeserializer) null);
    assertSame(collectionDeserializer1, collectionDeserializer0);
}","/**
 * @deprecated Since 2.7 as it does not pass `unwrapSingle`
 */"
"// Important: do NOT cache if polymorphic values
// since 2.5
@Override
public boolean isCachable() {
    // 26-Mar-2015, tatu: As per [databind#735], need to be careful
    return (_valueDeserializer == null) && (_valueTypeDeserializer == null) && (_delegateDeserializer == null);
}","public void test055() throws Throwable {
    Class<Object> class0 = Object.class;
    TypeBindings typeBindings0 = TypeBindings.create(class0, (JavaType[]) null);
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer(resolvedRecursiveType0, (JsonDeserializer<Object>) null, (TypeDeserializer) null, jsonLocationInstantiator0);
    Boolean boolean0 = Boolean.TRUE;
    CollectionDeserializer collectionDeserializer1 = collectionDeserializer0.withResolved((JsonDeserializer<?>) null, collectionDeserializer0, (TypeDeserializer) null, boolean0);
    boolean boolean1 = collectionDeserializer1.isCachable();
    assertFalse(boolean1);
}",""
"// Important: do NOT cache if polymorphic values
// since 2.5
@Override
public boolean isCachable() {
    // 26-Mar-2015, tatu: As per [databind#735], need to be careful
    return (_valueDeserializer == null) && (_valueTypeDeserializer == null) && (_delegateDeserializer == null);
}","public void test066() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    Class<SimpleModule> class0 = SimpleModule.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer(resolvedRecursiveType0, (JsonDeserializer<Object>) null, (TypeDeserializer) null, jsonLocationInstantiator0);
    Boolean boolean0 = Boolean.TRUE;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(resolvedRecursiveType0, typeFactory0);
    Class<Integer> class1 = Integer.class;
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.WRAPPER_OBJECT;
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(resolvedRecursiveType0, classNameIdResolver0, ""0ZtIb{8$scA&Gfjc;5B"", true, class1, jsonTypeInfo_As0);
    CollectionDeserializer collectionDeserializer1 = collectionDeserializer0.withResolved((JsonDeserializer<?>) null, (JsonDeserializer<?>) null, asPropertyTypeDeserializer0, boolean0);
    assertFalse(collectionDeserializer1.isCachable());
}",""
"@SuppressWarnings(""unchecked"")
protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd, Boolean unwrapSingle) {
    if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer) && (_unwrapSingle == unwrapSingle)) {
        return this;
    }
    return new CollectionDeserializer(_collectionType, (JsonDeserializer<Object>) vd, vtd, _valueInstantiator, (JsonDeserializer<Object>) dd, unwrapSingle);
}","public void test077() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    Class<Object> class0 = Object.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer(resolvedRecursiveType0, (JsonDeserializer<Object>) null, (TypeDeserializer) null, jsonLocationInstantiator0);
    Boolean boolean0 = Boolean.TRUE;
    CollectionDeserializer collectionDeserializer1 = collectionDeserializer0.withResolved((JsonDeserializer<?>) null, (JsonDeserializer<?>) null, (TypeDeserializer) null, boolean0);
    assertNotSame(collectionDeserializer1, collectionDeserializer0);
}","/**
 * Fluent-factory method call to construct contextual instance.
 *
 * @since 2.7
 */"
"// Important: do NOT cache if polymorphic values
// since 2.5
@Override
public boolean isCachable() {
    // 26-Mar-2015, tatu: As per [databind#735], need to be careful
    return (_valueDeserializer == null) && (_valueTypeDeserializer == null) && (_delegateDeserializer == null);
}","public void test088() throws Throwable {
    Class<Object> class0 = Object.class;
    TypeBindings typeBindings0 = TypeBindings.create(class0, (JavaType[]) null);
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<RuntimeException> class1 = RuntimeException.class;
    JavaType javaType0 = typeFactory0.constructReferenceType(class1, resolvedRecursiveType0);
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(resolvedRecursiveType0, typeFactory0);
    Class<BooleanNode> class2 = BooleanNode.class;
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.WRAPPER_OBJECT;
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(javaType0, classNameIdResolver0, ""_ahMC~QJ9{m+JF^PXH"", true, class2, jsonTypeInfo_As0);
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer(resolvedRecursiveType0, (JsonDeserializer<Object>) null, asPropertyTypeDeserializer0, jsonLocationInstantiator0);
    boolean boolean0 = collectionDeserializer0.isCachable();
    assertFalse(boolean0);
}",""
"// Important: do NOT cache if polymorphic values
// since 2.5
@Override
public boolean isCachable() {
    // 26-Mar-2015, tatu: As per [databind#735], need to be careful
    return (_valueDeserializer == null) && (_valueTypeDeserializer == null) && (_delegateDeserializer == null);
}","public void test099() throws Throwable {
    Class<InputStream> class0 = InputStream.class;
    JavaType[] javaTypeArray0 = new JavaType[0];
    TypeBindings typeBindings0 = TypeBindings.create(class0, javaTypeArray0);
    Class<RuntimeException> class1 = RuntimeException.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class1, typeBindings0);
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer(resolvedRecursiveType0, (JsonDeserializer<Object>) null, (TypeDeserializer) null, jsonLocationInstantiator0);
    Boolean boolean0 = Boolean.TRUE;
    CollectionDeserializer collectionDeserializer1 = collectionDeserializer0.withResolved(collectionDeserializer0, (JsonDeserializer<?>) null, (TypeDeserializer) null, boolean0);
    boolean boolean1 = collectionDeserializer1.isCachable();
    assertTrue(collectionDeserializer0.isCachable());
}",""
"// Important: do NOT cache if polymorphic values
// since 2.5
@Override
public boolean isCachable() {
    // 26-Mar-2015, tatu: As per [databind#735], need to be careful
    return (_valueDeserializer == null) && (_valueTypeDeserializer == null) && (_delegateDeserializer == null);
}","public void test0910() throws Throwable {
    Class<InputStream> class0 = InputStream.class;
    JavaType[] javaTypeArray0 = new JavaType[0];
    TypeBindings typeBindings0 = TypeBindings.create(class0, javaTypeArray0);
    Class<RuntimeException> class1 = RuntimeException.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class1, typeBindings0);
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer(resolvedRecursiveType0, (JsonDeserializer<Object>) null, (TypeDeserializer) null, jsonLocationInstantiator0);
    Boolean boolean0 = Boolean.TRUE;
    CollectionDeserializer collectionDeserializer1 = collectionDeserializer0.withResolved(collectionDeserializer0, (JsonDeserializer<?>) null, (TypeDeserializer) null, boolean0);
    boolean boolean1 = collectionDeserializer1.isCachable();
    assertFalse(boolean1);
}",""
"/*
    /**********************************************************
    /* Validation, post-processing (ResolvableDeserializer)
    /**********************************************************
     */
/**
 * Method called to finalize setup of this deserializer,
 * when it is known for which property deserializer is needed
 * for.
 */
@Override
public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {
    // May need to resolve types for delegate-based creators:
    JsonDeserializer<Object> delegateDeser = null;
    if (_valueInstantiator != null) {
        if (_valueInstantiator.canCreateUsingDelegate()) {
            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());
            if (delegateType == null) {
                throw new IllegalArgumentException(""Invalid delegate-creator definition for "" + _collectionType + "": value instantiator ("" + _valueInstantiator.getClass().getName() + "") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"");
            }
            delegateDeser = findDeserializer(ctxt, delegateType, property);
        }
    }
    // [databind#1043]: allow per-property allow-wrapping of single overrides:
    // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly
    //   comes down to ""List vs Collection"" I suppose... for now, pass Collection
    Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class, JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
    // also, often value deserializer is resolved here:
    JsonDeserializer<?> valueDeser = _valueDeserializer;
    // May have a content converter
    valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);
    final JavaType vt = _collectionType.getContentType();
    if (valueDeser == null) {
        valueDeser = ctxt.findContextualValueDeserializer(vt, property);
    } else {
        // if directly assigned, probably not yet contextual, so:
        valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);
    }
    // and finally, type deserializer needs context as well
    TypeDeserializer valueTypeDeser = _valueTypeDeserializer;
    if (valueTypeDeser != null) {
        valueTypeDeser = valueTypeDeser.forProperty(property);
    }
    return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);
}","public void test1011() throws Throwable {
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer((JavaType) null, (JsonDeserializer<Object>) null, (TypeDeserializer) null, (ValueInstantiator) null);
    // Undeclared exception!
    try {
        collectionDeserializer0.createContextual((DeserializationContext) null, (BeanProperty) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdDeserializer"", e);
    }
}",""
"/*
    /**********************************************************
    /* JsonDeserializer API
    /**********************************************************
     */
@SuppressWarnings(""unchecked"")
@Override
public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
    if (_delegateDeserializer != null) {
        return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
    }
    /* Empty String may be ok; bit tricky to check, however, since
         * there is also possibility of ""auto-wrapping"" of single-element arrays.
         * Hence we only accept empty String here.
         */
    if (p.hasToken(JsonToken.VALUE_STRING)) {
        String str = p.getText();
        if (str.length() == 0) {
            return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str);
        }
    }
    return deserialize(p, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt));
}","public void test1314() throws Throwable {
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer((JavaType) null, (JsonDeserializer<Object>) null, (TypeDeserializer) null, jsonLocationInstantiator0);
    ArrayNode arrayNode0 = new ArrayNode((JsonNodeFactory) null);
    JsonParser jsonParser0 = arrayNode0.traverse();
    // Undeclared exception!
    try {
        collectionDeserializer0.deserialize(jsonParser0, (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.ValueInstantiator"", e);
    }
}",""
"/*
    /**********************************************************
    /* JsonDeserializer API
    /**********************************************************
     */
@SuppressWarnings(""unchecked"")
@Override
public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
    if (_delegateDeserializer != null) {
        return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));
    }
    /* Empty String may be ok; bit tricky to check, however, since
         * there is also possibility of ""auto-wrapping"" of single-element arrays.
         * Hence we only accept empty String here.
         */
    if (p.hasToken(JsonToken.VALUE_STRING)) {
        String str = p.getText();
        if (str.length() == 0) {
            return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str);
        }
    }
    return deserialize(p, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt));
}","public void test1415() throws Throwable {
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    ArrayNode arrayNode0 = new ArrayNode((JsonNodeFactory) null);
    JsonParser jsonParser0 = arrayNode0.traverse();
    Class<Locale> class0 = Locale.class;
    CoreXMLDeserializers.Std coreXMLDeserializers_Std0 = new CoreXMLDeserializers.Std(class0, 42);
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer((JavaType) null, coreXMLDeserializers_Std0, (TypeDeserializer) null, jsonLocationInstantiator0, coreXMLDeserializers_Std0, (Boolean) null);
    // Undeclared exception!
    try {
        collectionDeserializer0.deserialize(jsonParser0, (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.FromStringDeserializer"", e);
    }
}",""
"@Override
public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt, Collection<Object> result) throws IOException {
    // Ok: must point to START_ARRAY (or equivalent)
    if (!p.isExpectedStartArrayToken()) {
        return handleNonArray(p, ctxt, result);
    }
    // [databind#631]: Assign current value, to be accessible by custom serializers
    p.setCurrentValue(result);
    JsonDeserializer<Object> valueDes = _valueDeserializer;
    final TypeDeserializer typeDeser = _valueTypeDeserializer;
    CollectionReferringAccumulator referringAccumulator = (valueDes.getObjectIdReader() == null) ? null : new CollectionReferringAccumulator(_collectionType.getContentType().getRawClass(), result);
    JsonToken t;
    while ((t = p.nextToken()) != JsonToken.END_ARRAY) {
        try {
            Object value;
            if (t == JsonToken.VALUE_NULL) {
                value = valueDes.getNullValue(ctxt);
            } else if (typeDeser == null) {
                value = valueDes.deserialize(p, ctxt);
            } else {
                value = valueDes.deserializeWithType(p, ctxt, typeDeser);
            }
            if (referringAccumulator != null) {
                referringAccumulator.add(value);
            } else {
                result.add(value);
            }
        } catch (UnresolvedForwardReference reference) {
            if (referringAccumulator == null) {
                throw JsonMappingException.from(p, ""Unresolved forward reference but no identity info"", reference);
            }
            Referring ref = referringAccumulator.handleUnresolvedReference(reference);
            reference.getRoid().appendReferring(ref);
        } catch (Exception e) {
            boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);
            if (!wrap && e instanceof RuntimeException) {
                throw (RuntimeException) e;
            }
            throw JsonMappingException.wrapWithPath(e, result, result.size());
        }
    }
    return result;
}","public void test1516() throws Throwable {
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    ArrayNode arrayNode0 = new ArrayNode((JsonNodeFactory) null);
    JsonParser jsonParser0 = arrayNode0.traverse();
    ArrayList<Object> arrayList0 = new ArrayList<Object>();
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(jsonParser0, tokenFilter0, false, false);
    filteringParserDelegate0.nextBooleanValue();
    Class<Locale> class0 = Locale.class;
    CoreXMLDeserializers.Std coreXMLDeserializers_Std0 = new CoreXMLDeserializers.Std(class0, 22);
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer((JavaType) null, coreXMLDeserializers_Std0, (TypeDeserializer) null, jsonLocationInstantiator0, coreXMLDeserializers_Std0, (Boolean) null);
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    collectionDeserializer0.deserialize(jsonParser0, (DeserializationContext) defaultDeserializationContext_Impl0, (Collection<Object>) arrayList0);
    // Undeclared exception!
    try {
        collectionDeserializer0.deserialize((JsonParser) filteringParserDelegate0, (DeserializationContext) defaultDeserializationContext_Impl0, (Collection<Object>) arrayList0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}",""
"@Override
public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt, Collection<Object> result) throws IOException {
    // Ok: must point to START_ARRAY (or equivalent)
    if (!p.isExpectedStartArrayToken()) {
        return handleNonArray(p, ctxt, result);
    }
    // [databind#631]: Assign current value, to be accessible by custom serializers
    p.setCurrentValue(result);
    JsonDeserializer<Object> valueDes = _valueDeserializer;
    final TypeDeserializer typeDeser = _valueTypeDeserializer;
    CollectionReferringAccumulator referringAccumulator = (valueDes.getObjectIdReader() == null) ? null : new CollectionReferringAccumulator(_collectionType.getContentType().getRawClass(), result);
    JsonToken t;
    while ((t = p.nextToken()) != JsonToken.END_ARRAY) {
        try {
            Object value;
            if (t == JsonToken.VALUE_NULL) {
                value = valueDes.getNullValue(ctxt);
            } else if (typeDeser == null) {
                value = valueDes.deserialize(p, ctxt);
            } else {
                value = valueDes.deserializeWithType(p, ctxt, typeDeser);
            }
            if (referringAccumulator != null) {
                referringAccumulator.add(value);
            } else {
                result.add(value);
            }
        } catch (UnresolvedForwardReference reference) {
            if (referringAccumulator == null) {
                throw JsonMappingException.from(p, ""Unresolved forward reference but no identity info"", reference);
            }
            Referring ref = referringAccumulator.handleUnresolvedReference(reference);
            reference.getRoid().appendReferring(ref);
        } catch (Exception e) {
            boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);
            if (!wrap && e instanceof RuntimeException) {
                throw (RuntimeException) e;
            }
            throw JsonMappingException.wrapWithPath(e, result, result.size());
        }
    }
    return result;
}","public void test1617() throws Throwable {
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    ArrayNode arrayNode0 = new ArrayNode((JsonNodeFactory) null);
    JsonParser jsonParser0 = arrayNode0.traverse();
    ArrayList<Object> arrayList0 = new ArrayList<Object>();
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(jsonParser0, tokenFilter0, true, true);
    filteringParserDelegate0.nextBooleanValue();
    Class<Locale> class0 = Locale.class;
    CoreXMLDeserializers.Std coreXMLDeserializers_Std0 = new CoreXMLDeserializers.Std(class0, 22);
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer((JavaType) null, coreXMLDeserializers_Std0, (TypeDeserializer) null, jsonLocationInstantiator0, coreXMLDeserializers_Std0, (Boolean) null);
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    Collection<Object> collection0 = collectionDeserializer0.deserialize(jsonParser0, (DeserializationContext) defaultDeserializationContext_Impl0, (Collection<Object>) arrayList0);
    try {
        collectionDeserializer0.deserialize((JsonParser) filteringParserDelegate0, (DeserializationContext) null, collection0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // (was java.lang.NullPointerException) (through reference chain: java.util.ArrayList[0])
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}",""
"@Override
public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt, Collection<Object> result) throws IOException {
    // Ok: must point to START_ARRAY (or equivalent)
    if (!p.isExpectedStartArrayToken()) {
        return handleNonArray(p, ctxt, result);
    }
    // [databind#631]: Assign current value, to be accessible by custom serializers
    p.setCurrentValue(result);
    JsonDeserializer<Object> valueDes = _valueDeserializer;
    final TypeDeserializer typeDeser = _valueTypeDeserializer;
    CollectionReferringAccumulator referringAccumulator = (valueDes.getObjectIdReader() == null) ? null : new CollectionReferringAccumulator(_collectionType.getContentType().getRawClass(), result);
    JsonToken t;
    while ((t = p.nextToken()) != JsonToken.END_ARRAY) {
        try {
            Object value;
            if (t == JsonToken.VALUE_NULL) {
                value = valueDes.getNullValue(ctxt);
            } else if (typeDeser == null) {
                value = valueDes.deserialize(p, ctxt);
            } else {
                value = valueDes.deserializeWithType(p, ctxt, typeDeser);
            }
            if (referringAccumulator != null) {
                referringAccumulator.add(value);
            } else {
                result.add(value);
            }
        } catch (UnresolvedForwardReference reference) {
            if (referringAccumulator == null) {
                throw JsonMappingException.from(p, ""Unresolved forward reference but no identity info"", reference);
            }
            Referring ref = referringAccumulator.handleUnresolvedReference(reference);
            reference.getRoid().appendReferring(ref);
        } catch (Exception e) {
            boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);
            if (!wrap && e instanceof RuntimeException) {
                throw (RuntimeException) e;
            }
            throw JsonMappingException.wrapWithPath(e, result, result.size());
        }
    }
    return result;
}","public void test1718() throws Throwable {
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    ArrayNode arrayNode0 = new ArrayNode((JsonNodeFactory) null);
    JsonParser jsonParser0 = arrayNode0.traverse();
    ArrayList<Object> arrayList0 = new ArrayList<Object>();
    Boolean boolean0 = Boolean.TRUE;
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer((JavaType) null, (JsonDeserializer<Object>) null, (TypeDeserializer) null, jsonLocationInstantiator0, (JsonDeserializer<Object>) null, boolean0);
    try {
        collectionDeserializer0.deserialize(jsonParser0, (DeserializationContext) null, (Collection<Object>) arrayList0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // (was java.lang.NullPointerException) (through reference chain: java.lang.Object[0])
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}",""
"@Override
public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt, Collection<Object> result) throws IOException {
    // Ok: must point to START_ARRAY (or equivalent)
    if (!p.isExpectedStartArrayToken()) {
        return handleNonArray(p, ctxt, result);
    }
    // [databind#631]: Assign current value, to be accessible by custom serializers
    p.setCurrentValue(result);
    JsonDeserializer<Object> valueDes = _valueDeserializer;
    final TypeDeserializer typeDeser = _valueTypeDeserializer;
    CollectionReferringAccumulator referringAccumulator = (valueDes.getObjectIdReader() == null) ? null : new CollectionReferringAccumulator(_collectionType.getContentType().getRawClass(), result);
    JsonToken t;
    while ((t = p.nextToken()) != JsonToken.END_ARRAY) {
        try {
            Object value;
            if (t == JsonToken.VALUE_NULL) {
                value = valueDes.getNullValue(ctxt);
            } else if (typeDeser == null) {
                value = valueDes.deserialize(p, ctxt);
            } else {
                value = valueDes.deserializeWithType(p, ctxt, typeDeser);
            }
            if (referringAccumulator != null) {
                referringAccumulator.add(value);
            } else {
                result.add(value);
            }
        } catch (UnresolvedForwardReference reference) {
            if (referringAccumulator == null) {
                throw JsonMappingException.from(p, ""Unresolved forward reference but no identity info"", reference);
            }
            Referring ref = referringAccumulator.handleUnresolvedReference(reference);
            reference.getRoid().appendReferring(ref);
        } catch (Exception e) {
            boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);
            if (!wrap && e instanceof RuntimeException) {
                throw (RuntimeException) e;
            }
            throw JsonMappingException.wrapWithPath(e, result, result.size());
        }
    }
    return result;
}","public void test1819() throws Throwable {
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    ArrayNode arrayNode0 = new ArrayNode((JsonNodeFactory) null);
    JsonParser jsonParser0 = arrayNode0.traverse();
    ArrayList<Object> arrayList0 = new ArrayList<Object>();
    Boolean boolean0 = Boolean.FALSE;
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer((JavaType) null, (JsonDeserializer<Object>) null, (TypeDeserializer) null, jsonLocationInstantiator0, (JsonDeserializer<Object>) null, boolean0);
    // Undeclared exception!
    try {
        collectionDeserializer0.deserialize(jsonParser0, (DeserializationContext) null, (Collection<Object>) arrayList0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.CollectionDeserializer"", e);
    }
}",""
"@Override
public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt, Collection<Object> result) throws IOException {
    // Ok: must point to START_ARRAY (or equivalent)
    if (!p.isExpectedStartArrayToken()) {
        return handleNonArray(p, ctxt, result);
    }
    // [databind#631]: Assign current value, to be accessible by custom serializers
    p.setCurrentValue(result);
    JsonDeserializer<Object> valueDes = _valueDeserializer;
    final TypeDeserializer typeDeser = _valueTypeDeserializer;
    CollectionReferringAccumulator referringAccumulator = (valueDes.getObjectIdReader() == null) ? null : new CollectionReferringAccumulator(_collectionType.getContentType().getRawClass(), result);
    JsonToken t;
    while ((t = p.nextToken()) != JsonToken.END_ARRAY) {
        try {
            Object value;
            if (t == JsonToken.VALUE_NULL) {
                value = valueDes.getNullValue(ctxt);
            } else if (typeDeser == null) {
                value = valueDes.deserialize(p, ctxt);
            } else {
                value = valueDes.deserializeWithType(p, ctxt, typeDeser);
            }
            if (referringAccumulator != null) {
                referringAccumulator.add(value);
            } else {
                result.add(value);
            }
        } catch (UnresolvedForwardReference reference) {
            if (referringAccumulator == null) {
                throw JsonMappingException.from(p, ""Unresolved forward reference but no identity info"", reference);
            }
            Referring ref = referringAccumulator.handleUnresolvedReference(reference);
            reference.getRoid().appendReferring(ref);
        } catch (Exception e) {
            boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);
            if (!wrap && e instanceof RuntimeException) {
                throw (RuntimeException) e;
            }
            throw JsonMappingException.wrapWithPath(e, result, result.size());
        }
    }
    return result;
}","public void test1920() throws Throwable {
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer((JavaType) null, (JsonDeserializer<Object>) null, (TypeDeserializer) null, jsonLocationInstantiator0);
    ArrayList<Object> arrayList0 = new ArrayList<Object>();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    // Undeclared exception!
    try {
        collectionDeserializer0.deserialize(jsonParser0, (DeserializationContext) defaultDeserializationContext_Impl0, (Collection<Object>) arrayList0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.CollectionDeserializer"", e);
    }
}",""
"protected final Collection<Object> handleNonArray(JsonParser p, DeserializationContext ctxt, Collection<Object> result) throws IOException {
    // Implicit arrays from single values?
    boolean canWrap = (_unwrapSingle == Boolean.TRUE) || ((_unwrapSingle == null) && ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));
    if (!canWrap) {
        throw ctxt.mappingException(_collectionType.getRawClass());
    }
    JsonDeserializer<Object> valueDes = _valueDeserializer;
    final TypeDeserializer typeDeser = _valueTypeDeserializer;
    JsonToken t = p.getCurrentToken();
    Object value;
    try {
        if (t == JsonToken.VALUE_NULL) {
            value = valueDes.getNullValue(ctxt);
        } else if (typeDeser == null) {
            value = valueDes.deserialize(p, ctxt);
        } else {
            value = valueDes.deserializeWithType(p, ctxt, typeDeser);
        }
    } catch (Exception e) {
        // note: pass Object.class, not Object[].class, as we need element type for error info
        throw JsonMappingException.wrapWithPath(e, Object.class, result.size());
    }
    result.add(value);
    return result;
}","public void test2021() throws Throwable {
    ArrayList<Object> arrayList0 = new ArrayList<Object>();
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    Class<SettableBeanProperty> class0 = SettableBeanProperty.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    Boolean boolean0 = Boolean.TRUE;
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    JsonFactory jsonFactory0 = new JsonFactory();
    byte[] byteArray0 = new byte[0];
    JsonParser jsonParser0 = jsonFactory0.createParser(byteArray0);
    Class<InputStream> class1 = InputStream.class;
    AsExternalTypeDeserializer asExternalTypeDeserializer0 = new AsExternalTypeDeserializer(resolvedRecursiveType0, (TypeIdResolver) null, ""END_ARRAY"", true, class1);
    CollectionDeserializer collectionDeserializer0 = new CollectionDeserializer(resolvedRecursiveType0, (JsonDeserializer<Object>) null, asExternalTypeDeserializer0, jsonLocationInstantiator0, (JsonDeserializer<Object>) null, boolean0);
    try {
        collectionDeserializer0.handleNonArray(jsonParser0, (DeserializationContext) null, arrayList0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // (was java.lang.NullPointerException) (through reference chain: java.lang.Object[0])
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 * Helper method called when current token is no START_ARRAY. Will either
 * throw an exception, or try to handle value as if member of implicit
 * array, depending on configuration.
 */"
