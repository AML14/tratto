focal_method,test_prefix,docstring
"public StdDateFormat withTimeZone(TimeZone tz) {
    if (tz == null) {
        tz = DEFAULT_TIMEZONE;
    }
    if ((tz == _timezone) || tz.equals(_timezone)) {
        return this;
    }
    return new StdDateFormat(tz, _locale, _lenient);
}","public void test000() throws Throwable {
    TimeZone timeZone0 = StdDateFormat.getDefaultTimeZone();
    Locale locale0 = Locale.TAIWAN;
    StdDateFormat stdDateFormat0 = new StdDateFormat(timeZone0, locale0);
    StdDateFormat stdDateFormat1 = stdDateFormat0.withTimeZone(timeZone0);
    assertSame(stdDateFormat1, stdDateFormat0);
}","/**
 * Method used for creating a new instance with specified timezone;
 * if no timezone specified, defaults to the default timezone (UTC).
 */"
"@Override
public StdDateFormat clone() {
    /* Although there is that much state to share, we do need to
         * orchestrate a bit, mostly since timezones may be changed
         */
    return new StdDateFormat(_timezone, _locale, _lenient);
}","public void test011() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    StdDateFormat stdDateFormat1 = stdDateFormat0.clone();
    assertNotSame(stdDateFormat0, stdDateFormat1);
}",""
"/*
    /**********************************************************
    /* Public API, configuration
    /**********************************************************
     */
// since 2.6
@Override
public TimeZone getTimeZone() {
    return _timezone;
}","public void test044() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.forLanguageTag("""");
    StdDateFormat stdDateFormat0 = new StdDateFormat(timeZone0, locale0);
    TimeZone timeZone1 = stdDateFormat0.getTimeZone();
    assertSame(timeZone0, timeZone1);
}",""
"public StdDateFormat withTimeZone(TimeZone tz) {
    if (tz == null) {
        tz = DEFAULT_TIMEZONE;
    }
    if ((tz == _timezone) || tz.equals(_timezone)) {
        return this;
    }
    return new StdDateFormat(tz, _locale, _lenient);
}","public void test055() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    StdDateFormat stdDateFormat1 = stdDateFormat0.withTimeZone((TimeZone) null);
    assertNotSame(stdDateFormat1, stdDateFormat0);
}","/**
 * Method used for creating a new instance with specified timezone;
 * if no timezone specified, defaults to the default timezone (UTC).
 */"
"// since 2.7[.2], as per [databind#1130]
@Override
public int hashCode() {
    return System.identityHashCode(this);
}","public void test066() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    stdDateFormat0.hashCode();
}",""
"public StdDateFormat withTimeZone(TimeZone tz) {
    if (tz == null) {
        tz = DEFAULT_TIMEZONE;
    }
    if ((tz == _timezone) || tz.equals(_timezone)) {
        return this;
    }
    return new StdDateFormat(tz, _locale, _lenient);
}","public void test077() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.JAPANESE;
    TimeZone timeZone1 = TimeZone.getTimeZone("""");
    StdDateFormat stdDateFormat0 = new StdDateFormat(timeZone0, locale0);
    StdDateFormat stdDateFormat1 = stdDateFormat0.withTimeZone(timeZone1);
    assertSame(stdDateFormat1, stdDateFormat0);
}","/**
 * Method used for creating a new instance with specified timezone;
 * if no timezone specified, defaults to the default timezone (UTC).
 */"
"/*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */
@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date dt;
    if (looksLikeISO8601(dateStr)) {
        // also includes ""plain""
        dt = parseAsISO8601(dateStr, pos, true);
    } else {
        // Also consider ""stringified"" simple time stamp
        int i = dateStr.length();
        while (--i >= 0) {
            char ch = dateStr.charAt(i);
            if (ch < '0' || ch > '9') {
                // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work
                if (i > 0 || ch != '-') {
                    break;
                }
            }
        }
        if ((i < 0) && // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive
        (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {
            dt = new Date(Long.parseLong(dateStr));
        } else {
            // Otherwise, fall back to using RFC 1123
            dt = parseAsRFC1123(dateStr, pos);
        }
    }
    if (dt != null) {
        return dt;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test088() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    Locale locale0 = Locale.PRC;
    StdDateFormat stdDateFormat1 = stdDateFormat0.withLocale(locale0);
    try {
        stdDateFormat1.parse(""yyyy-MM-dd'T'HH:mm:ss.SSSZ"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Can not parse date \""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"public StdDateFormat withLocale(Locale loc) {
    if (loc.equals(_locale)) {
        return this;
    }
    return new StdDateFormat(_timezone, loc, _lenient);
}","public void test099() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    Locale locale0 = Locale.US;
    StdDateFormat stdDateFormat1 = stdDateFormat0.withLocale(locale0);
    assertSame(stdDateFormat1, stdDateFormat0);
}",""
"// since 2.7
@Override
public boolean isLenient() {
    if (_lenient == null) {
        // default is, I believe, true
        return true;
    }
    return _lenient.booleanValue();
}","public void test1111() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    TimeZone timeZone0 = TimeZone.getDefault();
    stdDateFormat0.setTimeZone(timeZone0);
    assertTrue(stdDateFormat0.isLenient());
}",""
"// since 2.7
@Override
public boolean isLenient() {
    if (_lenient == null) {
        // default is, I believe, true
        return true;
    }
    return _lenient.booleanValue();
}","public void test1212() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    stdDateFormat0.setLenient(true);
    assertTrue(stdDateFormat0.isLenient());
}",""
"// since 2.7
@Override
public boolean isLenient() {
    if (_lenient == null) {
        // default is, I believe, true
        return true;
    }
    return _lenient.booleanValue();
}","public void test1313() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    boolean boolean0 = stdDateFormat0.isLenient();
    assertTrue(boolean0);
}",""
"/*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */
@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date dt;
    if (looksLikeISO8601(dateStr)) {
        // also includes ""plain""
        dt = parseAsISO8601(dateStr, pos, true);
    } else {
        // Also consider ""stringified"" simple time stamp
        int i = dateStr.length();
        while (--i >= 0) {
            char ch = dateStr.charAt(i);
            if (ch < '0' || ch > '9') {
                // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work
                if (i > 0 || ch != '-') {
                    break;
                }
            }
        }
        if ((i < 0) && // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive
        (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {
            dt = new Date(Long.parseLong(dateStr));
        } else {
            // Otherwise, fall back to using RFC 1123
            dt = parseAsRFC1123(dateStr, pos);
        }
    }
    if (dt != null) {
        return dt;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test1717() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    try {
        stdDateFormat0.parse("")"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Can not parse date \"")\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"/*
    /**********************************************************
    /* Std overrides
    /**********************************************************
     */
@Override
public String toString() {
    String str = ""DateFormat "" + getClass().getName();
    TimeZone tz = _timezone;
    if (tz != null) {
        str += "" (timezone: "" + tz + "")"";
    }
    str += ""(locale: "" + _locale + "")"";
    return str;
}","public void test2324() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    String string0 = stdDateFormat0.toString();
    assertEquals(""DateFormat com.fasterxml.jackson.databind.util.StdDateFormat(locale: en_US)"", string0);
}",""
"// since 2.7[.2], as per [databind#1130]
@Override
public boolean equals(Object o) {
    return (o == this);
}","public void test2425() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    boolean boolean0 = stdDateFormat0.equals((Object) null);
    assertFalse(boolean0);
}",""
"// since 2.7[.2], as per [databind#1130]
@Override
public boolean equals(Object o) {
    return (o == this);
}","public void test2526() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    boolean boolean0 = stdDateFormat0.equals(stdDateFormat0);
    assertTrue(boolean0);
}",""
"/*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */
@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date dt;
    if (looksLikeISO8601(dateStr)) {
        // also includes ""plain""
        dt = parseAsISO8601(dateStr, pos, true);
    } else {
        // Also consider ""stringified"" simple time stamp
        int i = dateStr.length();
        while (--i >= 0) {
            char ch = dateStr.charAt(i);
            if (ch < '0' || ch > '9') {
                // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work
                if (i > 0 || ch != '-') {
                    break;
                }
            }
        }
        if ((i < 0) && // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive
        (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {
            dt = new Date(Long.parseLong(dateStr));
        } else {
            // Otherwise, fall back to using RFC 1123
            dt = parseAsRFC1123(dateStr, pos);
        }
    }
    if (dt != null) {
        return dt;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test2627() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    try {
        stdDateFormat0.parse(""8JdG1V8wzx2q(XSh"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Can not parse date \""8JdG1V8wzx2q(XSh\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */
@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date dt;
    if (looksLikeISO8601(dateStr)) {
        // also includes ""plain""
        dt = parseAsISO8601(dateStr, pos, true);
    } else {
        // Also consider ""stringified"" simple time stamp
        int i = dateStr.length();
        while (--i >= 0) {
            char ch = dateStr.charAt(i);
            if (ch < '0' || ch > '9') {
                // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work
                if (i > 0 || ch != '-') {
                    break;
                }
            }
        }
        if ((i < 0) && // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive
        (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {
            dt = new Date(Long.parseLong(dateStr));
        } else {
            // Otherwise, fall back to using RFC 1123
            dt = parseAsRFC1123(dateStr, pos);
        }
    }
    if (dt != null) {
        return dt;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test2728() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    try {
        stdDateFormat0.parse(""0.000"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Can not parse date \""0.000\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test2829() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601("".000"", (ParsePosition) null, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test2930() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""y6)]-X\""4m "", (ParsePosition) null, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test3031() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""y.3ogo$BfvJLw3O:t<Z"", (ParsePosition) null, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test3132() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""yyyy-MM-dd'T'HH:mm:ss.SSSZ"", (ParsePosition) null, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test3233() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""(locale: "", (ParsePosition) null, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test3334() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    ParsePosition parsePosition0 = new ParsePosition(638);
    try {
        stdDateFormat0.parseAsISO8601(""eJXu:g-*?(S-HP:rK"", parsePosition0, true);
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Can not parse date \""eJXu:g-*?(S0-HPrK\"": while it seems to fit format 'yyyy-MM-dd'T'HH:mm:ss.SSSZ', parsing fails (leniency? null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test3435() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    ParsePosition parsePosition0 = new ParsePosition((-1092));
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""f\""R>X#-):"", parsePosition0, false);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test3536() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601("">]/@?+W_^.F"", (ParsePosition) null, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test3637() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601("")SrMG#$Rc+;6"", (ParsePosition) null, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test3738() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""yvR+;3;#"", (ParsePosition) null, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test3839() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""com.fasterxml.jackson.core.io.NumberInput"", (ParsePosition) null, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test3940() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""*'KlEo>q{w"", (ParsePosition) null, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test4041() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""DateFormat "", (ParsePosition) null, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test4142() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    // Undeclared exception!
    try {
        stdDateFormat0.parseAsISO8601(""(kawq"", (ParsePosition) null, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {
    /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */
    /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
    int len = dateStr.length();
    char c = dateStr.charAt(len - 1);
    DateFormat df;
    String formatStr;
    // Need to support ""plain"" date...
    if (len <= 10 && Character.isDigit(c)) {
        df = _formatPlain;
        formatStr = DATE_FORMAT_STR_PLAIN;
        if (df == null) {
            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);
        }
    } else if (c == 'Z') {
        df = _formatISO8601_z;
        formatStr = DATE_FORMAT_STR_ISO8601_Z;
        if (df == null) {
            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
            //    must use UTC, not whatever is configured as default timezone
            //    (because we know `Z` identifier is used)
            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
        }
        // may be missing milliseconds... if so, add
        if (dateStr.charAt(len - 4) == ':') {
            StringBuilder sb = new StringBuilder(dateStr);
            sb.insert(len - 1, "".000"");
            dateStr = sb.toString();
        }
    } else {
        // Let's see if we have timezone indicator or not...
        if (hasTimeZone(dateStr)) {
            c = dateStr.charAt(len - 3);
            if (c == ':') {
                // remove optional colon
                // remove colon
                StringBuilder sb = new StringBuilder(dateStr);
                sb.delete(len - 3, len - 2);
                dateStr = sb.toString();
            } else if (c == '+' || c == '-') {
                // missing minutes
                // let's just append '00'
                dateStr += ""00"";
            }
            // Milliseconds partial or missing; and even seconds are optional
            len = dateStr.length();
            // remove 'T', '+'/'-' and 4-digit timezone-offset
            int timeLen = len - dateStr.lastIndexOf('T') - 6;
            if (timeLen < 12) {
                // 8 for hh:mm:ss, 4 for .sss
                // insertion offset, before tz-offset
                int offset = len - 5;
                StringBuilder sb = new StringBuilder(dateStr);
                switch(timeLen) {
                    case 11:
                        sb.insert(offset, '0');
                        break;
                    case 10:
                        sb.insert(offset, ""00"");
                        break;
                    case // is this legal? (just second fraction marker)
                    9:
                        sb.insert(offset, ""000"");
                        break;
                    case 8:
                        sb.insert(offset, "".000"");
                        break;
                    case // not legal to have single-digit second
                    7:
                        break;
                    case // probably not legal, but let's allow
                    6:
                        sb.insert(offset, ""00.000"");
                    case // is legal to omit seconds
                    5:
                        sb.insert(offset, "":00.000"");
                }
                dateStr = sb.toString();
            }
            df = _formatISO8601;
            formatStr = DATE_FORMAT_STR_ISO8601;
            if (_formatISO8601 == null) {
                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);
            }
        } else {
            // If not, plain date, no timezone
            StringBuilder sb = new StringBuilder(dateStr);
            int timeLen = len - dateStr.lastIndexOf('T') - 1;
            // And possible also millisecond part if missing
            if (timeLen < 12) {
                // missing, or partial
                switch(timeLen) {
                    case 11:
                        sb.append('0');
                    case 10:
                        sb.append('0');
                    case 9:
                        sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                }
            }
            sb.append('Z');
            dateStr = sb.toString();
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);
            }
        }
    }
    Date dt = df.parse(dateStr, pos);
    // 22-Dec-2015, tatu: With non-lenient, may get null
    if (dt == null) {
        throw new ParseException(String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"", dateStr, formatStr, _lenient), pos.getErrorIndex());
    }
    return dt;
}","public void test4243() throws Throwable {
    StdDateFormat stdDateFormat0 = new StdDateFormat();
    ParsePosition parsePosition0 = new ParsePosition(9);
    try {
        stdDateFormat0.parseAsISO8601(""]2\""'C0nB- <'O"", parsePosition0, true);
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Can not parse date \""]2\""'C0nB.000- <'O\"": while it seems to fit format 'yyyy-MM-dd'T'HH:mm:ss.SSSZ', parsing fails (leniency? null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */
@Override
public Date parse(String dateStr) throws ParseException {
    dateStr = dateStr.trim();
    ParsePosition pos = new ParsePosition(0);
    Date dt;
    if (looksLikeISO8601(dateStr)) {
        // also includes ""plain""
        dt = parseAsISO8601(dateStr, pos, true);
    } else {
        // Also consider ""stringified"" simple time stamp
        int i = dateStr.length();
        while (--i >= 0) {
            char ch = dateStr.charAt(i);
            if (ch < '0' || ch > '9') {
                // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work
                if (i > 0 || ch != '-') {
                    break;
                }
            }
        }
        if ((i < 0) && // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive
        (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {
            dt = new Date(Long.parseLong(dateStr));
        } else {
            // Otherwise, fall back to using RFC 1123
            dt = parseAsRFC1123(dateStr, pos);
        }
    }
    if (dt != null) {
        return dt;
    }
    StringBuilder sb = new StringBuilder();
    for (String f : ALL_FORMATS) {
        if (sb.length() > 0) {
            sb.append(""\"", \"""");
        } else {
            sb.append('""');
        }
        sb.append(f);
    }
    sb.append('""');
    throw new ParseException(String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"", dateStr, sb.toString()), pos.getErrorIndex());
}","public void test4344() throws Throwable {
    StdDateFormat stdDateFormat0 = StdDateFormat.instance;
    try {
        stdDateFormat0.parse(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"");
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Can not parse date \""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)\"": not compatible with any of standard forms (\""yyyy-MM-dd'T'HH:mm:ss.SSSZ\"", \""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"", \""EEE, dd MMM yyyy HH:mm:ss zzz\"", \""yyyy-MM-dd\"")
        //
        verifyException(""com.fasterxml.jackson.databind.util.StdDateFormat"", e);
    }
}",""
