focal_method,test_prefix,docstring
"@Override
public boolean isRequired() {
    return _metadata.isRequired();
}","public void test00() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Integer> class0 = Integer.class;
    MapLikeType mapLikeType0 = typeFactory0.constructRawMapLikeType(class0);
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(mapLikeType0, (TypeIdResolver) null, ""Y46&.\""gCa@,bhPcfm"", false, mapLikeType0);
    PropertyName propertyName0 = PropertyName.USE_DEFAULT;
    CreatorProperty creatorProperty0 = new CreatorProperty(propertyName0, mapLikeType0, propertyName0, asPropertyTypeDeserializer0, (Annotations) null, (AnnotatedParameter) null, 0, ""Y46&.\""gCa@,bhPcfm"", (PropertyMetadata) null);
    assertFalse(creatorProperty0.isRequired());
}",""
"@SuppressWarnings(""resource"")
public String writeValueAsString(Object value) throws JsonProcessingException {
    // alas, we have to pull the recycler directly here...
    SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());
    try {
        _configAndWriteValue(_jsonFactory.createGenerator(sw), value);
    } catch (JsonProcessingException e) {
        // to support [JACKSON-758]
        throw e;
    } catch (IOException e) {
        // shouldn't really happen, but is declared as possibility so:
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    return sw.getAndClear();
}","public void test11() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer((JavaType) null, (TypeIdResolver) null, "".Gz#9\""#C"", false, (JavaType) null);
    String string0 = objectMapper0.writeValueAsString(asPropertyTypeDeserializer0);
    assertEquals(""{\""typeInclusion\"":\""PROPERTY\"",\""typeIdResolver\"":null,\""defaultImpl\"":null,\""propertyName\"":\"".Gz#9\\\""#C\""}"", string0);
}","/**
 *  Method that can be used to serialize any Java value as
 *  a String. Functionally equivalent to calling
 *  {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}
 *  and constructing String, but more efficient.
 * <p>
 *  Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
 */"
"@Override
public TypeDeserializer forProperty(BeanProperty prop) {
    return (prop == _property) ? this : new AsPropertyTypeDeserializer(this, prop);
}","public void test22() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Map> class0 = Map.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class0);
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(mapType0, typeFactory0);
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.PROPERTY;
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(mapType0, classNameIdResolver0, ""u6"", true, mapType0, jsonTypeInfo_As0);
    TypeDeserializer typeDeserializer0 = asPropertyTypeDeserializer0.forProperty((BeanProperty) null);
    assertSame(typeDeserializer0, asPropertyTypeDeserializer0);
}",""
"// off-lined to keep main method lean and mean...
@SuppressWarnings(""resource"")
protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) throws IOException {
    // As per [JACKSON-614], may have default implementation to use
    JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);
    if (deser != null) {
        if (tb != null) {
            tb.writeEndObject();
            p = tb.asParser(p);
            // must move to point to the first token:
            p.nextToken();
        }
        return deser.deserialize(p, ctxt);
    }
    // or, perhaps we just bumped into a ""natural"" value (boolean/int/double/String)?
    Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);
    if (result != null) {
        return result;
    }
    // or, something for which ""as-property"" won't work, changed into ""wrapper-array"" type:
    if (p.getCurrentToken() == JsonToken.START_ARRAY) {
        return super.deserializeTypedFromAny(p, ctxt);
    }
    ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME, ""missing property '"" + _typePropertyName + ""' that is to contain type id  (for class "" + baseTypeName() + "")"");
    return null;
}","public void test45() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    BooleanNode booleanNode0 = BooleanNode.getFalse();
    JsonParser jsonParser0 = objectMapper0.treeAsTokens(booleanNode0);
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer((JavaType) null, (TypeIdResolver) null, """", true, (JavaType) null);
    TokenBuffer tokenBuffer0 = new TokenBuffer(jsonParser0, deserializationContext0);
    Object object0 = asPropertyTypeDeserializer0._deserializeTypedUsingDefaultImpl(jsonParser0, deserializationContext0, tokenBuffer0);
    assertNull(object0);
}",""
