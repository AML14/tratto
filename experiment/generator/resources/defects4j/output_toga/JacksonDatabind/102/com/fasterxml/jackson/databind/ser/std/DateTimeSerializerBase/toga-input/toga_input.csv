focal_method,test_prefix,docstring
"@Override
public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {
    _acceptJsonFormatVisitor(visitor, typeHint, _asTimestamp(visitor.getProvider()));
}","public void test00() throws Throwable {
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer();
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    // Undeclared exception!
    try {
        sqlDateSerializer0.acceptJsonFormatVisitor(jsonFormatVisitorWrapper_Base0, (JavaType) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null SerializerProvider passed for java.sql.Date
        //
        verifyException(""com.fasterxml.jackson.databind.ser.std.DateTimeSerializerBase"", e);
    }
}",""
"@Override
public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {
    // Note! Should not skip if `property` null since that'd skip check
    // for config overrides, in case of root value
    if (property == null) {
        return this;
    }
    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());
    if (format == null) {
        return this;
    }
    // Simple case first: serialize as numeric timestamp?
    JsonFormat.Shape shape = format.getShape();
    if (shape.isNumeric()) {
        return withFormat(Boolean.TRUE, null);
    }
    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..
    // First: custom pattern will override things
    if (format.hasPattern()) {
        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();
        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);
        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();
        df.setTimeZone(tz);
        return withFormat(Boolean.FALSE, df);
    }
    // Otherwise, need one of these changes:
    final boolean hasLocale = format.hasLocale();
    final boolean hasTZ = format.hasTimeZone();
    final boolean asString = (shape == JsonFormat.Shape.STRING);
    if (!hasLocale && !hasTZ && !asString) {
        return this;
    }
    DateFormat df0 = serializers.getConfig().getDateFormat();
    // Jackson's own `StdDateFormat` is quite easy to deal with...
    if (df0 instanceof StdDateFormat) {
        StdDateFormat std = (StdDateFormat) df0;
        if (format.hasLocale()) {
            std = std.withLocale(format.getLocale());
        }
        if (format.hasTimeZone()) {
            std = std.withTimeZone(format.getTimeZone());
        }
        return withFormat(Boolean.FALSE, std);
    }
    // 08-Jun-2017, tatu: Unfortunately there's no generally usable
    //    mechanism for changing `DateFormat` instances (or even clone()ing)
    //    So: require it be `SimpleDateFormat`; can't config other types
    if (!(df0 instanceof SimpleDateFormat)) {
        serializers.reportBadDefinition(handledType(), String.format(""Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`"", df0.getClass().getName()));
    }
    SimpleDateFormat df = (SimpleDateFormat) df0;
    if (hasLocale) {
        // Ugh. No way to change `Locale`, create copy; must re-crete completely:
        df = new SimpleDateFormat(df.toPattern(), format.getLocale());
    } else {
        df = (SimpleDateFormat) df.clone();
    }
    TimeZone newTz = format.getTimeZone();
    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());
    if (changeTZ) {
        df.setTimeZone(newTz);
    }
    return withFormat(Boolean.FALSE, df);
}","public void test11() throws Throwable {
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
    JsonSerializer<?> jsonSerializer0 = sqlDateSerializer0.createContextual(defaultSerializerProvider_Impl0, beanProperty_Bogus0);
    assertSame(sqlDateSerializer0, jsonSerializer0);
}",""
"@Override
public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {
    // Note! Should not skip if `property` null since that'd skip check
    // for config overrides, in case of root value
    if (property == null) {
        return this;
    }
    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());
    if (format == null) {
        return this;
    }
    // Simple case first: serialize as numeric timestamp?
    JsonFormat.Shape shape = format.getShape();
    if (shape.isNumeric()) {
        return withFormat(Boolean.TRUE, null);
    }
    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..
    // First: custom pattern will override things
    if (format.hasPattern()) {
        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();
        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);
        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();
        df.setTimeZone(tz);
        return withFormat(Boolean.FALSE, df);
    }
    // Otherwise, need one of these changes:
    final boolean hasLocale = format.hasLocale();
    final boolean hasTZ = format.hasTimeZone();
    final boolean asString = (shape == JsonFormat.Shape.STRING);
    if (!hasLocale && !hasTZ && !asString) {
        return this;
    }
    DateFormat df0 = serializers.getConfig().getDateFormat();
    // Jackson's own `StdDateFormat` is quite easy to deal with...
    if (df0 instanceof StdDateFormat) {
        StdDateFormat std = (StdDateFormat) df0;
        if (format.hasLocale()) {
            std = std.withLocale(format.getLocale());
        }
        if (format.hasTimeZone()) {
            std = std.withTimeZone(format.getTimeZone());
        }
        return withFormat(Boolean.FALSE, std);
    }
    // 08-Jun-2017, tatu: Unfortunately there's no generally usable
    //    mechanism for changing `DateFormat` instances (or even clone()ing)
    //    So: require it be `SimpleDateFormat`; can't config other types
    if (!(df0 instanceof SimpleDateFormat)) {
        serializers.reportBadDefinition(handledType(), String.format(""Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`"", df0.getClass().getName()));
    }
    SimpleDateFormat df = (SimpleDateFormat) df0;
    if (hasLocale) {
        // Ugh. No way to change `Locale`, create copy; must re-crete completely:
        df = new SimpleDateFormat(df.toPattern(), format.getLocale());
    } else {
        df = (SimpleDateFormat) df.clone();
    }
    TimeZone newTz = format.getTimeZone();
    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());
    if (changeTZ) {
        df.setTimeZone(newTz);
    }
    return withFormat(Boolean.FALSE, df);
}","public void test22() throws Throwable {
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    JsonSerializer<?> jsonSerializer0 = sqlDateSerializer0.createContextual(defaultSerializerProvider_Impl0, (BeanProperty) null);
    assertSame(sqlDateSerializer0, jsonSerializer0);
}",""
"/*
    /**********************************************************
    /* TreeNode implementation
    /**********************************************************
     */
//  public abstract JsonToken asToken();
//  public abstract JsonToken traverse();
//  public abstract JsonToken traverse(ObjectCodec codec);
//  public abstract JsonParser.NumberType numberType();
@Override
public int size() {
    return 0;
}","public void test33() throws Throwable {
    Boolean boolean0 = Boolean.FALSE;
    DateFormat dateFormat0 = DateFormat.getDateTimeInstance();
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer(boolean0, dateFormat0);
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<HashMap> class0 = HashMap.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class0, class0);
    JsonNode jsonNode0 = sqlDateSerializer0.getSchema((SerializerProvider) defaultSerializerProvider_Impl0, (Type) mapType0, true);
    assertEquals(1, jsonNode0.size());
}",""
"/*
    /**********************************************************
    /* TreeNode implementation
    /**********************************************************
     */
//  public abstract JsonToken asToken();
//  public abstract JsonToken traverse();
//  public abstract JsonToken traverse(ObjectCodec codec);
//  public abstract JsonParser.NumberType numberType();
@Override
public int size() {
    return 0;
}","public void test44() throws Throwable {
    Boolean boolean0 = Boolean.valueOf(true);
    DateFormat dateFormat0 = DateFormat.getDateTimeInstance();
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer(boolean0, dateFormat0);
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<HashMap> class0 = HashMap.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class0, class0);
    JsonNode jsonNode0 = sqlDateSerializer0.getSchema((SerializerProvider) defaultSerializerProvider_Impl0, (Type) mapType0, true);
    assertEquals(1, jsonNode0.size());
}",""
"/*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */
protected boolean _asTimestamp(SerializerProvider serializers) {
    if (_useTimestamp != null) {
        return _useTimestamp.booleanValue();
    }
    if (_customFormat == null) {
        if (serializers != null) {
            return serializers.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        }
        // 12-Jun-2014, tatu: Is it legal not to have provider? Was NPE:ing earlier so leave a check
        throw new IllegalArgumentException(""Null SerializerProvider passed for "" + handledType().getName());
    }
    return false;
}","public void test55() throws Throwable {
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    // Undeclared exception!
    try {
        sqlDateSerializer0._asTimestamp(defaultSerializerProvider_Impl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}",""
"public boolean isUnwrappingSerializer() {
    return false;
}","public void test66() throws Throwable {
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer();
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    sqlDateSerializer0._acceptJsonFormatVisitor(jsonFormatVisitorWrapper_Base0, (JavaType) null, false);
    assertFalse(sqlDateSerializer0.isUnwrappingSerializer());
}","/**
 * Accessor for checking whether this serializer is an
 * ""unwrapping"" serializer; this is necessary to know since
 * it may also require caller to suppress writing of the
 * leading property name.
 */"
"public boolean isUnwrappingSerializer() {
    return false;
}","public void test77() throws Throwable {
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer();
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    sqlDateSerializer0._acceptJsonFormatVisitor(jsonFormatVisitorWrapper_Base0, (JavaType) null, true);
    assertFalse(sqlDateSerializer0.isUnwrappingSerializer());
}","/**
 * Accessor for checking whether this serializer is an
 * ""unwrapping"" serializer; this is necessary to know since
 * it may also require caller to suppress writing of the
 * leading property name.
 */"
"protected void _serializeAsString(Date value, JsonGenerator g, SerializerProvider provider) throws IOException {
    if (_customFormat == null) {
        provider.defaultSerializeDateValue(value, g);
        return;
    }
    // 19-Jul-2017, tatu: Here we will try a simple but (hopefully) effective mechanism for
    //    reusing formatter instance. This is our second attempt, after initially trying simple
    //    synchronization (which turned out to be bottleneck for some users in production...).
    //    While `ThreadLocal` could alternatively be used, it is likely that it would lead to
    //    higher memory footprint, but without much upside -- if we can not reuse, we'll just
    //    clone(), which has some overhead but not drastic one.
    DateFormat f = _reusedCustomFormat.getAndSet(null);
    if (f == null) {
        f = (DateFormat) _customFormat.clone();
    }
    g.writeString(f.format(value));
    _reusedCustomFormat.compareAndSet(null, f);
}","public void test88() throws Throwable {
    SqlDateSerializer sqlDateSerializer0 = new SqlDateSerializer();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    MockDate mockDate0 = new MockDate(779, 779, 779);
    // Undeclared exception!
    try {
        sqlDateSerializer0._serializeAsString(mockDate0, (JsonGenerator) null, defaultSerializerProvider_Impl0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}","/**
 * @since 2.9
 */"
