focal_method,test_prefix,docstring
"public final boolean useStaticType() {
    return _asStatic;
}","public void test000() throws Throwable {
    Class<Object> class0 = Object.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    MapType mapType0 = MapType.construct((Class<?>) class0, (JavaType) simpleType0, (JavaType) simpleType0);
    Class<String> class1 = String.class;
    JavaType javaType0 = mapType0._narrow(class1);
    assertFalse(javaType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test011() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Map> class0 = Map.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class0);
    MapType mapType1 = mapType0.withContentValueHandler(class0);
    assertFalse(mapType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test022() throws Throwable {
    Class<Object> class0 = Object.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    MapType mapType0 = MapType.construct((Class<?>) class0, (JavaType) simpleType0, (JavaType) simpleType0);
    TypeBindings typeBindings0 = TypeBindings.create(class0, (List<JavaType>) null);
    JavaType[] javaTypeArray0 = new JavaType[5];
    JavaType javaType0 = mapType0.refine(class0, typeBindings0, simpleType0, javaTypeArray0);
    assertFalse(javaType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test033() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Map> class0 = Map.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class0);
    MapType mapType1 = mapType0.withTypeHandler(mapType0);
    assertFalse(mapType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test044() throws Throwable {
    Class<Object> class0 = Object.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    MapType mapType0 = MapType.construct((Class<?>) class0, (JavaType) simpleType0, (JavaType) simpleType0);
    Integer integer0 = new Integer(48);
    MapType mapType1 = mapType0.withKeyValueHandler(integer0);
    assertFalse(mapType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test055() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Map> class0 = Map.class;
    Class<Object> class1 = Object.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class1, class1);
    Object object0 = new Object();
    MapType mapType1 = mapType0.withContentTypeHandler(object0);
    assertFalse(mapType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test067() throws Throwable {
    Class<Integer> class0 = Integer.class;
    Class<Object> class1 = Object.class;
    SimpleType simpleType0 = new SimpleType(class1);
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
    JavaType[] javaTypeArray0 = new JavaType[4];
    javaTypeArray0[1] = (JavaType) simpleType0;
    javaTypeArray0[3] = (JavaType) simpleType0;
    MapType mapType0 = MapType.construct((Class<?>) class0, typeBindings0, (JavaType) simpleType0, javaTypeArray0, javaTypeArray0[3], javaTypeArray0[1]);
    String string0 = mapType0.getTypeName();
    assertFalse(mapType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public final boolean isEnumType() {
    return _class.isEnum();
}","public void test078() throws Throwable {
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    MapLikeType mapLikeType0 = MapLikeType.upgradeFrom(simpleType0, simpleType0, simpleType0);
    MapType mapType0 = new MapType(mapLikeType0, mapLikeType0, mapLikeType0);
    assertFalse(mapType0.isEnumType());
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test089() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Map> class0 = Map.class;
    Class<Object> class1 = Object.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class1, class1);
    MapType mapType1 = mapType0.withKeyTypeHandler(mapType0);
    assertFalse(mapType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test0910() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Map> class0 = Map.class;
    Class<Object> class1 = Object.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class1, class1);
    MapType mapType1 = mapType0.withValueHandler(mapType0);
    assertFalse(mapType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1011() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Map> class0 = Map.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class0);
    MapType mapType1 = mapType0.withStaticTyping();
    MapType mapType2 = mapType1.withStaticTyping();
    assertFalse(mapType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1012() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Map> class0 = Map.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class0);
    MapType mapType1 = mapType0.withStaticTyping();
    MapType mapType2 = mapType1.withStaticTyping();
    assertTrue(mapType2.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public JavaType withContentType(JavaType contentType) {
    if (_valueType == contentType) {
        return this;
    }
    return new MapType(_class, _bindings, _superClass, _superInterfaces, _keyType, contentType, _valueHandler, _typeHandler, _asStatic);
}","public void test1113() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Map> class0 = Map.class;
    Class<Object> class1 = Object.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class1, class1);
    JavaType javaType0 = mapType0.withContentType(mapType0);
    assertNotSame(javaType0, mapType0);
}",""
"@Override
public abstract boolean equals(Object o);","public void test1114() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Map> class0 = Map.class;
    Class<Object> class1 = Object.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class1, class1);
    JavaType javaType0 = mapType0.withContentType(mapType0);
    assertFalse(javaType0.equals((Object) mapType0));
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1115() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Map> class0 = Map.class;
    Class<Object> class1 = Object.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class1, class1);
    JavaType javaType0 = mapType0.withContentType(mapType0);
    assertFalse(javaType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1216() throws Throwable {
    Class<Object> class0 = Object.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    MapType mapType0 = MapType.construct((Class<?>) class0, (JavaType) simpleType0, (JavaType) simpleType0);
    JavaType javaType0 = mapType0.withContentType(simpleType0);
    assertFalse(javaType0.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public JavaType withContentType(JavaType contentType) {
    if (_valueType == contentType) {
        return this;
    }
    return new MapType(_class, _bindings, _superClass, _superInterfaces, _keyType, contentType, _valueHandler, _typeHandler, _asStatic);
}","public void test1217() throws Throwable {
    Class<Object> class0 = Object.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    MapType mapType0 = MapType.construct((Class<?>) class0, (JavaType) simpleType0, (JavaType) simpleType0);
    JavaType javaType0 = mapType0.withContentType(simpleType0);
    assertSame(javaType0, mapType0);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1318() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Map> class0 = Map.class;
    Class<Object> class1 = Object.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class1, class1);
    MapType mapType1 = mapType0.withKeyType(mapType0);
    assertFalse(mapType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
"@Override
public MapType withKeyType(JavaType keyType) {
    if (keyType == _keyType) {
        return this;
    }
    return new MapType(_class, _bindings, _superClass, _superInterfaces, keyType, _valueType, _valueHandler, _typeHandler, _asStatic);
}","public void test1319() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Map> class0 = Map.class;
    Class<Object> class1 = Object.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class1, class1);
    MapType mapType1 = mapType0.withKeyType(mapType0);
    assertNotSame(mapType1, mapType0);
}",""
"@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null)
        return false;
    if (o.getClass() != getClass())
        return false;
    MapLikeType other = (MapLikeType) o;
    return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType);
}","public void test1320() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Map> class0 = Map.class;
    Class<Object> class1 = Object.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class1, class1);
    MapType mapType1 = mapType0.withKeyType(mapType0);
    assertFalse(mapType1.equals((Object) mapType0));
}",""
"@Override
public MapType withKeyType(JavaType keyType) {
    if (keyType == _keyType) {
        return this;
    }
    return new MapType(_class, _bindings, _superClass, _superInterfaces, keyType, _valueType, _valueHandler, _typeHandler, _asStatic);
}","public void test1421() throws Throwable {
    Class<Integer> class0 = Integer.class;
    Class<Object> class1 = Object.class;
    SimpleType simpleType0 = new SimpleType(class1);
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
    JavaType[] javaTypeArray0 = new JavaType[4];
    javaTypeArray0[0] = (JavaType) simpleType0;
    javaTypeArray0[1] = (JavaType) simpleType0;
    javaTypeArray0[3] = (JavaType) simpleType0;
    MapType mapType0 = MapType.construct((Class<?>) class0, typeBindings0, (JavaType) simpleType0, javaTypeArray0, javaTypeArray0[3], javaTypeArray0[1]);
    MapType mapType1 = mapType0.withKeyType(javaTypeArray0[0]);
    assertSame(mapType1, mapType0);
}",""
"public final boolean useStaticType() {
    return _asStatic;
}","public void test1422() throws Throwable {
    Class<Integer> class0 = Integer.class;
    Class<Object> class1 = Object.class;
    SimpleType simpleType0 = new SimpleType(class1);
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
    JavaType[] javaTypeArray0 = new JavaType[4];
    javaTypeArray0[0] = (JavaType) simpleType0;
    javaTypeArray0[1] = (JavaType) simpleType0;
    javaTypeArray0[3] = (JavaType) simpleType0;
    MapType mapType0 = MapType.construct((Class<?>) class0, typeBindings0, (JavaType) simpleType0, javaTypeArray0, javaTypeArray0[3], javaTypeArray0[1]);
    MapType mapType1 = mapType0.withKeyType(javaTypeArray0[0]);
    assertFalse(mapType1.useStaticType());
}","/**
 * Accessor for checking whether handlers for dealing with values of
 * this type should use static typing (as opposed to dynamic typing).
 * Note that while value of 'true' does mean that static typing is to
 * be used, value of 'false' may still be overridden by other settings.
 *
 * @since 2.2
 */"
