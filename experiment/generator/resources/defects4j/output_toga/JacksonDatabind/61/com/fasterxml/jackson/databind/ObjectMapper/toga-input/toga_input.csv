focal_method,test_prefix,docstring
"public ObjectMapper setNodeFactory(JsonNodeFactory f) {
    _deserializationConfig = _deserializationConfig.with(f);
    return this;
}","public void test0000() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonNodeFactory jsonNodeFactory0 = new JsonNodeFactory(false);
    ObjectMapper objectMapper1 = objectMapper0.setNodeFactory(jsonNodeFactory0);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for specifying {@link JsonNodeFactory} to use for
 * constructing root level tree nodes (via method
 * {@link #createObjectNode}
 */"
"@Deprecated
public ObjectReader reader(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test0011() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ArrayNode> class0 = ArrayNode.class;
    Class<Integer> class1 = Integer.class;
    MapLikeType mapLikeType0 = typeFactory0.constructMapLikeType(class0, class1, class1);
    ObjectReader objectReader0 = objectMapper0.reader((JavaType) mapLikeType0);
    assertNotNull(objectReader0);
}","/**
 * @deprecated Since 2.5, use {@link #readerFor(JavaType)} instead
 */"
"public Boolean getIsIgnoredType() {
    return _isIgnoredType;
}","public void test0022() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<BigIntegerNode> class0 = BigIntegerNode.class;
    MutableConfigOverride mutableConfigOverride0 = objectMapper0.configOverride(class0);
    assertNull(mutableConfigOverride0.getIsIgnoredType());
}",""
"public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause) {
    return createDeserializationContext(null, getDeserializationConfig()).hasValueDeserializerFor(type, cause);
}","public void test0033() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<MapLikeType> class0 = MapLikeType.class;
    JavaType javaType0 = TypeFactory.unknownType();
    JavaType[] javaTypeArray0 = new JavaType[3];
    ReferenceType referenceType0 = ReferenceType.construct(class0, (TypeBindings) null, javaType0, javaTypeArray0, javaType0);
    SQLInvalidAuthorizationSpecException sQLInvalidAuthorizationSpecException0 = new SQLInvalidAuthorizationSpecException(""ZW}K{l(V"");
    AtomicReference<Throwable> atomicReference0 = new AtomicReference<Throwable>(sQLInvalidAuthorizationSpecException0);
    boolean boolean0 = objectMapper0.canDeserialize((JavaType) referenceType0, atomicReference0);
    assertFalse(boolean0);
}","/**
 * Method similar to {@link #canDeserialize(JavaType)} but that can return
 * actual {@link Throwable} that was thrown when trying to construct
 * serializer: this may be useful in figuring out what the actual problem is.
 *
 * @since 2.3
 */"
"public ObjectMapper enable(SerializationFeature first, SerializationFeature... f) {
    _serializationConfig = _serializationConfig.with(first, f);
    return this;
}","public void test0044() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.INDENT_OUTPUT;
    SerializationFeature[] serializationFeatureArray0 = new SerializationFeature[4];
    // Undeclared exception!
    try {
        objectMapper0.enable(serializationFeature0, serializationFeatureArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializationConfig"", e);
    }
}","/**
 * Method for enabling specified {@link DeserializationConfig} features.
 * Modifies and returns this instance; no new object is created.
 */"
"public boolean canDeserialize(JavaType type) {
    return createDeserializationContext(null, getDeserializationConfig()).hasValueDeserializerFor(type, null);
}","public void test0055() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    // Undeclared exception!
    try {
        objectMapper0.canDeserialize((JavaType) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null JavaType passed
        //
        verifyException(""com.fasterxml.jackson.databind.deser.DeserializerCache"", e);
    }
}","/**
 *  Method that can be called to check whether mapper thinks
 *  it could deserialize an Object of given type.
 *  Check is done by checking whether a registered deserializer can
 *  be found or built for the type; if not (either by no mapping being
 *  found, or through an <code>Exception</code> being thrown, false
 *  is returned.
 * <p>
 *  <b>NOTE</b>: in case an exception is thrown during course of trying
 *  co construct matching deserializer, it will be effectively swallowed.
 *  If you want access to that exception, call
 *  {@link #canDeserialize(JavaType, AtomicReference)} instead.
 *
 *  @return True if mapper can find a serializer for instances of
 *   given class (potentially serializable), false otherwise (not
 *   serializable)
 */"
"public ObjectMapper enable(DeserializationFeature feature) {
    _deserializationConfig = _deserializationConfig.with(feature);
    return this;
}","public void test0066() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.READ_ENUMS_USING_TO_STRING;
    ObjectMapper objectMapper1 = objectMapper0.enable(deserializationFeature0);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for enabling specified {@link DeserializationConfig} features.
 * Modifies and returns this instance; no new object is created.
 */"
"public ObjectReader readerWithView(Class<?> view) {
    return _newReader(getDeserializationConfig().withView(view));
}","public void test0077() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<BeanDeserializer> class0 = BeanDeserializer.class;
    ObjectReader objectReader0 = objectMapper0.readerWithView(class0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * deserialize objects using specified JSON View (filter).
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(byte[] src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);
}","public void test0088() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    byte[] byteArray0 = new byte[5];
    // Undeclared exception!
    try {
        objectMapper0.readValue(byteArray0, (JavaType) null);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 5
        //
        verifyException(""com.fasterxml.jackson.core.io.UTF32Reader"", e);
    }
}",""
"public ObjectReader reader(ContextAttributes attrs) {
    return _newReader(getDeserializationConfig().with(attrs));
}","public void test0099() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ContextAttributes contextAttributes0 = ContextAttributes.getEmpty();
    ObjectReader objectReader0 = objectMapper0.reader(contextAttributes0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * use specified default attributes.
 *
 * @since 2.3
 */"
"public ObjectMapper setDateFormat(DateFormat dateFormat) {
    _deserializationConfig = _deserializationConfig.with(dateFormat);
    _serializationConfig = _serializationConfig.with(dateFormat);
    return this;
}","public void test01010() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DateFormat dateFormat0 = MockDateFormat.getTimeInstance(0);
    ObjectMapper objectMapper1 = objectMapper0.setDateFormat(dateFormat0);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for configuring the default {@link DateFormat} to use when serializing time
 * values as Strings, and deserializing from JSON Strings.
 * This is preferably to directly modifying {@link SerializationConfig} and
 * {@link DeserializationConfig} instances.
 * If you need per-request configuration, use {@link #writer(DateFormat)} to
 * create properly configured {@link ObjectWriter} and use that; this because
 * {@link ObjectWriter}s are thread-safe whereas ObjectMapper itself is only
 * thread-safe when configuring methods (such as this one) are NOT called.
 */"
"public ObjectMapper setLocale(Locale l) {
    _deserializationConfig = _deserializationConfig.with(l);
    _serializationConfig = _serializationConfig.with(l);
    return this;
}","public void test01111() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Locale locale0 = Locale.ENGLISH;
    ObjectMapper objectMapper1 = objectMapper0.setLocale(locale0);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for overriding default locale to use for formatting.
 * Default value used is {@link Locale#getDefault()}.
 */"
"public boolean isCachable() {
    return false;
}","public void test01515() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Long> class0 = Long.TYPE;
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    JavaType javaType0 = typeFactory0.constructType((Type) class0, typeBindings0);
    ObjectReader objectReader0 = objectMapper0.readerFor(javaType0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = (DefaultDeserializationContext.Impl) objectReader0._context;
    JsonDeserializer<Object> jsonDeserializer0 = objectMapper0._findRootDeserializer(defaultDeserializationContext_Impl0, javaType0);
    assertTrue(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"/*
    /**********************************************************
    /* Methods sub-classes MUST override
    /**********************************************************
     */
/**
 *  Method for creating a new {@link ObjectMapper} instance that
 *  has same initial configuration as this instance. Note that this
 *  also requires making a copy of the underlying {@link JsonFactory}
 *  instance.
 * <p>
 *  Method is typically
 *  used when multiple, differently configured mappers are needed.
 *  Although configuration is shared, cached serializers and deserializers
 *  are NOT shared, which means that the new instance may be re-configured
 *  before use; meaning that it behaves the same way as if an instance
 *  was constructed from scratch.
 *
 *  @since 2.1
 */
public ObjectMapper copy() {
    _checkInvalidCopy(ObjectMapper.class);
    return new ObjectMapper(this);
}","public void test01616() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.copy();
    assertNotSame(objectMapper0, objectMapper1);
}",""
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test01818() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.WRAP_ROOT_VALUE;
    SerializationFeature[] serializationFeatureArray0 = new SerializationFeature[0];
    ObjectWriter objectWriter0 = objectMapper0.writer(serializationFeature0, serializationFeatureArray0);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public ObjectReader reader(JsonNodeFactory f) {
    return _newReader(getDeserializationConfig()).with(f);
}","public void test01919() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.withExactBigDecimals(false);
    ObjectReader objectReader0 = objectMapper0.reader(jsonNodeFactory0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * use specified {@link JsonNodeFactory} for constructing JSON trees.
 */"
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public <T> T readValue(byte[] src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));
}","public void test02020() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    // Undeclared exception!
    try {
        objectMapper0.readValue((byte[]) null, (TypeReference) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.JsonFactory"", e);
    }
}",""
"public ObjectMapper setTimeZone(TimeZone tz) {
    _deserializationConfig = _deserializationConfig.with(tz);
    _serializationConfig = _serializationConfig.with(tz);
    return this;
}","public void test02222() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    TimeZone timeZone0 = TimeZone.getTimeZone(""JSON"");
    ObjectMapper objectMapper1 = objectMapper0.setTimeZone(timeZone0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for overriding default TimeZone to use for formatting.
 * Default value used is UTC (NOT default TimeZone of JVM).
 */"
"/*
    /**********************************************************
    /* Configuration, simple features: JsonGenerator.Feature
    /**********************************************************
     */
public boolean isEnabled(JsonGenerator.Feature f) {
    return _serializationConfig.isEnabled(f, _jsonFactory);
}","public void test02323() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT;
    boolean boolean0 = objectMapper0.isEnabled(jsonGenerator_Feature0);
    assertTrue(boolean0);
}",""
"public ObjectReader readerFor(TypeReference<?> type) {
    return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null, null, _injectableValues);
}","public void test02525() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    // Undeclared exception!
    try {
        objectMapper0.readerFor((TypeReference<?>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"public ObjectMapper findAndRegisterModules() {
    return registerModules(findModules());
}","public void test02626() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.findAndRegisterModules();
    assertSame(objectMapper1, objectMapper0);
}","/**
 *  Convenience method that is functionally equivalent to:
 * <code>
 *    mapper.registerModules(mapper.findModules());
 * </code>
 * <p>
 *  As with {@link #findModules()}, no caching is done for modules, so care
 *  needs to be taken to either create and share a single mapper instance;
 *  or to cache introspected set of modules.
 *
 *  @since 2.2
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(DataInput src, JavaType valueType) throws IOException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);
}","public void test02727() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<CollectionType> class0 = CollectionType.class;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ArrayType arrayType0 = typeFactory0.constructArrayType(class0);
    // Undeclared exception!
    try {
        objectMapper0.readValue((DataInput) null, (JavaType) arrayType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper"", e);
    }
}",""
"public ObjectReader reader(Base64Variant defaultBase64) {
    return _newReader(getDeserializationConfig().with(defaultBase64));
}","public void test02828() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader((Base64Variant) null);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * use specified Base64 encoding variant for Base64-encoded binary data.
 *
 * @since 2.1
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test02929() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(objectMapper0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test03030() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    DateFormat dateFormat0 = MockDateFormat.getDateInstance();
    ObjectWriter objectWriter0 = objectMapper0.writer(dateFormat0);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {
    acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);
}","public void test03131() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<SimpleModule> class0 = SimpleModule.class;
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base(defaultSerializerProvider_Impl0);
    objectMapper0.acceptJsonFormatVisitor((Class<?>) class0, (JsonFormatVisitorWrapper) jsonFormatVisitorWrapper_Base0);
}","/**
 *  Method for visiting type hierarchy for given type, using specified visitor.
 * <p>
 *  This method can be used for things like
 *  generating <a href=""http://json-schema.org/"">JSON Schema</a>
 *  instance for specified type.
 *
 *  @param type Type to generate schema for (possibly with generic signature)
 *
 *  @since 2.1
 */"
"public ObjectMapper setConfig(DeserializationConfig config) {
    _deserializationConfig = config;
    return this;
}","public void test03232() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ConfigOverrides configOverrides0 = new ConfigOverrides();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0, configOverrides0);
    ObjectMapper objectMapper1 = objectMapper0.setConfig(deserializationConfig0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 *  Method that allows overriding of the underlying {@link DeserializationConfig}
 *  object.
 *  It is added as a fallback method that may be used if no other configuration
 *  modifier method works: it should not be used if there are alternatives,
 *  and its use is generally discouraged.
 * <p>
 *  <b>NOTE</b>: only use this method if you know what you are doing -- it allows
 *  by-passing some of checks applied to other configuration methods.
 *  Also keep in mind that as with all configuration of {@link ObjectMapper},
 *  this is only thread-safe if done before calling any deserialization methods.
 *
 *  @since 2.4
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test03333() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writer((FilterProvider) null);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType);
}","public void test03434() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    try {
        objectMapper0.readValue(""E+<\u0001eT\u0005+@H!"", (JavaType) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized token 'E': was expecting ('true', 'false' or 'null')
        //  at [Source: java.lang.String@0000000022; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method to deserialize JSON content from given JSON content String.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"public boolean willFailOnUnknownId() {
    return _cfgFailOnUnknownId;
}","public void test03535() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleFilterProvider simpleFilterProvider0 = new SimpleFilterProvider();
    objectMapper0.setFilters(simpleFilterProvider0);
    assertTrue(simpleFilterProvider0.willFailOnUnknownId());
}",""
"public ObjectReader reader(DeserializationFeature feature) {
    return _newReader(getDeserializationConfig().with(feature));
}","public void test03636() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} with
 * specified feature enabled (compared to settings that this
 * mapper instance has).
 * Note that the resulting instance is NOT usable as is,
 * without defining expected value type.
 */"
"/*
    /**********************************************************
    /* Extended Public API: serialization
    /* (mapping from Java types to JSON)
    /**********************************************************
     */
/**
 * Method that can be used to serialize any Java value as
 * JSON output, written to File provided.
 */
public void writeValue(File resultFile, Object value) throws IOException, JsonGenerationException, JsonMappingException {
    _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value);
}","public void test03737() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MockFile mockFile0 = new MockFile("""", """");
    PipedReader pipedReader0 = new PipedReader(7);
    try {
        objectMapper0.writeValue((File) mockFile0, (Object) pipedReader0);
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileOutputStream"", e);
    }
}",""
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test03838() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writerWithType((JavaType) null);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test03939() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<InputStreamReader> class0 = InputStreamReader.class;
    ObjectWriter objectWriter0 = objectMapper0.writerWithView(class0);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test04040() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    objectMapper0.enableDefaultTyping();
    Class<NioPathDeserializer> class0 = NioPathDeserializer.class;
    ObjectWriter objectWriter0 = objectMapper0.writerWithType(class0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public <T> T readValue(byte[] src, int offset, int len, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef));
}","public void test04141() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    byte[] byteArray0 = new byte[3];
    // Undeclared exception!
    try {
        objectMapper0.readValue(byteArray0, 55296, (-1825), (TypeReference) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}",""
"@SuppressWarnings(""unchecked"")
@Override
public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {
    try {
        // Simple cast when we just want to cast to, say, ObjectNode
        // ... one caveat; while everything is Object.class, let's not take shortcut
        if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {
            return (T) n;
        }
        // 20-Apr-2016, tatu: Another thing: for VALUE_EMBEDDED_OBJECT, assume similar
        //    short-cut coercion
        if (n.asToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {
            if (n instanceof POJONode) {
                Object ob = ((POJONode) n).getPojo();
                if ((ob == null) || valueType.isInstance(ob)) {
                    return (T) ob;
                }
            }
        }
        return readValue(treeAsTokens(n), valueType);
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}","public void test04343() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.withExactBigDecimals(false);
    ValueNode valueNode0 = jsonNodeFactory0.numberNode((Long) null);
    Class<MapLikeType> class0 = MapLikeType.class;
    MapLikeType mapLikeType0 = objectMapper0.treeToValue((TreeNode) valueNode0, class0);
    assertNull(mapLikeType0);
}","/**
 *  Convenience conversion method that will bind data given JSON tree
 *  contains into specific value (usually bean) type.
 * <p>
 *  Functionally equivalent to:
 * <pre>
 *    objectMapper.convertValue(n, valueClass);
 * </pre>
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(Reader src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);
}","public void test04444() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    try {
        objectMapper0.readValue((Reader) null, (JavaType) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No content to map due to end-of-input
        //  at [Source: UNKNOWN; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}",""
"public ObjectReader reader(FormatSchema schema) {
    _verifySchemaType(schema);
    return _newReader(getDeserializationConfig(), null, null, schema, _injectableValues);
}","public void test04646() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader((FormatSchema) null);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * pass specific schema object to {@link JsonParser} used for
 * reading content.
 *
 * @param schema Schema to pass to parser
 */"
"@Deprecated
public ObjectReader reader(TypeReference<?> type) {
    return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null, null, _injectableValues);
}","public void test04747() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    // Undeclared exception!
    try {
        objectMapper0.reader((TypeReference<?>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * @deprecated Since 2.5, use {@link #readerFor(TypeReference)} instead
 */"
"@Override
@SuppressWarnings(""unchecked"")
public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readValue(getDeserializationConfig(), p, _typeFactory.constructType(valueTypeRef));
}","public void test04848() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeReference<SimpleModule> typeReference0 = (TypeReference<SimpleModule>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    doReturn((Type) null).when(typeReference0).getType();
    // Undeclared exception!
    try {
        objectMapper0.readValue((JsonParser) null, (TypeReference<?>) typeReference0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * Method to deserialize JSON content into a Java type, reference
 * to which is passed as argument. Type is passed using so-called
 * ""super type token"" (see )
 * and specifically needs to be used if the root type is a
 * parameterized (generic) container type.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"/*
    /**********************************************************
    /* Configuration, introspection
    /**********************************************************
     */
/**
 * Method for accessing currently configured visibility checker;
 * object used for determining whether given property element
 * (method, field, constructor) can be auto-detected or not.
 */
public VisibilityChecker<?> getVisibilityChecker() {
    return _serializationConfig.getDefaultVisibilityChecker();
}","public void test04949() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    VisibilityChecker<?> visibilityChecker0 = objectMapper0.getVisibilityChecker();
    assertNotNull(visibilityChecker0);
}",""
"public ObjectMapper enable(SerializationFeature f) {
    _serializationConfig = _serializationConfig.with(f);
    return this;
}","public void test05050() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.FAIL_ON_SELF_REFERENCES;
    ObjectMapper objectMapper1 = objectMapper0.enable(serializationFeature0);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for enabling specified {@link DeserializationConfig} feature.
 * Modifies and returns this instance; no new object is created.
 */"
"public ObjectMapper enable(DeserializationFeature first, DeserializationFeature... f) {
    _deserializationConfig = _deserializationConfig.with(first, f);
    return this;
}","public void test05151() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.READ_ENUMS_USING_TO_STRING;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[4];
    // Undeclared exception!
    try {
        objectMapper0.enable(deserializationFeature0, deserializationFeatureArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationConfig"", e);
    }
}","/**
 * Method for enabling specified {@link DeserializationConfig} features.
 * Modifies and returns this instance; no new object is created.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(URL src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);
}","public void test05353() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<MapLikeType> class0 = MapLikeType.class;
    URI uRI0 = MockURI.aHttpURI;
    URL uRL0 = MockURI.toURL(uRI0);
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    try {
        objectMapper0.readValue(uRL0, (JavaType) resolvedRecursiveType0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Could not find: foo.bar
        //
        verifyException(""org.evosuite.runtime.mock.java.net.EvoHttpURLConnection"", e);
    }
}",""
"@SuppressWarnings(""unchecked"")
public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);
}","public void test05454() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ByteArrayOutputStream> class0 = ByteArrayOutputStream.class;
    MapLikeType mapLikeType0 = typeFactory0.constructRawMapLikeType(class0);
    ObjectMapper objectMapper0 = new ObjectMapper();
    // Undeclared exception!
    try {
        objectMapper0.readValue((File) null, (JavaType) mapLikeType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}","/**
 * Method to deserialize JSON content from given file into given Java type.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"/*
    /**********************************************************
    /* Configuration: ser/deser factory, provider access
    /**********************************************************
     */
/**
 * Method for setting specific {@link SerializerFactory} to use
 * for constructing (bean) serializers.
 */
public ObjectMapper setSerializerFactory(SerializerFactory f) {
    _serializerFactory = f;
    return this;
}","public void test05555() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.setSerializerFactory((SerializerFactory) null);
    assertSame(objectMapper1, objectMapper0);
}",""
"@SuppressWarnings(""resource"")
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {
    ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());
    try {
        _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);
    } catch (JsonProcessingException e) {
        // to support [JACKSON-758]
        throw e;
    } catch (IOException e) {
        // shouldn't really happen, but is declared as possibility so:
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    byte[] result = bb.toByteArray();
    bb.release();
    return result;
}","public void test05656() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    HashMap<String, JsonNode> hashMap0 = new HashMap<String, JsonNode>();
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0, hashMap0);
    byte[] byteArray0 = objectMapper0.writeValueAsBytes(objectNode0);
    assertEquals(2, byteArray0.length);
}","/**
 *  Method that can be used to serialize any Java value as
 *  a byte array. Functionally equivalent to calling
 *  {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}
 *  and getting bytes, but more efficient.
 *  Encoding used will be UTF-8.
 * <p>
 *  Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
 */"
"/*
    /**********************************************************
    /* Configuration, simple features: JsonParser.Feature
    /**********************************************************
     */
public boolean isEnabled(JsonParser.Feature f) {
    return _deserializationConfig.isEnabled(f, _jsonFactory);
}","public void test05757() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER;
    boolean boolean0 = objectMapper0.isEnabled(jsonParser_Feature0);
    assertFalse(boolean0);
}",""
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {
    return readValues(p, _typeFactory.constructType(valueTypeRef));
}","public void test05858() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonParserSequence jsonParserSequence0 = JsonParserSequence.createFlattened(false, (JsonParser) null, (JsonParser) null);
    TypeReference<BasicBeanDescription> typeReference0 = (TypeReference<BasicBeanDescription>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    doReturn((Type) null).when(typeReference0).getType();
    // Undeclared exception!
    try {
        objectMapper0.readValues((JsonParser) jsonParserSequence0, (TypeReference<?>) typeReference0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * Method for reading sequence of Objects from parser stream.
 */"
"protected void _checkInvalidCopy(Class<?> exp) {
    if (getClass() != exp) {
        throw new IllegalStateException(""Failed copy(): "" + getClass().getName() + "" (version: "" + version() + "") does not override copy(); it has to"");
    }
}","public void test05959() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<OutputStreamWriter> class0 = OutputStreamWriter.class;
    // Undeclared exception!
    try {
        objectMapper0._checkInvalidCopy(class0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Failed copy(): com.fasterxml.jackson.databind.ObjectMapper (version: 2.8.4-SNAPSHOT) does not override copy(); it has to
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectMapper"", e);
    }
}","/**
 * @since 2.1
 */"
"public PropertyNamingStrategy getPropertyNamingStrategy() {
    // arbitrary choice but let's do:
    return _serializationConfig.getPropertyNamingStrategy();
}","public void test06060() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    PropertyNamingStrategy propertyNamingStrategy0 = objectMapper0.getPropertyNamingStrategy();
    assertNull(propertyNamingStrategy0);
}","/**
 * @since 2.5
 */"
"public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException {
    _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);
}","public void test06161() throws Throwable {
    JsonpCharacterEscapes jsonpCharacterEscapes0 = JsonpCharacterEscapes.instance();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    ObjectMapper objectMapper0 = new ObjectMapper();
    objectMapper0.writeValue((OutputStream) byteArrayBuilder0, (Object) jsonpCharacterEscapes0.ESCAPE_NONE);
    assertEquals((-1), CharacterEscapes.ESCAPE_STANDARD);
}","/**
 *  Method that can be used to serialize any Java value as
 *  JSON output, using output stream provided (using encoding
 *  {@link JsonEncoding#UTF8}).
 * <p>
 *  Note: method does not close the underlying stream explicitly
 *  here; however, {@link JsonFactory} this mapper uses may choose
 *  to close the stream depending on its settings (by default,
 *  it will try to close it when {@link JsonGenerator} we construct
 *  is closed).
 */"
"public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException {
    _configAndWriteValue(_jsonFactory.createGenerator(w), value);
}","public void test06262() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    PipedWriter pipedWriter0 = new PipedWriter();
    MockPrintWriter mockPrintWriter0 = new MockPrintWriter(pipedWriter0);
    StringReader stringReader0 = new StringReader(""Failed copy(): "");
    try {
        objectMapper0.writeValue((Writer) mockPrintWriter0, (Object) stringReader0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No serializer found for class java.io.StringReader and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS)
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Method that can be used to serialize any Java value as
 *  JSON output, using Writer provided.
 * <p>
 *  Note: method does not close the underlying stream explicitly
 *  here; however, {@link JsonFactory} this mapper uses may choose
 *  to close the stream depending on its settings (by default,
 *  it will try to close it when {@link JsonGenerator} we construct
 *  is closed).
 */"
"public void writeValue(DataOutput out, Object value) throws IOException {
    _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);
}","public void test06363() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(3751);
    MockPrintStream mockPrintStream0 = new MockPrintStream(byteArrayOutputStream0, true);
    ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(mockPrintStream0);
    try {
        objectMapper0.writeValue((DataOutput) objectOutputStream0, (Object) objectOutputStream0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No serializer found for class java.io.ObjectOutputStream and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS)
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 * @since 2.8
 */"
"public ObjectMapper setDefaultPrettyPrinter(PrettyPrinter pp) {
    _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(pp);
    return this;
}","public void test06464() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MinimalPrettyPrinter minimalPrettyPrinter0 = new MinimalPrettyPrinter();
    ObjectMapper objectMapper1 = objectMapper0.setDefaultPrettyPrinter(minimalPrettyPrinter0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for specifying {@link PrettyPrinter} to use when ""default pretty-printing""
 * is enabled (by enabling {@link SerializationFeature#INDENT_OUTPUT})
 *
 * @param pp Pretty printer to use by default.
 *
 * @return This mapper, useful for call-chaining
 *
 * @since 2.6
 */"
"public ObjectMapper configure(JsonParser.Feature f, boolean state) {
    _jsonFactory.configure(f, state);
    return this;
}","public void test06565() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_SINGLE_QUOTES;
    ObjectMapper objectMapper1 = objectMapper0.configure(jsonParser_Feature0, true);
    assertSame(objectMapper0, objectMapper1);
}","/**
 *  Method for changing state of specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s
 *  for parser instances this object mapper creates.
 * <p>
 *  Note that this is equivalent to directly calling same method
 *  on {@link #getFactory}.
 */"
"@Deprecated
public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) {
    addMixIn(target, mixinSource);
}","public void test06666() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<ObjectInputStream> class0 = ObjectInputStream.class;
    Class<SimpleModule> class1 = SimpleModule.class;
    objectMapper0.addMixInAnnotations(class0, class1);
}","/**
 * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #addMixIn(Class, Class)}.
 */"
"@Override
@SuppressWarnings(""unchecked"")
public final <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readValue(getDeserializationConfig(), p, (JavaType) valueType);
}","public void test06767() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory(objectMapper0);
    byte[] byteArray0 = new byte[9];
    JsonParser jsonParser0 = jsonFactory0.createParser(byteArray0, 192, (int) (byte) (-1));
    try {
        objectMapper0.readValue(jsonParser0, (ResolvedType) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No content to map due to end-of-input
        //  at [Source: [B@0000000023; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 * Method to deserialize JSON content into a Java type, reference
 * to which is passed as argument. Type is passed using
 * Jackson specific type; instance of which can be constructed using
 * {@link TypeFactory}.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"/*
    /**********************************************************
    /* Configuration, deserialization
    /**********************************************************
     */
/**
 *  Method that can be used to get hold of {@link JsonNodeFactory}
 *  that this mapper will use when directly constructing
 *  root {@link JsonNode} instances for Trees.
 * <p>
 *  Note: this is just a shortcut for calling
 * <pre>
 *    getDeserializationConfig().getNodeFactory()
 * </pre>
 */
public JsonNodeFactory getNodeFactory() {
    return _deserializationConfig.getNodeFactory();
}","public void test06868() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonNodeFactory jsonNodeFactory0 = objectMapper0.getNodeFactory();
    assertNotNull(jsonNodeFactory0);
}",""
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test06969() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writer();
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test07070() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    assertEquals(0, deserializationContext0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {
    _serializationConfig = _serializationConfig.with(ai);
    _deserializationConfig = _deserializationConfig.with(ai);
    return this;
}","public void test07171() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.setAnnotationIntrospector((AnnotationIntrospector) null);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for setting {@link AnnotationIntrospector} used by this
 * mapper instance for both serialization and deserialization.
 * Note that doing this will replace the current introspector, which
 * may lead to unavailability of core Jackson annotations.
 * If you want to combine handling of multiple introspectors,
 * have a look at {@link com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair}.
 *
 * @see com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair
 */"
"public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {
    _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);
    _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);
    return this;
}","public void test07272() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    PropertyAccessor propertyAccessor0 = PropertyAccessor.NONE;
    JsonAutoDetect.Visibility jsonAutoDetect_Visibility0 = JsonAutoDetect.Visibility.ANY;
    ObjectMapper objectMapper1 = objectMapper0.setVisibility(propertyAccessor0, jsonAutoDetect_Visibility0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 *  Convenience method that allows changing configuration for
 *  underlying {@link VisibilityChecker}s, to change details of what kinds of
 *  properties are auto-detected.
 *  Basically short cut for doing:
 * <pre>
 *   mapper.setVisibilityChecker(
 *      mapper.getVisibilityChecker().withVisibility(forMethod, visibility)
 *   );
 * </pre>
 *  one common use case would be to do:
 * <pre>
 *   mapper.setVisibility(JsonMethod.FIELD, Visibility.ANY);
 * </pre>
 *  which would make all member fields serializable without further annotations,
 *  instead of just public fields (default setting).
 *
 *  @param forMethod Type of property descriptor affected (field, getter/isGetter,
 *      setter, creator)
 *  @param visibility Minimum visibility to require for the property descriptors of type
 *
 *  @return Modified mapper instance (that is, ""this""), to allow chaining
 *     of configuration calls
 */"
"public ObjectMapper setSubtypeResolver(SubtypeResolver str) {
    _subtypeResolver = str;
    _deserializationConfig = _deserializationConfig.with(str);
    _serializationConfig = _serializationConfig.with(str);
    return this;
}","public void test07373() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    ObjectMapper objectMapper1 = objectMapper0.setSubtypeResolver(stdSubtypeResolver0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for setting custom subtype resolver to use.
 */"
"public ObjectMapper setInjectableValues(InjectableValues injectableValues) {
    _injectableValues = injectableValues;
    return this;
}","public void test07575() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    InjectableValues.Std injectableValues_Std0 = new InjectableValues.Std();
    ObjectMapper objectMapper1 = objectMapper0.setInjectableValues(injectableValues_Std0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for configuring {@link InjectableValues} which used to find
 * values to inject.
 */"
"public SerializerProvider getSerializerProvider() {
    return _serializerProvider;
}","public void test07676() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProvider();
    assertNotNull(serializerProvider0);
}","/**
 * Accessor for the ""blueprint"" (or, factory) instance, from which instances
 * are created by calling {@link DefaultSerializerProvider#createInstance}.
 * Note that returned instance can not be directly used as it is not properly
 * configured: to get a properly configured instance to call, use
 * {@link #getSerializerProviderInstance()} instead.
 */"
"public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {
    _serializationConfig = _serializationConfig.with(s);
    _deserializationConfig = _deserializationConfig.with(s);
    return this;
}","public void test07777() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    PropertyNamingStrategy.UpperCamelCaseStrategy propertyNamingStrategy_UpperCamelCaseStrategy0 = (PropertyNamingStrategy.UpperCamelCaseStrategy) PropertyNamingStrategy.UPPER_CAMEL_CASE;
    ObjectMapper objectMapper1 = objectMapper0.setPropertyNamingStrategy(propertyNamingStrategy_UpperCamelCaseStrategy0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for setting custom property naming strategy to use.
 */"
"public Object setHandlerInstantiator(HandlerInstantiator hi) {
    _deserializationConfig = _deserializationConfig.with(hi);
    _serializationConfig = _serializationConfig.with(hi);
    return this;
}","public void test07979() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    HandlerInstantiator handlerInstantiator0 = mock(HandlerInstantiator.class, new ViolatedAssumptionAnswer());
    Object object0 = objectMapper0.setHandlerInstantiator(handlerInstantiator0);
    assertSame(objectMapper0, object0);
}","/**
 * Method for configuring {@link HandlerInstantiator} to use for creating
 * instances of handlers (such as serializers, deserializers, type and type
 * id resolvers), given a class.
 *
 * @param hi Instantiator to use; if null, use the default implementation
 */"
"/*
    /**********************************************************
    /* Extended Public API, accessors
    /**********************************************************
     */
/**
 *  Method that can be called to check whether mapper thinks
 *  it could serialize an instance of given Class.
 *  Check is done
 *  by checking whether a serializer can be found for the type.
 * <p>
 *  NOTE: since this method does NOT throw exceptions, but internal
 *  processing may, caller usually has little information as to why
 *  serialization would fail. If you want access to internal {@link Exception},
 *  call {@link #canSerialize(Class, AtomicReference)} instead.
 *
 *  @return True if mapper can find a serializer for instances of
 *   given class (potentially serializable), false otherwise (not
 *   serializable)
 */
public boolean canSerialize(Class<?> type) {
    return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);
}","public void test08080() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<ResolvedRecursiveType> class0 = ResolvedRecursiveType.class;
    boolean boolean0 = objectMapper0.canSerialize(class0);
    assertTrue(boolean0);
}",""
"public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName) {
    TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);
    // we'll always use full class name, when using defaulting
    typer = typer.init(JsonTypeInfo.Id.CLASS, null);
    typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);
    typer = typer.typeProperty(propertyName);
    return setDefaultTyping(typer);
}","public void test08181() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT;
    ObjectMapper objectMapper1 = objectMapper0.enableDefaultTypingAsProperty(objectMapper_DefaultTyping0, ""{\""o}LO!?v^V"");
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for enabling automatic inclusion of type information -- needed
 * for proper deserialization of polymorphic types (unless types
 * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) --
 * using ""As.PROPERTY"" inclusion mechanism and specified property name
 * to use for inclusion (default being ""@class"" since default type information
 * always uses class name as type identifier)
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test08383() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonpCharacterEscapes jsonpCharacterEscapes0 = new JsonpCharacterEscapes();
    ObjectWriter objectWriter0 = objectMapper0.writer((CharacterEscapes) jsonpCharacterEscapes0);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Extended Public API: constructing ObjectReaders
    /* for more advanced configuration
    /**********************************************************
     */
/**
 * Factory method for constructing {@link ObjectReader} with
 * default settings. Note that the resulting instance is NOT usable as is,
 * without defining expected value type.
 */
public ObjectReader reader() {
    return _newReader(getDeserializationConfig()).with(_injectableValues);
}","public void test08484() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    assertNotNull(objectReader0);
}",""
"@SuppressWarnings(""unchecked"")
public <T> T readValue(JsonParser p, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readValue(getDeserializationConfig(), p, valueType);
}","public void test08686() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<CharArrayReader> class0 = CharArrayReader.class;
    Class<BufferedReader> class1 = BufferedReader.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructCollectionLikeType(class0, class1);
    // Undeclared exception!
    try {
        objectMapper0.readValue((JsonParser) null, (JavaType) collectionLikeType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectMapper"", e);
    }
}","/**
 * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, Class)}.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"@Override
public <T> MappingIterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(p, (JavaType) valueType);
}","public void test08787() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TokenFilter tokenFilter0 = TokenFilter.INCLUDE_ALL;
    FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate((JsonParser) null, tokenFilter0, true, true);
    // Undeclared exception!
    try {
        objectMapper0.readValues((JsonParser) filteringParserDelegate0, (ResolvedType) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 *  Convenience method, equivalent in function to:
 * <pre>
 *    readerFor(valueType).readValues(p);
 * </pre>
 * <p>
 *  Method for reading sequence of Objects from parser stream.
 *  Sequence can be either root-level ""unwrapped"" sequence (without surrounding
 *  JSON array), or a sequence contained in a JSON Array.
 *  In either case {@link JsonParser} <b>MUST</b> point to the first token of
 *  the first element, OR not point to any token (in which case it is advanced
 *  to the next token). This means, specifically, that for wrapped sequences,
 *  parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that
 *  contains values to read) but rather to the token following it which is the first
 *  token of the first value to read.
 * <p>
 *  Note that {@link ObjectReader} has more complete set of variants.
 */"
"public ObjectReader reader(DeserializationFeature first, DeserializationFeature... other) {
    return _newReader(getDeserializationConfig().with(first, other));
}","public void test08888() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_FLOAT_AS_INT;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[7];
    // Undeclared exception!
    try {
        objectMapper0.reader(deserializationFeature0, deserializationFeatureArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationConfig"", e);
    }
}","/**
 * Factory method for constructing {@link ObjectReader} with
 * specified features enabled (compared to settings that this
 * mapper instance has).
 * Note that the resulting instance is NOT usable as is,
 * without defining expected value type.
 */"
"public ObjectReader reader(InjectableValues injectableValues) {
    return _newReader(getDeserializationConfig(), null, null, null, injectableValues);
}","public void test08989() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    InjectableValues.Std injectableValues_Std0 = new InjectableValues.Std();
    ObjectReader objectReader0 = objectMapper0.reader((InjectableValues) injectableValues_Std0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * use specified injectable values.
 *
 * @param injectableValues Injectable values to use
 */"
"/*
    /**********************************************************
    /* Configuration, simple features: JsonFactory.Feature
    /**********************************************************
     */
/**
 *  Convenience method, equivalent to:
 * <pre>
 *   getJsonFactory().isEnabled(f);
 * </pre>
 */
public boolean isEnabled(JsonFactory.Feature f) {
    return _jsonFactory.isEnabled(f);
}","public void test09090() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory.Feature jsonFactory_Feature0 = JsonFactory.Feature.INTERN_FIELD_NAMES;
    boolean boolean0 = objectMapper0.isEnabled(jsonFactory_Feature0);
    assertTrue(boolean0);
}",""
"// For testing only:
public int mixInCount() {
    return _mixIns.localSize();
}","public void test09191() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    int int0 = objectMapper0.mixInCount();
    assertEquals(0, int0);
}",""
"@SuppressWarnings(""resource"")
public String writeValueAsString(Object value) throws JsonProcessingException {
    // alas, we have to pull the recycler directly here...
    SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());
    try {
        _configAndWriteValue(_jsonFactory.createGenerator(sw), value);
    } catch (JsonProcessingException e) {
        // to support [JACKSON-758]
        throw e;
    } catch (IOException e) {
        // shouldn't really happen, but is declared as possibility so:
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    return sw.getAndClear();
}","public void test09292() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    // Undeclared exception!
    try {
        objectMapper0.writeValueAsString(jsonFactory0);
        fail(""Expecting exception: NoClassDefFoundError"");
    } catch (NoClassDefFoundError e) {
        //
        // com/fasterxml/jackson/databind/JsonMappingException$Reference
        //
        verifyException(""com.fasterxml.jackson.databind.ser.std.BeanSerializerBase"", e);
    }
}","/**
 *  Method that can be used to serialize any Java value as
 *  a String. Functionally equivalent to calling
 *  {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}
 *  and constructing String, but more efficient.
 * <p>
 *  Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test09393() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.USE_EQUALITY_FOR_OBJECT_ID;
    ObjectWriter objectWriter0 = objectMapper0.writer(serializationFeature0);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test09494() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writer((FormatSchema) null);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean isDouble() {
    return false;
}","public void test09595() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectNode objectNode0 = objectMapper0.createObjectNode();
    assertFalse(objectNode0.isDouble());
}",""
"public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {
    return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause);
}","public void test09696() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<MockFileReader> class0 = MockFileReader.class;
    boolean boolean0 = objectMapper0.canSerialize(class0, (AtomicReference<Throwable>) null);
    assertTrue(boolean0);
}","/**
 * Method similar to {@link #canSerialize(Class)} but that can return
 * actual {@link Throwable} that was thrown when trying to construct
 * serializer: this may be useful in figuring out what the actual problem is.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Configuration, simple features: SerializationFeature
    /**********************************************************
     */
/**
 * Method for checking whether given serialization-specific
 * feature is enabled.
 */
public boolean isEnabled(SerializationFeature f) {
    return _serializationConfig.isEnabled(f);
}","public void test09797() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.USE_EQUALITY_FOR_OBJECT_ID;
    boolean boolean0 = objectMapper0.isEnabled(serializationFeature0);
    assertFalse(boolean0);
}",""
"public SerializerFactory getSerializerFactory() {
    return _serializerFactory;
}","public void test09898() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory((ObjectCodec) null);
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    SerializerFactory serializerFactory0 = objectMapper0.getSerializerFactory();
    assertNotNull(serializerFactory0);
}","/**
 *  Method for getting current {@link SerializerFactory}.
 * <p>
 *  Note that since instances are immutable, you can NOT change settings
 *  by accessing an instance and calling methods: this will simply create
 *  new instance of factory object.
 */"
"public ObjectMapper clearProblemHandlers() {
    _deserializationConfig = _deserializationConfig.withNoProblemHandlers();
    return this;
}","public void test09999() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.clearProblemHandlers();
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for removing all registered {@link DeserializationProblemHandler}s
 * instances from this mapper.
 */"
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public <T> T readValue(URL src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));
}","public void test100100() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    // Undeclared exception!
    try {
        objectMapper0.readValue((URL) null, (TypeReference) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.net.MockURL"", e);
    }
}","/**
 * Method to deserialize JSON content from given resource into given Java type.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"public ObjectMapper setBase64Variant(Base64Variant v) {
    _serializationConfig = _serializationConfig.with(v);
    _deserializationConfig = _deserializationConfig.with(v);
    return this;
}","public void test101101() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.setBase64Variant((Base64Variant) null);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method that will configure default {@link Base64Variant} that
 * <code>byte[]</code> serializers and deserializers will use.
 *
 * @param v Base64 variant to use
 *
 * @return This mapper, for convenience to allow chaining
 *
 * @since 2.1
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test102102() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writerWithDefaultPrettyPrinter();
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);
}","public void test103103() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper((JsonFactory) null);
    byte[] byteArray0 = new byte[5];
    try {
        objectMapper0.readValue(byteArray0, (int) (-128), (-1702), (JavaType) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No content to map due to end-of-input
        //  at [Source: [B@0000000025; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}",""
"public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {
    setPropertyInclusion(JsonInclude.Value.construct(incl, JsonInclude.Include.USE_DEFAULTS));
    return this;
}","public void test104104() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonInclude.Include jsonInclude_Include0 = JsonInclude.Include.ALWAYS;
    ObjectMapper objectMapper1 = objectMapper0.setSerializationInclusion(jsonInclude_Include0);
    assertSame(objectMapper1, objectMapper0);
}","/**
 *  Convenience method, equivalent to calling:
 * <pre>
 *   setPropertyInclusion(JsonInclude.Value.construct(incl, Include.ALWAYS));
 * </pre>
 */"
"public ObjectMapper disable(SerializationFeature first, SerializationFeature... f) {
    _serializationConfig = _serializationConfig.without(first, f);
    return this;
}","public void test105105() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.FAIL_ON_EMPTY_BEANS;
    SerializationFeature[] serializationFeatureArray0 = new SerializationFeature[0];
    ObjectMapper objectMapper1 = objectMapper0.disable(serializationFeature0, serializationFeatureArray0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for enabling specified {@link DeserializationConfig} features.
 * Modifies and returns this instance; no new object is created.
 */"
"public InjectableValues getInjectableValues() {
    return _injectableValues;
}","public void test106106() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    InjectableValues injectableValues0 = objectMapper0.getInjectableValues();
    assertNull(injectableValues0);
}","/**
 * @since 2.6
 */"
"public ObjectMapper disable(DeserializationFeature first, DeserializationFeature... f) {
    _deserializationConfig = _deserializationConfig.without(first, f);
    return this;
}","public void test107107() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.READ_ENUMS_USING_TO_STRING;
    // Undeclared exception!
    try {
        objectMapper0.disable(deserializationFeature0, (DeserializationFeature[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationConfig"", e);
    }
}","/**
 * Method for enabling specified {@link DeserializationConfig} features.
 * Modifies and returns this instance; no new object is created.
 */"
"public Class<?> findMixInClassFor(Class<?> cls) {
    return _mixIns.findMixInClassFor(cls);
}","public void test110110() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<DecimalNode> class0 = DecimalNode.class;
    Class<?> class1 = objectMapper0.findMixInClassFor(class0);
    assertNull(class1);
}",""
"public ObjectMapper setConfig(SerializationConfig config) {
    _serializationConfig = config;
    return this;
}","public void test112112() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.setConfig((SerializationConfig) null);
    assertSame(objectMapper0, objectMapper1);
}","/**
 *  Method that allows overriding of the underlying {@link SerializationConfig}
 *  object, which contains serialization-specific configuration settings.
 *  It is added as a fallback method that may be used if no other configuration
 *  modifier method works: it should not be used if there are alternatives,
 *  and its use is generally discouraged.
 * <p>
 *  <b>NOTE</b>: only use this method if you know what you are doing -- it allows
 *  by-passing some of checks applied to other configuration methods.
 *  Also keep in mind that as with all configuration of {@link ObjectMapper},
 *  this is only thread-safe if done before calling any serialization methods.
 *
 *  @since 2.4
 */"
"public boolean isBigDecimal() {
    return false;
}","public void test113113() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ArrayNode arrayNode0 = objectMapper0.createArrayNode();
    assertFalse(arrayNode0.isBigDecimal());
}",""
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Mutant accessors
        @Override
        public MutableConfigOverride configOverride(Class<?> type) {
            return mapper.configOverride(type);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test114114() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    NamedType[] namedTypeArray0 = new NamedType[4];
    SimpleModule simpleModule1 = simpleModule0.registerSubtypes(namedTypeArray0);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule1);
    assertSame(objectMapper0, objectMapper1);
}",""
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public <T> T readValue(File src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));
}","public void test115115() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    MockFile mockFile0 = new MockFile(""m{KhV`7jha@5\""b"");
    try {
        objectMapper0.readValue((File) mockFile0, (TypeReference) null);
        fail(""Expecting exception: FileNotFoundException"");
    } catch (FileNotFoundException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}","/**
 * Method to deserialize JSON content from given file into given Java type.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"public JavaType constructType(Type t) {
    return _typeFactory.constructType(t);
}","public void test116116() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    // Undeclared exception!
    try {
        objectMapper0.constructType((Type) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * Convenience method for constructing {@link JavaType} out of given
 * type (typically <code>java.lang.Class</code>), but without explicit
 * context.
 */"
"public ObjectMapper disable(SerializationFeature f) {
    _serializationConfig = _serializationConfig.without(f);
    return this;
}","public void test117117() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.WRITE_DATES_WITH_ZONE_ID;
    ObjectMapper objectMapper1 = objectMapper0.disable(serializationFeature0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for enabling specified {@link DeserializationConfig} features.
 * Modifies and returns this instance; no new object is created.
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test118118() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writer((Base64Variant) null);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public <T> T readValue(Reader src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));
}","public void test119119() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    PipedReader pipedReader0 = new PipedReader();
    PushbackReader pushbackReader0 = new PushbackReader(pipedReader0);
    TypeReference<BooleanNode> typeReference0 = (TypeReference<BooleanNode>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    doReturn((Type) null).when(typeReference0).getType();
    // Undeclared exception!
    try {
        objectMapper0.readValue((Reader) pushbackReader0, (TypeReference) typeReference0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}",""
"public ObjectMapper setFilterProvider(FilterProvider filterProvider) {
    _serializationConfig = _serializationConfig.withFilters(filterProvider);
    return this;
}","public void test120120() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleFilterProvider simpleFilterProvider0 = new SimpleFilterProvider();
    ObjectMapper objectMapper1 = objectMapper0.setFilterProvider(simpleFilterProvider0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 *  Method for configuring this mapper to use specified {@link FilterProvider} for
 *  mapping Filter Ids to actual filter instances.
 * <p>
 *  Note that usually it is better to use method {@link #writer(FilterProvider)};
 *  however, sometimes
 *  this method is more convenient. For example, some frameworks only allow configuring
 *  of ObjectMapper instances and not {@link ObjectWriter}s.
 *
 *  @since 2.6
 */"
"@SuppressWarnings(""unchecked"")
public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException {
    return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));
}","public void test121121() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<Object> class0 = Object.class;
    CoreXMLDeserializers.Std coreXMLDeserializers_Std0 = new CoreXMLDeserializers.Std(class0, (-163));
    TypeReference<String> typeReference0 = (TypeReference<String>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    doReturn((Type) null).when(typeReference0).getType();
    try {
        objectMapper0.convertValue((Object) coreXMLDeserializers_Std0, (TypeReference<?>) typeReference0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * See {@link #convertValue(Object, Class)}
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test122122() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ContextAttributes contextAttributes0 = ContextAttributes.getEmpty();
    ObjectWriter objectWriter0 = objectMapper0.writer(contextAttributes0);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public ObjectMapper addHandler(DeserializationProblemHandler h) {
    _deserializationConfig = _deserializationConfig.withHandler(h);
    return this;
}","public void test123123() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.addHandler((DeserializationProblemHandler) null);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for adding specified {@link DeserializationProblemHandler}
 * to be used for handling specific problems during deserialization.
 */"
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public <T> T readValue(InputStream src, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));
}","public void test124124() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Enumeration<ObjectInputStream> enumeration0 = (Enumeration<ObjectInputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(enumeration0).hasMoreElements();
    SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
    TypeReference<ArrayType> typeReference0 = (TypeReference<ArrayType>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    doReturn((Type) null).when(typeReference0).getType();
    // Undeclared exception!
    try {
        objectMapper0.readValue((InputStream) sequenceInputStream0, (TypeReference) typeReference0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}",""
"/*
    /**********************************************************
    /* Configuration, basic type handling
    /**********************************************************
     */
/**
 * Accessor for getting currently configured {@link TypeFactory} instance.
 */
public TypeFactory getTypeFactory() {
    return _typeFactory;
}","public void test125125() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    TypeFactory typeFactory0 = objectMapper0.getTypeFactory();
    assertNotNull(typeFactory0);
}",""
"public ObjectMapper disable(DeserializationFeature feature) {
    _deserializationConfig = _deserializationConfig.without(feature);
    return this;
}","public void test126126() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.EAGER_DESERIALIZER_FETCH;
    ObjectMapper objectMapper1 = objectMapper0.disable(deserializationFeature0);
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for enabling specified {@link DeserializationConfig} features.
 * Modifies and returns this instance; no new object is created.
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test127127() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectWriter objectWriter0 = objectMapper0.writerFor((JavaType) null);
    assertFalse(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {
    _jsonFactory.configure(f, state);
    return this;
}","public void test128128() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonGenerator.Feature jsonGenerator_Feature0 = JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS;
    ObjectMapper objectMapper1 = objectMapper0.configure(jsonGenerator_Feature0, false);
    assertSame(objectMapper0, objectMapper1);
}","/**
 *  Method for changing state of an on/off {@link JsonGenerator} feature for
 *  generator instances this object mapper creates.
 * <p>
 *  Note that this is equivalent to directly calling same method
 *  on {@link #getFactory}.
 */"
"public ObjectMapper disableDefaultTyping() {
    return setDefaultTyping(null);
}","public void test129129() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.disableDefaultTyping();
    assertSame(objectMapper1, objectMapper0);
}","/**
 * Method for disabling automatic inclusion of type information; if so, only
 * explicitly annotated types (ones with
 * {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) will have
 * additional embedded type information.
 */"
"public boolean isLong() {
    return false;
}","public void test130130() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TextNode textNode0 = objectMapper0.valueToTree((Object) "" for format "");
    assertFalse(textNode0.isLong());
}","/**
 * Method that can be used to check whether contained value
 * is a number represented as Java <code>long</code>.
 * Note, however, that even if this method returns false, it
 * is possible that conversion would be possible from other numeric
 * types -- to check if this is possible, use
 * {@link #canConvertToInt()} instead.
 *
 * @return True if the value contained by this node is stored as Java <code>long</code>
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);
}","public void test131131() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper((JsonFactory) null);
    PipedInputStream pipedInputStream0 = new PipedInputStream(375);
    BufferedInputStream bufferedInputStream0 = new BufferedInputStream(pipedInputStream0, 268);
    try {
        objectMapper0.readValue((InputStream) bufferedInputStream0, (JavaType) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedInputStream"", e);
    }
}",""
"public ObjectMapper setTypeFactory(TypeFactory f) {
    _typeFactory = f;
    _deserializationConfig = _deserializationConfig.with(f);
    _serializationConfig = _serializationConfig.with(f);
    return this;
}","public void test132132() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ObjectMapper objectMapper1 = objectMapper0.setTypeFactory(typeFactory0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 *  Method that can be used to override {@link TypeFactory} instance
 *  used by this mapper.
 * <p>
 *  Note: will also set {@link TypeFactory} that deserialization and
 *  serialization config objects use.
 */"
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException {
    return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));
}","public void test133133() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeReference<FilterOutputStream> typeReference0 = (TypeReference<FilterOutputStream>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    doReturn((Type) null).when(typeReference0).getType();
    // Undeclared exception!
    try {
        objectMapper0.readValue("""", (TypeReference) typeReference0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * Method to deserialize JSON content from given JSON content String.
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 * @throws JsonMappingException if the input JSON structure does not match structure
 *   expected for result type (or has other mismatch issues)
 */"
"@Override
public final boolean canOverrideAccessModifiers() {
    return _config.canOverrideAccessModifiers();
}","public void test134134() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    assertTrue(serializerProvider0.canOverrideAccessModifiers());
}",""
"public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {
    _serializerProvider = p;
    return this;
}","public void test135135() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    ObjectMapper objectMapper1 = objectMapper0.setSerializerProvider(defaultSerializerProvider_Impl0);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for setting ""blueprint"" {@link SerializerProvider} instance
 * to use as the base for actual provider instances to use for handling
 * caching of {@link JsonSerializer} instances.
 */"
"public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI, AnnotationIntrospector deserializerAI) {
    _serializationConfig = _serializationConfig.with(serializerAI);
    _deserializationConfig = _deserializationConfig.with(deserializerAI);
    return this;
}","public void test136136() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.setAnnotationIntrospectors((AnnotationIntrospector) null, (AnnotationIntrospector) null);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for changing {@link AnnotationIntrospector} instances used
 * by this mapper instance for serialization and deserialization,
 * specifying them separately so that different introspection can be
 * used for different aspects
 *
 * @since 2.1
 *
 * @param serializerAI {@link AnnotationIntrospector} to use for configuring
 *    serialization
 * @param deserializerAI {@link AnnotationIntrospector} to use for configuring
 *    deserialization
 *
 * @see com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair
 */"
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Mutant accessors
        @Override
        public MutableConfigOverride configOverride(Class<?> type) {
            return mapper.configOverride(type);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test137137() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory();
    Version version0 = jsonFactory0.version();
    SimpleModule simpleModule0 = new SimpleModule(version0);
    Class<MapLikeType> class0 = MapLikeType.class;
    JsonSerializer<MapLikeType> jsonSerializer0 = (JsonSerializer<MapLikeType>) mock(JsonSerializer.class, new ViolatedAssumptionAnswer());
    SimpleModule simpleModule1 = simpleModule0.addKeySerializer((Class<? extends MapLikeType>) class0, jsonSerializer0);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule1);
    assertSame(objectMapper1, objectMapper0);
}",""
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Mutant accessors
        @Override
        public MutableConfigOverride configOverride(Class<?> type) {
            return mapper.configOverride(type);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test138138() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    Class<AbstractDeserializer> class0 = AbstractDeserializer.class;
    simpleModule0.addKeyDeserializer(class0, (KeyDeserializer) null);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule0);
    assertSame(objectMapper0, objectMapper1);
}",""
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Mutant accessors
        @Override
        public MutableConfigOverride configOverride(Class<?> type) {
            return mapper.configOverride(type);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test139139() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    Class<NioPathDeserializer> class0 = NioPathDeserializer.class;
    JsonDeserializer<NioPathDeserializer> jsonDeserializer0 = (JsonDeserializer<NioPathDeserializer>) mock(JsonDeserializer.class, new ViolatedAssumptionAnswer());
    simpleModule0.addDeserializer(class0, (JsonDeserializer<? extends NioPathDeserializer>) jsonDeserializer0);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule0);
    assertSame(objectMapper0, objectMapper1);
}",""
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Mutant accessors
        @Override
        public MutableConfigOverride configOverride(Class<?> type) {
            return mapper.configOverride(type);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test140140() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    Class<ReferenceType> class0 = ReferenceType.class;
    Class<CoreXMLDeserializers.Std> class1 = CoreXMLDeserializers.Std.class;
    ValueInstantiator.Base valueInstantiator_Base0 = new ValueInstantiator.Base(class0);
    SimpleModule simpleModule1 = simpleModule0.addValueInstantiator(class1, valueInstantiator_Base0);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule1);
    assertSame(objectMapper0, objectMapper1);
}",""
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Mutant accessors
        @Override
        public MutableConfigOverride configOverride(Class<?> type) {
            return mapper.configOverride(type);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test141141() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    BeanDeserializerModifier beanDeserializerModifier0 = mock(BeanDeserializerModifier.class, new ViolatedAssumptionAnswer());
    SimpleModule simpleModule1 = simpleModule0.setDeserializerModifier(beanDeserializerModifier0);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule1);
    assertSame(objectMapper1, objectMapper0);
}",""
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Mutant accessors
        @Override
        public MutableConfigOverride configOverride(Class<?> type) {
            return mapper.configOverride(type);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test142142() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    Class<MockFileInputStream> class0 = MockFileInputStream.class;
    JsonSerializer<MockFileInputStream> jsonSerializer0 = (JsonSerializer<MockFileInputStream>) mock(JsonSerializer.class, new ViolatedAssumptionAnswer());
    SimpleModule simpleModule1 = simpleModule0.addSerializer((Class<? extends MockFileInputStream>) class0, jsonSerializer0);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule1);
    assertSame(objectMapper0, objectMapper1);
}",""
"/*
    /**********************************************************
    /* Module registration, discovery
    /**********************************************************
     */
/**
 * Method for registering a module that can extend functionality
 * provided by this mapper; for example, by adding providers for
 * custom serializers and deserializers.
 *
 * @param module Module to register
 */
public ObjectMapper registerModule(Module module) {
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                // plus let's keep them in order too, easier to debug or expose
                // in registration order if that matter
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            // try adding; if already had it, should skip
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    /* Let's ensure we have access to name and version information, 
         * even if we do not have immediate use for either. This way we know
         * that they will be available from beginning
         */
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    final ObjectMapper mapper = this;
    // And then call registration
    module.setupModule(new Module.SetupContext() {

        // // // Accessors
        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            // why do we need the cast here?!?
            return (C) mapper;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return mapper.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return mapper.isEnabled(f);
        }

        // // // Mutant accessors
        @Override
        public MutableConfigOverride configOverride(Class<?> type) {
            return mapper.configOverride(type);
        }

        // // // Methods for registering handlers: deserializers
        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        // // // Methods for registering handlers: serializers
        @Override
        public void addSerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);
        }

        // // // Methods for registering handlers: other
        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = mapper._typeFactory;
            f = f.withModifier(modifier);
            mapper.setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);
            mapper._deserializationContext = mapper._deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            mapper._deserializationConfig = mapper._deserializationConfig.with(ci);
            mapper._serializationConfig = mapper._serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);
            mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            mapper.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            mapper.addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            mapper.addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            mapper.setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public void test143143() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleModule simpleModule0 = new SimpleModule();
    Class<ReferenceType> class0 = ReferenceType.class;
    simpleModule0.setMixInAnnotation(class0, class0);
    ObjectMapper objectMapper1 = objectMapper0.registerModule(simpleModule0);
    assertSame(objectMapper1, objectMapper0);
}",""
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test148148() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.NON_FINAL;
    ObjectMapper objectMapper1 = objectMapper0.enableDefaultTyping(objectMapper_DefaultTyping0);
    Class<Throwable> class0 = Throwable.class;
    ObjectWriter objectWriter0 = objectMapper1.writerWithType(class0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test149149() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.NON_FINAL;
    objectMapper0.enableDefaultTyping(objectMapper_DefaultTyping0);
    Class<LongNode> class0 = LongNode.class;
    ObjectWriter objectWriter0 = objectMapper0.writerWithType(class0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"public ObjectMapper setMixInResolver(ClassIntrospector.MixInResolver resolver) {
    SimpleMixInResolver r = _mixIns.withOverrides(resolver);
    if (r != _mixIns) {
        _mixIns = r;
        _deserializationConfig = new DeserializationConfig(_deserializationConfig, r);
        _serializationConfig = new SerializationConfig(_serializationConfig, r);
    }
    return this;
}","public void test154154() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.setMixInResolver((ClassIntrospector.MixInResolver) null);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method that can be called to specify given resolver for locating
 * mix-in classes to use, overriding directly added mappings.
 * Note that direct mappings are not cleared, but they are only applied
 * if resolver does not provide mix-in matches.
 *
 * @since 2.6
 */"
"public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs) {
    /* 18-Sep-2014, tatu: Let's add explicit check to ensure no one tries to
         *   use ""As.EXTERNAL_PROPERTY"", since that will not work (with 2.5+)
         */
    if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) {
        throw new IllegalArgumentException(""Can not use includeAs of "" + includeAs);
    }
    TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);
    // we'll always use full class name, when using defaulting
    typer = typer.init(JsonTypeInfo.Id.CLASS, null);
    typer = typer.inclusion(includeAs);
    return setDefaultTyping(typer);
}","public void test155155() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.NON_FINAL;
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.EXTERNAL_PROPERTY;
    // Undeclared exception!
    try {
        objectMapper0.enableDefaultTyping(objectMapper_DefaultTyping0, jsonTypeInfo_As0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not use includeAs of EXTERNAL_PROPERTY
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectMapper"", e);
    }
}","/**
 *  Method for enabling automatic inclusion of type information, needed
 *  for proper deserialization of polymorphic types (unless types
 *  have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).
 * <P>
 *  NOTE: use of <code>JsonTypeInfo.As#EXTERNAL_PROPERTY</code> <b>NOT SUPPORTED</b>;
 *  and attempts of do so will throw an {@link IllegalArgumentException} to make
 *  this limitation explicit.
 *
 *  @param applicability Defines kinds of types for which additional type information
 *     is added; see {@link DefaultTyping} for more information.
 */"
"public ObjectMapper configure(MapperFeature f, boolean state) {
    _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f);
    _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f);
    return this;
}","public void test156156() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MapperFeature mapperFeature0 = MapperFeature.PROPAGATE_TRANSIENT_MARKER;
    ObjectMapper objectMapper1 = objectMapper0.configure(mapperFeature0, false);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for changing state of an on/off mapper feature for
 * this mapper instance.
 */"
"public ObjectMapper configure(MapperFeature f, boolean state) {
    _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f);
    _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f);
    return this;
}","public void test157157() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    MapperFeature mapperFeature0 = MapperFeature.AUTO_DETECT_CREATORS;
    ObjectMapper objectMapper1 = objectMapper0.configure(mapperFeature0, true);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for changing state of an on/off mapper feature for
 * this mapper instance.
 */"
"public ObjectMapper configure(SerializationFeature f, boolean state) {
    _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f);
    return this;
}","public void test158158() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    SerializationFeature serializationFeature0 = SerializationFeature.WRITE_DATES_AS_TIMESTAMPS;
    ObjectMapper objectMapper1 = objectMapper0.configure(serializationFeature0, false);
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for changing state of an on/off serialization feature for
 * this object mapper.
 */"
"public ObjectMapper configure(SerializationFeature f, boolean state) {
    _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f);
    return this;
}","public void test159159() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.WRITE_DATES_AS_TIMESTAMPS;
    objectMapper0.configure(serializationFeature0, true);
}","/**
 * Method for changing state of an on/off serialization feature for
 * this object mapper.
 */"
"public ObjectMapper configure(DeserializationFeature f, boolean state) {
    _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f);
    return this;
}","public void test160160() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_UNRESOLVED_OBJECT_IDS;
    objectMapper0.configure(deserializationFeature0, false);
}","/**
 * Method for changing state of an on/off deserialization feature for
 * this object mapper.
 */"
"public ObjectMapper configure(DeserializationFeature f, boolean state) {
    _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f);
    return this;
}","public void test161161() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.WRAP_EXCEPTIONS;
    objectMapper0.configure(deserializationFeature0, true);
}","/**
 * Method for changing state of an on/off deserialization feature for
 * this object mapper.
 */"
"@Override
public <T extends TreeNode> T readTree(JsonParser p) throws IOException, JsonProcessingException {
    /* 02-Mar-2009, tatu: One twist; deserialization provider
         *   will map JSON null straight into Java null. But what
         *   we want to return is the ""null node"" instead.
         */
    /* 05-Aug-2011, tatu: Also, must check for EOF here before
         *   calling readValue(), since that'll choke on it otherwise
         */
    DeserializationConfig cfg = getDeserializationConfig();
    JsonToken t = p.getCurrentToken();
    if (t == null) {
        t = p.nextToken();
        if (t == null) {
            return null;
        }
    }
    JsonNode n = (JsonNode) _readValue(cfg, p, JSON_NODE_TYPE);
    if (n == null) {
        n = getNodeFactory().nullNode();
    }
    @SuppressWarnings(""unchecked"")
    T result = (T) n;
    return result;
}","public void test167167() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory(objectMapper0);
    JsonParser jsonParser0 = jsonFactory0.createParser("""");
    objectMapper0.readTree(jsonParser0);
}","/**
 * Method to deserialize JSON content as tree expressed
 * using set of {@link JsonNode} instances. Returns
 * root of the resulting tree (where root can consist
 * of just a single node if the current event is a
 * value event, not container).
 *
 * @return a {@link JsonNode}, if valid JSON content found; null
 *   if input has no content to bind -- note, however, that if
 *   JSON <code>null</code> token is found, it will be represented
 *   as a non-null {@link JsonNode} (one that returns <code>true</code>
 *   for {@link JsonNode#isNull()}
 *
 * @throws IOException if a low-level I/O problem (unexpected end-of-input,
 *   network error) occurs (passed through as-is without additional wrapping -- note
 *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}
 *   does NOT result in wrapping of exception even if enabled)
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 */"
"public JsonNode readTree(byte[] content) throws IOException, JsonProcessingException {
    JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);
    return (n == null) ? NullNode.instance : n;
}","public void test168168() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    byte[] byteArray0 = new byte[3];
    byteArray0[0] = (byte) 49;
    byteArray0[1] = (byte) 49;
    byteArray0[2] = (byte) 49;
    objectMapper0.readTree(byteArray0);
}","/**
 * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.
 * Returns root of the resulting tree (where root can consist of just a single node if the current
 * event is a value event, not container).
 *
 * @param content JSON content to parse to build the JSON tree.
 *
 * @return a {@link JsonNode}, if valid JSON content found; null
 *   if input has no content to bind -- note, however, that if
 *   JSON <code>null</code> token is found, it will be represented
 *   as a non-null {@link JsonNode} (one that returns <code>true</code>
 *   for {@link JsonNode#isNull()}
 *
 * @throws JsonParseException if underlying input contains invalid content
 *    of type {@link JsonParser} supports (JSON for default case)
 */"
"/*
    /**********************************************************
    /* Public API (from TreeCodec via ObjectCodec): Tree Model support
    /**********************************************************
     */
@Override
public void writeTree(JsonGenerator jgen, TreeNode rootNode) throws IOException, JsonProcessingException {
    SerializationConfig config = getSerializationConfig();
    _serializerProvider(config).serializeValue(jgen, rootNode);
    if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {
        jgen.flush();
    }
}","public void test169169() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    JsonGenerator jsonGenerator0 = jsonFactory0.createGenerator((OutputStream) byteArrayBuilder0);
    FloatNode floatNode0 = new FloatNode((-2));
    ObjectMapper objectMapper0 = new ObjectMapper();
    objectMapper0.writeTree(jsonGenerator0, (TreeNode) floatNode0);
}",""
"public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException {
    SerializationConfig config = getSerializationConfig();
    _serializerProvider(config).serializeValue(jgen, rootNode);
    if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {
        jgen.flush();
    }
}","public void test170170() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder();
    JsonGenerator jsonGenerator0 = jsonFactory0.createGenerator((OutputStream) byteArrayBuilder0);
    FloatNode floatNode0 = new FloatNode(0);
    ObjectMapper objectMapper0 = new ObjectMapper();
    objectMapper0.writeTree(jsonGenerator0, (JsonNode) floatNode0);
}","/**
 * Method to serialize given JSON Tree, using generator
 * provided.
 */"
"@SuppressWarnings(""unchecked"")
@Override
public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {
    try {
        // Simple cast when we just want to cast to, say, ObjectNode
        // ... one caveat; while everything is Object.class, let's not take shortcut
        if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {
            return (T) n;
        }
        // 20-Apr-2016, tatu: Another thing: for VALUE_EMBEDDED_OBJECT, assume similar
        //    short-cut coercion
        if (n.asToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {
            if (n instanceof POJONode) {
                Object ob = ((POJONode) n).getPojo();
                if ((ob == null) || valueType.isInstance(ob)) {
                    return (T) ob;
                }
            }
        }
        return readValue(treeAsTokens(n), valueType);
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}","public void test171171() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    BinaryNode binaryNode0 = new BinaryNode((byte[]) null);
    Class<String> class0 = String.class;
    objectMapper0.treeToValue((TreeNode) binaryNode0, class0);
}","/**
 *  Convenience conversion method that will bind data given JSON tree
 *  contains into specific value (usually bean) type.
 * <p>
 *  Functionally equivalent to:
 * <pre>
 *    objectMapper.convertValue(n, valueClass);
 * </pre>
 */"
"@SuppressWarnings({ ""unchecked"", ""resource"" })
public <T extends JsonNode> T valueToTree(Object fromValue) throws IllegalArgumentException {
    if (fromValue == null)
        return null;
    TokenBuffer buf = new TokenBuffer(this, false);
    if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
        buf = buf.forceUseOfBigDecimal(true);
    }
    JsonNode result;
    try {
        writeValue(buf, fromValue);
        JsonParser p = buf.asParser();
        result = readTree(p);
        p.close();
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw new IllegalArgumentException(e.getMessage(), e);
    }
    return (T) result;
}","public void test172172() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    objectMapper0.valueToTree((Object) null);
}","/**
 *  Reverse of {@link #treeToValue}; given a value (usually bean), will
 *  construct equivalent JSON Tree representation. Functionally similar
 *  to serializing value into JSON and parsing JSON as tree, but
 *  more efficient.
 * <p>
 *  NOTE: while results are usually identical to that of serialization followed
 *  by deserialization, this is not always the case. In some cases serialization
 *  into intermediate representation will retain encapsulation of things like
 *  raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic
 *  node identity ({@link JsonNode}). If so, result is a valid tree, but values
 *  are not re-constructed through actual JSON representation. So if transformation
 *  requires actual materialization of JSON (or other data format that this mapper
 *  produces), it will be necessary to do actual serialization.
 *
 *  @param <T> Actual node type; usually either basic {@link JsonNode} or
 *   {@link com.fasterxml.jackson.databind.node.ObjectNode}
 *  @param fromValue Bean value to convert
 *  @return Root node of the resulting JSON tree
 */"
"public ObjectWriter writerFor(Class<?> rootType) {
    return _newWriter(getSerializationConfig(), ((rootType == null) ? null : _typeFactory.constructType(rootType)), /*PrettyPrinter*/
    null);
}","public void test174174() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    objectMapper0.writerFor((Class<?>) null);
}","/**
 *  Factory method for constructing {@link ObjectWriter} that will
 *  serialize objects using specified root type, instead of actual
 *  runtime type of value. Type must be a super-type of runtime type.
 * <p>
 *  Main reason for using this method is performance, as writer is able
 *  to pre-fetch serializer to use before write, and if writer is used
 *  more than once this avoids addition per-value serializer lookups.
 *
 *  @since 2.5
 */"
"public ObjectWriter writerFor(TypeReference<?> rootType) {
    return _newWriter(getSerializationConfig(), ((rootType == null) ? null : _typeFactory.constructType(rootType)), /*PrettyPrinter*/
    null);
}","public void test176176() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    objectMapper0.writerFor((TypeReference<?>) null);
}","/**
 *  Factory method for constructing {@link ObjectWriter} that will
 *  serialize objects using specified root type, instead of actual
 *  runtime type of value. Type must be a super-type of runtime type.
 * <p>
 *  Main reason for using this method is performance, as writer is able
 *  to pre-fetch serializer to use before write, and if writer is used
 *  more than once this avoids addition per-value serializer lookups.
 *
 *  @since 2.5
 */"
"public ObjectWriter writer(PrettyPrinter pp) {
    if (pp == null) {
        // need to use a marker to indicate explicit disabling of pp
        pp = ObjectWriter.NULL_PRETTY_PRINTER;
    }
    return _newWriter(getSerializationConfig(), /*root type*/
    null, pp);
}","public void test177177() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultPrettyPrinter defaultPrettyPrinter0 = new DefaultPrettyPrinter("" for format "");
    objectMapper0.writer((PrettyPrinter) defaultPrettyPrinter0);
}","/**
 * Factory method for constructing {@link ObjectWriter} that will
 * serialize objects using specified pretty printer for indentation
 * (or if null, no pretty printer)
 */"
"public ObjectWriter writer(PrettyPrinter pp) {
    if (pp == null) {
        // need to use a marker to indicate explicit disabling of pp
        pp = ObjectWriter.NULL_PRETTY_PRINTER;
    }
    return _newWriter(getSerializationConfig(), /*root type*/
    null, pp);
}","public void test178178() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    objectMapper0.writer((PrettyPrinter) null);
}","/**
 * Factory method for constructing {@link ObjectWriter} that will
 * serialize objects using specified pretty printer for indentation
 * (or if null, no pretty printer)
 */"
"@Deprecated
public ObjectWriter writerWithType(Class<?> rootType) {
    return _newWriter(getSerializationConfig(), // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:
    ((rootType == null) ? null : _typeFactory.constructType(rootType)), /*PrettyPrinter*/
    null);
}","public void test179179() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    objectMapper0.writerWithType((Class<?>) null);
}","/**
 * @deprecated Since 2.5, use {@link #writerFor(Class)} instead
 */"
"@Deprecated
public ObjectWriter writerWithType(TypeReference<?> rootType) {
    return _newWriter(getSerializationConfig(), // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:
    ((rootType == null) ? null : _typeFactory.constructType(rootType)), /*PrettyPrinter*/
    null);
}","public void test181181() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    objectMapper0.writerWithType((TypeReference<?>) null);
}","/**
 * @deprecated Since 2.5, use {@link #writerFor(TypeReference)} instead
 */"
"@SuppressWarnings(""unchecked"")
public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException {
    // sanity check for null first:
    if (fromValue == null)
        return null;
    return (T) _convert(fromValue, toValueType);
}","public void test183183() throws Throwable {
    Class<ObjectInputStream> class0 = ObjectInputStream.class;
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    try {
        objectMapper0.convertValue((Object) typeBindings0, (JavaType) resolvedRecursiveType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized field \""com.fasterxml.jackson.core.io.SerializedString@0000000215\"" (class java.io.ObjectInputStream), not marked as ignorable (one known property: \""internalObjectInputFilter\""])
        //  at [Source: java.lang.String@0000000717; line: -1, column: -1] (through reference chain: java.io.ObjectInputStream[\""com.fasterxml.jackson.core.io.SerializedString@0000000215\""])
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectMapper"", e);
    }
}","/**
 * See {@link #convertValue(Object, Class)}
 */"
"@SuppressWarnings(""unchecked"")
public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException {
    // sanity check for null first:
    if (fromValue == null)
        return null;
    return (T) _convert(fromValue, toValueType);
}","public void test184184() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    Class<PipedInputStream> class0 = PipedInputStream.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    objectMapper0.convertValue((Object) null, (JavaType) resolvedRecursiveType0);
}","/**
 * See {@link #convertValue(Object, Class)}
 */"
"@SuppressWarnings(""resource"")
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException {
    // also, as per [databind#11], consider case for simple cast
    /* But with caveats: one is that while everything is Object.class, we don't
         * want to ""optimize"" that out; and the other is that we also do not want
         * to lose conversions of generic types.
         */
    Class<?> targetType = toValueType.getRawClass();
    if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) {
        return fromValue;
    }
    // Then use TokenBuffer, which is a JsonGenerator:
    TokenBuffer buf = new TokenBuffer(this, false);
    if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
        buf = buf.forceUseOfBigDecimal(true);
    }
    try {
        // inlined 'writeValue' with minor changes:
        // first: disable wrapping when writing
        SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);
        // no need to check for closing of TokenBuffer
        _serializerProvider(config).serializeValue(buf, fromValue);
        // then matching read, inlined 'readValue' with minor mods:
        final JsonParser p = buf.asParser();
        Object result;
        // ok to pass in existing feature flags; unwrapping handled by mapper
        final DeserializationConfig deserConfig = getDeserializationConfig();
        JsonToken t = _initForReading(p);
        if (t == JsonToken.VALUE_NULL) {
            DeserializationContext ctxt = createDeserializationContext(p, deserConfig);
            result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);
        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
            result = null;
        } else {
            // pointing to event other than null
            DeserializationContext ctxt = createDeserializationContext(p, deserConfig);
            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);
            // note: no handling of unwrapping
            result = deser.deserialize(p, ctxt);
        }
        p.close();
        return result;
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}","public void test185185() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JavaType javaType0 = TypeFactory.unknownType();
    objectMapper0._convert((Object) null, javaType0);
}","/**
 * Actual conversion implementation: instead of using existing read
 * and write methods, much of code is inlined. Reason for this is
 * that we must avoid root value wrapping/unwrapping both for efficiency and
 * for correctness. If root value wrapping/unwrapping is actually desired,
 * caller must use explicit <code>writeValue</code> and
 * <code>readValue</code> methods.
 */"
"public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor) throws JsonMappingException {
    if (type == null) {
        throw new IllegalArgumentException(""type must be provided"");
    }
    _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);
}","public void test186186() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFormatVisitorWrapper.Base jsonFormatVisitorWrapper_Base0 = new JsonFormatVisitorWrapper.Base();
    // Undeclared exception!
    try {
        objectMapper0.acceptJsonFormatVisitor((JavaType) null, (JsonFormatVisitorWrapper) jsonFormatVisitorWrapper_Base0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // type must be provided
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectMapper"", e);
    }
}","/**
 *  Method for visiting type hierarchy for given type, using specified visitor.
 *  Visitation uses <code>Serializer</code> hierarchy and related properties
 * <p>
 *  This method can be used for things like
 *  generating <a href=""http://json-schema.org/"">JSON Schema</a>
 *  instance for specified type.
 *
 *  @param type Type to generate schema for (possibly with generic signature)
 *
 *  @since 2.1
 */"
"protected Object _readMapAndClose(JsonParser p0, JavaType valueType) throws IOException {
    try (JsonParser p = p0) {
        Object result;
        JsonToken t = _initForReading(p);
        if (t == JsonToken.VALUE_NULL) {
            // Ask JsonDeserializer what 'null value' to use:
            DeserializationContext ctxt = createDeserializationContext(p, getDeserializationConfig());
            result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);
        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
            result = null;
        } else {
            DeserializationConfig cfg = getDeserializationConfig();
            DeserializationContext ctxt = createDeserializationContext(p, cfg);
            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);
            if (cfg.useRootWrapping()) {
                result = _unwrapAndDeserialize(p, ctxt, cfg, valueType, deser);
            } else {
                result = deser.deserialize(p, ctxt);
            }
            ctxt.checkUnresolvedObjectId();
        }
        // Need to consume the token too
        p.clearCurrentToken();
        return result;
    }
}","public void test187187() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    // Undeclared exception!
    try {
        objectMapper0._readMapAndClose((JsonParser) null, (JavaType) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectMapper"", e);
    }
}",""
