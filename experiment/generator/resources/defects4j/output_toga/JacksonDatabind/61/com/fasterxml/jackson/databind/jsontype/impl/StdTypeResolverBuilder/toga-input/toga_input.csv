focal_method,test_prefix,docstring
"@Override
public StdTypeResolverBuilder typeIdVisibility(boolean isVisible) {
    _typeIdVisible = isVisible;
    return this;
}","public void test000() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    stdTypeResolverBuilder0.typeIdVisibility(false);
}",""
"public String getTypeProperty() {
    return _typeProperty;
}","public void test011() throws Throwable {
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE;
    ObjectMapper.DefaultTypeResolverBuilder objectMapper_DefaultTypeResolverBuilder0 = new ObjectMapper.DefaultTypeResolverBuilder(objectMapper_DefaultTyping0);
    objectMapper_DefaultTypeResolverBuilder0.getTypeProperty();
}",""
"public boolean isTypeIdVisible() {
    return _typeIdVisible;
}","public void test022() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = new StdTypeResolverBuilder();
    StdTypeResolverBuilder.noTypeInfoBuilder();
    stdTypeResolverBuilder0.isTypeIdVisible();
}",""
"@Override
public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl) {
    _defaultImpl = defaultImpl;
    return this;
}","public void test033() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = new StdTypeResolverBuilder();
    Class<JsonFactory.Feature> class0 = JsonFactory.Feature.class;
    stdTypeResolverBuilder0.defaultImpl(class0);
}",""
"/*
    /**********************************************************
    /* Accessors
    /**********************************************************
     */
@Override
public Class<?> getDefaultImpl() {
    return _defaultImpl;
}","public void test044() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    stdTypeResolverBuilder0.getDefaultImpl();
}",""
"@Override
public StdTypeResolverBuilder typeProperty(String typeIdPropName) {
    // ok to have null/empty; will restore to use defaults
    if (typeIdPropName == null || typeIdPropName.length() == 0) {
        typeIdPropName = _idType.getDefaultPropertyName();
    }
    _typeProperty = typeIdPropName;
    return this;
}","public void test055() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = new StdTypeResolverBuilder();
    stdTypeResolverBuilder0.typeProperty("""");
}","/**
 * Method for constructing an instance with specified type property name
 * (property name to use for type id when using ""as-property"" inclusion).
 */"
"/*
    /**********************************************************
    /* Construction, configuration
    /**********************************************************
     */
@Override
public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs) {
    if (includeAs == null) {
        throw new IllegalArgumentException(""includeAs can not be null"");
    }
    _includeAs = includeAs;
    return this;
}","public void test066() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.EXISTING_PROPERTY;
    stdTypeResolverBuilder0.inclusion(jsonTypeInfo_As0);
}",""
"@Override
public StdTypeResolverBuilder typeProperty(String typeIdPropName) {
    // ok to have null/empty; will restore to use defaults
    if (typeIdPropName == null || typeIdPropName.length() == 0) {
        typeIdPropName = _idType.getDefaultPropertyName();
    }
    _typeProperty = typeIdPropName;
    return this;
}","public void test077() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = new StdTypeResolverBuilder();
    stdTypeResolverBuilder0.typeProperty(""!UML*bCDuMG6yTH&a#"");
}","/**
 * Method for constructing an instance with specified type property name
 * (property name to use for type id when using ""as-property"" inclusion).
 */"
"@Override
public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeSerializer(idRes, null);
        case PROPERTY:
            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeSerializer(idRes, null);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeSerializer(idRes, null, _typeProperty);
        case EXISTING_PROPERTY:
            // as per [#528]
            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test088() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = new StdTypeResolverBuilder();
    JavaType javaType0 = TypeFactory.unknownType();
    ArrayDeque<NamedType> arrayDeque0 = new ArrayDeque<NamedType>();
    stdTypeResolverBuilder0.buildTypeSerializer((SerializationConfig) null, javaType0, arrayDeque0);
}",""
"/*
    /**********************************************************
    /* Internal methods
    /**********************************************************
     */
/**
 * Helper method that will either return configured custom
 * type id resolver, or construct a standard resolver
 * given configuration.
 */
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) {
    // Custom id resolver?
    if (_customIdResolver != null) {
        return _customIdResolver;
    }
    if (_idType == null)
        throw new IllegalStateException(""Can not build, 'init()' not yet called"");
    switch(_idType) {
        case CLASS:
            return new ClassNameIdResolver(baseType, config.getTypeFactory());
        case MINIMAL_CLASS:
            return new MinimalClassNameIdResolver(baseType, config.getTypeFactory());
        case NAME:
            return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser);
        case // hmmh. should never get this far with 'none'
        NONE:
            return null;
        // need custom resolver...
        case CUSTOM:
    }
    throw new IllegalStateException(""Do not know how to construct standard type id resolver for idType: "" + _idType);
}","public void test099() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    JavaType javaType0 = TypeFactory.unknownType();
    LinkedHashSet<NamedType> linkedHashSet0 = new LinkedHashSet<NamedType>();
    stdTypeResolverBuilder0.idResolver((MapperConfig<?>) null, javaType0, linkedHashSet0, true, true);
}",""
"@Override
public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeSerializer(idRes, null);
        case PROPERTY:
            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeSerializer(idRes, null);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeSerializer(idRes, null, _typeProperty);
        case EXISTING_PROPERTY:
            // as per [#528]
            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test1010() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.CUSTOM;
    stdTypeResolverBuilder0._idType = jsonTypeInfo_Id0;
    JavaType javaType0 = TypeFactory.unknownType();
    LinkedHashSet<NamedType> linkedHashSet0 = new LinkedHashSet<NamedType>();
    stdTypeResolverBuilder0.buildTypeSerializer((SerializationConfig) null, javaType0, linkedHashSet0);
}",""
"@Override
public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeSerializer(idRes, null);
        case PROPERTY:
            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeSerializer(idRes, null);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeSerializer(idRes, null, _typeProperty);
        case EXISTING_PROPERTY:
            // as per [#528]
            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test1111() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = new StdTypeResolverBuilder();
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.MINIMAL_CLASS;
    stdTypeResolverBuilder0._idType = jsonTypeInfo_Id0;
    SerializationConfig serializationConfig0 = null;
    JavaType javaType0 = TypeFactory.unknownType();
    HashSet<NamedType> hashSet0 = new HashSet<NamedType>();
    // Undeclared exception!
    try {
        stdTypeResolverBuilder0.buildTypeSerializer((SerializationConfig) null, javaType0, hashSet0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeSerializer(idRes, null);
        case PROPERTY:
            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeSerializer(idRes, null);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeSerializer(idRes, null, _typeProperty);
        case EXISTING_PROPERTY:
            // as per [#528]
            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test1313() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    JavaType javaType0 = TypeFactory.unknownType();
    LinkedHashSet<NamedType> linkedHashSet0 = new LinkedHashSet<NamedType>();
    stdTypeResolverBuilder0.buildTypeSerializer((SerializationConfig) null, javaType0, linkedHashSet0);
}",""
"// as per [#368]
// removed when fix [#528]
//private IllegalArgumentException _noExisting() {
//    return new IllegalArgumentException(""Inclusion type ""+_includeAs+"" not yet supported"");
//}
@Override
public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);
    JavaType defaultImpl;
    if (_defaultImpl == null) {
        defaultImpl = null;
    } else {
        // 20-Mar-2016, tatu: It is important to do specialization go through
        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct
        //   call to JavaType was used, but that can not work reliably with 2.7
        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT
        //   if so, need to add explicit checks for marker types. Not ideal, but
        //   seems like a reasonable compromise.
        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {
            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);
        } else {
            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);
        }
    }
    // First, method for converting type info to type id:
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case PROPERTY:
        case // as per [#528] same class as PROPERTY
        EXISTING_PROPERTY:
            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test1414() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = new StdTypeResolverBuilder();
    TreeSet<NamedType> treeSet0 = new TreeSet<NamedType>();
    stdTypeResolverBuilder0.buildTypeDeserializer((DeserializationConfig) null, (JavaType) null, treeSet0);
}",""
"// as per [#368]
// removed when fix [#528]
//private IllegalArgumentException _noExisting() {
//    return new IllegalArgumentException(""Inclusion type ""+_includeAs+"" not yet supported"");
//}
@Override
public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);
    JavaType defaultImpl;
    if (_defaultImpl == null) {
        defaultImpl = null;
    } else {
        // 20-Mar-2016, tatu: It is important to do specialization go through
        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct
        //   call to JavaType was used, but that can not work reliably with 2.7
        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT
        //   if so, need to add explicit checks for marker types. Not ideal, but
        //   seems like a reasonable compromise.
        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {
            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);
        } else {
            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);
        }
    }
    // First, method for converting type info to type id:
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case PROPERTY:
        case // as per [#528] same class as PROPERTY
        EXISTING_PROPERTY:
            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test1515() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    JavaType javaType0 = TypeFactory.unknownType();
    LinkedHashSet<NamedType> linkedHashSet0 = new LinkedHashSet<NamedType>();
    stdTypeResolverBuilder0.buildTypeDeserializer((DeserializationConfig) null, javaType0, linkedHashSet0);
}",""
"/*
    /**********************************************************
    /* Internal methods
    /**********************************************************
     */
/**
 * Helper method that will either return configured custom
 * type id resolver, or construct a standard resolver
 * given configuration.
 */
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) {
    // Custom id resolver?
    if (_customIdResolver != null) {
        return _customIdResolver;
    }
    if (_idType == null)
        throw new IllegalStateException(""Can not build, 'init()' not yet called"");
    switch(_idType) {
        case CLASS:
            return new ClassNameIdResolver(baseType, config.getTypeFactory());
        case MINIMAL_CLASS:
            return new MinimalClassNameIdResolver(baseType, config.getTypeFactory());
        case NAME:
            return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser);
        case // hmmh. should never get this far with 'none'
        NONE:
            return null;
        // need custom resolver...
        case CUSTOM:
    }
    throw new IllegalStateException(""Do not know how to construct standard type id resolver for idType: "" + _idType);
}","public void test1616() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.NAME;
    stdTypeResolverBuilder0._idType = jsonTypeInfo_Id0;
    JavaType javaType0 = TypeFactory.unknownType();
    LinkedHashSet<NamedType> linkedHashSet0 = new LinkedHashSet<NamedType>();
    stdTypeResolverBuilder0.idResolver((MapperConfig<?>) null, javaType0, linkedHashSet0, false, false);
}",""
"/*
    /**********************************************************
    /* Internal methods
    /**********************************************************
     */
/**
 * Helper method that will either return configured custom
 * type id resolver, or construct a standard resolver
 * given configuration.
 */
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) {
    // Custom id resolver?
    if (_customIdResolver != null) {
        return _customIdResolver;
    }
    if (_idType == null)
        throw new IllegalStateException(""Can not build, 'init()' not yet called"");
    switch(_idType) {
        case CLASS:
            return new ClassNameIdResolver(baseType, config.getTypeFactory());
        case MINIMAL_CLASS:
            return new MinimalClassNameIdResolver(baseType, config.getTypeFactory());
        case NAME:
            return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser);
        case // hmmh. should never get this far with 'none'
        NONE:
            return null;
        // need custom resolver...
        case CUSTOM:
    }
    throw new IllegalStateException(""Do not know how to construct standard type id resolver for idType: "" + _idType);
}","public void test1717() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    JavaType javaType0 = TypeFactory.unknownType();
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(javaType0, (TypeFactory) null);
    stdTypeResolverBuilder0._customIdResolver = (TypeIdResolver) minimalClassNameIdResolver0;
    LinkedHashSet<NamedType> linkedHashSet0 = new LinkedHashSet<NamedType>();
    stdTypeResolverBuilder0.idResolver((MapperConfig<?>) null, javaType0, linkedHashSet0, true, true);
}",""
"@Override
public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeSerializer(idRes, null);
        case PROPERTY:
            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeSerializer(idRes, null);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeSerializer(idRes, null, _typeProperty);
        case EXISTING_PROPERTY:
            // as per [#528]
            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test1818() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<TextNode> class0 = TextNode.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.CUSTOM;
    StdTypeResolverBuilder stdTypeResolverBuilder1 = stdTypeResolverBuilder0.init(jsonTypeInfo_Id0, minimalClassNameIdResolver0);
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.WRAPPER_OBJECT;
    HashSet<NamedType> hashSet0 = new HashSet<NamedType>();
    StdTypeResolverBuilder stdTypeResolverBuilder2 = stdTypeResolverBuilder1.inclusion(jsonTypeInfo_As0);
    stdTypeResolverBuilder2.buildTypeSerializer((SerializationConfig) null, collectionLikeType0, hashSet0);
}",""
"@Override
public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeSerializer(idRes, null);
        case PROPERTY:
            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeSerializer(idRes, null);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeSerializer(idRes, null, _typeProperty);
        case EXISTING_PROPERTY:
            // as per [#528]
            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test1919() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<TextNode> class0 = TextNode.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.MINIMAL_CLASS;
    StdTypeResolverBuilder stdTypeResolverBuilder1 = stdTypeResolverBuilder0.init(jsonTypeInfo_Id0, minimalClassNameIdResolver0);
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.WRAPPER_ARRAY;
    HashSet<NamedType> hashSet0 = new HashSet<NamedType>();
    stdTypeResolverBuilder1.inclusion(jsonTypeInfo_As0);
    stdTypeResolverBuilder0.buildTypeSerializer((SerializationConfig) null, collectionLikeType0, hashSet0);
}",""
"/*
    /**********************************************************
    /* Internal methods
    /**********************************************************
     */
/**
 * Helper method that will either return configured custom
 * type id resolver, or construct a standard resolver
 * given configuration.
 */
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) {
    // Custom id resolver?
    if (_customIdResolver != null) {
        return _customIdResolver;
    }
    if (_idType == null)
        throw new IllegalStateException(""Can not build, 'init()' not yet called"");
    switch(_idType) {
        case CLASS:
            return new ClassNameIdResolver(baseType, config.getTypeFactory());
        case MINIMAL_CLASS:
            return new MinimalClassNameIdResolver(baseType, config.getTypeFactory());
        case NAME:
            return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser);
        case // hmmh. should never get this far with 'none'
        NONE:
            return null;
        // need custom resolver...
        case CUSTOM:
    }
    throw new IllegalStateException(""Do not know how to construct standard type id resolver for idType: "" + _idType);
}","public void test2020() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.CLASS;
    stdTypeResolverBuilder0._idType = jsonTypeInfo_Id0;
    JavaType javaType0 = TypeFactory.unknownType();
    LinkedHashSet<NamedType> linkedHashSet0 = new LinkedHashSet<NamedType>();
    stdTypeResolverBuilder0.idResolver((MapperConfig<?>) null, javaType0, linkedHashSet0, true, true);
}",""
"@Override
public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeSerializer(idRes, null);
        case PROPERTY:
            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeSerializer(idRes, null);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeSerializer(idRes, null, _typeProperty);
        case EXISTING_PROPERTY:
            // as per [#528]
            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test2121() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = new StdTypeResolverBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<JavaType> class0 = JavaType.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.CUSTOM;
    StdTypeResolverBuilder stdTypeResolverBuilder1 = stdTypeResolverBuilder0.init(jsonTypeInfo_Id0, minimalClassNameIdResolver0);
    HashSet<NamedType> hashSet0 = new HashSet<NamedType>();
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.EXTERNAL_PROPERTY;
    StdTypeResolverBuilder stdTypeResolverBuilder2 = stdTypeResolverBuilder1.inclusion(jsonTypeInfo_As0);
    stdTypeResolverBuilder2.buildTypeSerializer((SerializationConfig) null, collectionLikeType0, hashSet0);
}",""
"@Override
public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeSerializer(idRes, null);
        case PROPERTY:
            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeSerializer(idRes, null);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeSerializer(idRes, null, _typeProperty);
        case EXISTING_PROPERTY:
            // as per [#528]
            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test2222() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = new StdTypeResolverBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<TextNode> class0 = TextNode.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.MINIMAL_CLASS;
    StdTypeResolverBuilder stdTypeResolverBuilder1 = stdTypeResolverBuilder0.init(jsonTypeInfo_Id0, minimalClassNameIdResolver0);
    HashSet<NamedType> hashSet0 = new HashSet<NamedType>();
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.EXISTING_PROPERTY;
    stdTypeResolverBuilder1.inclusion(jsonTypeInfo_As0);
    stdTypeResolverBuilder0.buildTypeSerializer((SerializationConfig) null, collectionLikeType0, hashSet0);
}",""
"@Override
public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeSerializer(idRes, null);
        case PROPERTY:
            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeSerializer(idRes, null);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeSerializer(idRes, null, _typeProperty);
        case EXISTING_PROPERTY:
            // as per [#528]
            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test2323() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = new StdTypeResolverBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<BasicBeanDescription> class0 = BasicBeanDescription.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.MINIMAL_CLASS;
    StdTypeResolverBuilder stdTypeResolverBuilder1 = stdTypeResolverBuilder0.init(jsonTypeInfo_Id0, minimalClassNameIdResolver0);
    LinkedHashSet<NamedType> linkedHashSet0 = new LinkedHashSet<NamedType>();
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.PROPERTY;
    stdTypeResolverBuilder1.inclusion(jsonTypeInfo_As0);
    stdTypeResolverBuilder1.buildTypeSerializer((SerializationConfig) null, collectionLikeType0, linkedHashSet0);
}",""
"// as per [#368]
// removed when fix [#528]
//private IllegalArgumentException _noExisting() {
//    return new IllegalArgumentException(""Inclusion type ""+_includeAs+"" not yet supported"");
//}
@Override
public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);
    JavaType defaultImpl;
    if (_defaultImpl == null) {
        defaultImpl = null;
    } else {
        // 20-Mar-2016, tatu: It is important to do specialization go through
        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct
        //   call to JavaType was used, but that can not work reliably with 2.7
        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT
        //   if so, need to add explicit checks for marker types. Not ideal, but
        //   seems like a reasonable compromise.
        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {
            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);
        } else {
            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);
        }
    }
    // First, method for converting type info to type id:
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case PROPERTY:
        case // as per [#528] same class as PROPERTY
        EXISTING_PROPERTY:
            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test2424() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = new StdTypeResolverBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Module> class0 = Module.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.MINIMAL_CLASS;
    stdTypeResolverBuilder0.init(jsonTypeInfo_Id0, minimalClassNameIdResolver0);
    Vector<NamedType> vector0 = new Vector<NamedType>();
    stdTypeResolverBuilder0.buildTypeDeserializer((DeserializationConfig) null, collectionLikeType0, vector0);
}",""
"// as per [#368]
// removed when fix [#528]
//private IllegalArgumentException _noExisting() {
//    return new IllegalArgumentException(""Inclusion type ""+_includeAs+"" not yet supported"");
//}
@Override
public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);
    JavaType defaultImpl;
    if (_defaultImpl == null) {
        defaultImpl = null;
    } else {
        // 20-Mar-2016, tatu: It is important to do specialization go through
        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct
        //   call to JavaType was used, but that can not work reliably with 2.7
        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT
        //   if so, need to add explicit checks for marker types. Not ideal, but
        //   seems like a reasonable compromise.
        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {
            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);
        } else {
            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);
        }
    }
    // First, method for converting type info to type id:
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case PROPERTY:
        case // as per [#528] same class as PROPERTY
        EXISTING_PROPERTY:
            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test2525() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<TextNode> class0 = TextNode.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.MINIMAL_CLASS;
    StdTypeResolverBuilder stdTypeResolverBuilder1 = stdTypeResolverBuilder0.init(jsonTypeInfo_Id0, minimalClassNameIdResolver0);
    stdTypeResolverBuilder1.defaultImpl(class0);
    stdTypeResolverBuilder0.buildTypeDeserializer((DeserializationConfig) null, collectionLikeType0, (Collection<NamedType>) null);
}",""
"// as per [#368]
// removed when fix [#528]
//private IllegalArgumentException _noExisting() {
//    return new IllegalArgumentException(""Inclusion type ""+_includeAs+"" not yet supported"");
//}
@Override
public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);
    JavaType defaultImpl;
    if (_defaultImpl == null) {
        defaultImpl = null;
    } else {
        // 20-Mar-2016, tatu: It is important to do specialization go through
        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct
        //   call to JavaType was used, but that can not work reliably with 2.7
        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT
        //   if so, need to add explicit checks for marker types. Not ideal, but
        //   seems like a reasonable compromise.
        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {
            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);
        } else {
            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);
        }
    }
    // First, method for converting type info to type id:
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case PROPERTY:
        case // as per [#528] same class as PROPERTY
        EXISTING_PROPERTY:
            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test2626() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Module> class0 = Module.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.MINIMAL_CLASS;
    StdTypeResolverBuilder stdTypeResolverBuilder1 = stdTypeResolverBuilder0.init(jsonTypeInfo_Id0, minimalClassNameIdResolver0);
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.WRAPPER_OBJECT;
    stdTypeResolverBuilder1.inclusion(jsonTypeInfo_As0);
    stdTypeResolverBuilder1.buildTypeDeserializer((DeserializationConfig) null, collectionLikeType0, (Collection<NamedType>) null);
}",""
"// as per [#368]
// removed when fix [#528]
//private IllegalArgumentException _noExisting() {
//    return new IllegalArgumentException(""Inclusion type ""+_includeAs+"" not yet supported"");
//}
@Override
public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);
    JavaType defaultImpl;
    if (_defaultImpl == null) {
        defaultImpl = null;
    } else {
        // 20-Mar-2016, tatu: It is important to do specialization go through
        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct
        //   call to JavaType was used, but that can not work reliably with 2.7
        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT
        //   if so, need to add explicit checks for marker types. Not ideal, but
        //   seems like a reasonable compromise.
        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {
            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);
        } else {
            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);
        }
    }
    // First, method for converting type info to type id:
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case PROPERTY:
        case // as per [#528] same class as PROPERTY
        EXISTING_PROPERTY:
            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test2727() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = new StdTypeResolverBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Module> class0 = Module.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.MINIMAL_CLASS;
    stdTypeResolverBuilder0.init(jsonTypeInfo_Id0, minimalClassNameIdResolver0);
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.EXTERNAL_PROPERTY;
    StdTypeResolverBuilder stdTypeResolverBuilder1 = stdTypeResolverBuilder0.inclusion(jsonTypeInfo_As0);
    stdTypeResolverBuilder1.buildTypeDeserializer((DeserializationConfig) null, collectionLikeType0, (Collection<NamedType>) null);
}",""
"// as per [#368]
// removed when fix [#528]
//private IllegalArgumentException _noExisting() {
//    return new IllegalArgumentException(""Inclusion type ""+_includeAs+"" not yet supported"");
//}
@Override
public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);
    JavaType defaultImpl;
    if (_defaultImpl == null) {
        defaultImpl = null;
    } else {
        // 20-Mar-2016, tatu: It is important to do specialization go through
        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct
        //   call to JavaType was used, but that can not work reliably with 2.7
        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT
        //   if so, need to add explicit checks for marker types. Not ideal, but
        //   seems like a reasonable compromise.
        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {
            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);
        } else {
            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);
        }
    }
    // First, method for converting type info to type id:
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case PROPERTY:
        case // as per [#528] same class as PROPERTY
        EXISTING_PROPERTY:
            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test2828() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Module> class0 = Module.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.MINIMAL_CLASS;
    StdTypeResolverBuilder stdTypeResolverBuilder1 = stdTypeResolverBuilder0.init(jsonTypeInfo_Id0, minimalClassNameIdResolver0);
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.WRAPPER_ARRAY;
    stdTypeResolverBuilder0.inclusion(jsonTypeInfo_As0);
    stdTypeResolverBuilder1.buildTypeDeserializer((DeserializationConfig) null, collectionLikeType0, (Collection<NamedType>) null);
}",""
"// as per [#368]
// removed when fix [#528]
//private IllegalArgumentException _noExisting() {
//    return new IllegalArgumentException(""Inclusion type ""+_includeAs+"" not yet supported"");
//}
@Override
public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);
    JavaType defaultImpl;
    if (_defaultImpl == null) {
        defaultImpl = null;
    } else {
        // 20-Mar-2016, tatu: It is important to do specialization go through
        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct
        //   call to JavaType was used, but that can not work reliably with 2.7
        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT
        //   if so, need to add explicit checks for marker types. Not ideal, but
        //   seems like a reasonable compromise.
        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {
            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);
        } else {
            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);
        }
    }
    // First, method for converting type info to type id:
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case PROPERTY:
        case // as per [#528] same class as PROPERTY
        EXISTING_PROPERTY:
            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test2929() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<TextNode> class0 = TextNode.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.CLASS;
    stdTypeResolverBuilder0.init(jsonTypeInfo_Id0, minimalClassNameIdResolver0);
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.EXISTING_PROPERTY;
    stdTypeResolverBuilder0.inclusion(jsonTypeInfo_As0);
    stdTypeResolverBuilder0.buildTypeDeserializer((DeserializationConfig) null, collectionLikeType0, (Collection<NamedType>) null);
}",""
"// as per [#368]
// removed when fix [#528]
//private IllegalArgumentException _noExisting() {
//    return new IllegalArgumentException(""Inclusion type ""+_includeAs+"" not yet supported"");
//}
@Override
public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);
    JavaType defaultImpl;
    if (_defaultImpl == null) {
        defaultImpl = null;
    } else {
        // 20-Mar-2016, tatu: It is important to do specialization go through
        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct
        //   call to JavaType was used, but that can not work reliably with 2.7
        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT
        //   if so, need to add explicit checks for marker types. Not ideal, but
        //   seems like a reasonable compromise.
        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {
            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);
        } else {
            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);
        }
    }
    // First, method for converting type info to type id:
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case PROPERTY:
        case // as per [#528] same class as PROPERTY
        EXISTING_PROPERTY:
            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test3030() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = new StdTypeResolverBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<TypeIdResolver> class0 = TypeIdResolver.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.CLASS;
    StdTypeResolverBuilder stdTypeResolverBuilder1 = stdTypeResolverBuilder0.init(jsonTypeInfo_Id0, minimalClassNameIdResolver0);
    ValueInstantiators.Base valueInstantiators_Base0 = new ValueInstantiators.Base();
    Class<NoClass> class1 = NoClass.class;
    stdTypeResolverBuilder0.defaultImpl(class1);
    TreeSet<NamedType> treeSet0 = new TreeSet<NamedType>();
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    defaultDeserializationContext_Impl0.leaseObjectBuffer();
    defaultDeserializationContext_Impl0.getConfig();
    // Undeclared exception!
    try {
        stdTypeResolverBuilder1.buildTypeDeserializer((DeserializationConfig) null, collectionLikeType0, treeSet0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder"", e);
    }
}",""
"/*
    /**********************************************************
    /* Construction, configuration
    /**********************************************************
     */
@Override
public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs) {
    if (includeAs == null) {
        throw new IllegalArgumentException(""includeAs can not be null"");
    }
    _includeAs = includeAs;
    return this;
}","public void test3131() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Integer> class0 = Integer.TYPE;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    StdTypeResolverBuilder stdTypeResolverBuilder1 = stdTypeResolverBuilder0.init((JsonTypeInfo.Id) null, minimalClassNameIdResolver0);
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.WRAPPER_OBJECT;
    // Undeclared exception!
    try {
        stdTypeResolverBuilder1.inclusion(jsonTypeInfo_As0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // idType can not be null
        //
        verifyException(""com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder"", e);
    }
}",""
"// as per [#368]
// removed when fix [#528]
//private IllegalArgumentException _noExisting() {
//    return new IllegalArgumentException(""Inclusion type ""+_includeAs+"" not yet supported"");
//}
@Override
public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);
    JavaType defaultImpl;
    if (_defaultImpl == null) {
        defaultImpl = null;
    } else {
        // 20-Mar-2016, tatu: It is important to do specialization go through
        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct
        //   call to JavaType was used, but that can not work reliably with 2.7
        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT
        //   if so, need to add explicit checks for marker types. Not ideal, but
        //   seems like a reasonable compromise.
        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {
            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);
        } else {
            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);
        }
    }
    // First, method for converting type info to type id:
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case PROPERTY:
        case // as per [#528] same class as PROPERTY
        EXISTING_PROPERTY:
            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test3232() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<JavaType> class0 = JavaType.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.CLASS;
    StdTypeResolverBuilder stdTypeResolverBuilder1 = stdTypeResolverBuilder0.init(jsonTypeInfo_Id0, minimalClassNameIdResolver0);
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.PROPERTY;
    stdTypeResolverBuilder1.inclusion(jsonTypeInfo_As0);
    TreeSet<NamedType> treeSet0 = new TreeSet<NamedType>();
    stdTypeResolverBuilder1.buildTypeDeserializer((DeserializationConfig) null, collectionLikeType0, treeSet0);
}",""
"// as per [#368]
// removed when fix [#528]
//private IllegalArgumentException _noExisting() {
//    return new IllegalArgumentException(""Inclusion type ""+_includeAs+"" not yet supported"");
//}
@Override
public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (_idType == JsonTypeInfo.Id.NONE) {
        return null;
    }
    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
    //    regardless of setting
    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);
    JavaType defaultImpl;
    if (_defaultImpl == null) {
        defaultImpl = null;
    } else {
        // 20-Mar-2016, tatu: It is important to do specialization go through
        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct
        //   call to JavaType was used, but that can not work reliably with 2.7
        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT
        //   if so, need to add explicit checks for marker types. Not ideal, but
        //   seems like a reasonable compromise.
        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {
            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);
        } else {
            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);
        }
    }
    // First, method for converting type info to type id:
    switch(_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case PROPERTY:
        case // as per [#528] same class as PROPERTY
        EXISTING_PROPERTY:
            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);
    }
    throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: "" + _includeAs);
}","public void test3333() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Void> class0 = Void.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(collectionLikeType0, typeFactory0);
    JsonTypeInfo.Id jsonTypeInfo_Id0 = JsonTypeInfo.Id.MINIMAL_CLASS;
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(collectionLikeType0, typeFactory0);
    StdTypeResolverBuilder stdTypeResolverBuilder1 = stdTypeResolverBuilder0.init(jsonTypeInfo_Id0, classNameIdResolver0);
    StdTypeResolverBuilder stdTypeResolverBuilder2 = stdTypeResolverBuilder1.defaultImpl(class0);
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.WRAPPER_ARRAY;
    stdTypeResolverBuilder2.inclusion(jsonTypeInfo_As0);
    stdTypeResolverBuilder2.buildTypeDeserializer((DeserializationConfig) null, collectionLikeType0, (Collection<NamedType>) null);
}",""
"/*
    /**********************************************************
    /* Construction, configuration
    /**********************************************************
     */
@Override
public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs) {
    if (includeAs == null) {
        throw new IllegalArgumentException(""includeAs can not be null"");
    }
    _includeAs = includeAs;
    return this;
}","public void test3434() throws Throwable {
    StdTypeResolverBuilder stdTypeResolverBuilder0 = new StdTypeResolverBuilder();
    stdTypeResolverBuilder0.inclusion((JsonTypeInfo.As) null);
}",""
