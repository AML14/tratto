focal_method,test_prefix,docstring
"public boolean isCachable() {
    return false;
}","public void test011() throws Throwable {
    NumberDeserializers.BigDecimalDeserializer numberDeserializers_BigDecimalDeserializer0 = new NumberDeserializers.BigDecimalDeserializer();
    assertFalse(numberDeserializers_BigDecimalDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test055() throws Throwable {
    Class<Character> class0 = Character.class;
    Character character0 = Character.valueOf('f');
    NumberDeserializers.CharacterDeserializer numberDeserializers_CharacterDeserializer0 = new NumberDeserializers.CharacterDeserializer(class0, character0);
    assertFalse(numberDeserializers_CharacterDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test066() throws Throwable {
    Class<Short> class0 = Short.class;
    Short short0 = new Short((short) (-3647));
    NumberDeserializers.ShortDeserializer numberDeserializers_ShortDeserializer0 = new NumberDeserializers.ShortDeserializer(class0, short0);
    assertFalse(numberDeserializers_ShortDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test088() throws Throwable {
    Class<Byte> class0 = Byte.class;
    Byte byte0 = new Byte((byte) 125);
    NumberDeserializers.ByteDeserializer numberDeserializers_ByteDeserializer0 = new NumberDeserializers.ByteDeserializer(class0, byte0);
    assertFalse(numberDeserializers_ByteDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test1111() throws Throwable {
    Class<Boolean> class0 = Boolean.TYPE;
    Boolean boolean0 = Boolean.valueOf(""com.fasterxml.jackson.databind.deser.std.NumberDeserializers$CharacterDeserializer"");
    NumberDeserializers.BooleanDeserializer numberDeserializers_BooleanDeserializer0 = new NumberDeserializers.BooleanDeserializer(class0, boolean0);
    assertFalse(numberDeserializers_BooleanDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test1313() throws Throwable {
    Class<Float> class0 = Float.TYPE;
    Float float0 = new Float(0.0);
    NumberDeserializers.FloatDeserializer numberDeserializers_FloatDeserializer0 = new NumberDeserializers.FloatDeserializer(class0, float0);
    assertFalse(numberDeserializers_FloatDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test1717() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    NumberDeserializers.IntegerDeserializer numberDeserializers_IntegerDeserializer0 = NumberDeserializers.IntegerDeserializer.wrapperInstance;
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(numberDeserializers_IntegerDeserializer0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public static JsonDeserializer<?> find(Class<?> rawType, String clsName) {
    if (rawType.isPrimitive()) {
        if (rawType == Integer.TYPE) {
            return IntegerDeserializer.primitiveInstance;
        }
        if (rawType == Boolean.TYPE) {
            return BooleanDeserializer.primitiveInstance;
        }
        if (rawType == Long.TYPE) {
            return LongDeserializer.primitiveInstance;
        }
        if (rawType == Double.TYPE) {
            return DoubleDeserializer.primitiveInstance;
        }
        if (rawType == Character.TYPE) {
            return CharacterDeserializer.primitiveInstance;
        }
        if (rawType == Byte.TYPE) {
            return ByteDeserializer.primitiveInstance;
        }
        if (rawType == Short.TYPE) {
            return ShortDeserializer.primitiveInstance;
        }
        if (rawType == Float.TYPE) {
            return FloatDeserializer.primitiveInstance;
        }
    } else if (_classNames.contains(clsName)) {
        // Start with most common types; int, boolean, long, double
        if (rawType == Integer.class) {
            return IntegerDeserializer.wrapperInstance;
        }
        if (rawType == Boolean.class) {
            return BooleanDeserializer.wrapperInstance;
        }
        if (rawType == Long.class) {
            return LongDeserializer.wrapperInstance;
        }
        if (rawType == Double.class) {
            return DoubleDeserializer.wrapperInstance;
        }
        if (rawType == Character.class) {
            return CharacterDeserializer.wrapperInstance;
        }
        if (rawType == Byte.class) {
            return ByteDeserializer.wrapperInstance;
        }
        if (rawType == Short.class) {
            return ShortDeserializer.wrapperInstance;
        }
        if (rawType == Float.class) {
            return FloatDeserializer.wrapperInstance;
        }
        if (rawType == Number.class) {
            return NumberDeserializer.instance;
        }
        if (rawType == BigDecimal.class) {
            return BigDecimalDeserializer.instance;
        }
        if (rawType == BigInteger.class) {
            return BigIntegerDeserializer.instance;
        }
    } else {
        return null;
    }
    // should never occur
    throw new IllegalArgumentException(""Internal error: can't find deserializer for "" + rawType.getName());
}","public void test1818() throws Throwable {
    Class<Float> class0 = Float.TYPE;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""x"");
    assertNotNull(jsonDeserializer0);
}",""
"public boolean isCachable() {
    return false;
}","public void test1819() throws Throwable {
    Class<Float> class0 = Float.TYPE;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""x"");
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test1920() throws Throwable {
    Class<Integer> class0 = Integer.TYPE;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""java.math.BigInteger"");
    assertTrue(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test2021() throws Throwable {
    Class<Boolean> class0 = Boolean.TYPE;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""java.math.BigInteger"");
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test2122() throws Throwable {
    Class<Long> class0 = Long.TYPE;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""java.mth.BigInteger"");
    assertTrue(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test2223() throws Throwable {
    Class<Double> class0 = Double.TYPE;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""java.|ath.BigInteger"");
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test2324() throws Throwable {
    Class<Character> class0 = Character.TYPE;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, (String) null);
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test2425() throws Throwable {
    Class<Byte> class0 = Byte.TYPE;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""java.math.BigInteger"");
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test2526() throws Throwable {
    Class<Short> class0 = Short.TYPE;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, (String) null);
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test2728() throws Throwable {
    Class<Integer> class0 = Integer.class;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""java.math.BigInteger"");
    assertTrue(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test2829() throws Throwable {
    Class<Boolean> class0 = Boolean.class;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""java.math.BigInteger"");
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test2930() throws Throwable {
    Class<Long> class0 = Long.class;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""java.math.BigInteger"");
    assertTrue(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test3031() throws Throwable {
    Class<Double> class0 = Double.class;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""java.math.BigInteger"");
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test3132() throws Throwable {
    Class<Character> class0 = Character.class;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""java.math.BigInteger"");
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test3233() throws Throwable {
    Class<Byte> class0 = Byte.class;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""java.math.BigInteger"");
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test3435() throws Throwable {
    Class<Float> class0 = Float.class;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""java.math.BigInteger"");
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test3536() throws Throwable {
    Class<BigInteger> class0 = BigInteger.class;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""java.math.BigInteger"");
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test3637() throws Throwable {
    Class<BigDecimal> class0 = BigDecimal.class;
    JsonDeserializer<?> jsonDeserializer0 = NumberDeserializers.find(class0, ""java.math.BigInteger"");
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public static JsonDeserializer<?> find(Class<?> rawType, String clsName) {
    if (rawType.isPrimitive()) {
        if (rawType == Integer.TYPE) {
            return IntegerDeserializer.primitiveInstance;
        }
        if (rawType == Boolean.TYPE) {
            return BooleanDeserializer.primitiveInstance;
        }
        if (rawType == Long.TYPE) {
            return LongDeserializer.primitiveInstance;
        }
        if (rawType == Double.TYPE) {
            return DoubleDeserializer.primitiveInstance;
        }
        if (rawType == Character.TYPE) {
            return CharacterDeserializer.primitiveInstance;
        }
        if (rawType == Byte.TYPE) {
            return ByteDeserializer.primitiveInstance;
        }
        if (rawType == Short.TYPE) {
            return ShortDeserializer.primitiveInstance;
        }
        if (rawType == Float.TYPE) {
            return FloatDeserializer.primitiveInstance;
        }
    } else if (_classNames.contains(clsName)) {
        // Start with most common types; int, boolean, long, double
        if (rawType == Integer.class) {
            return IntegerDeserializer.wrapperInstance;
        }
        if (rawType == Boolean.class) {
            return BooleanDeserializer.wrapperInstance;
        }
        if (rawType == Long.class) {
            return LongDeserializer.wrapperInstance;
        }
        if (rawType == Double.class) {
            return DoubleDeserializer.wrapperInstance;
        }
        if (rawType == Character.class) {
            return CharacterDeserializer.wrapperInstance;
        }
        if (rawType == Byte.class) {
            return ByteDeserializer.wrapperInstance;
        }
        if (rawType == Short.class) {
            return ShortDeserializer.wrapperInstance;
        }
        if (rawType == Float.class) {
            return FloatDeserializer.wrapperInstance;
        }
        if (rawType == Number.class) {
            return NumberDeserializer.instance;
        }
        if (rawType == BigDecimal.class) {
            return BigDecimalDeserializer.instance;
        }
        if (rawType == BigInteger.class) {
            return BigIntegerDeserializer.instance;
        }
    } else {
        return null;
    }
    // should never occur
    throw new IllegalArgumentException(""Internal error: can't find deserializer for "" + rawType.getName());
}","public void test3738() throws Throwable {
    Class<String> class0 = String.class;
    // Undeclared exception!
    try {
        NumberDeserializers.find(class0, ""java.math.BigInteger"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Internal error: can't find deserializer for java.lang.String
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.NumberDeserializers"", e);
    }
}",""
