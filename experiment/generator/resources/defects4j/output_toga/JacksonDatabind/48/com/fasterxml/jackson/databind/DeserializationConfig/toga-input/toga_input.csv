focal_method,test_prefix,docstring
"@SuppressWarnings(""unchecked"")
public <T extends BeanDescription> T introspectForCreation(JavaType type) {
    return (T) getClassIntrospector().forCreation(this, type, this);
}","public void test000() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    // Undeclared exception!
    try {
        deserializationConfig0.introspectForCreation((JavaType) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationConfig"", e);
    }
}","/**
 * Method that will introspect subset of bean properties needed to
 * construct bean instance.
 */"
"public abstract T with(HandlerInstantiator hi);","public void test011() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with((HandlerInstantiator) null);
    assertSame(deserializationConfig1, deserializationConfig0);
}","/**
 *  Method for constructing and returning a new instance with different
 *  {@link HandlerInstantiator}
 *  to use.
 * <p>
 *  NOTE: make sure to register new instance with <code>ObjectMapper</code>
 *  if directly calling this method.
 */"
"public boolean isFloat() {
    return false;
}","public void test022() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ArrayNode arrayNode0 = objectMapper0.createArrayNode();
    assertFalse(arrayNode0.isFloat());
}","/**
 * @since 2.2
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test033() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    Locale locale0 = Locale.KOREA;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(locale0);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public abstract T with(Locale l);","public void test034() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    Locale locale0 = Locale.KOREA;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(locale0);
    assertNotSame(deserializationConfig1, deserializationConfig0);
}","/**
 * Method for constructing and returning a new instance with different
 * default {@link java.util.Locale} to use for formatting.
 */"
"@Override
public DeserializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {
    return _withBase(_base.withVisibility(forMethod, visibility));
}","public void test045() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    PropertyAccessor propertyAccessor0 = PropertyAccessor.CREATOR;
    JsonAutoDetect.Visibility jsonAutoDetect_Visibility0 = JsonAutoDetect.Visibility.NON_PRIVATE;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withVisibility(propertyAccessor0, jsonAutoDetect_Visibility0);
    assertNotSame(deserializationConfig1, deserializationConfig0);
}",""
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test046() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    PropertyAccessor propertyAccessor0 = PropertyAccessor.CREATOR;
    JsonAutoDetect.Visibility jsonAutoDetect_Visibility0 = JsonAutoDetect.Visibility.NON_PRIVATE;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withVisibility(propertyAccessor0, jsonAutoDetect_Visibility0);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public ObjectReader with(JsonNodeFactory f) {
    return _with(_config.with(f));
}","public void test079() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<ObjectReader> class0 = ObjectReader.class;
    ObjectReader objectReader0 = objectMapper0.readerFor(class0);
    ObjectReader objectReader1 = objectReader0.with((JsonNodeFactory) null);
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new reader instance with configuration that uses
 *  passed {@link JsonNodeFactory} for constructing {@link JsonNode}
 *  instances.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 */"
"public T withAttributes(Map<?, ?> attributes) {
    return with(getAttributes().withSharedAttributes(attributes));
}","public void test0810() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    HashMap<ObjectIdResolver, SettableBeanProperty> hashMap0 = new HashMap<ObjectIdResolver, SettableBeanProperty>();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withAttributes(hashMap0);
    assertNotSame(deserializationConfig1, deserializationConfig0);
}","/**
 * Method for constructing an instance that has only specified
 * attributes, removing any attributes that exist before the call.
 *
 * @since 2.3
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test0811() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    HashMap<ObjectIdResolver, SettableBeanProperty> hashMap0 = new HashMap<ObjectIdResolver, SettableBeanProperty>();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withAttributes(hashMap0);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"@SuppressWarnings(""unchecked"")
public <T extends BeanDescription> T introspectForBuilder(JavaType type) {
    return (T) getClassIntrospector().forDeserializationWithBuilder(this, type, this);
}","public void test0912() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    // Undeclared exception!
    try {
        deserializationConfig0.introspectForBuilder((JavaType) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationConfig"", e);
    }
}","/**
 * @since 2.0
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test1114() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withAppendedAnnotationIntrospector(annotationIntrospector0);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public abstract T withAppendedAnnotationIntrospector(AnnotationIntrospector introspector);","public void test1115() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withAppendedAnnotationIntrospector(annotationIntrospector0);
    assertNotSame(deserializationConfig1, deserializationConfig0);
}","/**
 * Method for constructing and returning a new instance with additional
 * {@link AnnotationIntrospector} appended (as the lowest priority one)
 */"
"public abstract T withInsertedAnnotationIntrospector(AnnotationIntrospector introspector);","public void test1216() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withInsertedAnnotationIntrospector((AnnotationIntrospector) null);
    assertSame(deserializationConfig1, deserializationConfig0);
}","/**
 * Method for constructing and returning a new instance with additional
 * {@link AnnotationIntrospector} inserted (as the highest priority one)
 */"
"public ObjectMapper disableDefaultTyping() {
    return setDefaultTyping(null);
}","public void test1317() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.disableDefaultTyping();
    assertSame(objectMapper0, objectMapper1);
}","/**
 * Method for disabling automatic inclusion of type information; if so, only
 * explicitly annotated types (ones with
 * {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) will have
 * additional embedded type information.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test1519() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    BasicClassIntrospector basicClassIntrospector0 = new BasicClassIntrospector();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with((ClassIntrospector) basicClassIntrospector0);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public abstract T with(ClassIntrospector ci);","public void test1520() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    BasicClassIntrospector basicClassIntrospector0 = new BasicClassIntrospector();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with((ClassIntrospector) basicClassIntrospector0);
    assertNotSame(deserializationConfig1, deserializationConfig0);
}","/**
 *  Method for constructing and returning a new instance with different
 *  {@link ClassIntrospector}
 *  to use.
 * <p>
 *  NOTE: make sure to register new instance with <code>ObjectMapper</code>
 *  if directly calling this method.
 */"
"/*
    /**********************************************************
    /* Other configuration
    /**********************************************************
     */
/**
 * Method for getting head of the problem handler chain. May be null,
 * if no handlers have been added.
 */
public LinkedNode<DeserializationProblemHandler> getProblemHandlers() {
    return _problemHandlers;
}","public void test1621() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    LinkedNode<DeserializationProblemHandler> linkedNode0 = deserializationConfig0.getProblemHandlers();
    assertNull(linkedNode0);
}",""
"public abstract T with(PropertyNamingStrategy strategy);","public void test1722() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with((PropertyNamingStrategy) null);
    assertSame(deserializationConfig1, deserializationConfig0);
}","/**
 *  Method for constructing and returning a new instance with different
 *  {@link PropertyNamingStrategy}
 *  to use.
 * <p>
 *  NOTE: make sure to register new instance with <code>ObjectMapper</code>
 *  if directly calling this method.
 */"
"@Override
public DeserializationConfig with(VisibilityChecker<?> vc) {
    return _withBase(_base.withVisibilityChecker(vc));
}","public void test1823() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    VisibilityChecker<?> visibilityChecker0 = deserializationConfig0.getDefaultVisibilityChecker();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(visibilityChecker0);
    assertSame(deserializationConfig1, deserializationConfig0);
}",""
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test1924() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = new DeserializationConfig(deserializationConfig0, (SimpleMixInResolver) null);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"/*
    /**********************************************************
    /* Methods sub-classes MUST override
    /**********************************************************
     */
/**
 *  Method for creating a new {@link ObjectMapper} instance that
 *  has same initial configuration as this instance. Note that this
 *  also requires making a copy of the underlying {@link JsonFactory}
 *  instance.
 * <p>
 *  Method is typically
 *  used when multiple, differently configured mappers are needed.
 *  Although configuration is shared, cached serializers and deserializers
 *  are NOT shared, which means that the new instance may be re-configured
 *  before use; meaning that it behaves the same way as if an instance
 *  was constructed from scratch.
 *
 *  @since 2.1
 */
public ObjectMapper copy() {
    _checkInvalidCopy(ObjectMapper.class);
    return new ObjectMapper(this);
}","public void test2025() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper objectMapper1 = objectMapper0.copy();
    assertNotSame(objectMapper0, objectMapper1);
}",""
"public abstract T with(Base64Variant base64);","public void test2126() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with((Base64Variant) null);
    assertNotSame(deserializationConfig1, deserializationConfig0);
}","/**
 * Method for constructing and returning a new instance with different
 * default {@link Base64Variant} to use with base64-encoded binary values.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test2127() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with((Base64Variant) null);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test2228() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DateFormat dateFormat0 = MockDateFormat.getTimeInstance();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(dateFormat0);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public abstract T with(DateFormat df);","public void test2229() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DateFormat dateFormat0 = MockDateFormat.getTimeInstance();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(dateFormat0);
    assertNotSame(deserializationConfig1, deserializationConfig0);
}","/**
 *  Method for constructing and returning a new instance with different
 *  {@link DateFormat}
 *  to use.
 * <p>
 *  NOTE: make sure to register new instance with <code>ObjectMapper</code>
 *  if directly calling this method.
 */"
"public abstract T with(TypeFactory typeFactory);","public void test2330() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(typeFactory0);
    assertSame(deserializationConfig1, deserializationConfig0);
}","/**
 * Method for constructing and returning a new instance with different
 * {@link TypeFactory}
 * to use.
 */"
"// for unit tests only:
protected BaseSettings getBaseSettings() {
    return _base;
}","public void test2431() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    BaseSettings baseSettings1 = deserializationConfig0.getBaseSettings();
    assertSame(baseSettings1, baseSettings0);
}",""
"/*
    /**********************************************************
    /* Addition fluent factory methods, common to all sub-types
    /**********************************************************
     */
/**
 *  Method for constructing and returning a new instance with different
 *  {@link AnnotationIntrospector} to use (replacing old one).
 * <p>
 *  NOTE: make sure to register new instance with <code>ObjectMapper</code>
 *  if directly calling this method.
 */
public abstract T with(AnnotationIntrospector ai);","public void test2532() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with((AnnotationIntrospector) null);
    assertNotSame(deserializationConfig1, deserializationConfig0);
}",""
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test2533() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with((AnnotationIntrospector) null);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public abstract T with(TimeZone tz);","public void test2634() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    TimeZone timeZone0 = TimeZone.getDefault();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(timeZone0);
    assertNotSame(deserializationConfig1, deserializationConfig0);
}","/**
 * Method for constructing and returning a new instance with different
 * default {@link java.util.TimeZone} to use for formatting of date values.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test2635() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    TimeZone timeZone0 = TimeZone.getDefault();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(timeZone0);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test2838() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[2];
    MapperFeature mapperFeature0 = MapperFeature.AUTO_DETECT_FIELDS;
    mapperFeatureArray0[0] = mapperFeature0;
    MapperFeature mapperFeature1 = MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES;
    mapperFeatureArray0[1] = mapperFeature1;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(mapperFeatureArray0);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test2839() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[2];
    MapperFeature mapperFeature0 = MapperFeature.AUTO_DETECT_FIELDS;
    mapperFeatureArray0[0] = mapperFeature0;
    MapperFeature mapperFeature1 = MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES;
    mapperFeatureArray0[1] = mapperFeature1;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(mapperFeatureArray0);
    assertTrue(deserializationConfig1.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public final boolean shouldSortPropertiesAlphabetically() {
    return isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);
}","public void test2840() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[2];
    MapperFeature mapperFeature0 = MapperFeature.AUTO_DETECT_FIELDS;
    mapperFeatureArray0[0] = mapperFeature0;
    MapperFeature mapperFeature1 = MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES;
    mapperFeatureArray0[1] = mapperFeature1;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(mapperFeatureArray0);
    assertFalse(deserializationConfig1.shouldSortPropertiesAlphabetically());
}","/**
 * Accessor for checking whether default settings for property handling
 * indicate that properties should be alphabetically ordered or not.
 */"
"// For testing only:
public int mixInCount() {
    return _mixIns.localSize();
}","public void test3143() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    ObjectMapper objectMapper1 = objectMapper0.setSubtypeResolver(stdSubtypeResolver0);
    assertEquals(0, objectMapper1.mixInCount());
}",""
"@Override
public DeserializationConfig with(SubtypeResolver str) {
    return (_subtypeResolver == str) ? this : new DeserializationConfig(this, str);
}","public void test3244() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with((SubtypeResolver) stdSubtypeResolver0);
    assertSame(deserializationConfig1, deserializationConfig0);
}",""
"/*
    /**********************************************************
    /* MapperConfig implementation/overrides: other
    /**********************************************************
     */
@Override
public boolean useRootWrapping() {
    if (_rootName != null) {
        // empty String disables wrapping; non-empty enables
        return !_rootName.isEmpty();
    }
    return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE);
}","public void test3345() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    PropertyName propertyName0 = PropertyName.construct(""JSON"", ""JSON"");
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withRootName(propertyName0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withRootName((PropertyName) null);
    assertFalse(deserializationConfig2.useRootWrapping());
}",""
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test3346() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    PropertyName propertyName0 = PropertyName.construct(""JSON"", ""JSON"");
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withRootName(propertyName0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withRootName((PropertyName) null);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"/*
    /**********************************************************
    /* MapperConfig implementation/overrides: other
    /**********************************************************
     */
@Override
public boolean useRootWrapping() {
    if (_rootName != null) {
        // empty String disables wrapping; non-empty enables
        return !_rootName.isEmpty();
    }
    return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE);
}","public void test3347() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    PropertyName propertyName0 = PropertyName.construct(""JSON"", ""JSON"");
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withRootName(propertyName0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withRootName((PropertyName) null);
    assertTrue(deserializationConfig1.useRootWrapping());
}",""
"@Override
public DeserializationConfig withRootName(PropertyName rootName) {
    if (rootName == null) {
        if (_rootName == null) {
            return this;
        }
    } else if (rootName.equals(_rootName)) {
        return this;
    }
    return new DeserializationConfig(this, rootName);
}","public void test3448() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withRootName((PropertyName) null);
    assertSame(deserializationConfig1, deserializationConfig0);
}",""
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test3549() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    PropertyName propertyName0 = PropertyName.construct(""JSON"", ""JSON"");
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withRootName(propertyName0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withRootName(propertyName0);
    assertEquals(15214880, deserializationConfig2.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"/*
    /**********************************************************
    /* MapperConfig implementation/overrides: other
    /**********************************************************
     */
@Override
public boolean useRootWrapping() {
    if (_rootName != null) {
        // empty String disables wrapping; non-empty enables
        return !_rootName.isEmpty();
    }
    return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE);
}","public void test3550() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    PropertyName propertyName0 = PropertyName.construct(""JSON"", ""JSON"");
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withRootName(propertyName0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withRootName(propertyName0);
    assertTrue(deserializationConfig2.useRootWrapping());
}",""
"@Override
public DeserializationConfig withView(Class<?> view) {
    return (_view == view) ? this : new DeserializationConfig(this, view);
}","public void test3651() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    Class<Object> class0 = Object.class;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withView(class0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withView(class0);
    assertNotSame(deserializationConfig2, deserializationConfig0);
}",""
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test3652() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    Class<Object> class0 = Object.class;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withView(class0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withView(class0);
    assertEquals(15214880, deserializationConfig2.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public T withoutAttribute(Object key) {
    return with(getAttributes().withoutSharedAttribute(key));
}","public void test3753() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withoutAttribute((Object) null);
    assertSame(deserializationConfig1, deserializationConfig0);
}","/**
 * Method for constructing an instance that has no
 * value for attribute for given key.
 *
 * @since 2.3
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test3854() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(deserializationFeature0);
    assertEquals(15477024, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test3855() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(deserializationFeature0);
    assertTrue(deserializationConfig1.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public final boolean shouldSortPropertiesAlphabetically() {
    return isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);
}","public void test3856() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(deserializationFeature0);
    assertFalse(deserializationConfig1.shouldSortPropertiesAlphabetically());
}","/**
 * Accessor for checking whether default settings for property handling
 * indicate that properties should be alphabetically ordered or not.
 */"
"/*
    /**********************************************************
    /* Life-cycle, DeserializationFeature-based factory methods
    /**********************************************************
     */
/**
 * Fluent factory method that will construct and return a new configuration
 * object instance with specified features enabled.
 */
public DeserializationConfig with(DeserializationFeature feature) {
    int newDeserFeatures = (_deserFeatures | feature.getMask());
    return (newDeserFeatures == _deserFeatures) ? this : new DeserializationConfig(this, _mapperFeatures, newDeserFeatures, _parserFeatures, _parserFeaturesToChange, _formatReadFeatures, _formatReadFeaturesToChange);
}","public void test3957() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.EAGER_DESERIALIZER_FETCH;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(deserializationFeature0);
    assertSame(deserializationConfig1, deserializationConfig0);
}",""
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test4058() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[0];
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(deserializationFeature0, deserializationFeatureArray0);
    assertTrue(deserializationConfig1.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public final boolean shouldSortPropertiesAlphabetically() {
    return isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);
}","public void test4059() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[0];
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(deserializationFeature0, deserializationFeatureArray0);
    assertFalse(deserializationConfig1.shouldSortPropertiesAlphabetically());
}","/**
 * Accessor for checking whether default settings for property handling
 * indicate that properties should be alphabetically ordered or not.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test4060() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[0];
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(deserializationFeature0, deserializationFeatureArray0);
    assertEquals(15215392, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public DeserializationConfig with(DeserializationFeature first, DeserializationFeature... features) {
    int newDeserFeatures = _deserFeatures | first.getMask();
    for (DeserializationFeature f : features) {
        newDeserFeatures |= f.getMask();
    }
    return (newDeserFeatures == _deserFeatures) ? this : new DeserializationConfig(this, _mapperFeatures, newDeserFeatures, _parserFeatures, _parserFeaturesToChange, _formatReadFeatures, _formatReadFeaturesToChange);
}","public void test4161() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.WRAP_EXCEPTIONS;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[1];
    deserializationFeatureArray0[0] = deserializationFeature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(deserializationFeature0, deserializationFeatureArray0);
    assertSame(deserializationConfig1, deserializationConfig0);
}","/**
 * Fluent factory method that will construct and return a new configuration
 * object instance with specified features enabled.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test4262() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[1];
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY;
    deserializationFeatureArray0[0] = deserializationFeature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withFeatures(deserializationFeatureArray0);
    assertEquals(15231264, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final boolean canOverrideAccessModifiers() {
    return isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS);
}","public void test4263() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[1];
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY;
    deserializationFeatureArray0[0] = deserializationFeature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withFeatures(deserializationFeatureArray0);
    assertTrue(deserializationConfig1.canOverrideAccessModifiers());
}","/**
 * Accessor for determining whether it is ok to try to force override of access
 * modifiers to be able to get or set values of non-public Methods, Fields;
 * to invoke non-public Constructors, Methods; or to instantiate non-public
 * Classes. By default this is enabled, but on some platforms it needs to be
 * prevented since if this would violate security constraints and cause failures.
 *
 * @return True if access modifier overriding is allowed (and may be done for
 *   any Field, Method, Constructor or Class); false to prevent any attempts
 *   to override.
 */"
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test4264() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[1];
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY;
    deserializationFeatureArray0[0] = deserializationFeature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withFeatures(deserializationFeatureArray0);
    assertTrue(deserializationConfig1.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test4466() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.EAGER_DESERIALIZER_FETCH;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.without(deserializationFeature0);
    assertTrue(deserializationConfig1.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test4467() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.EAGER_DESERIALIZER_FETCH;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.without(deserializationFeature0);
    assertEquals(6826272, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public DeserializationConfig without(DeserializationFeature feature) {
    int newDeserFeatures = _deserFeatures & ~feature.getMask();
    return (newDeserFeatures == _deserFeatures) ? this : new DeserializationConfig(this, _mapperFeatures, newDeserFeatures, _parserFeatures, _parserFeaturesToChange, _formatReadFeatures, _formatReadFeaturesToChange);
}","public void test4568() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, (SubtypeResolver) null, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.without(deserializationFeature0);
    assertSame(deserializationConfig1, deserializationConfig0);
}","/**
 * Fluent factory method that will construct and return a new configuration
 * object instance with specified feature disabled.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test4669() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_FLOAT_AS_INT;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[0];
    DeserializationConfig deserializationConfig1 = deserializationConfig0.without(deserializationFeature0, deserializationFeatureArray0);
    assertEquals(14690592, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test4670() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_FLOAT_AS_INT;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[0];
    DeserializationConfig deserializationConfig1 = deserializationConfig0.without(deserializationFeature0, deserializationFeatureArray0);
    assertTrue(deserializationConfig1.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public DeserializationConfig without(DeserializationFeature first, DeserializationFeature... features) {
    int newDeserFeatures = _deserFeatures & ~first.getMask();
    for (DeserializationFeature f : features) {
        newDeserFeatures &= ~f.getMask();
    }
    return (newDeserFeatures == _deserFeatures) ? this : new DeserializationConfig(this, _mapperFeatures, newDeserFeatures, _parserFeatures, _parserFeaturesToChange, _formatReadFeatures, _formatReadFeaturesToChange);
}","public void test4771() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_FLOAT_AS_INT;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[1];
    // Undeclared exception!
    try {
        deserializationConfig0.without(deserializationFeature0, deserializationFeatureArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationConfig"", e);
    }
}","/**
 * Fluent factory method that will construct and return a new configuration
 * object instance with specified features disabled.
 */"
"public DeserializationConfig without(DeserializationFeature first, DeserializationFeature... features) {
    int newDeserFeatures = _deserFeatures & ~first.getMask();
    for (DeserializationFeature f : features) {
        newDeserFeatures &= ~f.getMask();
    }
    return (newDeserFeatures == _deserFeatures) ? this : new DeserializationConfig(this, _mapperFeatures, newDeserFeatures, _parserFeatures, _parserFeaturesToChange, _formatReadFeatures, _formatReadFeaturesToChange);
}","public void test4872() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[0];
    DeserializationConfig deserializationConfig1 = deserializationConfig0.without(deserializationFeature0, deserializationFeatureArray0);
    assertSame(deserializationConfig1, deserializationConfig0);
}","/**
 * Fluent factory method that will construct and return a new configuration
 * object instance with specified features disabled.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test4973() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[1];
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;
    deserializationFeatureArray0[0] = deserializationFeature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withoutFeatures(deserializationFeatureArray0);
    assertEquals(15214848, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test4974() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[1];
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;
    deserializationFeatureArray0[0] = deserializationFeature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withoutFeatures(deserializationFeatureArray0);
    assertTrue(deserializationConfig1.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test5176() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.STRICT_DUPLICATE_DETECTION;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(jsonParser_Feature0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.with(jsonParser_Feature0);
    assertEquals(15214880, deserializationConfig2.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"/*
    /**********************************************************
    /* Life-cycle, JsonParser.Feature-based factory methods
    /**********************************************************
     */
/**
 * Fluent factory method that will construct and return a new configuration
 * object instance with specified features enabled.
 *
 * @since 2.5
 */
public DeserializationConfig with(JsonParser.Feature feature) {
    int newSet = _parserFeatures | feature.getMask();
    int newMask = _parserFeaturesToChange | feature.getMask();
    return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this : new DeserializationConfig(this, _mapperFeatures, _deserFeatures, newSet, newMask, _formatReadFeatures, _formatReadFeaturesToChange);
}","public void test5177() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.STRICT_DUPLICATE_DETECTION;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(jsonParser_Feature0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.with(jsonParser_Feature0);
    assertSame(deserializationConfig2, deserializationConfig1);
}",""
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test5178() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.STRICT_DUPLICATE_DETECTION;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(jsonParser_Feature0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.with(jsonParser_Feature0);
    assertTrue(deserializationConfig2.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public final boolean shouldSortPropertiesAlphabetically() {
    return isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);
}","public void test5381() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature[] jsonParser_FeatureArray0 = new JsonParser.Feature[1];
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.AUTO_CLOSE_SOURCE;
    jsonParser_FeatureArray0[0] = jsonParser_Feature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withFeatures(jsonParser_FeatureArray0);
    assertFalse(deserializationConfig1.shouldSortPropertiesAlphabetically());
}","/**
 * Accessor for checking whether default settings for property handling
 * indicate that properties should be alphabetically ordered or not.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test5382() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature[] jsonParser_FeatureArray0 = new JsonParser.Feature[1];
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.AUTO_CLOSE_SOURCE;
    jsonParser_FeatureArray0[0] = jsonParser_Feature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withFeatures(jsonParser_FeatureArray0);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test5383() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature[] jsonParser_FeatureArray0 = new JsonParser.Feature[1];
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.AUTO_CLOSE_SOURCE;
    jsonParser_FeatureArray0[0] = jsonParser_Feature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withFeatures(jsonParser_FeatureArray0);
    assertTrue(deserializationConfig1.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public DeserializationConfig without(JsonParser.Feature feature) {
    int newSet = _parserFeatures & ~feature.getMask();
    int newMask = _parserFeaturesToChange | feature.getMask();
    return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this : new DeserializationConfig(this, _mapperFeatures, _deserFeatures, newSet, newMask, _formatReadFeatures, _formatReadFeaturesToChange);
}","public void test5484() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(jsonParser_Feature0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.without(jsonParser_Feature0);
    assertNotSame(deserializationConfig2, deserializationConfig1);
}","/**
 * Fluent factory method that will construct and return a new configuration
 * object instance with specified feature disabled.
 *
 * @since 2.5
 */"
"public final boolean canOverrideAccessModifiers() {
    return isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS);
}","public void test5485() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(jsonParser_Feature0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.without(jsonParser_Feature0);
    assertTrue(deserializationConfig2.canOverrideAccessModifiers());
}","/**
 * Accessor for determining whether it is ok to try to force override of access
 * modifiers to be able to get or set values of non-public Methods, Fields;
 * to invoke non-public Constructors, Methods; or to instantiate non-public
 * Classes. By default this is enabled, but on some platforms it needs to be
 * prevented since if this would violate security constraints and cause failures.
 *
 * @return True if access modifier overriding is allowed (and may be done for
 *   any Field, Method, Constructor or Class); false to prevent any attempts
 *   to override.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test5486() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(jsonParser_Feature0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.without(jsonParser_Feature0);
    assertEquals(15214880, deserializationConfig2.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test5587() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.without(jsonParser_Feature0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.without(jsonParser_Feature0);
    assertEquals(15214880, deserializationConfig2.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public DeserializationConfig without(JsonParser.Feature feature) {
    int newSet = _parserFeatures & ~feature.getMask();
    int newMask = _parserFeaturesToChange | feature.getMask();
    return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this : new DeserializationConfig(this, _mapperFeatures, _deserFeatures, newSet, newMask, _formatReadFeatures, _formatReadFeaturesToChange);
}","public void test5588() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.without(jsonParser_Feature0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.without(jsonParser_Feature0);
    assertNotSame(deserializationConfig2, deserializationConfig0);
}","/**
 * Fluent factory method that will construct and return a new configuration
 * object instance with specified feature disabled.
 *
 * @since 2.5
 */"
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test5590() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.without(jsonParser_Feature0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.without(jsonParser_Feature0);
    assertTrue(deserializationConfig2.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public final boolean isEnabled(JsonParser.Feature f, JsonFactory factory) {
    int mask = f.getMask();
    if ((_parserFeaturesToChange & mask) != 0) {
        return (_parserFeatures & f.getMask()) != 0;
    }
    return factory.isEnabled(f);
}","public void test5691() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS;
    JsonParser.Feature[] jsonParser_FeatureArray0 = new JsonParser.Feature[2];
    jsonParser_FeatureArray0[0] = jsonParser_Feature0;
    jsonParser_FeatureArray0[1] = jsonParser_Feature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withoutFeatures(jsonParser_FeatureArray0);
    JsonFactory jsonFactory0 = new JsonFactory();
    boolean boolean0 = deserializationConfig1.isEnabled(jsonParser_Feature0, jsonFactory0);
    assertNotSame(deserializationConfig1, deserializationConfig0);
}",""
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test5693() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS;
    JsonParser.Feature[] jsonParser_FeatureArray0 = new JsonParser.Feature[2];
    jsonParser_FeatureArray0[0] = jsonParser_Feature0;
    jsonParser_FeatureArray0[1] = jsonParser_Feature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withoutFeatures(jsonParser_FeatureArray0);
    JsonFactory jsonFactory0 = new JsonFactory();
    boolean boolean0 = deserializationConfig1.isEnabled(jsonParser_Feature0, jsonFactory0);
    assertTrue(deserializationConfig1.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test5694() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS;
    JsonParser.Feature[] jsonParser_FeatureArray0 = new JsonParser.Feature[2];
    jsonParser_FeatureArray0[0] = jsonParser_Feature0;
    jsonParser_FeatureArray0[1] = jsonParser_Feature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withoutFeatures(jsonParser_FeatureArray0);
    JsonFactory jsonFactory0 = new JsonFactory();
    boolean boolean0 = deserializationConfig1.isEnabled(jsonParser_Feature0, jsonFactory0);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test5795() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(jsonParser_Feature0);
    JsonParser.Feature[] jsonParser_FeatureArray0 = new JsonParser.Feature[2];
    jsonParser_FeatureArray0[0] = jsonParser_Feature0;
    jsonParser_FeatureArray0[1] = jsonParser_Feature0;
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withoutFeatures(jsonParser_FeatureArray0);
    assertEquals(15214880, deserializationConfig2.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test5797() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(jsonParser_Feature0);
    JsonParser.Feature[] jsonParser_FeatureArray0 = new JsonParser.Feature[2];
    jsonParser_FeatureArray0[0] = jsonParser_Feature0;
    jsonParser_FeatureArray0[1] = jsonParser_Feature0;
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withoutFeatures(jsonParser_FeatureArray0);
    assertTrue(deserializationConfig2.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test5999() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(3, 3).when(formatFeature0).getMask();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(formatFeature0);
    assertTrue(deserializationConfig1.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test59100() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(3, 3).when(formatFeature0).getMask();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(formatFeature0);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final boolean shouldSortPropertiesAlphabetically() {
    return isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);
}","public void test59101() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(3, 3).when(formatFeature0).getMask();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(formatFeature0);
    assertFalse(deserializationConfig1.shouldSortPropertiesAlphabetically());
}","/**
 * Accessor for checking whether default settings for property handling
 * indicate that properties should be alphabetically ordered or not.
 */"
"/*
    /**********************************************************
    /* Life-cycle, JsonParser.FormatFeature-based factory methods
    /**********************************************************
     */
/**
 * Fluent factory method that will construct and return a new configuration
 * object instance with specified features enabled.
 *
 * @since 2.7
 */
public DeserializationConfig with(FormatFeature feature) {
    int newSet = _formatReadFeatures | feature.getMask();
    int newMask = _formatReadFeaturesToChange | feature.getMask();
    return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this : new DeserializationConfig(this, _mapperFeatures, _deserFeatures, _parserFeatures, _parserFeaturesToChange, newSet, newMask);
}","public void test60102() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(0, 0).when(formatFeature0).getMask();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(formatFeature0);
    assertSame(deserializationConfig1, deserializationConfig0);
}",""
"/*
    /**********************************************************
    /* Life-cycle, JsonParser.FormatFeature-based factory methods
    /**********************************************************
     */
/**
 * Fluent factory method that will construct and return a new configuration
 * object instance with specified features enabled.
 *
 * @since 2.7
 */
public DeserializationConfig with(FormatFeature feature) {
    int newSet = _formatReadFeatures | feature.getMask();
    int newMask = _formatReadFeaturesToChange | feature.getMask();
    return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this : new DeserializationConfig(this, _mapperFeatures, _deserFeatures, _parserFeatures, _parserFeaturesToChange, newSet, newMask);
}","public void test61103() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(0, 322).when(formatFeature0).getMask();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(formatFeature0);
    assertNotSame(deserializationConfig1, deserializationConfig0);
}",""
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test61104() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(0, 322).when(formatFeature0).getMask();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(formatFeature0);
    assertTrue(deserializationConfig1.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test61105() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(0, 322).when(formatFeature0).getMask();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(formatFeature0);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test62108() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    FormatFeature[] formatFeatureArray0 = new FormatFeature[5];
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(2403, 2403, 579, 1024, 579).when(formatFeature0).getMask();
    formatFeatureArray0[0] = formatFeature0;
    formatFeatureArray0[1] = formatFeature0;
    formatFeatureArray0[2] = formatFeature0;
    formatFeatureArray0[3] = formatFeature0;
    formatFeatureArray0[4] = formatFeature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withFeatures(formatFeatureArray0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withoutFeatures(formatFeatureArray0);
    assertEquals(15214880, deserializationConfig2.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test62109() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    FormatFeature[] formatFeatureArray0 = new FormatFeature[5];
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(2403, 2403, 579, 1024, 579).when(formatFeature0).getMask();
    formatFeatureArray0[0] = formatFeature0;
    formatFeatureArray0[1] = formatFeature0;
    formatFeatureArray0[2] = formatFeature0;
    formatFeatureArray0[3] = formatFeature0;
    formatFeatureArray0[4] = formatFeature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withFeatures(formatFeatureArray0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withoutFeatures(formatFeatureArray0);
    assertTrue(deserializationConfig2.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public DeserializationConfig without(FormatFeature feature) {
    int newSet = _formatReadFeatures & ~feature.getMask();
    int newMask = _formatReadFeaturesToChange | feature.getMask();
    return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this : new DeserializationConfig(this, _mapperFeatures, _deserFeatures, _parserFeatures, _parserFeaturesToChange, newSet, newMask);
}","public void test64111() throws Throwable {
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    FormatFeature[] formatFeatureArray0 = new FormatFeature[2];
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(123, 123, 192, 123).when(formatFeature0).getMask();
    formatFeatureArray0[0] = formatFeature0;
    formatFeatureArray0[1] = formatFeature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withFeatures(formatFeatureArray0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.without(formatFeature0);
    assertNotSame(deserializationConfig2, deserializationConfig1);
}","/**
 * Fluent factory method that will construct and return a new configuration
 * object instance with specified feature disabled.
 *
 * @since 2.7
 */"
"public final boolean canOverrideAccessModifiers() {
    return isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS);
}","public void test64112() throws Throwable {
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    FormatFeature[] formatFeatureArray0 = new FormatFeature[2];
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(123, 123, 192, 123).when(formatFeature0).getMask();
    formatFeatureArray0[0] = formatFeature0;
    formatFeatureArray0[1] = formatFeature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withFeatures(formatFeatureArray0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.without(formatFeature0);
    assertTrue(deserializationConfig2.canOverrideAccessModifiers());
}","/**
 * Accessor for determining whether it is ok to try to force override of access
 * modifiers to be able to get or set values of non-public Methods, Fields;
 * to invoke non-public Constructors, Methods; or to instantiate non-public
 * Classes. By default this is enabled, but on some platforms it needs to be
 * prevented since if this would violate security constraints and cause failures.
 *
 * @return True if access modifier overriding is allowed (and may be done for
 *   any Field, Method, Constructor or Class); false to prevent any attempts
 *   to override.
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test64113() throws Throwable {
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig((BaseSettings) null, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    FormatFeature[] formatFeatureArray0 = new FormatFeature[2];
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(123, 123, 192, 123).when(formatFeature0).getMask();
    formatFeatureArray0[0] = formatFeature0;
    formatFeatureArray0[1] = formatFeature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withFeatures(formatFeatureArray0);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.without(formatFeature0);
    assertEquals(15214880, deserializationConfig2.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public DeserializationConfig without(FormatFeature feature) {
    int newSet = _formatReadFeatures & ~feature.getMask();
    int newMask = _formatReadFeaturesToChange | feature.getMask();
    return ((_formatReadFeatures == newSet) && (_formatReadFeaturesToChange == newMask)) ? this : new DeserializationConfig(this, _mapperFeatures, _deserFeatures, _parserFeatures, _parserFeaturesToChange, newSet, newMask);
}","public void test65115() throws Throwable {
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig((BaseSettings) null, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(0, 0).when(formatFeature0).getMask();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.without(formatFeature0);
    assertSame(deserializationConfig1, deserializationConfig0);
}","/**
 * Fluent factory method that will construct and return a new configuration
 * object instance with specified feature disabled.
 *
 * @since 2.7
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test66117() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    FormatFeature[] formatFeatureArray0 = new FormatFeature[5];
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(2403, 2403, 579, 1024, 579).when(formatFeature0).getMask();
    formatFeatureArray0[0] = formatFeature0;
    formatFeatureArray0[1] = formatFeature0;
    formatFeatureArray0[2] = formatFeature0;
    formatFeatureArray0[3] = formatFeature0;
    formatFeatureArray0[4] = formatFeature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withoutFeatures(formatFeatureArray0);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test66118() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    FormatFeature[] formatFeatureArray0 = new FormatFeature[5];
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn(2403, 2403, 579, 1024, 579).when(formatFeature0).getMask();
    formatFeatureArray0[0] = formatFeature0;
    formatFeatureArray0[1] = formatFeature0;
    formatFeatureArray0[2] = formatFeature0;
    formatFeatureArray0[3] = formatFeature0;
    formatFeatureArray0[4] = formatFeature0;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withoutFeatures(formatFeatureArray0);
    assertTrue(deserializationConfig1.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"/*
    /**********************************************************
    /* Life-cycle, deserialization-specific factory methods
    /**********************************************************
     */
/**
 * Fluent factory method that will construct a new instance with
 * specified {@link JsonNodeFactory}
 */
public DeserializationConfig with(JsonNodeFactory f) {
    if (_nodeFactory == f) {
        return this;
    }
    return new DeserializationConfig(this, f);
}","public void test68120() throws Throwable {
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig((BaseSettings) null, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(jsonNodeFactory0);
    assertSame(deserializationConfig1, deserializationConfig0);
}",""
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test69121() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withHandler((DeserializationProblemHandler) null);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withHandler((DeserializationProblemHandler) null);
    assertEquals(15214880, deserializationConfig2.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public DeserializationConfig withHandler(DeserializationProblemHandler h) {
    // Sanity check: let's prevent adding same handler multiple times
    if (LinkedNode.contains(_problemHandlers, h)) {
        return this;
    }
    return new DeserializationConfig(this, new LinkedNode<DeserializationProblemHandler>(h, _problemHandlers));
}","public void test69122() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withHandler((DeserializationProblemHandler) null);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withHandler((DeserializationProblemHandler) null);
    assertSame(deserializationConfig2, deserializationConfig1);
}","/**
 * Method that can be used to add a handler that can (try to)
 * resolve non-fatal deserialization problems.
 */"
"public DeserializationConfig withNoProblemHandlers() {
    if (_problemHandlers == null) {
        return this;
    }
    return new DeserializationConfig(this, (LinkedNode<DeserializationProblemHandler>) null);
}","public void test70124() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withHandler((DeserializationProblemHandler) null);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withNoProblemHandlers();
    assertNotSame(deserializationConfig2, deserializationConfig1);
}","/**
 * Method for removing all configured problem handlers; usually done to replace
 * existing handler(s) with different one(s)
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test70125() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withHandler((DeserializationProblemHandler) null);
    DeserializationConfig deserializationConfig2 = deserializationConfig1.withNoProblemHandlers();
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public DeserializationConfig withNoProblemHandlers() {
    if (_problemHandlers == null) {
        return this;
    }
    return new DeserializationConfig(this, (LinkedNode<DeserializationProblemHandler>) null);
}","public void test71126() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withNoProblemHandlers();
    assertSame(deserializationConfig1, deserializationConfig0);
}","/**
 * Method for removing all configured problem handlers; usually done to replace
 * existing handler(s) with different one(s)
 */"
"/*
    /**********************************************************
    /* JsonParser initialization
    /**********************************************************
     */
/**
 * Method called by {@link ObjectMapper} and {@link ObjectReader}
 * to modify those {@link com.fasterxml.jackson.core.JsonParser.Feature} settings
 * that have been configured via this config instance.
 *
 * @since 2.5
 */
public void initialize(JsonParser p) {
    if (_parserFeaturesToChange != 0) {
        p.overrideStdFeatures(_parserFeatures, _parserFeaturesToChange);
    }
    if (_formatReadFeaturesToChange != 0) {
        p.overrideFormatFeatures(_formatReadFeatures, _formatReadFeaturesToChange);
    }
}","public void test73128() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(jsonParser_Feature0);
    // Undeclared exception!
    try {
        deserializationConfig1.initialize((JsonParser) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationConfig"", e);
    }
}",""
"/*
    /**********************************************************
    /* JsonParser initialization
    /**********************************************************
     */
/**
 * Method called by {@link ObjectMapper} and {@link ObjectReader}
 * to modify those {@link com.fasterxml.jackson.core.JsonParser.Feature} settings
 * that have been configured via this config instance.
 *
 * @since 2.5
 */
public void initialize(JsonParser p) {
    if (_parserFeaturesToChange != 0) {
        p.overrideStdFeatures(_parserFeatures, _parserFeaturesToChange);
    }
    if (_formatReadFeaturesToChange != 0) {
        p.overrideFormatFeatures(_formatReadFeatures, _formatReadFeaturesToChange);
    }
}","public void test74129() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    FormatFeature formatFeature0 = mock(FormatFeature.class, new ViolatedAssumptionAnswer());
    doReturn((-1), (-1)).when(formatFeature0).getMask();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.without(formatFeature0);
    // Undeclared exception!
    try {
        deserializationConfig1.initialize((JsonParser) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationConfig"", e);
    }
}",""
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test75130() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    MapperFeature mapperFeature0 = MapperFeature.USE_ANNOTATIONS;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(mapperFeature0, false);
    deserializationConfig1.getAnnotationIntrospector();
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final boolean canOverrideAccessModifiers() {
    return isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS);
}","public void test75131() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    MapperFeature mapperFeature0 = MapperFeature.USE_ANNOTATIONS;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(mapperFeature0, false);
    deserializationConfig1.getAnnotationIntrospector();
    assertTrue(deserializationConfig1.canOverrideAccessModifiers());
}","/**
 * Accessor for determining whether it is ok to try to force override of access
 * modifiers to be able to get or set values of non-public Methods, Fields;
 * to invoke non-public Constructors, Methods; or to instantiate non-public
 * Classes. By default this is enabled, but on some platforms it needs to be
 * prevented since if this would violate security constraints and cause failures.
 *
 * @return True if access modifier overriding is allowed (and may be done for
 *   any Field, Method, Constructor or Class); false to prevent any attempts
 *   to override.
 */"
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test75132() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    MapperFeature mapperFeature0 = MapperFeature.USE_ANNOTATIONS;
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(mapperFeature0, false);
    deserializationConfig1.getAnnotationIntrospector();
    assertFalse(deserializationConfig1.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"/*
    /**********************************************************
    /* MapperConfig implementation/overrides: other
    /**********************************************************
     */
@Override
public boolean useRootWrapping() {
    if (_rootName != null) {
        // empty String disables wrapping; non-empty enables
        return !_rootName.isEmpty();
    }
    return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE);
}","public void test79136() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    PropertyName propertyName0 = PropertyName.construct("""", (String) null);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withRootName(propertyName0);
    boolean boolean0 = deserializationConfig1.useRootWrapping();
    assertNotSame(deserializationConfig1, deserializationConfig0);
}",""
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test79137() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    PropertyName propertyName0 = PropertyName.construct("""", (String) null);
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withRootName(propertyName0);
    boolean boolean0 = deserializationConfig1.useRootWrapping();
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"/*
    /**********************************************************
    /* MapperConfig implementation/overrides: other
    /**********************************************************
     */
@Override
public boolean useRootWrapping() {
    if (_rootName != null) {
        // empty String disables wrapping; non-empty enables
        return !_rootName.isEmpty();
    }
    return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE);
}","public void test80139() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    PropertyName propertyName0 = PropertyName.construct("""", """");
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withRootName(propertyName0);
    boolean boolean0 = deserializationConfig1.useRootWrapping();
    assertTrue(boolean0);
}",""
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test80140() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    PropertyName propertyName0 = PropertyName.construct("""", """");
    DeserializationConfig deserializationConfig1 = deserializationConfig0.withRootName(propertyName0);
    boolean boolean0 = deserializationConfig1.useRootWrapping();
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final boolean isEnabled(JsonParser.Feature f, JsonFactory factory) {
    int mask = f.getMask();
    if ((_parserFeaturesToChange & mask) != 0) {
        return (_parserFeatures & f.getMask()) != 0;
    }
    return factory.isEnabled(f);
}","public void test81141() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    JsonFactory jsonFactory0 = new JsonFactory();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_SINGLE_QUOTES;
    boolean boolean0 = deserializationConfig0.isEnabled(jsonParser_Feature0, jsonFactory0);
    assertFalse(boolean0);
}",""
"public final boolean isAnnotationProcessingEnabled() {
    return isEnabled(MapperFeature.USE_ANNOTATIONS);
}","public void test82142() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.AUTO_CLOSE_SOURCE;
    JsonFactory jsonFactory0 = new JsonFactory();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(jsonParser_Feature0);
    boolean boolean0 = deserializationConfig1.isEnabled(jsonParser_Feature0, jsonFactory0);
    assertTrue(deserializationConfig1.isAnnotationProcessingEnabled());
}","/**
 * Method for determining whether annotation processing is enabled or not
 * (default settings are typically that it is enabled; must explicitly disable).
 *
 * @return True if annotation processing is enabled; false if not
 */"
"public final int getDeserializationFeatures() {
    return _deserFeatures;
}","public void test82143() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.AUTO_CLOSE_SOURCE;
    JsonFactory jsonFactory0 = new JsonFactory();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(jsonParser_Feature0);
    boolean boolean0 = deserializationConfig1.isEnabled(jsonParser_Feature0, jsonFactory0);
    assertEquals(15214880, deserializationConfig1.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 */"
"public final boolean isEnabled(JsonParser.Feature f, JsonFactory factory) {
    int mask = f.getMask();
    if ((_parserFeaturesToChange & mask) != 0) {
        return (_parserFeatures & f.getMask()) != 0;
    }
    return factory.isEnabled(f);
}","public void test82144() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, (SimpleMixInResolver) null, rootNameLookup0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.AUTO_CLOSE_SOURCE;
    JsonFactory jsonFactory0 = new JsonFactory();
    DeserializationConfig deserializationConfig1 = deserializationConfig0.with(jsonParser_Feature0);
    boolean boolean0 = deserializationConfig1.isEnabled(jsonParser_Feature0, jsonFactory0);
    assertTrue(boolean0);
}",""
"public final boolean hasDeserializationFeatures(int featureMask) {
    return (_deserFeatures & featureMask) == featureMask;
}","public void test83145() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, (SubtypeResolver) null, simpleMixInResolver0, rootNameLookup0);
    boolean boolean0 = deserializationConfig0.hasDeserializationFeatures(1187);
    assertFalse(boolean0);
}","/**
 * Bulk access method for checking that all features specified by
 * mask are enabled.
 *
 * @since 2.3
 */"
"public final boolean hasDeserializationFeatures(int featureMask) {
    return (_deserFeatures & featureMask) == featureMask;
}","public void test84146() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, (SubtypeResolver) null, simpleMixInResolver0, rootNameLookup0);
    boolean boolean0 = deserializationConfig0.hasDeserializationFeatures(10496);
    assertTrue(boolean0);
}","/**
 * Bulk access method for checking that all features specified by
 * mask are enabled.
 *
 * @since 2.3
 */"
"public final boolean hasSomeOfFeatures(int featureMask) {
    return (_deserFeatures & featureMask) != 0;
}","public void test85147() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    boolean boolean0 = deserializationConfig0.hasSomeOfFeatures(1);
    assertFalse(boolean0);
}","/**
 * Bulk access method for checking that at least one of features specified by
 * mask is enabled.
 *
 * @since 2.6
 */"
"public final boolean hasSomeOfFeatures(int featureMask) {
    return (_deserFeatures & featureMask) != 0;
}","public void test86148() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    ObjectMapper objectMapper0 = new ObjectMapper();
    SimpleMixInResolver simpleMixInResolver0 = objectMapper0._mixIns;
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings0, (SubtypeResolver) null, simpleMixInResolver0, rootNameLookup0);
    boolean boolean0 = deserializationConfig0.hasSomeOfFeatures(741);
    assertTrue(boolean0);
}","/**
 * Bulk access method for checking that at least one of features specified by
 * mask is enabled.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Support for polymorphic type handling
    /**********************************************************
     */
/**
 * Helper method that is needed to properly handle polymorphic referenced
 * types, such as types referenced by {@link java.util.concurrent.atomic.AtomicReference},
 * or various ""optional"" types.
 *
 * @since 2.4
 */
public TypeDeserializer findTypeDeserializer(JavaType baseType) throws JsonMappingException {
    BeanDescription bean = introspectClassAnnotations(baseType.getRawClass());
    AnnotatedClass ac = bean.getClassInfo();
    TypeResolverBuilder<?> b = getAnnotationIntrospector().findTypeResolver(this, ac, baseType);
    /* Ok: if there is no explicit type info handler, we may want to
         * use a default. If so, config object knows what to use.
         */
    Collection<NamedType> subtypes = null;
    if (b == null) {
        b = getDefaultTyper(baseType);
        if (b == null) {
            return null;
        }
    } else {
        subtypes = getSubtypeResolver().collectAndResolveSubtypesByTypeId(this, ac);
    }
    /* 04-May-2014, tatu: When called from DeserializerFactory, additional code like
         *   this is invoked. But here we do not actually have access to mappings, so not
         *   quite sure what to do, if anything. May need to revisit if the underlying
         *   problem re-surfaces...
         */
    /*
        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {
            JavaType defaultType = mapAbstractType(config, baseType);
            if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) {
                b = b.defaultImpl(defaultType.getRawClass());
            }
        }
        */
    return b.buildTypeDeserializer(this, baseType, subtypes);
}","public void test87149() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    BasicClassIntrospector basicClassIntrospector0 = new BasicClassIntrospector();
    BaseSettings baseSettings1 = baseSettings0.withClassIntrospector(basicClassIntrospector0);
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    StdTypeResolverBuilder stdTypeResolverBuilder0 = StdTypeResolverBuilder.noTypeInfoBuilder();
    BaseSettings baseSettings2 = baseSettings1.withTypeResolverBuilder(stdTypeResolverBuilder0);
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings2, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    JavaType javaType0 = TypeFactory.unknownType();
    TypeDeserializer typeDeserializer0 = deserializationConfig0.findTypeDeserializer(javaType0);
    assertNull(typeDeserializer0);
}",""
"/*
    /**********************************************************
    /* Support for polymorphic type handling
    /**********************************************************
     */
/**
 * Helper method that is needed to properly handle polymorphic referenced
 * types, such as types referenced by {@link java.util.concurrent.atomic.AtomicReference},
 * or various ""optional"" types.
 *
 * @since 2.4
 */
public TypeDeserializer findTypeDeserializer(JavaType baseType) throws JsonMappingException {
    BeanDescription bean = introspectClassAnnotations(baseType.getRawClass());
    AnnotatedClass ac = bean.getClassInfo();
    TypeResolverBuilder<?> b = getAnnotationIntrospector().findTypeResolver(this, ac, baseType);
    /* Ok: if there is no explicit type info handler, we may want to
         * use a default. If so, config object knows what to use.
         */
    Collection<NamedType> subtypes = null;
    if (b == null) {
        b = getDefaultTyper(baseType);
        if (b == null) {
            return null;
        }
    } else {
        subtypes = getSubtypeResolver().collectAndResolveSubtypesByTypeId(this, ac);
    }
    /* 04-May-2014, tatu: When called from DeserializerFactory, additional code like
         *   this is invoked. But here we do not actually have access to mappings, so not
         *   quite sure what to do, if anything. May need to revisit if the underlying
         *   problem re-surfaces...
         */
    /*
        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {
            JavaType defaultType = mapAbstractType(config, baseType);
            if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) {
                b = b.defaultImpl(defaultType.getRawClass());
            }
        }
        */
    return b.buildTypeDeserializer(this, baseType, subtypes);
}","public void test88150() throws Throwable {
    BaseSettings baseSettings0 = ObjectMapper.DEFAULT_BASE;
    BasicClassIntrospector basicClassIntrospector0 = new BasicClassIntrospector();
    BaseSettings baseSettings1 = baseSettings0.withClassIntrospector(basicClassIntrospector0);
    SimpleMixInResolver simpleMixInResolver0 = new SimpleMixInResolver((ClassIntrospector.MixInResolver) null);
    StdSubtypeResolver stdSubtypeResolver0 = new StdSubtypeResolver();
    RootNameLookup rootNameLookup0 = new RootNameLookup();
    DeserializationConfig deserializationConfig0 = new DeserializationConfig(baseSettings1, stdSubtypeResolver0, simpleMixInResolver0, rootNameLookup0);
    JavaType javaType0 = TypeFactory.unknownType();
    TypeDeserializer typeDeserializer0 = deserializationConfig0.findTypeDeserializer(javaType0);
    assertNull(typeDeserializer0);
}",""
