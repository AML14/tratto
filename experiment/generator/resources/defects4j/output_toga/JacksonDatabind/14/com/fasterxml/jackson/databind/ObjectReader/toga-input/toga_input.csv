focal_method,test_prefix,docstring
"public boolean isEnabled(MapperFeature f) {
    return _config.isEnabled(f);
}","public void test000() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    MapperFeature mapperFeature0 = MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES;
    boolean boolean0 = objectReader0.isEnabled(mapperFeature0);
    assertFalse(boolean0);
}",""
"public final String getRootName() {
    return _rootName;
}","public void test011() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader((FormatSchema) null);
    DeserializationConfig deserializationConfig0 = objectReader0.getConfig();
    assertNull(deserializationConfig0.getRootName());
}",""
"@Override
public void writeTree(JsonGenerator jgen, TreeNode rootNode) {
    throw new UnsupportedOperationException();
}","public void test022() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    MissingNode missingNode0 = MissingNode.getInstance();
    IOContext iOContext0 = new IOContext(bufferRecycler0, missingNode0, false);
    MockFile mockFile0 = new MockFile("""", "".n:UoBD2T\""p8"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 0, objectReader0, mockPrintStream0);
    // Undeclared exception!
    try {
        objectReader0.writeTree(uTF8JsonGenerator0, missingNode0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}",""
"public ObjectReader with(JsonFactory f) {
    if (f == _parserFactory) {
        return this;
    }
    ObjectReader r = _new(this, f);
    // Also, try re-linking, if possible...
    if (f.getCodec() == null) {
        f.setCodec(r);
    }
    return r;
}","public void test055() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectReader objectReader1 = objectReader0.with(jsonFactory0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new reader instance with configuration that uses
 *  passed {@link JsonFactory} for constructing underlying Readers.
 * <p>
 *  NOTE: only factories that <b>DO NOT REQUIRE SPECIAL MAPPERS</b>
 *  (that is, ones that return <code>false</code> for
 *  {@link JsonFactory#requiresCustomCodec()}) can be used: trying
 *  to use one that requires custom codec will throw exception
 *
 *  @since 2.1
 */"
"public ObjectReader withView(Class<?> activeView) {
    return _with(_config.withView(activeView));
}","public void test066() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    Class<DecimalNode> class0 = DecimalNode.class;
    ObjectReader objectReader1 = objectReader0.withView(class0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new instance with configuration that
 *  uses specified View for filtering.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 */"
"public ObjectReader withAttributes(Map<Object, Object> attrs) {
    return _with(_config.withAttributes(attrs));
}","public void test077() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    HashMap<Object, Object> hashMap0 = new HashMap<Object, Object>();
    ObjectReader objectReader1 = objectReader0.withAttributes(hashMap0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 * @since 2.3
 */"
"public final <T> MappingIterator<T> readValues(byte[] src) throws IOException, JsonProcessingException {
    return readValues(src, 0, src.length);
}","public void test088() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    byte[] byteArray0 = new byte[0];
    try {
        objectReader0.readValues(byteArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No value type configured for ObjectReader
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}","/**
 * Overloaded version of {@link #readValue(InputStream)}.
 */"
"@SuppressWarnings(""resource"")
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException {
    ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());
    try {
        _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);
    } catch (JsonProcessingException e) {
        // to support [JACKSON-758]
        throw e;
    } catch (IOException e) {
        // shouldn't really happen, but is declared as possibility so:
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    byte[] result = bb.toByteArray();
    bb.release();
    return result;
}","public void test099() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectReader objectReader0 = objectMapper0.readerForUpdating((Object) jsonFactory0);
    // Undeclared exception!
    try {
        objectMapper0.writeValueAsBytes(objectReader0);
        fail(""Expecting exception: NoClassDefFoundError"");
    } catch (NoClassDefFoundError e) {
        //
        // com/fasterxml/jackson/databind/JsonMappingException$Reference
        //
        verifyException(""com.fasterxml.jackson.databind.ser.std.BeanSerializerBase"", e);
    }
}","/**
 *  Method that can be used to serialize any Java value as
 *  a byte array. Functionally equivalent to calling
 *  {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}
 *  and getting bytes, but more efficient.
 *  Encoding used will be UTF-8.
 * <p>
 *  Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
 */"
"protected void _reportUndetectableSource(Object src) throws JsonProcessingException {
    throw new JsonParseException(""Can not use source of type "" + src.getClass().getName() + "" with format auto-detection: must be byte- not char-based"", JsonLocation.NA);
}","public void test1010() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    JsonInclude.Include jsonInclude_Include0 = JsonInclude.Include.ALWAYS;
    try {
        objectReader0._reportUndetectableSource(jsonInclude_Include0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Can not use source of type com.fasterxml.jackson.annotation.JsonInclude$Include with format auto-detection: must be byte- not char-based
        //  at [Source: java.lang.String@0000000021; line: -1, column: -1]
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}",""
"/*
    /**********************************************************
    /* Life-cycle, fluent factory methods for JsonParser.Features
    /**********************************************************
     */
/**
 * Method for constructing a new reader instance that is configured
 * with specified feature enabled.
 */
public ObjectReader with(JsonParser.Feature feature) {
    return _with(_config.with(feature));
}","public void test1111() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS;
    ObjectReader objectReader1 = objectReader0.with(jsonParser_Feature0);
    assertNotSame(objectReader1, objectReader0);
}",""
"public ObjectReader without(JsonParser.Feature feature) {
    return _with(_config.without(feature));
}","public void test1212() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS;
    ObjectReader objectReader1 = objectReader0.without(jsonParser_Feature0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 * Method for constructing a new reader instance that is configured
 * with specified feature disabled.
 */"
"/*
    /**********************************************************
    /* Life-cycle, fluent factory methods for DeserializationFeatures
    /**********************************************************
     */
/**
 * Method for constructing a new reader instance that is configured
 * with specified feature enabled.
 */
public ObjectReader with(DeserializationFeature feature) {
    return _with(_config.with(feature));
}","public void test1414() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS;
    ObjectReader objectReader1 = objectReader0.with(deserializationFeature0);
    assertNotSame(objectReader1, objectReader0);
}",""
"@SuppressWarnings(""resource"")
protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing) throws IOException {
    if (!match.hasMatch()) {
        _reportUnkownFormat(_dataFormatReaders, match);
    }
    JsonParser p = match.createParserWithMatch();
    // One more thing: we Own the input stream now; and while it's
    // not super clean way to do it, we must ensure closure so:
    if (forceClosing) {
        p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);
    }
    // important: use matching ObjectReader (may not be 'this')
    return match.getReader()._bindAndClose(p, _valueToUpdate);
}","public void test1515() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    Vector<ObjectReader> vector0 = new Vector<ObjectReader>(1);
    DataFormatReaders dataFormatReaders0 = new DataFormatReaders(vector0);
    DataFormatReaders.Match dataFormatReaders_Match0 = dataFormatReaders0.findFormat((byte[]) null, 64, 64);
    // Undeclared exception!
    try {
        objectReader0._detectBindAndClose(dataFormatReaders_Match0, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}",""
"public ObjectReader withRootName(String rootName) {
    return _with(_config.withRootName(rootName));
}","public void test1717() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ObjectReader objectReader1 = objectReader0.withRootName("""");
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new instance with configuration that
 *  specifies what root name to expect for ""root name unwrapping"".
 *  See {@link DeserializationConfig#withRootName(String)} for
 *  details.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 */"
"public ObjectReader withHandler(DeserializationProblemHandler h) {
    return _with(_config.withHandler(h));
}","public void test1818() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ObjectReader objectReader1 = objectReader0.withHandler((DeserializationProblemHandler) null);
    assertNotSame(objectReader1, objectReader0);
}",""
"@Override
@SuppressWarnings(""unchecked"")
public <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {
    return (T) withType((JavaType) valueType).readValue(jp);
}","public void test1919() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    IOContext iOContext0 = new IOContext(bufferRecycler0, ""IN=zJhe\""N(OMS7M"", false);
    CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();
    ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 252, (Reader) null, objectMapper0, charsToNameCanonicalizer0);
    ObjectReader objectReader0 = objectMapper0.reader((FormatSchema) null);
    try {
        objectReader0.readValue((JsonParser) readerBasedJsonParser0, (ResolvedType) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No content to map due to end-of-input
        //  at [Source: java.lang.String@0000000022; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Convenience method that binds content read using given parser, using
 *  configuration of this reader, except that expected value type
 *  is specified with the call (instead of currently configured root type).
 *  Value return is either newly constructed, or root value that
 *  was specified with {@link #withValueToUpdate(Object)}.
 * <p>
 *  NOTE: this method never tries to auto-detect format, since actual
 *  (data-format specific) parser is given.
 */"
"@SuppressWarnings(""unchecked"")
@Override
public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException {
    return (T) _bindAsTree(jp);
}","public void test2020() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.READ_ENUMS_USING_TO_STRING;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    JsonFactory jsonFactory0 = new JsonFactory();
    char[] charArray0 = new char[1];
    JsonParser jsonParser0 = jsonFactory0.createParser(charArray0, (-808), (-808));
    try {
        objectReader0.readTree(jsonParser0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No content to map due to end-of-input
        //  at [Source: [C@0000000023; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Convenience method that binds content read using given parser, using
 *  configuration of this reader, except that content is bound as
 *  JSON tree instead of configured root value type.
 * <p>
 *  Note: if an object was specified with {@link #withValueToUpdate}, it
 *  will be ignored.
 * <p>
 *  NOTE: this method never tries to auto-detect format, since actual
 *  (data-format specific) parser is given.
 */"
"public ObjectReader with(Locale l) {
    return _with(_config.with(l));
}","public void test2121() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    Locale locale0 = Locale.ITALIAN;
    ObjectReader objectReader1 = objectReader0.with(locale0);
    assertNotSame(objectReader1, objectReader0);
}",""
"@Override
public <T> Iterator<T> readValues(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {
    return readValues(jp, (JavaType) valueType);
}","public void test2222() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ConcurrentHashMap> class0 = ConcurrentHashMap.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class0);
    Iterator<AbstractDeserializer> iterator0 = objectReader0.readValues((JsonParser) null, (ResolvedType) mapType0);
    assertNotNull(iterator0);
}","/**
 *  Convenience method that is equivalent to:
 * <pre>
 *    withType(valueType).readValues(jp);
 * </pre>
 * <p>
 *  NOTE: this method never tries to auto-detect format, since actual
 *  (data-format specific) parser is given.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(JsonNode src) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(src);
    }
    return (T) _bindAndClose(treeAsTokens(src), _valueToUpdate);
}","public void test2323() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<CoreXMLDeserializers.Std> class0 = CoreXMLDeserializers.Std.class;
    ObjectReader objectReader0 = objectMapper0.reader((Class<?>) class0);
    MissingNode missingNode0 = MissingNode.getInstance();
    try {
        objectReader0.readValue((JsonNode) missingNode0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Can not deserialize instance of com.fasterxml.jackson.databind.ext.CoreXMLDeserializers$Std out of NOT_AVAILABLE token
        //  at [Source: java.lang.String@0000000021; line: -1, column: -1]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Convenience method for converting results from given JSON tree into given
 *  value type. Basically short-cut for:
 * <pre>
 *    objectReader.readValue(src.traverse())
 * </pre>
 */"
"/*
    /**********************************************************
    /* Life-cycle, fluent factory methods, other
    /**********************************************************
     */
public ObjectReader with(DeserializationConfig config) {
    return _with(config);
}","public void test2828() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.USE_BIG_INTEGER_FOR_INTS;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    // Undeclared exception!
    try {
        objectReader0.with((DeserializationConfig) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}",""
"/*
    /**********************************************************
    /* Simple accessors
    /**********************************************************
     */
public boolean isEnabled(DeserializationFeature f) {
    return _config.isEnabled(f);
}","public void test2929() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_INVALID_SUBTYPE;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    boolean boolean0 = objectReader0.isEnabled(deserializationFeature0);
    assertTrue(boolean0);
}",""
"public ObjectReader with(ContextAttributes attrs) {
    return _with(_config.with(attrs));
}","public void test3030() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<BooleanNode> class0 = BooleanNode.class;
    ObjectReader objectReader0 = objectMapper0.reader((Class<?>) class0);
    ContextAttributes contextAttributes0 = ContextAttributes.getEmpty();
    ObjectReader objectReader1 = objectReader0.with(contextAttributes0);
    assertSame(objectReader1, objectReader0);
}","/**
 * @since 2.3
 */"
"public ObjectReader without(DeserializationFeature first, DeserializationFeature... other) {
    return _with(_config.without(first, other));
}","public void test3131() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[4];
    // Undeclared exception!
    try {
        objectReader0.without(deserializationFeature0, deserializationFeatureArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationConfig"", e);
    }
}","/**
 * Method for constructing a new reader instance that is configured
 * with specified features disabled.
 */"
"@SuppressWarnings(""unchecked"")
@Override
public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {
    return (T) withType(valueTypeRef).readValue(jp);
}","public void test3232() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    TypeReference<BeanDeserializer> typeReference0 = (TypeReference<BeanDeserializer>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    doReturn((Type) null).when(typeReference0).getType();
    // Undeclared exception!
    try {
        objectReader0.readValue((JsonParser) null, (TypeReference<?>) typeReference0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 *  Convenience method that binds content read using given parser, using
 *  configuration of this reader, except that expected value type
 *  is specified with the call (instead of currently configured root type).
 *  Value return is either newly constructed, or root value that
 *  was specified with {@link #withValueToUpdate(Object)}.
 * <p>
 *  NOTE: this method never tries to auto-detect format, since actual
 *  (data-format specific) parser is given.
 */"
"public TypeFactory getTypeFactory() {
    return _config.getTypeFactory();
}","public void test3333() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    TypeFactory typeFactory0 = objectReader0.getTypeFactory();
    assertNotNull(typeFactory0);
}",""
"@Override
public <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException {
    return withType(valueTypeRef).readValues(jp);
}","public void test3434() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonParserSequence jsonParserSequence0 = JsonParserSequence.createFlattened((JsonParser) null, (JsonParser) null);
    TypeReference<Object> typeReference0 = (TypeReference<Object>) mock(TypeReference.class, new ViolatedAssumptionAnswer());
    doReturn((Type) null).when(typeReference0).getType();
    // Undeclared exception!
    try {
        objectReader0.readValues((JsonParser) jsonParserSequence0, (TypeReference<?>) typeReference0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 *  Convenience method that is equivalent to:
 * <pre>
 *    withType(valueTypeRef).readValues(jp);
 * </pre>
 * <p>
 *  NOTE: this method never tries to auto-detect format, since actual
 *  (data-format specific) parser is given.
 */"
"protected InputStream _inputStream(URL src) throws IOException {
    return src.openStream();
}","public void test3535() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.READ_ENUMS_USING_TO_STRING;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    URL uRL0 = MockURL.getFileExample();
    // Undeclared exception!
    try {
        objectReader0._inputStream(uRL0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.net.URL"", e);
    }
}",""
"@SuppressWarnings(""unchecked"")
public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {
    return (T) withType(valueType).readValue(jp);
}","public void test3636() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<Object> class0 = Object.class;
    ObjectReader objectReader0 = objectMapper0.reader((Class<?>) class0);
    ArrayNode arrayNode0 = objectMapper0.createArrayNode();
    JsonParser jsonParser0 = objectMapper0.treeAsTokens(arrayNode0);
    try {
        objectReader0.readValue(jsonParser0, (JavaType) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No value type configured for ObjectReader
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}","/**
 *  Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, ResolvedType)}.
 * <p>
 *  NOTE: this method never tries to auto-detect format, since actual
 *  (data-format specific) parser is given.
 */"
"public boolean isEnabled(JsonParser.Feature f) {
    return _parserFactory.isEnabled(f);
}","public void test3939() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    HashMap<String, Object> hashMap0 = new HashMap<String, Object>();
    InjectableValues.Std injectableValues_Std0 = new InjectableValues.Std(hashMap0);
    ObjectReader objectReader0 = objectMapper0.reader((InjectableValues) injectableValues_Std0);
    JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.AUTO_CLOSE_SOURCE;
    boolean boolean0 = objectReader0.isEnabled(jsonParser_Feature0);
    assertTrue(boolean0);
}",""
"public boolean isInt() {
    return false;
}","public void test4040() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonNode jsonNode0 = objectReader0.createArrayNode();
    assertFalse(jsonNode0.isInt());
}","/**
 * Method that can be used to check whether contained value
 * is a number represented as Java <code>int</code>.
 * Note, however, that even if this method returns false, it
 * is possible that conversion would be possible from other numeric
 * types -- to check if this is possible, use
 * {@link #canConvertToInt()} instead.
 *
 * @return True if the value contained by this node is stored as Java int
 */"
"public ObjectReader with(Base64Variant defaultBase64) {
    return _with(_config.with(defaultBase64));
}","public void test4141() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[1];
    deserializationFeatureArray0[0] = deserializationFeature0;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0, deserializationFeatureArray0);
    ObjectReader objectReader1 = objectReader0.with((Base64Variant) null);
    assertNotSame(objectReader1, objectReader0);
}",""
"public ObjectReader without(DeserializationFeature feature) {
    return _with(_config.without(feature));
}","public void test4242() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE;
    ObjectReader objectReader1 = objectReader0.without(deserializationFeature0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 * Method for constructing a new reader instance that is configured
 * with specified feature disabled.
 */"
"public ObjectReader withAttribute(Object key, Object value) {
    return _with(_config.withAttribute(key, value));
}","public void test4343() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    MissingNode missingNode0 = MissingNode.getInstance();
    ObjectReader objectReader1 = objectReader0.withAttribute(objectMapper0, missingNode0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 * @since 2.3
 */"
"@Deprecated
public ObjectReader withType(java.lang.reflect.Type valueType) {
    return forType(_config.getTypeFactory().constructType(valueType));
}","public void test4444() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<BooleanNode> class0 = BooleanNode.class;
    ObjectReader objectReader0 = objectMapper0.reader((Class<?>) class0);
    ObjectReader objectReader1 = objectReader0.withType((Type) class0);
    assertSame(objectReader1, objectReader0);
}","/**
 * @deprecated since 2.5 Use {@link #forType(Class)} instead
 */"
"/*
    /**********************************************************
    /* Deserialization methods; others similar to what ObjectMapper has
    /**********************************************************
     */
/**
 * Method that binds content read from given input source,
 * using configuration of this reader.
 * Value return is either newly constructed, or root value that
 * was specified with {@link #withValueToUpdate(Object)}.
 */
@SuppressWarnings(""unchecked"")
public <T> T readValue(InputStream src) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        return (T) _detectBindAndClose(_dataFormatReaders.findFormat(src), false);
    }
    return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);
}","public void test4545() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader((JsonNodeFactory) null);
    try {
        objectReader0.readValue((InputStream) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No content to map due to end-of-input
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}",""
"public ObjectReader withoutAttribute(Object key) {
    return _with(_config.withoutAttribute(key));
}","public void test4646() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ObjectReader objectReader1 = objectReader0.withoutAttribute(""Can not use source of type "");
    assertSame(objectReader1, objectReader0);
}","/**
 * @since 2.3
 */"
"public ObjectReader with(TimeZone tz) {
    return _with(_config.with(tz));
}","public void test4747() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_INVALID_SUBTYPE;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    TimeZone timeZone0 = TimeZone.getDefault();
    ObjectReader objectReader1 = objectReader0.with(timeZone0);
    assertNotSame(objectReader1, objectReader0);
}",""
"public ObjectReader with(DeserializationFeature first, DeserializationFeature... other) {
    return _with(_config.with(first, other));
}","public void test4848() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    ObjectMapper objectMapper0 = new ObjectMapper((JsonFactory) null, defaultSerializerProvider_Impl0, defaultDeserializationContext_Impl0);
    ContextAttributes contextAttributes0 = ContextAttributes.Impl.getEmpty();
    ObjectReader objectReader0 = objectMapper0.reader(contextAttributes0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[2];
    // Undeclared exception!
    try {
        objectReader0.with(deserializationFeature0, deserializationFeatureArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationConfig"", e);
    }
}","/**
 * Method for constructing a new reader instance that is configured
 * with specified features enabled.
 */"
"public boolean isDouble() {
    return false;
}","public void test4949() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[1];
    deserializationFeatureArray0[0] = deserializationFeature0;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0, deserializationFeatureArray0);
    JsonNode jsonNode0 = objectReader0.readTree(""0"");
    assertFalse(jsonNode0.isDouble());
}",""
"public ContextAttributes getAttributes() {
    return _config.getAttributes();
}","public void test5151() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ContextAttributes contextAttributes0 = objectReader0.getAttributes();
    assertNotNull(contextAttributes0);
}","/**
 * @since 2.3
 */"
"public ObjectReader forType(TypeReference<?> valueTypeRef) {
    return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));
}","public void test5252() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    // Undeclared exception!
    try {
        objectReader0.forType((TypeReference<?>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}","/**
 *  Method for constructing a new reader instance that is configured
 *  to data bind into specified type.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 *
 *  @since 2.5
 */"
"@Override
public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException {
    throw new UnsupportedOperationException(""Not implemented for ObjectReader"");
}","public void test5353() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    BufferRecycler bufferRecycler0 = new BufferRecycler();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    IOContext iOContext0 = new IOContext(bufferRecycler0, deserializationFeature0, true);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""f7T>"");
    UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-1030), objectReader0, mockPrintStream0);
    // Undeclared exception!
    try {
        objectReader0.writeValue(uTF8JsonGenerator0, (Object) null);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Not implemented for ObjectReader
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}",""
"/*
    /**********************************************************
    /* Implementation of rest of ObjectCodec methods
    /**********************************************************
     */
@Override
public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {
    try {
        return readValue(treeAsTokens(n), valueType);
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}","public void test5454() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ObjectReader objectReader1 = objectMapper0.readerForUpdating((Object) objectReader0);
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectNode objectNode0 = new ObjectNode(jsonNodeFactory0);
    Class<MissingNode> class0 = MissingNode.class;
    // Undeclared exception!
    try {
        objectReader1.treeToValue((TreeNode) objectNode0, class0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // Can not update object of type com.fasterxml.jackson.databind.ObjectReader (by deserializer of type com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer)
        //
        verifyException(""com.fasterxml.jackson.databind.JsonDeserializer"", e);
    }
}",""
"public ObjectReader with(InjectableValues injectableValues) {
    if (_injectableValues == injectableValues) {
        return this;
    }
    return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate, _schema, injectableValues, _dataFormatReaders);
}","public void test5555() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    InjectableValues.Std injectableValues_Std0 = new InjectableValues.Std();
    ObjectReader objectReader1 = objectReader0.with((InjectableValues) injectableValues_Std0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new instance with configuration that uses
 *  passed {@link InjectableValues} to provide injectable values.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 */"
"public ObjectReader with(JsonFactory f) {
    if (f == _parserFactory) {
        return this;
    }
    ObjectReader r = _new(this, f);
    // Also, try re-linking, if possible...
    if (f.getCodec() == null) {
        f.setCodec(r);
    }
    return r;
}","public void test5656() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectReader objectReader0 = objectMapper0.readerForUpdating((Object) jsonFactory0);
    ObjectReader objectReader1 = objectReader0.with(jsonFactory0);
    assertSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new reader instance with configuration that uses
 *  passed {@link JsonFactory} for constructing underlying Readers.
 * <p>
 *  NOTE: only factories that <b>DO NOT REQUIRE SPECIAL MAPPERS</b>
 *  (that is, ones that return <code>false</code> for
 *  {@link JsonFactory#requiresCustomCodec()}) can be used: trying
 *  to use one that requires custom codec will throw exception
 *
 *  @since 2.1
 */"
"public ObjectReader with(JsonFactory f) {
    if (f == _parserFactory) {
        return this;
    }
    ObjectReader r = _new(this, f);
    // Also, try re-linking, if possible...
    if (f.getCodec() == null) {
        f.setCodec(r);
    }
    return r;
}","public void test5757() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper1 = new ObjectMapper(jsonFactory0);
    ObjectReader objectReader1 = objectReader0.with(jsonFactory0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new reader instance with configuration that uses
 *  passed {@link JsonFactory} for constructing underlying Readers.
 * <p>
 *  NOTE: only factories that <b>DO NOT REQUIRE SPECIAL MAPPERS</b>
 *  (that is, ones that return <code>false</code> for
 *  {@link JsonFactory#requiresCustomCodec()}) can be used: trying
 *  to use one that requires custom codec will throw exception
 *
 *  @since 2.1
 */"
"public ObjectReader with(FormatSchema schema) {
    if (_schema == schema) {
        return this;
    }
    _verifySchemaType(schema);
    return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate, schema, _injectableValues, _dataFormatReaders);
}","public void test5858() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ObjectReader objectReader1 = objectReader0.with((FormatSchema) null);
    assertSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new instance with configuration that
 *  passes specified {@link FormatSchema} to {@link JsonParser} that
 *  is constructed for parsing content.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 */"
"public ObjectReader withValueToUpdate(Object value) {
    if (value == _valueToUpdate)
        return this;
    if (value == null) {
        throw new IllegalArgumentException(""cat not update null value"");
    }
    JavaType t;
    /* no real benefit from pre-fetching, as updating readers are much
         * less likely to be reused, and value type may also be forced
         * with a later chained call...
         */
    if (_valueType == null) {
        t = _config.constructType(value.getClass());
    } else {
        t = _valueType;
    }
    return _new(this, _config, t, _rootDeserializer, value, _schema, _injectableValues, _dataFormatReaders);
}","public void test5959() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    ObjectReader objectReader1 = objectReader0.withValueToUpdate(objectMapper0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new instance with configuration that
 *  updates passed Object (as root value), instead of constructing
 *  a new value.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 */"
"public ObjectReader withValueToUpdate(Object value) {
    if (value == _valueToUpdate)
        return this;
    if (value == null) {
        throw new IllegalArgumentException(""cat not update null value"");
    }
    JavaType t;
    /* no real benefit from pre-fetching, as updating readers are much
         * less likely to be reused, and value type may also be forced
         * with a later chained call...
         */
    if (_valueType == null) {
        t = _config.constructType(value.getClass());
    } else {
        t = _valueType;
    }
    return _new(this, _config, t, _rootDeserializer, value, _schema, _injectableValues, _dataFormatReaders);
}","public void test6060() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<DecimalNode> class0 = DecimalNode.class;
    ObjectReader objectReader0 = objectMapper0.readerWithView((Class<?>) class0);
    ObjectReader objectReader1 = objectReader0.withValueToUpdate((Object) null);
    assertSame(objectReader0, objectReader1);
}","/**
 *  Method for constructing a new instance with configuration that
 *  updates passed Object (as root value), instead of constructing
 *  a new value.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 */"
"public ObjectReader withValueToUpdate(Object value) {
    if (value == _valueToUpdate)
        return this;
    if (value == null) {
        throw new IllegalArgumentException(""cat not update null value"");
    }
    JavaType t;
    /* no real benefit from pre-fetching, as updating readers are much
         * less likely to be reused, and value type may also be forced
         * with a later chained call...
         */
    if (_valueType == null) {
        t = _config.constructType(value.getClass());
    } else {
        t = _valueType;
    }
    return _new(this, _config, t, _rootDeserializer, value, _schema, _injectableValues, _dataFormatReaders);
}","public void test6161() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<SimpleType> class0 = SimpleType.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    ObjectReader objectReader0 = objectMapper0.reader((JavaType) simpleType0);
    ObjectReader objectReader1 = objectReader0.withValueToUpdate(class0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 *  Method for constructing a new instance with configuration that
 *  updates passed Object (as root value), instead of constructing
 *  a new value.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(Reader src) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(src);
    }
    return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);
}","public void test6262() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    PipedReader pipedReader0 = new PipedReader();
    try {
        objectReader0.readValue((Reader) pipedReader0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedReader"", e);
    }
}","/**
 * Method that binds content read from given input source,
 * using configuration of this reader.
 * Value return is either newly constructed, or root value that
 * was specified with {@link #withValueToUpdate(Object)}.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(String src) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(src);
    }
    return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);
}","public void test6363() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    try {
        objectReader0.readValue(""'), but "");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected character (''' (code 39)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')
        //  at [Source: java.lang.String@0000000024; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method that binds content read from given JSON string,
 * using configuration of this reader.
 * Value return is either newly constructed, or root value that
 * was specified with {@link #withValueToUpdate(Object)}.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(byte[] src) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        return (T) _detectBindAndClose(src, 0, src.length);
    }
    return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);
}","public void test6464() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_INVALID_SUBTYPE;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    byte[] byteArray0 = new byte[1];
    try {
        objectReader0.readValue(byteArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Illegal character ((CTRL-CHAR, code 0)): only regular white space (\\r, \\n, \\t) is allowed between tokens
        //  at [Source: [B@0000000025; line: 1, column: 2]
        //
        verifyException(""com.fasterxml.jackson.core.JsonParser"", e);
    }
}","/**
 * Method that binds content read from given byte array,
 * using configuration of this reader.
 * Value return is either newly constructed, or root value that
 * was specified with {@link #withValueToUpdate(Object)}.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(byte[] src, int offset, int length) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        return (T) _detectBindAndClose(src, offset, length);
    }
    return (T) _bindAndClose(_parserFactory.createParser(src, offset, length), _valueToUpdate);
}","public void test6565() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    // Undeclared exception!
    try {
        objectReader0.readValue((byte[]) null, 1, 1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.core.json.UTF8StreamJsonParser"", e);
    }
}","/**
 * Method that binds content read from given byte array,
 * using configuration of this reader.
 * Value return is either newly constructed, or root value that
 * was specified with {@link #withValueToUpdate(Object)}.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(File src) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);
    }
    return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);
}","public void test6666() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    // Undeclared exception!
    try {
        objectReader0.readValue((File) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}",""
"@SuppressWarnings(""unchecked"")
public <T> T readValue(URL src) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);
    }
    return (T) _bindAndClose(_parserFactory.createParser(src), _valueToUpdate);
}","public void test6767() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    URL uRL0 = MockURL.getFileExample();
    // Undeclared exception!
    try {
        objectReader0.readValue(uRL0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.net.URL"", e);
    }
}","/**
 * Method that binds content read from given input source,
 * using configuration of this reader.
 * Value return is either newly constructed, or root value that
 * was specified with {@link #withValueToUpdate(Object)}.
 */"
"public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        return _detectBindAndCloseAsTree(in);
    }
    return _bindAndCloseAsTree(_parserFactory.createParser(in));
}","public void test6868() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    try {
        objectReader0.readTree((InputStream) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No content to map due to end-of-input
        //  at [Source: UNKNOWN; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Method that reads content from given input source,
 *  using configuration of this reader, and binds it as JSON Tree.
 * <p>
 *  Note that if an object was specified with a call to
 *  {@link #withValueToUpdate(Object)}
 *  it will just be ignored; result is always a newly constructed
 *  {@link JsonNode} instance.
 */"
"public JsonNode readTree(Reader r) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(r);
    }
    return _bindAndCloseAsTree(_parserFactory.createParser(r));
}","public void test6969() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    PipedReader pipedReader0 = new PipedReader();
    try {
        objectReader0.readTree((Reader) pipedReader0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedReader"", e);
    }
}","/**
 *  Method that reads content from given input source,
 *  using configuration of this reader, and binds it as JSON Tree.
 * <p>
 *  Note that if an object was specified with a call to
 *  {@link #withValueToUpdate(Object)}
 *  it will just be ignored; result is always a newly constructed
 *  {@link JsonNode} instance.
 */"
"public <T> MappingIterator<T> readValues(InputStream src) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);
    }
    return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);
}","public void test7070() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    try {
        objectReader0.readValues((InputStream) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No value type configured for ObjectReader
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}","/**
 *  Method for reading sequence of Objects from parser stream.
 * <p>
 *  Sequence can be either wrapped or unwrapped root-level sequence:
 *  wrapped means that the elements are enclosed in JSON Array;
 *  and unwrapped that elements are directly accessed at main level.
 *  Assumption is that iff the first token of the document is
 *  <code>START_ARRAY</code>, we have a wrapped sequence; otherwise
 *  unwrapped. For wrapped sequences, leading <code>START_ARRAY</code>
 *  is skipped, so that for both cases, underlying {@link JsonParser}
 *  will point to what is expected to be the first token of the first
 *  element.
 * <p>
 *  Note that the wrapped vs unwrapped logic means that it is NOT
 *  possible to use this method for reading an unwrapped sequence
 *  of elements written as JSON Arrays: to read such sequences, one
 *  has to use {@link #readValues(JsonParser)}, making sure parser
 *  points to the first token of the first element (i.e. the second
 *  <code>START_ARRAY</code> which is part of the first element).
 */"
"@SuppressWarnings(""resource"")
public <T> MappingIterator<T> readValues(Reader src) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(src);
    }
    JsonParser p = _parserFactory.createParser(src);
    _initForMultiRead(p);
    p.nextToken();
    DeserializationContext ctxt = createDeserializationContext(p, _config);
    return _newIterator(_valueType, p, ctxt, _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);
}","public void test7171() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    PipedReader pipedReader0 = new PipedReader();
    try {
        objectReader0.readValues((Reader) pipedReader0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedReader"", e);
    }
}","/**
 * Overloaded version of {@link #readValue(InputStream)}.
 */"
"@SuppressWarnings(""resource"")
public <T> MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(json);
    }
    JsonParser p = _parserFactory.createParser(json);
    _initForMultiRead(p);
    p.nextToken();
    DeserializationContext ctxt = createDeserializationContext(p, _config);
    return _newIterator(_valueType, p, ctxt, _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);
}","public void test7272() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    try {
        objectReader0.readValues("""");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No value type configured for ObjectReader
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}","/**
 * Overloaded version of {@link #readValue(InputStream)}.
 *
 * @param json String that contains JSON content to parse
 */"
"public <T> MappingIterator<T> readValues(File src) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        return _detectBindAndReadValues(_dataFormatReaders.findFormat(_inputStream(src)), false);
    }
    return _bindAndReadValues(_parserFactory.createParser(src), _valueToUpdate);
}","public void test7373() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    // Undeclared exception!
    try {
        objectReader0.readValues((File) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.mock.java.io.MockFileInputStream"", e);
    }
}","/**
 * Overloaded version of {@link #readValue(InputStream)}.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(JsonNode src) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(src);
    }
    return (T) _bindAndClose(treeAsTokens(src), _valueToUpdate);
}","public void test7474() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    NullNode nullNode0 = NullNode.instance;
    try {
        objectReader0.readValue((JsonNode) nullNode0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No value type configured for ObjectReader
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}","/**
 *  Convenience method for converting results from given JSON tree into given
 *  value type. Basically short-cut for:
 * <pre>
 *    objectReader.readValue(src.traverse())
 * </pre>
 */"
"public JsonNode readTree(String json) throws IOException, JsonProcessingException {
    if (_dataFormatReaders != null) {
        _reportUndetectableSource(json);
    }
    return _bindAndCloseAsTree(_parserFactory.createParser(json));
}","public void test7575() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.UNWRAP_ROOT_VALUE;
    DeserializationFeature[] deserializationFeatureArray0 = new DeserializationFeature[1];
    deserializationFeatureArray0[0] = deserializationFeature0;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0, deserializationFeatureArray0);
    try {
        objectReader0.readTree(""0"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Current token not START_OBJECT (needed to unwrap root name 'JsonNode'), but VALUE_NUMBER_INT
        //  at [Source: java.lang.String@0000000026; line: 1, column: 1]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Method that reads content from given JSON input String,
 *  using configuration of this reader, and binds it as JSON Tree.
 * <p>
 *  Note that if an object was specified with a call to
 *  {@link #withValueToUpdate(Object)}
 *  it will just be ignored; result is always a newly constructed
 *  {@link JsonNode} instance.
 */"
"@Deprecated
public ObjectReader withType(java.lang.reflect.Type valueType) {
    return forType(_config.getTypeFactory().constructType(valueType));
}","public void test7676() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<BooleanNode> class0 = BooleanNode.class;
    objectMapper0.reader((Class<?>) class0);
    DeserializationFeature deserializationFeature0 = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    ObjectReader objectReader1 = objectReader0.withType((Type) class0);
    assertNotSame(objectReader1, objectReader0);
}","/**
 * @deprecated since 2.5 Use {@link #forType(Class)} instead
 */"
"@SuppressWarnings(""resource"")
protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing) throws IOException, JsonProcessingException {
    if (!match.hasMatch()) {
        _reportUnkownFormat(_dataFormatReaders, match);
    }
    JsonParser p = match.createParserWithMatch();
    // One more thing: we Own the input stream now; and while it's
    // not super clean way to do it, we must ensure closure so:
    if (forceClosing) {
        p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);
    }
    // important: use matching ObjectReader (may not be 'this')
    return match.getReader()._bindAndReadValues(p, _valueToUpdate);
}","public void test7777() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    byte[] byteArray0 = new byte[7];
    Stack<ObjectReader> stack0 = new Stack<ObjectReader>();
    DataFormatReaders dataFormatReaders0 = new DataFormatReaders(stack0);
    DataFormatReaders.Match dataFormatReaders_Match0 = dataFormatReaders0.findFormat(byteArray0);
    // Undeclared exception!
    try {
        objectReader0._detectBindAndReadValues(dataFormatReaders_Match0, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ObjectReader"", e);
    }
}",""
"/*
    /**********************************************************
    /* Internal methods, other
    /**********************************************************
     */
/**
 * @since 2.2
 */
protected void _verifySchemaType(FormatSchema schema) {
    if (schema != null) {
        if (!_parserFactory.canUseSchema(schema)) {
            throw new IllegalArgumentException(""Can not use FormatSchema of type "" + schema.getClass().getName() + "" for format "" + _parserFactory.getFormatName());
        }
    }
}","public void test7878() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    objectReader0._verifySchemaType((FormatSchema) null);
}",""
