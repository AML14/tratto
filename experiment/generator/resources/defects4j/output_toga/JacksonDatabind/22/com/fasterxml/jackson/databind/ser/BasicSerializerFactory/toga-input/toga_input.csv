focal_method,test_prefix,docstring
"/*
    /**********************************************************
    /* Factory methods, for non-container types
    /**********************************************************
     */
/**
 * @since 2.5
 */
protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType valueType) throws JsonMappingException {
    return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType));
}","public void test000() throws Throwable {
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    // Undeclared exception!
    try {
        beanSerializerFactory0.buildIteratorSerializer((SerializationConfig) null, simpleType0, (BeanDescription) null, false, simpleType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.BasicSerializerFactory"", e);
    }
}",""
"@Override
public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) {
    return withConfig(_factoryConfig.withSerializerModifier(modifier));
}","public void test011() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    // Undeclared exception!
    try {
        beanSerializerFactory0.withSerializerModifier((BeanSerializerModifier) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not pass null modifier
        //
        verifyException(""com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig"", e);
    }
}","/**
 * Convenience method for creating a new factory instance with additional bean
 * serializer modifier.
 */"
"protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping, JavaType keyType, JavaType valueType) throws JsonMappingException {
    return new MapEntrySerializer(valueType, keyType, valueType, staticTyping, createTypeSerializer(config, valueType), null);
}","public void test033() throws Throwable {
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    // Undeclared exception!
    try {
        beanSerializerFactory0.buildMapEntrySerializer((SerializationConfig) null, simpleType0, (BeanDescription) null, true, simpleType0, simpleType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.BasicSerializerFactory"", e);
    }
}","/**
 * @since 2.5
 */"
"@Override
public final SerializerFactory withAdditionalSerializers(Serializers additional) {
    return withConfig(_factoryConfig.withAdditionalSerializers(additional));
}","public void test044() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    SimpleSerializers simpleSerializers0 = new SimpleSerializers();
    SerializerFactory serializerFactory0 = beanSerializerFactory0.withAdditionalSerializers(simpleSerializers0);
    assertNotSame(serializerFactory0, beanSerializerFactory0);
}","/**
 * Convenience method for creating a new factory instance with an additional
 * serializer provider.
 */"
"/*
    /**********************************************************
    /* Public API (from ObjectCodec): serialization
    /* (mapping from Java types to Json)
    /**********************************************************
     */
/**
 * Method that can be used to serialize any Java value as
 * JSON output, using provided {@link JsonGenerator}.
 */
@Override
public void writeValue(JsonGenerator g, Object value) throws IOException, JsonGenerationException, JsonMappingException {
    SerializationConfig config = getSerializationConfig();
    /* 12-May-2015/2.6, tatu: Looks like we do NOT want to call the usual
         *    'config.initialize(g)` here, since it is assumed that generator
         *    has been configured by caller. But for some reason we don't
         *    trust indentation settings...
         */
    // 10-Aug-2012, tatu: as per [Issue#12], must handle indentation:
    if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {
        if (g.getPrettyPrinter() == null) {
            g.setPrettyPrinter(config.constructDefaultPrettyPrinter());
        }
    }
    if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {
        _writeCloseableValue(g, value, config);
    } else {
        _serializerProvider(config).serializeValue(g, value);
        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {
            g.flush();
        }
    }
}","public void test055() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory();
    MockFile mockFile0 = new MockFile(""JSON"");
    JsonEncoding jsonEncoding0 = JsonEncoding.UTF8;
    JsonGenerator jsonGenerator0 = jsonFactory0.createGenerator((File) mockFile0, jsonEncoding0);
    MapperFeature[] mapperFeatureArray0 = new MapperFeature[9];
    MapperFeature mapperFeature0 = MapperFeature.AUTO_DETECT_CREATORS;
    mapperFeatureArray0[0] = mapperFeature0;
    mapperFeatureArray0[1] = mapperFeature0;
    mapperFeatureArray0[2] = mapperFeature0;
    mapperFeatureArray0[3] = mapperFeature0;
    mapperFeatureArray0[4] = mapperFeatureArray0[0];
    MapperFeature mapperFeature1 = MapperFeature.AUTO_DETECT_GETTERS;
    mapperFeatureArray0[5] = mapperFeature1;
    mapperFeatureArray0[6] = mapperFeature0;
    mapperFeatureArray0[7] = mapperFeatureArray0[1];
    mapperFeatureArray0[8] = mapperFeature0;
    objectMapper0.disable(mapperFeatureArray0);
    SQLNonTransientException sQLNonTransientException0 = new SQLNonTransientException(""iF7|VDi5;"");
    SQLTimeoutException sQLTimeoutException0 = new SQLTimeoutException(""iF7|VDi5;"", ""JSON"", sQLNonTransientException0);
    // Undeclared exception!
    try {
        objectMapper0.writeValue(jsonGenerator0, (Object) sQLTimeoutException0);
        fail(""Expecting exception: StackOverflowError"");
    } catch (StackOverflowError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"/*
    /**********************************************************
    /* Public API (from ObjectCodec): serialization
    /* (mapping from Java types to Json)
    /**********************************************************
     */
/**
 * Method that can be used to serialize any Java value as
 * JSON output, using provided {@link JsonGenerator}.
 */
@Override
public void writeValue(JsonGenerator g, Object value) throws IOException, JsonGenerationException, JsonMappingException {
    SerializationConfig config = getSerializationConfig();
    /* 12-May-2015/2.6, tatu: Looks like we do NOT want to call the usual
         *    'config.initialize(g)` here, since it is assumed that generator
         *    has been configured by caller. But for some reason we don't
         *    trust indentation settings...
         */
    // 10-Aug-2012, tatu: as per [Issue#12], must handle indentation:
    if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {
        if (g.getPrettyPrinter() == null) {
            g.setPrettyPrinter(config.constructDefaultPrettyPrinter());
        }
    }
    if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {
        _writeCloseableValue(g, value, config);
    } else {
        _serializerProvider(config).serializeValue(g, value);
        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {
            g.flush();
        }
    }
}","public void test066() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory();
    MockFile mockFile0 = new MockFile(""JSON"");
    JsonEncoding jsonEncoding0 = JsonEncoding.UTF8;
    JsonGenerator jsonGenerator0 = jsonFactory0.createGenerator((File) mockFile0, jsonEncoding0);
    try {
        objectMapper0.writeValue(jsonGenerator0, (Object) beanSerializerFactory0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No serializer found for class com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) ) (through reference chain: com.fasterxml.jackson.databind.ser.BeanSerializerFactory[\""factoryConfig\""])
        //
        verifyException(""com.fasterxml.jackson.databind.ser.impl.UnknownSerializer"", e);
    }
}",""
"@Override
public final SerializerFactory withAdditionalKeySerializers(Serializers additional) {
    return withConfig(_factoryConfig.withAdditionalKeySerializers(additional));
}","public void test077() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    Serializers.Base serializers_Base0 = new Serializers.Base();
    SerializerFactory serializerFactory0 = beanSerializerFactory0.withAdditionalKeySerializers(serializers_Base0);
    assertNotSame(beanSerializerFactory0, serializerFactory0);
}","/**
 * Convenience method for creating a new factory instance with an additional
 * key serializer provider.
 */"
"protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {
    JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);
    if (ser != null) {
        return ser;
    }
    final SerializationConfig config = prov.getConfig();
    // Container types differ from non-container types
    // (note: called method checks for module-provided serializers)
    if (type.isContainerType()) {
        if (!staticTyping) {
            staticTyping = usesStaticTyping(config, beanDesc, null);
            // [Issue#23]: Need to figure out how to force passed parameterization
            //  to stick...
            /*
                if (property == null) {
                    JavaType t = origType.getContentType();
                    if (t != null && !t.hasRawClass(Object.class)) {
                        staticTyping = true;
                    }
                }
                */
        }
        // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...
        ser = buildContainerSerializer(prov, type, beanDesc, staticTyping);
        // Will return right away, since called method does post-processing:
        if (ser != null) {
            return ser;
        }
    } else {
        // Modules may provide serializers of POJO types:
        for (Serializers serializers : customSerializers()) {
            ser = serializers.findSerializer(config, type, beanDesc);
            if (ser != null) {
                break;
            }
        }
        // 25-Jun-2015, tatu: Then JsonSerializable, @JsonValue etc. NOTE! Prior to 2.6,
        //    this call was BEFORE custom serializer lookup, which was wrong.
    }
    if (ser == null) {
        // Otherwise, we will check ""primary types""; both marker types that
        // indicate specific handling (JsonSerializable), or main types that have
        // precedence over container types
        ser = findSerializerByLookup(type, config, beanDesc, staticTyping);
        if (ser == null) {
            ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);
            if (ser == null) {
                // And this is where this class comes in: if type is not a
                // known ""primary JDK type"", perhaps it's a bean? We can still
                // get a null, if we can't find a single suitable bean property.
                ser = findBeanSerializer(prov, type, beanDesc);
                // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?
                if (ser == null) {
                    ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);
                    // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get
                    //   'unknown' serializer assigned earlier, here, so that it gets properly
                    //   post-processed
                    if (ser == null) {
                        ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());
                    }
                }
            }
        }
    }
    if (ser != null) {
        // [databind#120]: Allow post-processing
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                ser = mod.modifySerializer(config, beanDesc, ser);
            }
        }
    }
    return ser;
}","public void test1111() throws Throwable {
    SerializerFactoryConfig serializerFactoryConfig0 = new SerializerFactoryConfig();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    Object object0 = new Object();
    Class<SerializationFeature> class0 = SerializationFeature.class;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, object0, (Object) defaultSerializerProvider_Impl0);
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((AnnotatedMethod) null).when(pOJOPropertiesCollector0).getJsonValueMethod();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    BeanSerializerFactory beanSerializerFactory0 = new BeanSerializerFactory(serializerFactoryConfig0);
    // Undeclared exception!
    try {
        beanSerializerFactory0._createSerializer2(defaultSerializerProvider_Impl0, referenceType0, basicBeanDescription0, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.util.EnumValues"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API (from ObjectCodec): serialization
    /* (mapping from Java types to Json)
    /**********************************************************
     */
/**
 * Method that can be used to serialize any Java value as
 * JSON output, using provided {@link JsonGenerator}.
 */
@Override
public void writeValue(JsonGenerator g, Object value) throws IOException, JsonGenerationException, JsonMappingException {
    SerializationConfig config = getSerializationConfig();
    /* 12-May-2015/2.6, tatu: Looks like we do NOT want to call the usual
         *    'config.initialize(g)` here, since it is assumed that generator
         *    has been configured by caller. But for some reason we don't
         *    trust indentation settings...
         */
    // 10-Aug-2012, tatu: as per [Issue#12], must handle indentation:
    if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {
        if (g.getPrettyPrinter() == null) {
            g.setPrettyPrinter(config.constructDefaultPrettyPrinter());
        }
    }
    if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {
        _writeCloseableValue(g, value, config);
    } else {
        _serializerProvider(config).serializeValue(g, value);
        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {
            g.flush();
        }
    }
}","public void test1212() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    JsonFactory jsonFactory0 = new JsonFactory();
    MockFile mockFile0 = new MockFile(""JSON"", ""JSON"");
    JsonEncoding jsonEncoding0 = JsonEncoding.UTF16_LE;
    JsonGenerator jsonGenerator0 = jsonFactory0.createGenerator((File) mockFile0, jsonEncoding0);
    try {
        objectMapper0.writeValue(jsonGenerator0, (Object) defaultSerializerProvider_Impl0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // (was java.lang.NullPointerException) (through reference chain: com.fasterxml.jackson.databind.ser.Impl[\""annotationIntrospector\""])
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}",""
"/*
    /**********************************************************
    /* Public API (from ObjectCodec): serialization
    /* (mapping from Java types to Json)
    /**********************************************************
     */
/**
 * Method that can be used to serialize any Java value as
 * JSON output, using provided {@link JsonGenerator}.
 */
@Override
public void writeValue(JsonGenerator g, Object value) throws IOException, JsonGenerationException, JsonMappingException {
    SerializationConfig config = getSerializationConfig();
    /* 12-May-2015/2.6, tatu: Looks like we do NOT want to call the usual
         *    'config.initialize(g)` here, since it is assumed that generator
         *    has been configured by caller. But for some reason we don't
         *    trust indentation settings...
         */
    // 10-Aug-2012, tatu: as per [Issue#12], must handle indentation:
    if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {
        if (g.getPrettyPrinter() == null) {
            g.setPrettyPrinter(config.constructDefaultPrettyPrinter());
        }
    }
    if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {
        _writeCloseableValue(g, value, config);
    } else {
        _serializerProvider(config).serializeValue(g, value);
        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {
            g.flush();
        }
    }
}","public void test1313() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JsonFactory jsonFactory0 = new JsonFactory();
    MockFile mockFile0 = new MockFile(""JSON"");
    JsonEncoding jsonEncoding0 = JsonEncoding.UTF8;
    JsonGenerator jsonGenerator0 = jsonFactory0.createGenerator((File) mockFile0, jsonEncoding0);
    POJONode pOJONode0 = new POJONode(jsonFactory0);
    try {
        objectMapper0.writeValue(jsonGenerator0, (Object) pOJONode0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed com.fasterxml.jackson.core.JsonFactory)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.DefaultSerializerProvider"", e);
    }
}",""
"/*
    /**********************************************************
    /* Factory methods, container types:
    /**********************************************************
     */
/**
 * @since 2.1
 */
protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {
    final SerializationConfig config = prov.getConfig();
    /* [databind#23], 15-Mar-2013, tatu: must force static handling of root value type,
         *   with just one important exception: if value type is ""untyped"", let's
         *   leave it as is; no clean way to make it work.
         */
    if (!staticTyping && type.useStaticType()) {
        if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {
            staticTyping = true;
        }
    }
    // Let's see what we can learn about element/content/value type, type serializer for it:
    JavaType elementType = type.getContentType();
    TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType);
    // if elements have type serializer, can not force static typing:
    if (elementTypeSerializer != null) {
        staticTyping = false;
    }
    JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo());
    if (type.isMapLikeType()) {
        // implements java.util.Map
        MapLikeType mlt = (MapLikeType) type;
        /* 29-Sep-2012, tatu: This is actually too early to (try to) find
             *  key serializer from property annotations, and can lead to caching
             *  issues (see [databind#75]). Instead, must be done from 'createContextual()' call.
             *  But we do need to check class annotations.
             */
        JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());
        if (mlt.isTrueMapType()) {
            return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer);
        }
        // With Map-like, just 2 options: (1) Custom, (2) Annotations
        JsonSerializer<?> ser = null;
        for (Serializers serializers : customSerializers()) {
            // (1) Custom
            MapLikeType mlType = (MapLikeType) type;
            ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);
            if (ser != null) {
                if (_factoryConfig.hasSerializerModifiers()) {
                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                        ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);
                    }
                }
                return ser;
            }
        }
        return null;
    }
    if (type.isCollectionLikeType()) {
        CollectionLikeType clt = (CollectionLikeType) type;
        if (clt.isTrueCollectionType()) {
            return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer);
        }
        // With Map-like, just 2 options: (1) Custom, (2) Annotations
        JsonSerializer<?> ser = null;
        CollectionLikeType clType = (CollectionLikeType) type;
        for (Serializers serializers : customSerializers()) {
            // (1) Custom
            ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer);
            if (ser != null) {
                if (_factoryConfig.hasSerializerModifiers()) {
                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                        ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);
                    }
                }
                return ser;
            }
        }
        return null;
    }
    if (type.isArrayType()) {
        return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer);
    }
    return null;
}","public void test1919() throws Throwable {
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    // Undeclared exception!
    try {
        beanSerializerFactory0.buildContainerSerializer(defaultSerializerProvider_Impl0, simpleType0, (BeanDescription) null, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.BasicSerializerFactory"", e);
    }
}",""
"public boolean hasPrefetchedSerializer() {
    return _prefetch.hasSerializer();
}","public void test2020() throws Throwable {
    SerializerFactoryConfig serializerFactoryConfig0 = new SerializerFactoryConfig();
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<SQLNonTransientConnectionException> class0 = SQLNonTransientConnectionException.class;
    Class<SQLInvalidAuthorizationSpecException> class1 = SQLInvalidAuthorizationSpecException.class;
    JavaType javaType0 = TypeFactory.unknownType();
    MissingNode missingNode0 = MissingNode.getInstance();
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class1, javaType0, (Object) serializerFactoryConfig0, (Object) missingNode0);
    MapType mapType0 = MapType.construct(class0, referenceType0, javaType0);
    ObjectWriter objectWriter0 = objectMapper0.writerFor((JavaType) mapType0);
    assertTrue(objectWriter0.hasPrefetchedSerializer());
}","/**
 * Diagnostics method that can be called to check whether this writer
 * has pre-fetched serializer to use: pre-fetching improves performance
 * when writer instances are reused as it avoids a per-call serializer
 * lookup.
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Factory methods, container types:
    /**********************************************************
     */
/**
 * @since 2.1
 */
protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException {
    final SerializationConfig config = prov.getConfig();
    /* [databind#23], 15-Mar-2013, tatu: must force static handling of root value type,
         *   with just one important exception: if value type is ""untyped"", let's
         *   leave it as is; no clean way to make it work.
         */
    if (!staticTyping && type.useStaticType()) {
        if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {
            staticTyping = true;
        }
    }
    // Let's see what we can learn about element/content/value type, type serializer for it:
    JavaType elementType = type.getContentType();
    TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType);
    // if elements have type serializer, can not force static typing:
    if (elementTypeSerializer != null) {
        staticTyping = false;
    }
    JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo());
    if (type.isMapLikeType()) {
        // implements java.util.Map
        MapLikeType mlt = (MapLikeType) type;
        /* 29-Sep-2012, tatu: This is actually too early to (try to) find
             *  key serializer from property annotations, and can lead to caching
             *  issues (see [databind#75]). Instead, must be done from 'createContextual()' call.
             *  But we do need to check class annotations.
             */
        JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());
        if (mlt.isTrueMapType()) {
            return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer);
        }
        // With Map-like, just 2 options: (1) Custom, (2) Annotations
        JsonSerializer<?> ser = null;
        for (Serializers serializers : customSerializers()) {
            // (1) Custom
            MapLikeType mlType = (MapLikeType) type;
            ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);
            if (ser != null) {
                if (_factoryConfig.hasSerializerModifiers()) {
                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                        ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);
                    }
                }
                return ser;
            }
        }
        return null;
    }
    if (type.isCollectionLikeType()) {
        CollectionLikeType clt = (CollectionLikeType) type;
        if (clt.isTrueCollectionType()) {
            return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer);
        }
        // With Map-like, just 2 options: (1) Custom, (2) Annotations
        JsonSerializer<?> ser = null;
        CollectionLikeType clType = (CollectionLikeType) type;
        for (Serializers serializers : customSerializers()) {
            // (1) Custom
            ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer);
            if (ser != null) {
                if (_factoryConfig.hasSerializerModifiers()) {
                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                        ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);
                    }
                }
                return ser;
            }
        }
        return null;
    }
    if (type.isArrayType()) {
        return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer);
    }
    return null;
}","public void test2121() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Map> class0 = Map.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class0);
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    CollectionType collectionType0 = CollectionType.construct(class0, mapType0);
    CollectionType collectionType1 = collectionType0.withStaticTyping();
    // Undeclared exception!
    try {
        beanSerializerFactory0.buildContainerSerializer(defaultSerializerProvider_Impl0, collectionType1, (BeanDescription) null, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.BasicSerializerFactory"", e);
    }
}",""
"protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) {
    /* 16-Aug-2010, tatu: If there is a (value) type serializer, we can not force
         *    static typing; that would make it impossible to handle expected subtypes
         */
    if (typeSer != null) {
        return false;
    }
    AnnotationIntrospector intr = config.getAnnotationIntrospector();
    JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo());
    if (t != null && t != JsonSerialize.Typing.DEFAULT_TYPING) {
        return (t == JsonSerialize.Typing.STATIC);
    }
    return config.isEnabled(MapperFeature.USE_STATIC_TYPING);
}","public void test3232() throws Throwable {
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    AsExistingPropertyTypeSerializer asExistingPropertyTypeSerializer0 = new AsExistingPropertyTypeSerializer((TypeIdResolver) null, (BeanProperty) null, ""uv"");
    boolean boolean0 = beanSerializerFactory0.usesStaticTyping((SerializationConfig) null, basicBeanDescription0, asExistingPropertyTypeSerializer0);
    assertFalse(boolean0);
}","/**
 * Helper method to check whether global settings and/or class
 * annotations for the bean class indicate that static typing
 * (declared types)  should be used for properties.
 * (instead of dynamic runtime types).
 *
 * @since 2.1 (earlier had variant with additional 'property' parameter)
 */"
"protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) {
    if (src == null) {
        return null;
    }
    if (!(src instanceof Class)) {
        throw new IllegalStateException(""AnnotationIntrospector."" + methodName + ""() returned value of type "" + src.getClass().getName() + "": expected type JsonSerializer or Class<JsonSerializer> instead"");
    }
    Class<?> cls = (Class<?>) src;
    if (cls == noneClass || ClassUtil.isBogusClass(cls)) {
        return null;
    }
    return cls;
}","public void test3333() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    Class<Time> class0 = Time.class;
    // Undeclared exception!
    try {
        beanSerializerFactory0._verifyAsClass(jsonFactory0, """", class0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // AnnotationIntrospector.() returned value of type com.fasterxml.jackson.core.JsonFactory: expected type JsonSerializer or Class<JsonSerializer> instead
        //
        verifyException(""com.fasterxml.jackson.databind.ser.BasicSerializerFactory"", e);
    }
}",""
"protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) {
    if (src == null) {
        return null;
    }
    if (!(src instanceof Class)) {
        throw new IllegalStateException(""AnnotationIntrospector."" + methodName + ""() returned value of type "" + src.getClass().getName() + "": expected type JsonSerializer or Class<JsonSerializer> instead"");
    }
    Class<?> cls = (Class<?>) src;
    if (cls == noneClass || ClassUtil.isBogusClass(cls)) {
        return null;
    }
    return cls;
}","public void test3434() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    Class<DataTruncation> class0 = DataTruncation.class;
    Class<?> class1 = beanSerializerFactory0._verifyAsClass((Object) null, ""W,w \n%.~^&6 ]."", class0);
    assertNull(class1);
}",""
"protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) {
    if (src == null) {
        return null;
    }
    if (!(src instanceof Class)) {
        throw new IllegalStateException(""AnnotationIntrospector."" + methodName + ""() returned value of type "" + src.getClass().getName() + "": expected type JsonSerializer or Class<JsonSerializer> instead"");
    }
    Class<?> cls = (Class<?>) src;
    if (cls == noneClass || ClassUtil.isBogusClass(cls)) {
        return null;
    }
    return cls;
}","public void test3535() throws Throwable {
    BeanSerializerFactory beanSerializerFactory0 = BeanSerializerFactory.instance;
    Class<JSONWrappedObject> class0 = JSONWrappedObject.class;
    Class<?> class1 = beanSerializerFactory0._verifyAsClass(class0, (String) null, class0);
    assertNull(class1);
}",""
