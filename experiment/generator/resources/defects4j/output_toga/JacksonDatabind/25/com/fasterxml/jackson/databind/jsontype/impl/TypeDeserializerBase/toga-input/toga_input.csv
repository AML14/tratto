focal_method,test_prefix,docstring
"@Override
public final String getPropertyName() {
    return _typePropertyName;
}","public void test000() throws Throwable {
    Class<HijrahEra> class0 = HijrahEra.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(simpleType0, (TypeFactory) null);
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(simpleType0, minimalClassNameIdResolver0, """", true, class0);
    String string0 = asPropertyTypeDeserializer0.getPropertyName();
    assertEquals("""", string0);
}",""
"/*
    /**********************************************************
    /* Accessors for metadata
    /**********************************************************
     */
/**
 * Accessor for mechanism that this resolver uses for determining
 * type id from type. Mostly informational; not required to be called
 * or used.
 */
public JsonTypeInfo.Id getMechanism();","public void test011() throws Throwable {
    Class<HijrahEra> class0 = HijrahEra.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(simpleType0, (TypeFactory) null);
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(simpleType0, minimalClassNameIdResolver0, """", false, class0);
    TypeIdResolver typeIdResolver0 = asPropertyTypeDeserializer0.getTypeIdResolver();
    assertEquals(JsonTypeInfo.Id.MINIMAL_CLASS, typeIdResolver0.getMechanism());
}",""
"@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append('[').append(getClass().getName());
    sb.append(""; base-type:"").append(_baseType);
    sb.append(""; id-resolver: "").append(_idResolver);
    sb.append(']');
    return sb.toString();
}","public void test022() throws Throwable {
    Class<HijrahEra> class0 = HijrahEra.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(simpleType0, (TypeFactory) null);
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(simpleType0, minimalClassNameIdResolver0, """", true, class0);
    String string0 = asPropertyTypeDeserializer0.toString();
    assertNotNull(string0);
}",""
"public String baseTypeName() {
    return _baseType.getRawClass().getName();
}","public void test033() throws Throwable {
    Class<HijrahEra> class0 = HijrahEra.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(simpleType0, (TypeFactory) null);
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(simpleType0, minimalClassNameIdResolver0, ""g/"", false, class0);
    String string0 = asPropertyTypeDeserializer0.baseTypeName();
    assertEquals(""java.time.chrono.HijrahEra"", string0);
}",""
"@Deprecated
protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException {
    return _deserializeWithNativeTypeId(jp, ctxt, jp.getTypeId());
}","public void test044() throws Throwable {
    Class<HijrahEra> class0 = HijrahEra.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(simpleType0, (TypeIdResolver) null, ""$wF7hhAG|}(X+)"", true, class0);
    // Undeclared exception!
    try {
        asPropertyTypeDeserializer0._deserializeWithNativeTypeId((JsonParser) null, (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase"", e);
    }
}","/**
 * Helper method called when {@link JsonParser} indicates that it can use
 * so-called native type ids. Assumption from there is that only native
 * type ids are to be used.
 *
 * @since 2.3
 */"
"protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException {
    JsonDeserializer<Object> deser;
    if (typeId == null) {
        /* 04-May-2014, tatu: Should error be obligatory, or should there be another method
             *   for ""try to deserialize with native tpye id""?
             */
        deser = _findDefaultImplDeserializer(ctxt);
        if (deser == null) {
            throw ctxt.mappingException(""No (native) type id found when one was expected for polymorphic type handling"");
        }
    } else {
        String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId);
        deser = _findDeserializer(ctxt, typeIdStr);
    }
    return deser.deserialize(jp, ctxt);
}","public void test066() throws Throwable {
    Class<HijrahEra> class0 = HijrahEra.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(simpleType0, (TypeIdResolver) null, ""&@hi\""j,2&]Tz`7."", true, (Class<?>) null);
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    // Undeclared exception!
    try {
        asPropertyTypeDeserializer0._deserializeWithNativeTypeId((JsonParser) null, deserializationContext0, (Object) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.NullifyingDeserializer"", e);
    }
}","/**
 * Helper method called when {@link JsonParser} indicates that it can use
 * so-called native type ids, and such type id has been found.
 *
 * @since 2.4
 */"
"@Override
public Class<?> getDefaultImpl() {
    return (_defaultImpl == null) ? null : _defaultImpl.getRawClass();
}","public void test088() throws Throwable {
    Class<HijrahEra> class0 = HijrahEra.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(simpleType0, (TypeFactory) null);
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(simpleType0, minimalClassNameIdResolver0, ""Z"", true, (Class<?>) null);
    Class<?> class1 = asPropertyTypeDeserializer0.getDefaultImpl();
    assertNull(class1);
}",""
"protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException {
    JsonDeserializer<Object> deser;
    if (typeId == null) {
        /* 04-May-2014, tatu: Should error be obligatory, or should there be another method
             *   for ""try to deserialize with native tpye id""?
             */
        deser = _findDefaultImplDeserializer(ctxt);
        if (deser == null) {
            throw ctxt.mappingException(""No (native) type id found when one was expected for polymorphic type handling"");
        }
    } else {
        String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId);
        deser = _findDeserializer(ctxt, typeIdStr);
    }
    return deser.deserialize(jp, ctxt);
}","public void test099() throws Throwable {
    Class<HijrahEra> class0 = HijrahEra.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(simpleType0, (TypeIdResolver) null, ""$wF7h<G|}(wX+)"", false, class0);
    // Undeclared exception!
    try {
        asPropertyTypeDeserializer0._deserializeWithNativeTypeId((JsonParser) null, (DeserializationContext) null, simpleType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase"", e);
    }
}","/**
 * Helper method called when {@link JsonParser} indicates that it can use
 * so-called native type ids, and such type id has been found.
 *
 * @since 2.4
 */"
"protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException {
    JsonDeserializer<Object> deser;
    if (typeId == null) {
        /* 04-May-2014, tatu: Should error be obligatory, or should there be another method
             *   for ""try to deserialize with native tpye id""?
             */
        deser = _findDefaultImplDeserializer(ctxt);
        if (deser == null) {
            throw ctxt.mappingException(""No (native) type id found when one was expected for polymorphic type handling"");
        }
    } else {
        String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId);
        deser = _findDeserializer(ctxt, typeIdStr);
    }
    return deser.deserialize(jp, ctxt);
}","public void test1010() throws Throwable {
    Class<HijrahEra> class0 = HijrahEra.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(simpleType0, (TypeIdResolver) null, ""$lF7h<Grc|}FwX+)"", true, class0);
    // Undeclared exception!
    try {
        asPropertyTypeDeserializer0._deserializeWithNativeTypeId((JsonParser) null, (DeserializationContext) null, (Object) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase"", e);
    }
}","/**
 * Helper method called when {@link JsonParser} indicates that it can use
 * so-called native type ids, and such type id has been found.
 *
 * @since 2.4
 */"
"public boolean isCachable() {
    return false;
}","public void test1111() throws Throwable {
    Class<HijrahEra> class0 = HijrahEra.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(simpleType0, (TypeFactory) null);
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(simpleType0, minimalClassNameIdResolver0, ""'): "", false, class0);
    CoreXMLDeserializers.Std coreXMLDeserializers_Std0 = new CoreXMLDeserializers.Std(class0, (-8));
    asPropertyTypeDeserializer0._defaultImplDeserializer = (JsonDeserializer<Object>) coreXMLDeserializers_Std0;
    JsonDeserializer<Object> jsonDeserializer0 = asPropertyTypeDeserializer0._findDefaultImplDeserializer((DeserializationContext) null);
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt, Object typeId) throws IOException {
    JsonDeserializer<Object> deser;
    if (typeId == null) {
        /* 04-May-2014, tatu: Should error be obligatory, or should there be another method
             *   for ""try to deserialize with native tpye id""?
             */
        deser = _findDefaultImplDeserializer(ctxt);
        if (deser == null) {
            throw ctxt.mappingException(""No (native) type id found when one was expected for polymorphic type handling"");
        }
    } else {
        String typeIdStr = (typeId instanceof String) ? (String) typeId : String.valueOf(typeId);
        deser = _findDeserializer(ctxt, typeIdStr);
    }
    return deser.deserialize(jp, ctxt);
}","public void test1212() throws Throwable {
    Class<HijrahEra> class0 = HijrahEra.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    String string0 = ""c;v\\u25"";
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(simpleType0, (TypeIdResolver) null, string0, false, class0);
    // Undeclared exception!
    try {
        asPropertyTypeDeserializer0._deserializeWithNativeTypeId((JsonParser) null, (DeserializationContext) null, string0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase"", e);
    }
}","/**
 * Helper method called when {@link JsonParser} indicates that it can use
 * so-called native type ids, and such type id has been found.
 *
 * @since 2.4
 */"
"protected JsonDeserializer<Object> _handleUnknownTypeId(DeserializationContext ctxt, String typeId, TypeIdResolver idResolver, JavaType baseType) throws IOException {
    String extraDesc;
    if (idResolver instanceof TypeIdResolverBase) {
        extraDesc = ((TypeIdResolverBase) idResolver).getDescForKnownTypeIds();
        if (extraDesc == null) {
            extraDesc = ""known type ids are not statically known"";
        } else {
            extraDesc = ""known type ids = "" + extraDesc;
        }
    } else {
        extraDesc = null;
    }
    throw ctxt.unknownTypeException(_baseType, typeId, extraDesc);
}","public void test1313() throws Throwable {
    Class<HijrahEra> class0 = HijrahEra.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(simpleType0, (TypeIdResolver) null, "":00.000"", true, class0);
    // Undeclared exception!
    try {
        asPropertyTypeDeserializer0._handleUnknownTypeId((DeserializationContext) null, "":00.000"", (TypeIdResolver) null, simpleType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase"", e);
    }
}","/**
 * Helper method called when given type id can not be resolved into
 * concrete deserializer either directly (using given {@link  TypeIdResolver}),
 * or using default type.
 * Default implementation simply throws a {@link com.fasterxml.jackson.databind.JsonMappingException} to
 * indicate the problem; sub-classes may choose
 *
 * @return If it is possible to resolve type id into a {@link JsonDeserializer}
 *   should return that deserializer; otherwise throw an exception to indicate
 *   the problem.
 *
 * @since 2.5
 */"
"protected JsonDeserializer<Object> _handleUnknownTypeId(DeserializationContext ctxt, String typeId, TypeIdResolver idResolver, JavaType baseType) throws IOException {
    String extraDesc;
    if (idResolver instanceof TypeIdResolverBase) {
        extraDesc = ((TypeIdResolverBase) idResolver).getDescForKnownTypeIds();
        if (extraDesc == null) {
            extraDesc = ""known type ids are not statically known"";
        } else {
            extraDesc = ""known type ids = "" + extraDesc;
        }
    } else {
        extraDesc = null;
    }
    throw ctxt.unknownTypeException(_baseType, typeId, extraDesc);
}","public void test1414() throws Throwable {
    Class<HijrahEra> class0 = HijrahEra.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MinimalClassNameIdResolver minimalClassNameIdResolver0 = new MinimalClassNameIdResolver(simpleType0, (TypeFactory) null);
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(simpleType0, minimalClassNameIdResolver0, """", false, class0);
    // Undeclared exception!
    try {
        asPropertyTypeDeserializer0._handleUnknownTypeId((DeserializationContext) null, """", minimalClassNameIdResolver0, simpleType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase"", e);
    }
}","/**
 * Helper method called when given type id can not be resolved into
 * concrete deserializer either directly (using given {@link  TypeIdResolver}),
 * or using default type.
 * Default implementation simply throws a {@link com.fasterxml.jackson.databind.JsonMappingException} to
 * indicate the problem; sub-classes may choose
 *
 * @return If it is possible to resolve type id into a {@link JsonDeserializer}
 *   should return that deserializer; otherwise throw an exception to indicate
 *   the problem.
 *
 * @since 2.5
 */"
