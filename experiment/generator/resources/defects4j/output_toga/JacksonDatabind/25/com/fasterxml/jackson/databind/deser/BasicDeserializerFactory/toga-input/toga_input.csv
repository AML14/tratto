focal_method,test_prefix,docstring
"/*
    /********************************************************
    /* Configuration handling: fluent factories
    /********************************************************
     */
/**
 * Convenience method for creating a new factory instance with additional deserializer
 * provider.
 */
@Override
public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {
    return withConfig(_factoryConfig.withAdditionalDeserializers(additional));
}","public void test000() throws Throwable {
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.withAdditionalDeserializers((Deserializers) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not pass null Deserializers
        //
        verifyException(""com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig"", e);
    }
}",""
"@Override
public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {
    return withConfig(_factoryConfig.withDeserializerModifier(modifier));
}","public void test011() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    // Undeclared exception!
    try {
        beanDeserializerFactory0.withDeserializerModifier((BeanDeserializerModifier) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not pass null modifier
        //
        verifyException(""com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig"", e);
    }
}","/**
 * Convenience method for creating a new factory instance with additional
 * {@link BeanDeserializerModifier}.
 */"
"public boolean hasDeserializerModifiers() {
    return _modifiers.length > 0;
}","public void test033() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DeserializerFactoryConfig deserializerFactoryConfig0 = beanDeserializerFactory0.getFactoryConfig();
    assertFalse(deserializerFactoryConfig0.hasDeserializerModifiers());
}",""
"@Override
public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {
    return withConfig(_factoryConfig.withValueInstantiators(instantiators));
}","public void test044() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    ValueInstantiators.Base valueInstantiators_Base0 = new ValueInstantiators.Base();
    DeserializerFactory deserializerFactory0 = beanDeserializerFactory0.withValueInstantiators(valueInstantiators_Base0);
    assertNotSame(beanDeserializerFactory0, deserializerFactory0);
}","/**
 * Convenience method for creating a new factory instance with additional
 * {@link ValueInstantiators}.
 */"
"@Override
public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {
    return withConfig(_factoryConfig.withAbstractTypeResolver(resolver));
}","public void test066() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    SimpleAbstractTypeResolver simpleAbstractTypeResolver0 = new SimpleAbstractTypeResolver();
    DeserializerFactory deserializerFactory0 = beanDeserializerFactory0.withAbstractTypeResolver(simpleAbstractTypeResolver0);
    assertNotSame(beanDeserializerFactory0, deserializerFactory0);
}","/**
 * Convenience method for creating a new factory instance with additional
 * {@link AbstractTypeResolver}.
 */"
"public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {
    if (instDef == null) {
        return null;
    }
    ValueInstantiator inst;
    if (instDef instanceof ValueInstantiator) {
        return (ValueInstantiator) instDef;
    }
    if (!(instDef instanceof Class)) {
        throw new IllegalStateException(""AnnotationIntrospector returned key deserializer definition of type "" + instDef.getClass().getName() + ""; expected type KeyDeserializer or Class<KeyDeserializer> instead"");
    }
    Class<?> instClass = (Class<?>) instDef;
    if (ClassUtil.isBogusClass(instClass)) {
        return null;
    }
    if (!ValueInstantiator.class.isAssignableFrom(instClass)) {
        throw new IllegalStateException(""AnnotationIntrospector returned Class "" + instClass.getName() + ""; expected Class<ValueInstantiator>"");
    }
    HandlerInstantiator hi = config.getHandlerInstantiator();
    if (hi != null) {
        inst = hi.valueInstantiatorInstance(config, annotated, instClass);
        if (inst != null) {
            return inst;
        }
    }
    return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers());
}","public void test077() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    Class<SQLNonTransientConnectionException> class0 = SQLNonTransientConnectionException.class;
    // Undeclared exception!
    try {
        beanDeserializerFactory0._valueInstantiatorInstance((DeserializationConfig) null, (Annotated) null, class0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // AnnotationIntrospector returned Class java.sql.SQLNonTransientConnectionException; expected Class<ValueInstantiator>
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {
    if (instDef == null) {
        return null;
    }
    ValueInstantiator inst;
    if (instDef instanceof ValueInstantiator) {
        return (ValueInstantiator) instDef;
    }
    if (!(instDef instanceof Class)) {
        throw new IllegalStateException(""AnnotationIntrospector returned key deserializer definition of type "" + instDef.getClass().getName() + ""; expected type KeyDeserializer or Class<KeyDeserializer> instead"");
    }
    Class<?> instClass = (Class<?>) instDef;
    if (ClassUtil.isBogusClass(instClass)) {
        return null;
    }
    if (!ValueInstantiator.class.isAssignableFrom(instClass)) {
        throw new IllegalStateException(""AnnotationIntrospector returned Class "" + instClass.getName() + ""; expected Class<ValueInstantiator>"");
    }
    HandlerInstantiator hi = config.getHandlerInstantiator();
    if (hi != null) {
        inst = hi.valueInstantiatorInstance(config, annotated, instClass);
        if (inst != null) {
            return inst;
        }
    }
    return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers());
}","public void test088() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    ValueInstantiator valueInstantiator0 = beanDeserializerFactory0._valueInstantiatorInstance((DeserializationConfig) null, (Annotated) null, (Object) null);
    assertNull(valueInstantiator0);
}",""
"public boolean canCreateFromBoolean() {
    return false;
}","public void test099() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    JsonLocationInstantiator jsonLocationInstantiator0 = new JsonLocationInstantiator();
    ValueInstantiator valueInstantiator0 = beanDeserializerFactory0._valueInstantiatorInstance((DeserializationConfig) null, (Annotated) null, jsonLocationInstantiator0);
    assertFalse(valueInstantiator0.canCreateFromBoolean());
}","/**
 * Method that can be called to check whether a double (boolean / Boolean) based
 * creator is available to use (to call {@link #createFromDouble}).
 */"
"public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {
    if (instDef == null) {
        return null;
    }
    ValueInstantiator inst;
    if (instDef instanceof ValueInstantiator) {
        return (ValueInstantiator) instDef;
    }
    if (!(instDef instanceof Class)) {
        throw new IllegalStateException(""AnnotationIntrospector returned key deserializer definition of type "" + instDef.getClass().getName() + ""; expected type KeyDeserializer or Class<KeyDeserializer> instead"");
    }
    Class<?> instClass = (Class<?>) instDef;
    if (ClassUtil.isBogusClass(instClass)) {
        return null;
    }
    if (!ValueInstantiator.class.isAssignableFrom(instClass)) {
        throw new IllegalStateException(""AnnotationIntrospector returned Class "" + instClass.getName() + ""; expected Class<ValueInstantiator>"");
    }
    HandlerInstantiator hi = config.getHandlerInstantiator();
    if (hi != null) {
        inst = hi.valueInstantiatorInstance(config, annotated, instClass);
        if (inst != null) {
            return inst;
        }
    }
    return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers());
}","public void test1010() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    // Undeclared exception!
    try {
        beanDeserializerFactory0._valueInstantiatorInstance((DeserializationConfig) null, (Annotated) null, beanDeserializerFactory0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // AnnotationIntrospector returned key deserializer definition of type com.fasterxml.jackson.databind.deser.BeanDeserializerFactory; expected type KeyDeserializer or Class<KeyDeserializer> instead
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef) {
    JsonCreator.Mode mode = intr.findCreatorBinding(creator);
    if (mode == JsonCreator.Mode.PROPERTIES) {
        return true;
    }
    if (mode == JsonCreator.Mode.DELEGATING) {
        return false;
    }
    // If explicit name, or inject id, property-based
    if (((propDef != null) && propDef.isExplicitlyNamed()) || (intr.findInjectableValueId(creator.getParameter(0)) != null)) {
        return true;
    }
    if (propDef != null) {
        // One more thing: if implicit name matches property with a getter
        // or field, we'll consider it property-based as well
        String implName = propDef.getName();
        if (implName != null && !implName.isEmpty()) {
            if (propDef.couldSerialize()) {
                return true;
            }
        }
    }
    // in absence of everything else, default to delegating
    return false;
}","public void test1111() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    Class<SQLNonTransientConnectionException> class0 = SQLNonTransientConnectionException.class;
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    AnnotatedClass annotatedClass0 = AnnotatedClass.constructWithoutSuperTypes(class0, annotationIntrospector0, (ClassIntrospector.MixInResolver) null);
    AnnotatedConstructor annotatedConstructor0 = annotatedClass0.getDefaultConstructor();
    PropertyName propertyName0 = BeanDeserializerBase.TEMP_PROPERTY_NAME;
    POJOPropertyBuilder pOJOPropertyBuilder0 = new POJOPropertyBuilder(propertyName0, annotationIntrospector0, false);
    boolean boolean0 = beanDeserializerFactory0._checkIfCreatorPropertyBased(annotationIntrospector0, annotatedConstructor0, pOJOPropertyBuilder0);
    assertFalse(boolean0);
}",""
"protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef) {
    JsonCreator.Mode mode = intr.findCreatorBinding(creator);
    if (mode == JsonCreator.Mode.PROPERTIES) {
        return true;
    }
    if (mode == JsonCreator.Mode.DELEGATING) {
        return false;
    }
    // If explicit name, or inject id, property-based
    if (((propDef != null) && propDef.isExplicitlyNamed()) || (intr.findInjectableValueId(creator.getParameter(0)) != null)) {
        return true;
    }
    if (propDef != null) {
        // One more thing: if implicit name matches property with a getter
        // or field, we'll consider it property-based as well
        String implName = propDef.getName();
        if (implName != null && !implName.isEmpty()) {
            if (propDef.couldSerialize()) {
                return true;
            }
        }
    }
    // in absence of everything else, default to delegating
    return false;
}","public void test1212() throws Throwable {
    Class<SQLNonTransientConnectionException> class0 = SQLNonTransientConnectionException.class;
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    AnnotatedClass annotatedClass0 = AnnotatedClass.constructWithoutSuperTypes(class0, annotationIntrospector0, (ClassIntrospector.MixInResolver) null);
    AnnotatedConstructor annotatedConstructor0 = annotatedClass0.getDefaultConstructor();
    POJOPropertyBuilder pOJOPropertyBuilder0 = new POJOPropertyBuilder((PropertyName) null, annotationIntrospector0, true);
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    boolean boolean0 = beanDeserializerFactory0._checkIfCreatorPropertyBased(annotationIntrospector0, annotatedConstructor0, pOJOPropertyBuilder0);
    assertFalse(boolean0);
}",""
"protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr, AnnotatedWithParams creator, BeanPropertyDefinition propDef) {
    JsonCreator.Mode mode = intr.findCreatorBinding(creator);
    if (mode == JsonCreator.Mode.PROPERTIES) {
        return true;
    }
    if (mode == JsonCreator.Mode.DELEGATING) {
        return false;
    }
    // If explicit name, or inject id, property-based
    if (((propDef != null) && propDef.isExplicitlyNamed()) || (intr.findInjectableValueId(creator.getParameter(0)) != null)) {
        return true;
    }
    if (propDef != null) {
        // One more thing: if implicit name matches property with a getter
        // or field, we'll consider it property-based as well
        String implName = propDef.getName();
        if (implName != null && !implName.isEmpty()) {
            if (propDef.couldSerialize()) {
                return true;
            }
        }
    }
    // in absence of everything else, default to delegating
    return false;
}","public void test1313() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    Class<SQLNonTransientConnectionException> class0 = SQLNonTransientConnectionException.class;
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    AnnotatedClass annotatedClass0 = AnnotatedClass.constructWithoutSuperTypes(class0, annotationIntrospector0, (ClassIntrospector.MixInResolver) null);
    AnnotatedConstructor annotatedConstructor0 = annotatedClass0.getDefaultConstructor();
    PropertyName propertyName0 = PropertyName.NO_NAME;
    POJOPropertyBuilder pOJOPropertyBuilder0 = new POJOPropertyBuilder(propertyName0, annotationIntrospector0, false);
    boolean boolean0 = beanDeserializerFactory0._checkIfCreatorPropertyBased(annotationIntrospector0, annotatedConstructor0, pOJOPropertyBuilder0);
    assertFalse(boolean0);
}",""
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test1515() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    JsonNodeFactory jsonNodeFactory0 = JsonNodeFactory.instance;
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(jsonNodeFactory0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        PropertyName name = intr.findNameForDeserialization(param);
        if (name != null) {
            return name;
        }
        // 14-Apr-2014, tatu: Need to also consider possible implicit name
        //  (for JDK8, or via paranamer)
        String str = intr.findImplicitPropertyName(param);
        if (str != null && !str.isEmpty()) {
            return PropertyName.construct(str);
        }
    }
    return null;
}","public void test1616() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    PropertyName propertyName0 = beanDeserializerFactory0._findParamName((AnnotatedParameter) null, (AnnotationIntrospector) null);
    assertNull(propertyName0);
}",""
"protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        PropertyName name = intr.findNameForDeserialization(param);
        if (name != null) {
            return name;
        }
        // 14-Apr-2014, tatu: Need to also consider possible implicit name
        //  (for JDK8, or via paranamer)
        String str = intr.findImplicitPropertyName(param);
        if (str != null && !str.isEmpty()) {
            return PropertyName.construct(str);
        }
    }
    return null;
}","public void test1717() throws Throwable {
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    Class<BinaryNode> class0 = BinaryNode.class;
    SimpleType simpleType0 = SimpleType.construct(class0);
    SQLTransientConnectionException sQLTransientConnectionException0 = new SQLTransientConnectionException();
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, (JavaType) simpleType0, (Object) sQLTransientConnectionException0, (Object) null);
    CollectionType collectionType0 = CollectionType.construct(class0, referenceType0);
    AnnotationMap annotationMap0 = new AnnotationMap();
    AnnotatedParameter annotatedParameter0 = new AnnotatedParameter((AnnotatedWithParams) null, collectionType0, annotationMap0, 309);
    PropertyName propertyName0 = beanDeserializerFactory0._findParamName(annotatedParameter0, (AnnotationIntrospector) null);
    assertNull(propertyName0);
}",""
"protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    String str = intr.findImplicitPropertyName(param);
    if (str != null && !str.isEmpty()) {
        return PropertyName.construct(str);
    }
    return null;
}","public void test1818() throws Throwable {
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    PropertyName propertyName0 = beanDeserializerFactory0._findImplicitParamName((AnnotatedParameter) null, annotationIntrospector0);
    assertNull(propertyName0);
}",""
"// in 2.6, remove from 2.7
@Deprecated
protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        return intr.findNameForDeserialization(param);
    }
    return null;
}","public void test1919() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    PropertyName propertyName0 = beanDeserializerFactory0._findExplicitParamName((AnnotatedParameter) null, annotationIntrospector0);
    assertNull(propertyName0);
}",""
"// in 2.6, remove from 2.7
@Deprecated
protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        return intr.findNameForDeserialization(param);
    }
    return null;
}","public void test2020() throws Throwable {
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    AnnotationMap annotationMap0 = new AnnotationMap();
    AnnotatedParameter annotatedParameter0 = new AnnotatedParameter((AnnotatedWithParams) null, (Type) null, annotationMap0, (-2));
    PropertyName propertyName0 = beanDeserializerFactory0._findExplicitParamName(annotatedParameter0, (AnnotationIntrospector) null);
    assertNull(propertyName0);
}",""
"// in 2.6, remove from 2.7
@Deprecated
protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        return intr.findNameForDeserialization(param);
    }
    return null;
}","public void test2121() throws Throwable {
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    AnnotationMap annotationMap0 = new AnnotationMap();
    AnnotatedParameter annotatedParameter0 = new AnnotatedParameter((AnnotatedWithParams) null, (Type) null, annotationMap0, (-3712));
    PropertyName propertyName0 = beanDeserializerFactory0._findExplicitParamName(annotatedParameter0, annotationIntrospector0);
    assertNull(propertyName0);
}",""
"// in 2.6, remove from 2.7
@Deprecated
protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        PropertyName n = intr.findNameForDeserialization(param);
        return (n != null) && n.hasSimpleName();
    }
    return false;
}","public void test2222() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    boolean boolean0 = beanDeserializerFactory0._hasExplicitParamName((AnnotatedParameter) null, annotationIntrospector0);
    assertFalse(boolean0);
}",""
"// in 2.6, remove from 2.7
@Deprecated
protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        PropertyName n = intr.findNameForDeserialization(param);
        return (n != null) && n.hasSimpleName();
    }
    return false;
}","public void test2323() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    AnnotationIntrospector annotationIntrospector0 = AnnotationIntrospector.nopInstance();
    AnnotationMap annotationMap0 = new AnnotationMap();
    AnnotatedParameter annotatedParameter0 = new AnnotatedParameter((AnnotatedWithParams) null, (Type) null, annotationMap0, (-3702));
    boolean boolean0 = beanDeserializerFactory0._hasExplicitParamName(annotatedParameter0, annotationIntrospector0);
    assertFalse(boolean0);
}",""
"// in 2.6, remove from 2.7
@Deprecated
protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr) {
    if (param != null && intr != null) {
        PropertyName n = intr.findNameForDeserialization(param);
        return (n != null) && n.hasSimpleName();
    }
    return false;
}","public void test2424() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    AnnotationMap annotationMap0 = new AnnotationMap();
    AnnotatedParameter annotatedParameter0 = new AnnotatedParameter((AnnotatedWithParams) null, (Type) null, annotationMap0, (-2594));
    boolean boolean0 = beanDeserializerFactory0._hasExplicitParamName(annotatedParameter0, (AnnotationIntrospector) null);
    assertFalse(boolean0);
}",""
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test2525() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    MockIOException mockIOException0 = new MockIOException();
    SQLSyntaxErrorException sQLSyntaxErrorException0 = new SQLSyntaxErrorException(""java.com.fasterxml.jackson.databind.node.BooleanNode"", mockIOException0);
    SQLWarning sQLWarning0 = new SQLWarning(""JSON"", sQLSyntaxErrorException0);
    BatchUpdateException batchUpdateException0 = new BatchUpdateException(sQLWarning0);
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(batchUpdateException0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config) {
    Class<?> collectionClass = type.getRawClass();
    collectionClass = _collectionFallbacks.get(collectionClass.getName());
    if (collectionClass == null) {
        return null;
    }
    return (CollectionType) config.constructSpecializedType(type, collectionClass);
}","public void test2626() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    JavaType javaType0 = TypeFactory.unknownType();
    CollectionType collectionType0 = beanDeserializerFactory0._mapAbstractCollectionType(javaType0, (DeserializationConfig) null);
    assertNull(collectionType0);
}",""
"// Copied almost verbatim from ""createCollectionDeserializer"" -- should try to share more code
@Override
public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException {
    JavaType contentType = type.getContentType();
    // Very first thing: is deserializer hard-coded for elements?
    JsonDeserializer<Object> contentDeser = contentType.getValueHandler();
    final DeserializationConfig config = ctxt.getConfig();
    // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:
    TypeDeserializer contentTypeDeser = contentType.getTypeHandler();
    // but if not, may still be possible to find:
    if (contentTypeDeser == null) {
        contentTypeDeser = findTypeDeserializer(config, contentType);
    }
    JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser);
    if (deser != null) {
        // and then new with 2.2: ability to post-process it too (Issue#120)
        if (_factoryConfig.hasDeserializerModifiers()) {
            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser);
            }
        }
    }
    return deser;
}","public void test2727() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ArrayList> class0 = ArrayList.class;
    CollectionType collectionType0 = typeFactory0.constructRawCollectionType(class0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.createCollectionLikeDeserializer(defaultDeserializationContext_Impl0, collectionType0, (BeanDescription) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test2929() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT;
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(objectMapper_DefaultTyping0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test3030() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT;
    objectMapper0.enableDefaultTypingAsProperty(objectMapper_DefaultTyping0, ""JSON"");
    ConcurrentHashMap<POJONode, TokenBuffer> concurrentHashMap0 = new ConcurrentHashMap<POJONode, TokenBuffer>();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(concurrentHashMap0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test3131() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT;
    ObjectMapper objectMapper1 = objectMapper0.enableDefaultTyping(objectMapper_DefaultTyping0);
    ObjectReader objectReader0 = objectMapper1.readerForUpdating(jsonFactory0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public ObjectReader forType(JavaType valueType) {
    if (valueType != null && valueType.equals(_valueType)) {
        return this;
    }
    JsonDeserializer<Object> rootDeser = _prefetchRootDeserializer(valueType);
    // type is stored here, no need to make a copy of config
    DataFormatReaders det = _dataFormatReaders;
    if (det != null) {
        det = det.withType(valueType);
    }
    return _new(this, _config, valueType, rootDeser, _valueToUpdate, _schema, _injectableValues, det);
}","public void test3232() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(beanDeserializerFactory0);
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ConcurrentHashMap> class0 = ConcurrentHashMap.class;
    Class<ConcurrentSkipListMap> class1 = ConcurrentSkipListMap.class;
    MapType mapType0 = typeFactory0.constructMapType(class1, class0, class0);
    ObjectReader objectReader1 = objectReader0.forType((JavaType) mapType0);
    assertNotSame(objectReader0, objectReader1);
}","/**
 *  Method for constructing a new reader instance that is configured
 *  to data bind into specified type.
 * <p>
 *  Note that the method does NOT change state of this reader, but
 *  rather construct and returns a newly configured instance.
 *
 *  @since 2.5
 */"
"/*
    /**********************************************************
    /* DeserializerFactory API implementation
    /**********************************************************
     */
/**
 * Method that {@link DeserializerCache}s call to create a new
 * deserializer for types other than Collections, Maps, arrays and
 * enums.
 */
@Override
public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {
    final DeserializationConfig config = ctxt.getConfig();
    // We may also have custom overrides:
    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);
    if (custom != null) {
        return custom;
    }
    /* One more thing to check: do we have an exception type
         * (Throwable or its sub-classes)? If so, need slightly
         * different handling.
         */
    if (type.isThrowable()) {
        return buildThrowableDeserializer(ctxt, type, beanDesc);
    }
    /* Or, for abstract types, may have alternate means for resolution
         * (defaulting, materialization)
         */
    if (type.isAbstract()) {
        // [JACKSON-41] (v1.6): Let's make it possible to materialize abstract types.
        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);
        if (concreteType != null) {
            /* important: introspect actual implementation (abstract class or
                 * interface doesn't have constructors, for one)
                 */
            beanDesc = config.introspect(concreteType);
            return buildBeanDeserializer(ctxt, concreteType, beanDesc);
        }
    }
    // Otherwise, may want to check handlers for standard types, from superclass:
    @SuppressWarnings(""unchecked"")
    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);
    if (deser != null) {
        return deser;
    }
    // Otherwise: could the class be a Bean class? If not, bail out
    if (!isPotentialBeanType(type.getRawClass())) {
        return null;
    }
    // Use generic bean introspection to build deserializer
    return buildBeanDeserializer(ctxt, type, beanDesc);
}","public void test3333() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    JavaType javaType0 = TypeFactory.unknownType();
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    SimpleAbstractTypeResolver simpleAbstractTypeResolver0 = new SimpleAbstractTypeResolver();
    DeserializerFactoryConfig deserializerFactoryConfig1 = deserializerFactoryConfig0.withAbstractTypeResolver(simpleAbstractTypeResolver0);
    BeanDeserializerFactory beanDeserializerFactory1 = new BeanDeserializerFactory(deserializerFactoryConfig1);
    // Undeclared exception!
    try {
        beanDeserializerFactory1.createBeanDeserializer(defaultDeserializationContext_Impl0, javaType0, (BeanDescription) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test3434() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    AtomicReference<NamedType> atomicReference0 = new AtomicReference<NamedType>((NamedType) null);
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(atomicReference0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public boolean isCachable() {
    return false;
}","public void test3535() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    JavaType javaType0 = TypeFactory.unknownType();
    Class<TokenBuffer> class0 = TokenBuffer.class;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, javaType0, (Object) beanDeserializerFactory0, (Object) beanDeserializerFactory0);
    JsonDeserializer<Object> jsonDeserializer0 = beanDeserializerFactory0.createBeanDeserializer(defaultDeserializationContext_Impl0, referenceType0, (BeanDescription) null);
    assertFalse(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"public boolean isCachable() {
    return false;
}","public void test3636() throws Throwable {
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    Deserializers.Base deserializers_Base0 = new Deserializers.Base();
    DeserializerFactoryConfig deserializerFactoryConfig1 = deserializerFactoryConfig0.withAdditionalDeserializers(deserializers_Base0);
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig1);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    JsonDeserializer<Object> jsonDeserializer0 = beanDeserializerFactory0.createBeanDeserializer(defaultDeserializationContext_Impl0, simpleType0, (BeanDescription) null);
    assertTrue(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"/*
    /**********************************************************
    /* JsonDeserializerFactory impl: Enum deserializers
    /**********************************************************
     */
/**
 * Factory method for constructing serializers of {@link Enum} types.
 */
@Override
public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {
    final DeserializationConfig config = ctxt.getConfig();
    final Class<?> enumClass = type.getRawClass();
    // 23-Nov-2010, tatu: Custom deserializer?
    JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc);
    if (deser == null) {
        // [JACKSON-193] May have @JsonCreator for static factory method:
        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {
            if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {
                int argCount = factory.getParameterCount();
                if (argCount == 1) {
                    Class<?> returnType = factory.getRawReturnType();
                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)
                    if (returnType.isAssignableFrom(enumClass)) {
                        deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory);
                        break;
                    }
                }
                throw new IllegalArgumentException(""Unsuitable method ("" + factory + "") decorated with @JsonCreator (for Enum type "" + enumClass.getName() + "")"");
            }
        }
        // [JACKSON-749] Also, need to consider @JsonValue, if one found
        if (deser == null) {
            deser = new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()));
        }
    }
    // and then new with 2.2: ability to post-process it too (Issue#120)
    if (_factoryConfig.hasDeserializerModifiers()) {
        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
            deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser);
        }
    }
    return deser;
}","public void test3737() throws Throwable {
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    Deserializers.Base deserializers_Base0 = new Deserializers.Base();
    DeserializerFactoryConfig deserializerFactoryConfig1 = deserializerFactoryConfig0.withAdditionalDeserializers(deserializers_Base0);
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig1);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.createEnumDeserializer(defaultDeserializationContext_Impl0, simpleType0, (BeanDescription) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"public boolean isCachable() {
    return false;
}","public void test3838() throws Throwable {
    SimpleType simpleType0 = (SimpleType) TypeBindings.UNBOUND;
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    Deserializers.Base deserializers_Base0 = new Deserializers.Base();
    DeserializerFactoryConfig deserializerFactoryConfig1 = deserializerFactoryConfig0.withAdditionalDeserializers(deserializers_Base0);
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig1);
    JsonDeserializer<?> jsonDeserializer0 = beanDeserializerFactory0.createTreeDeserializer((DeserializationConfig) null, simpleType0, (BeanDescription) null);
    assertTrue(jsonDeserializer0.isCachable());
}","/**
 *  Method called to see if deserializer instance is cachable and
 *  usable for other properties of same type (type for which instance
 *  was created).
 * <p>
 *  Note that cached instances are still resolved on per-property basis,
 *  if instance implements {@link com.fasterxml.jackson.databind.deser.ResolvableDeserializer}:
 *  cached instance is just as the base. This means that in most cases it is safe to
 *  cache instances; however, it only makes sense to cache instances
 *  if instantiation is expensive, or if instances are heavy-weight.
 * <p>
 *  Default implementation returns false, to indicate that no caching
 *  is done.
 */"
"protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException {
    // [JACKSON-154]: Also need to handle keyUsing, contentUsing
    if (type.isContainerType()) {
        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();
        JavaType keyType = type.getKeyType();
        if (keyType != null) {
            Object kdDef = intr.findKeyDeserializer(member);
            KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);
            if (kd != null) {
                type = ((MapLikeType) type).withKeyValueHandler(kd);
                // just in case it's used below
                keyType = type.getKeyType();
            }
        }
        // and all container types have content types...
        Object cdDef = intr.findContentDeserializer(member);
        JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);
        if (cd != null) {
            type = type.withContentValueHandler(cd);
        }
        /* 04-Feb-2010, tatu: Need to figure out JAXB annotations that indicate type
             *    information to use for polymorphic members; and specifically types for
             *    collection values (contents).
             *    ... but only applies to members (fields, methods), not classes
             */
        if (member instanceof AnnotatedMember) {
            TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member);
            if (contentTypeDeser != null) {
                type = type.withContentTypeHandler(contentTypeDeser);
            }
        }
    }
    TypeDeserializer valueTypeDeser;
    if (member instanceof AnnotatedMember) {
        // JAXB allows per-property annotations
        valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member);
    } else {
        // classes just have Jackson annotations
        // probably only occurs if 'property' is null anyway
        valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type);
    }
    if (valueTypeDeser != null) {
        type = type.withTypeHandler(valueTypeDeser);
    }
    return type;
}","public void test4040() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    Class<AnnotatedParameter> class0 = AnnotatedParameter.class;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    SimpleType simpleType0 = SimpleType.construct(class0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.resolveType(defaultDeserializationContext_Impl0, basicBeanDescription0, simpleType0, (AnnotatedMember) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}","/**
 * Helper method used to resolve method return types and field
 * types. The main trick here is that the containing bean may
 * have type variable binding information (when deserializing
 * using generic type passed as type reference), which is
 * needed in some cases.
 */"
"protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) {
    if (enumType == null) {
        return null;
    }
    BeanDescription beanDesc = config.introspect(enumType);
    return beanDesc.findJsonValueMethod();
}","public void test4141() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<LongNode> class0 = LongNode.class;
    JavaType javaType0 = typeFactory0.uncheckedSimpleType(class0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0._findJsonValueFor((DeserializationConfig) null, javaType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) {
    if (enumType == null) {
        return null;
    }
    BeanDescription beanDesc = config.introspect(enumType);
    return beanDesc.findJsonValueMethod();
}","public void test4242() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    AnnotatedMethod annotatedMethod0 = beanDeserializerFactory0._findJsonValueFor((DeserializationConfig) null, (JavaType) null);
    assertNull(annotatedMethod0);
}",""
