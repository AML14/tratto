focal_method,test_prefix,docstring
"public TypeFactory withClassLoader(ClassLoader classLoader) {
    return new TypeFactory(_parser, _modifiers, classLoader);
}","public void test000() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    typeFactory0.withClassLoader(classLoader0);
}",""
"protected JavaType _fromParamType(ClassStack context, ParameterizedType ptype, TypeBindings parentBindings) {
    // Assumption here is we'll always get Class, not one of other Types
    Class<?> rawType = (Class<?>) ptype.getRawType();
    // 29-Oct-2015, tatu: For performance reasons, let's streamline handling of
    //   couple of not-so-useful parametric types
    if (rawType == CLS_ENUM) {
        return CORE_TYPE_ENUM;
    }
    if (rawType == CLS_COMPARABLE) {
        return CORE_TYPE_COMPARABLE;
    }
    if (rawType == CLS_CLASS) {
        return CORE_TYPE_CLASS;
    }
    // First: what is the actual base type? One odd thing is that 'getRawType'
    // returns Type, not Class<?> as one might expect. But let's assume it is
    // always of type Class: if not, need to add more code to resolve it to Class.
    Type[] args = ptype.getActualTypeArguments();
    int paramCount = (args == null) ? 0 : args.length;
    JavaType[] pt;
    TypeBindings newBindings;
    if (paramCount == 0) {
        newBindings = EMPTY_BINDINGS;
    } else {
        pt = new JavaType[paramCount];
        for (int i = 0; i < paramCount; ++i) {
            pt[i] = _fromAny(context, args[i], parentBindings);
        }
        newBindings = TypeBindings.create(rawType, pt);
    }
    return _fromClass(context, rawType, newBindings);
}","public void test022() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Properties> class0 = Properties.class;
    ClassStack classStack0 = new ClassStack(class0);
    ParameterizedType parameterizedType0 = mock(ParameterizedType.class, new ViolatedAssumptionAnswer());
    doReturn((Type[]) null).when(parameterizedType0).getActualTypeArguments();
    doReturn((Type) null).when(parameterizedType0).getRawType();
    TypeBindings typeBindings0 = TypeFactory.EMPTY_BINDINGS;
    // Undeclared exception!
    try {
        typeFactory0._fromParamType(classStack0, parameterizedType0, typeBindings0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * This method deals with parameterized types, that is,
 * first class generic classes.
 */"
"public TypeFactory withModifier(TypeModifier mod) {
    if (mod == null) {
        // mostly for unit tests
        return new TypeFactory(_parser, _modifiers, _classLoader);
    }
    if (_modifiers == null) {
        return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader);
    }
    return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader);
}","public void test033() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    TypeModifier typeModifier0 = mock(TypeModifier.class, new ViolatedAssumptionAnswer());
    typeFactory0.withModifier(typeModifier0);
}",""
"public static Class<?> rawClass(Type t) {
    if (t instanceof Class<?>) {
        return (Class<?>) t;
    }
    // Should be able to optimize bit more in future...
    return defaultInstance().constructType(t).getRawClass();
}","public void test044() throws Throwable {
    TypeFactory.rawClass((Type) null);
}","/**
 * Static helper method that can be called to figure out type-erased
 * call for given JDK type. It can be called statically since type resolution
 * process can never change actual type-erased class; thereby static
 * default instance is used for determination.
 */"
"/*
    /**********************************************************
    /* Type conversion, parameterization resolution methods
    /**********************************************************
     */
/**
 * Factory method for creating a subtype of given base type, as defined
 * by specified subclass; but retaining generic type information if any.
 * Can be used, for example, to get equivalent of ""HashMap&lt;String,Integer&gt;""
 * from ""Map&lt;String,Integer&gt;"" by giving <code>HashMap.class</code>
 * as subclass.
 */
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {
    // simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == subclass) {
        return baseType;
    }
    JavaType newType;
    // also: if we start from untyped, not much to save
    do {
        // bogus loop to be able to break
        if (rawBase == Object.class) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        if (!rawBase.isAssignableFrom(subclass)) {
            throw new IllegalArgumentException(String.format(""Class %s not subtype of %s"", subclass.getName(), baseType));
        }
        // A few special cases where we can simplify handling:
        // (1) Original target type has no generics -- just resolve subtype
        if (baseType.getBindings().isEmpty()) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        // (2) A small set of ""well-known"" List/Map subtypes where can take a short-cut
        if (baseType.isContainerType()) {
            if (baseType.isMapLikeType()) {
                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {
                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));
                    break;
                }
            } else if (baseType.isCollectionLikeType()) {
                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {
                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));
                    break;
                }
                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,
                //    but they are impl details and we basically do not care...
                if (rawBase == EnumSet.class) {
                    return baseType;
                }
            }
        }
        // (3) Sub-class does not take type parameters -- just resolve subtype
        int typeParamCount = subclass.getTypeParameters().length;
        if (typeParamCount == 0) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        // If not, we'll need to do more thorough forward+backwards resolution. Sigh.
        // !!! TODO (as of 28-Jan-2016, at least)
        // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is
        //    a way to fully resolve and merge hierarchies; but that gets expensive
        //    so let's, for now, try to create close-enough approximation that
        //    is not 100% same, structurally, but has equivalent information for
        //    our specific neeeds.
        // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)
        //  for a case where this code does get invoked: not ideal
        // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but
        //  not certain it would reliably work... but let's hope for best for now
        if (baseType.isInterface()) {
            newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType });
        } else {
            newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES);
        }
        // Only SimpleType returns null, but if so just resolve regularly
        if (newType == null) {
            TypeBindings tb = null;
            if (baseType.containedTypeCount() == typeParamCount) {
                if (typeParamCount == 1) {
                    tb = TypeBindings.create(subclass, baseType.containedType(0));
                } else if (typeParamCount == 2) {
                    tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1));
                }
            }
            newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb);
        }
    } while (false);
    // except possibly handlers
    //      newType = newType.withHandlersFrom(baseType);
    return newType;
    // 20-Oct-2015, tatu: Old simplistic approach
    /*
        // Currently mostly SimpleType instances can become something else
        if (baseType instanceof SimpleType) {
            // and only if subclass is an array, Collection or Map
            if (subclass.isArray()
                || Map.class.isAssignableFrom(subclass)
                || Collection.class.isAssignableFrom(subclass)) {
                // need to assert type compatibility...
                if (!baseType.getRawClass().isAssignableFrom(subclass)) {
                    throw new IllegalArgumentException(""Class ""+subclass.getClass().getName()+"" not subtype of ""+baseType);
                }
                // this _should_ work, right?
                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());
                // one more thing: handlers to copy?
                Object h = baseType.getValueHandler();
                if (h != null) {
                    subtype = subtype.withValueHandler(h);
                }
                h = baseType.getTypeHandler();
                if (h != null) {
                    subtype = subtype.withTypeHandler(h);
                }
                return subtype;
            }
        }
        // But there is the need for special case for arrays too, it seems
        if (baseType instanceof ArrayType) {
            if (subclass.isArray()) {
                // actually see if it might be a no-op first:
                ArrayType at = (ArrayType) baseType;
                Class<?> rawComp = subclass.getComponentType();
                if (at.getContentType().getRawClass() == rawComp) {
                    return baseType;
                }
                JavaType componentType = _fromAny(null, rawComp, null);
                return ((ArrayType) baseType).withComponentType(componentType);
            }
        }

        // otherwise regular narrowing should work just fine
        return baseType.narrowBy(subclass);
        */
}","public void test055() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<EnumSet> class0 = EnumSet.class;
    CollectionType collectionType0 = typeFactory0.constructCollectionType(class0, class0);
    typeFactory0.constructSpecializedType(collectionType0, class0);
}",""
"@Deprecated
public JavaType constructType(Type type, Class<?> contextClass) {
    TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();
    return _fromAny(null, type, bindings);
}","public void test066() throws Throwable {
    Class<CollectionLikeType> class0 = CollectionLikeType.class;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.constructType((Type) class0, (Class<?>) class0);
}","/**
 * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
 */"
"protected JavaType _findWellKnownSimple(Class<?> clz) {
    if (clz.isPrimitive()) {
        if (clz == CLS_BOOL)
            return CORE_TYPE_BOOL;
        if (clz == CLS_INT)
            return CORE_TYPE_INT;
        if (clz == CLS_LONG)
            return CORE_TYPE_LONG;
    } else {
        if (clz == CLS_STRING)
            return CORE_TYPE_STRING;
        // since 2.7
        if (clz == CLS_OBJECT)
            return CORE_TYPE_OBJECT;
    }
    return null;
}","public void test088() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ObjectMapper.DefaultTyping> class0 = ObjectMapper.DefaultTyping.class;
    typeFactory0._findWellKnownSimple(class0);
}","/**
 * Helper method called to see if requested, non-generic-parameterized
 * type is one of common, ""well-known"" types, instances of which are
 * pre-constructed and do not need dynamic caching.
 *
 * @since 2.7
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test1010() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.constructFromCanonical(""com.fasterxml.jackson.databind.deser.std.NumberDeserializers$FloatDeserializer"");
    typeFactory0.findClass(""wE;eG"");
}",""
"public MapLikeType constructRawMapLikeType(Class<?> mapClass) {
    return constructMapLikeType(mapClass, unknownType(), unknownType());
}","public void test1313() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<SimpleType> class0 = SimpleType.class;
    typeFactory0.constructRawMapLikeType(class0);
}","/**
 *  Method that can be used to construct ""raw"" Map-like type; meaning that its
 *  parameterization is unknown.
 *  This is similar to using <code>Object.class</code> parameterization,
 *  and is equivalent to calling:
 * <pre>
 *   typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());
 * </pre>
 * <p>
 *  This method should only be used if parameterization is completely unavailable.
 */"
"public MapType constructRawMapType(Class<? extends Map> mapClass) {
    return constructMapType(mapClass, unknownType(), unknownType());
}","public void test1414() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Properties> class0 = Properties.class;
    // Undeclared exception!
    try {
        typeFactory0.constructRawMapType(class0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not create TypeBindings for class java.util.Properties with 2 type parameters: class expects 0
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeBindings"", e);
    }
}","/**
 *  Method that can be used to construct ""raw"" Map type; meaning that its
 *  parameterization is unknown.
 *  This is similar to using <code>Object.class</code> parameterization,
 *  and is equivalent to calling:
 * <pre>
 *   typeFactory.constructMapType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());
 * </pre>
 * <p>
 *  This method should only be used if parameterization is completely unavailable.
 */"
"public static Class<?> rawClass(Type t) {
    if (t instanceof Class<?>) {
        return (Class<?>) t;
    }
    // Should be able to optimize bit more in future...
    return defaultInstance().constructType(t).getRawClass();
}","public void test1515() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<SerializationFeature> class0 = SerializationFeature.class;
    MapLikeType mapLikeType0 = typeFactory0.constructMapLikeType(class0, class0, class0);
    TypeFactory.rawClass(mapLikeType0);
}","/**
 * Static helper method that can be called to figure out type-erased
 * call for given JDK type. It can be called statically since type resolution
 * process can never change actual type-erased class; thereby static
 * default instance is used for determination.
 */"
"/*
    /**********************************************************
    /* Static methods for non-instance-specific functionality
    /**********************************************************
     */
/**
 * Method for constructing a marker type that indicates missing generic
 * type information, which is handled same as simple type for
 * <code>java.lang.Object</code>.
 */
public static JavaType unknownType() {
    return defaultInstance()._unknownType();
}","public void test1616() throws Throwable {
    TypeFactory.defaultInstance();
    TypeFactory.unknownType();
}",""
"public JavaType constructReferenceType(Class<?> rawType, JavaType referredType) {
    return // no bindings
    ReferenceType.// no bindings
    construct(// no bindings
    rawType, // no bindings
    null, // or super-class, interfaces?
    null, // or super-class, interfaces?
    null, referredType);
}","public void test1717() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<MapLikeType> class0 = MapLikeType.class;
    Class<ReferenceType> class1 = ReferenceType.class;
    typeFactory0._findWellKnownSimple(class1);
    // Undeclared exception!
    try {
        typeFactory0.constructReferenceType(class0, (JavaType) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.type.ReferenceType"", e);
    }
}","/**
 * @since 2.6
 */"
"public JavaType constructType(TypeReference<?> typeRef) {
    // 19-Oct-2015, tatu: Simpler variant like so should work
    return _fromAny(null, typeRef.getType(), EMPTY_BINDINGS);
    // but if not, due to funky sub-classing, type variables, what follows
    // is a more complete processing a la Java ClassMate.
    /*
        final Class<?> refdRawType = typeRef.getClass();
        JavaType type = _fromClass(null, refdRawType, EMPTY_BINDINGS);
        JavaType genType = type.findSuperType(TypeReference.class);
        if (genType == null) { // sanity check; shouldn't occur
            throw new IllegalArgumentException(""Unparameterized GenericType instance (""+refdRawType.getName()+"")"");
        }
        TypeBindings b = genType.getBindings();
        JavaType[] params = b.typeParameterArray();
        if (params.length == 0) {
            throw new IllegalArgumentException(""Unparameterized GenericType instance (""+refdRawType.getName()+"")"");
        }
        return params[0];
        */
}","public void test1818() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.constructType((TypeReference<?>) null);
}",""
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test1919() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.findClass(""mJM~ayZ9M(}d3"");
}",""
"public JavaType uncheckedSimpleType(Class<?> cls) {
    // 18-Oct-2015, tatu: Not sure how much problem missing super-type info is here
    return _constructSimple(cls, EMPTY_BINDINGS, null, null);
}","public void test2323() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<String> class0 = String.class;
    typeFactory0.uncheckedSimpleType(class0);
}","/**
 *  Method that will force construction of a simple type, without trying to
 *  check for more specialized types.
 * <p>
 *  NOTE: no type modifiers are called on type either, so calling this method
 *  should only be used if caller really knows what it's doing...
 */"
"public JavaType moreSpecificType(JavaType type1, JavaType type2) {
    if (type1 == null) {
        return type2;
    }
    if (type2 == null) {
        return type1;
    }
    Class<?> raw1 = type1.getRawClass();
    Class<?> raw2 = type2.getRawClass();
    if (raw1 == raw2) {
        return type1;
    }
    // TODO: maybe try sub-classing, to retain generic types?
    if (raw1.isAssignableFrom(raw2)) {
        return type2;
    }
    return type1;
}","public void test2424() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<EnumSet> class0 = EnumSet.class;
    CollectionType collectionType0 = typeFactory0.constructRawCollectionType(class0);
    typeFactory0.moreSpecificType(collectionType0, collectionType0);
}","/**
 * Method that can be called to figure out more specific of two
 * types (if they are related; that is, one implements or extends the
 * other); or if not related, return the primary type.
 *
 * @param type1 Primary type to consider
 * @param type2 Secondary type to consider
 *
 * @since 2.2
 */"
"public void clearCache() {
    _typeCache.clear();
}","public void test2525() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.clearCache();
}","/**
 * Method that will clear up any cached type definitions that may
 * be cached by this {@link TypeFactory} instance.
 * This method should not be commonly used, that is, only use it
 * if you know there is a problem with retention of type definitions;
 * the most likely (and currently only known) problem is retention
 * of {@link Class} instances via {@link JavaType} reference.
 *
 * @since 2.4.1
 */"
"public JavaType moreSpecificType(JavaType type1, JavaType type2) {
    if (type1 == null) {
        return type2;
    }
    if (type2 == null) {
        return type1;
    }
    Class<?> raw1 = type1.getRawClass();
    Class<?> raw2 = type2.getRawClass();
    if (raw1 == raw2) {
        return type1;
    }
    // TODO: maybe try sub-classing, to retain generic types?
    if (raw1.isAssignableFrom(raw2)) {
        return type2;
    }
    return type1;
}","public void test2626() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ArrayType arrayType0 = typeFactory0.constructArrayType((JavaType) null);
    // Undeclared exception!
    try {
        typeFactory0.moreSpecificType(arrayType0, arrayType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.type.ArrayType"", e);
    }
}","/**
 * Method that can be called to figure out more specific of two
 * types (if they are related; that is, one implements or extends the
 * other); or if not related, return the primary type.
 *
 * @param type1 Primary type to consider
 * @param type2 Secondary type to consider
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test2828() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_ENUM;
    typeFactory0.constructType((Type) simpleType0, (JavaType) simpleType0);
    typeFactory0.findClass(""[value=%sdcontent=%s]"");
}",""
"public static Class<?> rawClass(Type t) {
    if (t instanceof Class<?>) {
        return (Class<?>) t;
    }
    // Should be able to optimize bit more in future...
    return defaultInstance().constructType(t).getRawClass();
}","public void test2929() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    TypeFactory.rawClass(simpleType0);
}","/**
 * Static helper method that can be called to figure out type-erased
 * call for given JDK type. It can be called statically since type resolution
 * process can never change actual type-erased class; thereby static
 * default instance is used for determination.
 */"
"public JavaType uncheckedSimpleType(Class<?> cls) {
    // 18-Oct-2015, tatu: Not sure how much problem missing super-type info is here
    return _constructSimple(cls, EMPTY_BINDINGS, null, null);
}","public void test3030() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ArrayType> class0 = ArrayType.class;
    TypeBindings typeBindings0 = TypeFactory.EMPTY_BINDINGS;
    typeFactory0.findTypeParameters(class0, class0, typeBindings0);
    Class<MapperFeature> class1 = MapperFeature.class;
    typeFactory0.uncheckedSimpleType(class1);
}","/**
 *  Method that will force construction of a simple type, without trying to
 *  check for more specialized types.
 * <p>
 *  NOTE: no type modifiers are called on type either, so calling this method
 *  should only be used if caller really knows what it's doing...
 */"
"public JavaType[] findTypeParameters(JavaType type, Class<?> expType) {
    JavaType match = type.findSuperType(expType);
    if (match == null) {
        return NO_TYPES;
    }
    return match.getBindings().typeParameterArray();
}","public void test3131() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_COMPARABLE;
    Class<DeserializationFeature> class0 = DeserializationFeature.class;
    typeFactory0.findTypeParameters((JavaType) simpleType0, (Class<?>) class0);
}","/**
 * Method that is to figure out actual type parameters that given
 * class binds to generic types defined by given (generic)
 * interface or class.
 * This could mean, for example, trying to figure out
 * key and value types for Map implementations.
 *
 * @param type Sub-type (leaf type) that implements <code>expType</code>
 */"
"public JavaType uncheckedSimpleType(Class<?> cls) {
    // 18-Oct-2015, tatu: Not sure how much problem missing super-type info is here
    return _constructSimple(cls, EMPTY_BINDINGS, null, null);
}","public void test3232() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<SerializationFeature> class0 = SerializationFeature.class;
    typeFactory0.uncheckedSimpleType(class0);
}","/**
 *  Method that will force construction of a simple type, without trying to
 *  check for more specialized types.
 * <p>
 *  NOTE: no type modifiers are called on type either, so calling this method
 *  should only be used if caller really knows what it's doing...
 */"
"public JavaType moreSpecificType(JavaType type1, JavaType type2) {
    if (type1 == null) {
        return type2;
    }
    if (type2 == null) {
        return type1;
    }
    Class<?> raw1 = type1.getRawClass();
    Class<?> raw2 = type2.getRawClass();
    if (raw1 == raw2) {
        return type1;
    }
    // TODO: maybe try sub-classing, to retain generic types?
    if (raw1.isAssignableFrom(raw2)) {
        return type2;
    }
    return type1;
}","public void test4141() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.moreSpecificType((JavaType) null, (JavaType) null);
}","/**
 * Method that can be called to figure out more specific of two
 * types (if they are related; that is, one implements or extends the
 * other); or if not related, return the primary type.
 *
 * @param type1 Primary type to consider
 * @param type2 Secondary type to consider
 *
 * @since 2.2
 */"
"public TypeFactory withModifier(TypeModifier mod) {
    if (mod == null) {
        // mostly for unit tests
        return new TypeFactory(_parser, _modifiers, _classLoader);
    }
    if (_modifiers == null) {
        return new TypeFactory(_parser, new TypeModifier[] { mod }, _classLoader);
    }
    return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod), _classLoader);
}","public void test4242() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.withModifier((TypeModifier) null);
}",""
"// But otherwise gets bit tricky, as we need to partially resolve the type hierarchy
// (hopefully passing null Class for root is ok)
// Otherwise, two choices: match N first, or empty. Do latter, for now
/**
 * Method similar to {@link #constructSpecializedType}, but that creates a
 * less-specific type of given type. Usually this is as simple as simply
 * finding super-type with type erasure of <code>superClass</code>, but
 * there may be need for some additional work-arounds.
 *
 * @param superClass
 *
 * @since 2.7
 */
public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) {
    // simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == superClass) {
        return baseType;
    }
    JavaType superType = baseType.findSuperType(superClass);
    if (superType == null) {
        // Most likely, caller did not verify sub/super-type relationship
        if (!superClass.isAssignableFrom(rawBase)) {
            throw new IllegalArgumentException(String.format(""Class %s not a super-type of %s"", superClass.getName(), baseType));
        }
        // 01-Nov-2015, tatu: Should never happen, but ch
        throw new IllegalArgumentException(String.format(""Internal error: class %s not included as super-type for %s"", superClass.getName(), baseType));
    }
    return superType;
}","public void test4444() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<RuntimeException> class0 = RuntimeException.class;
    JavaType javaType0 = typeFactory0._unknownType();
    // Undeclared exception!
    try {
        typeFactory0.constructGeneralizedType(javaType0, class0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Class java.lang.RuntimeException not a super-type of [simple type, class java.lang.Object]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}",""
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test4646() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.findClass(""float"");
}",""
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test4747() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    typeFactory0.findClass(""char"");
}",""
"public JavaType moreSpecificType(JavaType type1, JavaType type2) {
    if (type1 == null) {
        return type2;
    }
    if (type2 == null) {
        return type1;
    }
    Class<?> raw1 = type1.getRawClass();
    Class<?> raw2 = type2.getRawClass();
    if (raw1 == raw2) {
        return type1;
    }
    // TODO: maybe try sub-classing, to retain generic types?
    if (raw1.isAssignableFrom(raw2)) {
        return type2;
    }
    return type1;
}","public void test5151() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    typeFactory0.moreSpecificType(simpleType0, simpleType0);
}","/**
 * Method that can be called to figure out more specific of two
 * types (if they are related; that is, one implements or extends the
 * other); or if not related, return the primary type.
 *
 * @param type1 Primary type to consider
 * @param type2 Secondary type to consider
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test5353() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.findClass(""short"");
}",""
"// But otherwise gets bit tricky, as we need to partially resolve the type hierarchy
// (hopefully passing null Class for root is ok)
// Otherwise, two choices: match N first, or empty. Do latter, for now
/**
 * Method similar to {@link #constructSpecializedType}, but that creates a
 * less-specific type of given type. Usually this is as simple as simply
 * finding super-type with type erasure of <code>superClass</code>, but
 * there may be need for some additional work-arounds.
 *
 * @param superClass
 *
 * @since 2.7
 */
public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) {
    // simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == superClass) {
        return baseType;
    }
    JavaType superType = baseType.findSuperType(superClass);
    if (superType == null) {
        // Most likely, caller did not verify sub/super-type relationship
        if (!superClass.isAssignableFrom(rawBase)) {
            throw new IllegalArgumentException(String.format(""Class %s not a super-type of %s"", superClass.getName(), baseType));
        }
        // 01-Nov-2015, tatu: Should never happen, but ch
        throw new IllegalArgumentException(String.format(""Internal error: class %s not included as super-type for %s"", superClass.getName(), baseType));
    }
    return superType;
}","public void test5454() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ObjectMapper.DefaultTyping> class0 = ObjectMapper.DefaultTyping.class;
    Class<MapLikeType> class1 = MapLikeType.class;
    Class<SerializationFeature> class2 = SerializationFeature.class;
    MapLikeType mapLikeType0 = typeFactory0.constructMapLikeType(class0, class1, class2);
    FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
    typeFactory0.moreSpecificType(mapLikeType0, mapLikeType0);
    Class<HashSet> class3 = HashSet.class;
    typeFactory0.constructCollectionType(class3, class2);
    Class<Object> class4 = Object.class;
    typeFactory0.constructGeneralizedType(mapLikeType0, class4);
}",""
"public JavaType moreSpecificType(JavaType type1, JavaType type2) {
    if (type1 == null) {
        return type2;
    }
    if (type2 == null) {
        return type1;
    }
    Class<?> raw1 = type1.getRawClass();
    Class<?> raw2 = type2.getRawClass();
    if (raw1 == raw2) {
        return type1;
    }
    // TODO: maybe try sub-classing, to retain generic types?
    if (raw1.isAssignableFrom(raw2)) {
        return type2;
    }
    return type1;
}","public void test5555() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<DeserializationFeature> class0 = DeserializationFeature.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    typeFactory0.moreSpecificType(collectionLikeType0, collectionLikeType0);
}","/**
 * Method that can be called to figure out more specific of two
 * types (if they are related; that is, one implements or extends the
 * other); or if not related, return the primary type.
 *
 * @param type1 Primary type to consider
 * @param type2 Secondary type to consider
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test5656() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.findClass(""Tnh>^XldB5.V~+;f!_P"");
}",""
"// But otherwise gets bit tricky, as we need to partially resolve the type hierarchy
// (hopefully passing null Class for root is ok)
// Otherwise, two choices: match N first, or empty. Do latter, for now
/**
 * Method similar to {@link #constructSpecializedType}, but that creates a
 * less-specific type of given type. Usually this is as simple as simply
 * finding super-type with type erasure of <code>superClass</code>, but
 * there may be need for some additional work-arounds.
 *
 * @param superClass
 *
 * @since 2.7
 */
public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) {
    // simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == superClass) {
        return baseType;
    }
    JavaType superType = baseType.findSuperType(superClass);
    if (superType == null) {
        // Most likely, caller did not verify sub/super-type relationship
        if (!superClass.isAssignableFrom(rawBase)) {
            throw new IllegalArgumentException(String.format(""Class %s not a super-type of %s"", superClass.getName(), baseType));
        }
        // 01-Nov-2015, tatu: Should never happen, but ch
        throw new IllegalArgumentException(String.format(""Internal error: class %s not included as super-type for %s"", superClass.getName(), baseType));
    }
    return superType;
}","public void test5858() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    TypeParser typeParser0 = new TypeParser(typeFactory0);
    Class<ArrayList> class0 = ArrayList.class;
    CollectionType collectionType0 = typeFactory0.constructRawCollectionType(class0);
    TypeParser typeParser1 = new TypeParser(typeFactory0);
    typeFactory0.constructType((Type) collectionType0, (TypeBindings) null);
    Class<HashSet> class1 = HashSet.class;
    typeFactory0.constructCollectionType(class0, class0);
    JsonFactory jsonFactory0 = new JsonFactory();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl1 = new DefaultSerializerProvider.Impl(defaultSerializerProvider_Impl0);
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0, defaultSerializerProvider_Impl1, defaultDeserializationContext_Impl0);
    ObjectMapper objectMapper1 = objectMapper0.setSerializerProvider((DefaultSerializerProvider) null);
    ObjectReader objectReader0 = objectMapper1.readerFor(class0);
    TypeFactory typeFactory1 = objectReader0.getTypeFactory();
    CollectionType collectionType1 = typeFactory1.constructCollectionType(class1, class0);
    Class<Object> class2 = Object.class;
    typeFactory0.constructGeneralizedType(collectionType1, class2);
}",""
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test5959() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    typeFactory0.findClass(""int"");
}",""
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test6060() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    TypeFactory typeFactory1 = typeFactory0.withClassLoader(classLoader0);
    typeFactory1.findClass(""s`["");
}",""
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test6161() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.findClass(""void"");
}",""
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test6262() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.findClass(""byte"");
}",""
"/*
    /**********************************************************
    /* Type conversion, parameterization resolution methods
    /**********************************************************
     */
/**
 * Factory method for creating a subtype of given base type, as defined
 * by specified subclass; but retaining generic type information if any.
 * Can be used, for example, to get equivalent of ""HashMap&lt;String,Integer&gt;""
 * from ""Map&lt;String,Integer&gt;"" by giving <code>HashMap.class</code>
 * as subclass.
 */
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {
    // simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == subclass) {
        return baseType;
    }
    JavaType newType;
    // also: if we start from untyped, not much to save
    do {
        // bogus loop to be able to break
        if (rawBase == Object.class) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        if (!rawBase.isAssignableFrom(subclass)) {
            throw new IllegalArgumentException(String.format(""Class %s not subtype of %s"", subclass.getName(), baseType));
        }
        // A few special cases where we can simplify handling:
        // (1) Original target type has no generics -- just resolve subtype
        if (baseType.getBindings().isEmpty()) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        // (2) A small set of ""well-known"" List/Map subtypes where can take a short-cut
        if (baseType.isContainerType()) {
            if (baseType.isMapLikeType()) {
                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {
                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));
                    break;
                }
            } else if (baseType.isCollectionLikeType()) {
                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {
                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));
                    break;
                }
                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,
                //    but they are impl details and we basically do not care...
                if (rawBase == EnumSet.class) {
                    return baseType;
                }
            }
        }
        // (3) Sub-class does not take type parameters -- just resolve subtype
        int typeParamCount = subclass.getTypeParameters().length;
        if (typeParamCount == 0) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        // If not, we'll need to do more thorough forward+backwards resolution. Sigh.
        // !!! TODO (as of 28-Jan-2016, at least)
        // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is
        //    a way to fully resolve and merge hierarchies; but that gets expensive
        //    so let's, for now, try to create close-enough approximation that
        //    is not 100% same, structurally, but has equivalent information for
        //    our specific neeeds.
        // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)
        //  for a case where this code does get invoked: not ideal
        // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but
        //  not certain it would reliably work... but let's hope for best for now
        if (baseType.isInterface()) {
            newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType });
        } else {
            newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES);
        }
        // Only SimpleType returns null, but if so just resolve regularly
        if (newType == null) {
            TypeBindings tb = null;
            if (baseType.containedTypeCount() == typeParamCount) {
                if (typeParamCount == 1) {
                    tb = TypeBindings.create(subclass, baseType.containedType(0));
                } else if (typeParamCount == 2) {
                    tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1));
                }
            }
            newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb);
        }
    } while (false);
    // except possibly handlers
    //      newType = newType.withHandlersFrom(baseType);
    return newType;
    // 20-Oct-2015, tatu: Old simplistic approach
    /*
        // Currently mostly SimpleType instances can become something else
        if (baseType instanceof SimpleType) {
            // and only if subclass is an array, Collection or Map
            if (subclass.isArray()
                || Map.class.isAssignableFrom(subclass)
                || Collection.class.isAssignableFrom(subclass)) {
                // need to assert type compatibility...
                if (!baseType.getRawClass().isAssignableFrom(subclass)) {
                    throw new IllegalArgumentException(""Class ""+subclass.getClass().getName()+"" not subtype of ""+baseType);
                }
                // this _should_ work, right?
                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());
                // one more thing: handlers to copy?
                Object h = baseType.getValueHandler();
                if (h != null) {
                    subtype = subtype.withValueHandler(h);
                }
                h = baseType.getTypeHandler();
                if (h != null) {
                    subtype = subtype.withTypeHandler(h);
                }
                return subtype;
            }
        }
        // But there is the need for special case for arrays too, it seems
        if (baseType instanceof ArrayType) {
            if (subclass.isArray()) {
                // actually see if it might be a no-op first:
                ArrayType at = (ArrayType) baseType;
                Class<?> rawComp = subclass.getComponentType();
                if (at.getContentType().getRawClass() == rawComp) {
                    return baseType;
                }
                JavaType componentType = _fromAny(null, rawComp, null);
                return ((ArrayType) baseType).withComponentType(componentType);
            }
        }

        // otherwise regular narrowing should work just fine
        return baseType.narrowBy(subclass);
        */
}","public void test6363() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_INT;
    Class<AnnotationIntrospector.ReferenceProperty.Type> class0 = AnnotationIntrospector.ReferenceProperty.Type.class;
    // Undeclared exception!
    try {
        typeFactory0.constructSpecializedType(simpleType0, class0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Class com.fasterxml.jackson.databind.AnnotationIntrospector$ReferenceProperty$Type not subtype of [simple type, class int]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}",""
"public static Class<?> rawClass(Type t) {
    if (t instanceof Class<?>) {
        return (Class<?>) t;
    }
    // Should be able to optimize bit more in future...
    return defaultInstance().constructType(t).getRawClass();
}","public void test6565() throws Throwable {
    Class<LinkedList> class0 = LinkedList.class;
    TypeFactory.rawClass(class0);
}","/**
 * Static helper method that can be called to figure out type-erased
 * call for given JDK type. It can be called statically since type resolution
 * process can never change actual type-erased class; thereby static
 * default instance is used for determination.
 */"
"public JavaType moreSpecificType(JavaType type1, JavaType type2) {
    if (type1 == null) {
        return type2;
    }
    if (type2 == null) {
        return type1;
    }
    Class<?> raw1 = type1.getRawClass();
    Class<?> raw2 = type2.getRawClass();
    if (raw1 == raw2) {
        return type1;
    }
    // TODO: maybe try sub-classing, to retain generic types?
    if (raw1.isAssignableFrom(raw2)) {
        return type2;
    }
    return type1;
}","public void test6666() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<CollectionLikeType> class0 = CollectionLikeType.class;
    TypeBindings typeBindings0 = TypeFactory.EMPTY_BINDINGS;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_COMPARABLE;
    JavaType[] javaTypeArray0 = new JavaType[0];
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, typeBindings0, (JavaType) simpleType0, javaTypeArray0, (JavaType) simpleType0);
    typeFactory0.moreSpecificType(referenceType0, simpleType0);
}","/**
 * Method that can be called to figure out more specific of two
 * types (if they are related; that is, one implements or extends the
 * other); or if not related, return the primary type.
 *
 * @param type1 Primary type to consider
 * @param type2 Secondary type to consider
 *
 * @since 2.2
 */"
"// But otherwise gets bit tricky, as we need to partially resolve the type hierarchy
// (hopefully passing null Class for root is ok)
// Otherwise, two choices: match N first, or empty. Do latter, for now
/**
 * Method similar to {@link #constructSpecializedType}, but that creates a
 * less-specific type of given type. Usually this is as simple as simply
 * finding super-type with type erasure of <code>superClass</code>, but
 * there may be need for some additional work-arounds.
 *
 * @param superClass
 *
 * @since 2.7
 */
public JavaType constructGeneralizedType(JavaType baseType, Class<?> superClass) {
    // simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == superClass) {
        return baseType;
    }
    JavaType superType = baseType.findSuperType(superClass);
    if (superType == null) {
        // Most likely, caller did not verify sub/super-type relationship
        if (!superClass.isAssignableFrom(rawBase)) {
            throw new IllegalArgumentException(String.format(""Class %s not a super-type of %s"", superClass.getName(), baseType));
        }
        // 01-Nov-2015, tatu: Should never happen, but ch
        throw new IllegalArgumentException(String.format(""Internal error: class %s not included as super-type for %s"", superClass.getName(), baseType));
    }
    return superType;
}","public void test6767() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<LinkedList> class0 = LinkedList.class;
    CollectionType collectionType0 = typeFactory0.constructCollectionType(class0, class0);
    typeFactory0.constructGeneralizedType(collectionType0, class0);
}",""
"public JavaType moreSpecificType(JavaType type1, JavaType type2) {
    if (type1 == null) {
        return type2;
    }
    if (type2 == null) {
        return type1;
    }
    Class<?> raw1 = type1.getRawClass();
    Class<?> raw2 = type2.getRawClass();
    if (raw1 == raw2) {
        return type1;
    }
    // TODO: maybe try sub-classing, to retain generic types?
    if (raw1.isAssignableFrom(raw2)) {
        return type2;
    }
    return type1;
}","public void test6868() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_LONG;
    typeFactory0.moreSpecificType(simpleType0, (JavaType) null);
}","/**
 * Method that can be called to figure out more specific of two
 * types (if they are related; that is, one implements or extends the
 * other); or if not related, return the primary type.
 *
 * @param type1 Primary type to consider
 * @param type2 Secondary type to consider
 *
 * @since 2.2
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test7171() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<ArrayType> class0 = ArrayType.class;
    JavaType javaType0 = TypeBase._bogusSuperClass(class0);
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_COMPARABLE;
    MapType mapType0 = new MapType(simpleType0, simpleType0, simpleType0);
    MapType mapType1 = mapType0.withKeyType(simpleType0);
    MapType mapType2 = mapType1.withTypeHandler(javaType0);
    typeFactory0.moreSpecificType(javaType0, mapType2);
    typeFactory0.findClass(""K_:"");
}",""
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test7272() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    typeFactory0.findClass(""double"");
}",""
"/*
    /**********************************************************
    /* Type conversion, parameterization resolution methods
    /**********************************************************
     */
/**
 * Factory method for creating a subtype of given base type, as defined
 * by specified subclass; but retaining generic type information if any.
 * Can be used, for example, to get equivalent of ""HashMap&lt;String,Integer&gt;""
 * from ""Map&lt;String,Integer&gt;"" by giving <code>HashMap.class</code>
 * as subclass.
 */
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {
    // simple optimization to avoid costly introspection if type-erased type does NOT differ
    final Class<?> rawBase = baseType.getRawClass();
    if (rawBase == subclass) {
        return baseType;
    }
    JavaType newType;
    // also: if we start from untyped, not much to save
    do {
        // bogus loop to be able to break
        if (rawBase == Object.class) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        if (!rawBase.isAssignableFrom(subclass)) {
            throw new IllegalArgumentException(String.format(""Class %s not subtype of %s"", subclass.getName(), baseType));
        }
        // A few special cases where we can simplify handling:
        // (1) Original target type has no generics -- just resolve subtype
        if (baseType.getBindings().isEmpty()) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        // (2) A small set of ""well-known"" List/Map subtypes where can take a short-cut
        if (baseType.isContainerType()) {
            if (baseType.isMapLikeType()) {
                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {
                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));
                    break;
                }
            } else if (baseType.isCollectionLikeType()) {
                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {
                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));
                    break;
                }
                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,
                //    but they are impl details and we basically do not care...
                if (rawBase == EnumSet.class) {
                    return baseType;
                }
            }
        }
        // (3) Sub-class does not take type parameters -- just resolve subtype
        int typeParamCount = subclass.getTypeParameters().length;
        if (typeParamCount == 0) {
            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
            break;
        }
        // If not, we'll need to do more thorough forward+backwards resolution. Sigh.
        // !!! TODO (as of 28-Jan-2016, at least)
        // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is
        //    a way to fully resolve and merge hierarchies; but that gets expensive
        //    so let's, for now, try to create close-enough approximation that
        //    is not 100% same, structurally, but has equivalent information for
        //    our specific neeeds.
        // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)
        //  for a case where this code does get invoked: not ideal
        // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but
        //  not certain it would reliably work... but let's hope for best for now
        if (baseType.isInterface()) {
            newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType });
        } else {
            newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES);
        }
        // Only SimpleType returns null, but if so just resolve regularly
        if (newType == null) {
            TypeBindings tb = null;
            if (baseType.containedTypeCount() == typeParamCount) {
                if (typeParamCount == 1) {
                    tb = TypeBindings.create(subclass, baseType.containedType(0));
                } else if (typeParamCount == 2) {
                    tb = TypeBindings.create(subclass, baseType.containedType(0), baseType.containedType(1));
                }
            }
            newType = _fromClass(null, subclass, (tb == null) ? TypeBindings.emptyBindings() : tb);
        }
    } while (false);
    // except possibly handlers
    //      newType = newType.withHandlersFrom(baseType);
    return newType;
    // 20-Oct-2015, tatu: Old simplistic approach
    /*
        // Currently mostly SimpleType instances can become something else
        if (baseType instanceof SimpleType) {
            // and only if subclass is an array, Collection or Map
            if (subclass.isArray()
                || Map.class.isAssignableFrom(subclass)
                || Collection.class.isAssignableFrom(subclass)) {
                // need to assert type compatibility...
                if (!baseType.getRawClass().isAssignableFrom(subclass)) {
                    throw new IllegalArgumentException(""Class ""+subclass.getClass().getName()+"" not subtype of ""+baseType);
                }
                // this _should_ work, right?
                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());
                // one more thing: handlers to copy?
                Object h = baseType.getValueHandler();
                if (h != null) {
                    subtype = subtype.withValueHandler(h);
                }
                h = baseType.getTypeHandler();
                if (h != null) {
                    subtype = subtype.withTypeHandler(h);
                }
                return subtype;
            }
        }
        // But there is the need for special case for arrays too, it seems
        if (baseType instanceof ArrayType) {
            if (subclass.isArray()) {
                // actually see if it might be a no-op first:
                ArrayType at = (ArrayType) baseType;
                Class<?> rawComp = subclass.getComponentType();
                if (at.getContentType().getRawClass() == rawComp) {
                    return baseType;
                }
                JavaType componentType = _fromAny(null, rawComp, null);
                return ((ArrayType) baseType).withComponentType(componentType);
            }
        }

        // otherwise regular narrowing should work just fine
        return baseType.narrowBy(subclass);
        */
}","public void test7373() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    simpleType0.toString();
    Class<MapType> class0 = MapType.class;
    typeFactory0.constructSpecializedType(simpleType0, class0);
}",""
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test7474() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.findClass(""long"");
}",""
"@SuppressWarnings(""resource"")
public String writeValueAsString(Object value) throws JsonProcessingException {
    // alas, we have to pull the recycler directly here...
    SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());
    try {
        _configAndWriteValue(_jsonFactory.createGenerator(sw), value);
    } catch (JsonProcessingException e) {
        // to support [JACKSON-758]
        throw e;
    } catch (IOException e) {
        // shouldn't really happen, but is declared as possibility so:
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    return sw.getAndClear();
}","public void test7575() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Integer> class0 = Integer.TYPE;
    Class<ArrayList> class1 = ArrayList.class;
    typeFactory0.constructRawCollectionType(class1);
    JsonFactory jsonFactory0 = new JsonFactory();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0, defaultSerializerProvider_Impl0, defaultDeserializationContext_Impl0);
    try {
        objectMapper0.writeValueAsString(defaultDeserializationContext_Impl0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // (was java.lang.NullPointerException) (through reference chain: com.fasterxml.jackson.databind.deser.Impl[\""base64Variant\""])
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Method that can be used to serialize any Java value as
 *  a String. Functionally equivalent to calling
 *  {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}
 *  and constructing String, but more efficient.
 * <p>
 *  Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
 */"
"@Deprecated
public JavaType constructType(Type type, JavaType contextType) {
    TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings();
    return _fromAny(null, type, bindings);
}","public void test7878() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    JavaType javaType0 = null;
    // Undeclared exception!
    try {
        typeFactory0.constructType((Type) null, (JavaType) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unrecognized Type: [null]
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeFactory"", e);
    }
}","/**
 * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)
 */"
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test7979() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Integer> class0 = Integer.TYPE;
    Class<ArrayList> class1 = ArrayList.class;
    CollectionType collectionType0 = typeFactory0.constructRawCollectionType(class1);
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    TypeParser typeParser0 = new TypeParser(typeFactory0);
    TypeParser typeParser1 = typeParser0.withFactory(typeFactory0);
    TypeModifier[] typeModifierArray0 = new TypeModifier[9];
    TypeModifier typeModifier0 = mock(TypeModifier.class, new ViolatedAssumptionAnswer());
    typeModifierArray0[0] = typeModifier0;
    typeModifierArray0[1] = typeModifier0;
    typeModifierArray0[2] = typeModifier0;
    typeModifierArray0[3] = typeModifier0;
    typeModifierArray0[4] = typeModifier0;
    typeModifierArray0[5] = typeModifier0;
    typeModifierArray0[6] = typeModifier0;
    typeModifierArray0[7] = typeModifier0;
    typeModifierArray0[8] = typeModifier0;
    TypeFactory typeFactory1 = new TypeFactory(typeParser1, typeModifierArray0);
    JavaType[] javaTypeArray0 = new JavaType[0];
    JavaType javaType0 = typeFactory1.constructParametricType(class0, javaTypeArray0);
    Class<ObjectMapper.DefaultTyping> class2 = ObjectMapper.DefaultTyping.class;
    TypeBindings typeBindings0 = TypeBindings.create(class1, javaType0);
    typeFactory0._constructSimple(class2, typeBindings0, collectionType0, javaTypeArray0);
    typeFactory0.findClass("""");
}",""
"public static TypeBindings create(Class<?> erasedType, JavaType typeArg1, JavaType typeArg2) {
    // 30-Oct-2015, tatu: Minor optimization for relatively common cases
    TypeVariable<?>[] vars = TypeParamStash.paramsFor2(erasedType);
    int varLen = (vars == null) ? 0 : vars.length;
    if (varLen != 2) {
        throw new IllegalArgumentException(""Can not create TypeBindings for class "" + erasedType.getName() + "" with 2 type parameters: class expects "" + varLen);
    }
    return new TypeBindings(new String[] { vars[0].getName(), vars[1].getName() }, new JavaType[] { typeArg1, typeArg2 }, null);
}","public void test8080() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.instance;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_ENUM;
    Class<MapperFeature> class0 = MapperFeature.class;
    JavaType javaType0 = typeFactory0.constructSpecializedType(simpleType0, class0);
    // Undeclared exception!
    try {
        TypeBindings.create(class0, javaType0, javaType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not create TypeBindings for class com.fasterxml.jackson.databind.MapperFeature with 2 type parameters: class expects 0
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeBindings"", e);
    }
}",""
"/*
    /**********************************************************
    /* Low-level helper methods
    /**********************************************************
     */
/**
 * Low-level lookup method moved from {@link com.fasterxml.jackson.databind.util.ClassUtil},
 * to allow for overriding of lookup functionality in environments like OSGi.
 *
 * @since 2.6
 */
public Class<?> findClass(String className) throws ClassNotFoundException {
    if (className.indexOf('.') < 0) {
        Class<?> prim = _findPrimitive(className);
        if (prim != null) {
            return prim;
        }
    }
    // Two-phase lookup: first using context ClassLoader; then default
    Throwable prob = null;
    ClassLoader loader = this.getClassLoader();
    if (loader == null) {
        loader = Thread.currentThread().getContextClassLoader();
    }
    if (loader != null) {
        try {
            return classForName(className, true, loader);
        } catch (Exception e) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    try {
        return classForName(className);
    } catch (Exception e) {
        if (prob == null) {
            prob = ClassUtil.getRootCause(e);
        }
    }
    if (prob instanceof RuntimeException) {
        throw (RuntimeException) prob;
    }
    throw new ClassNotFoundException(prob.getMessage(), prob);
}","public void test8181() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    typeFactory0.findClass(""boolean"");
}",""
