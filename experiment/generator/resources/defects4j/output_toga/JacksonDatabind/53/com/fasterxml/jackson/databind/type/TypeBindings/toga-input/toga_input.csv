focal_method,test_prefix,docstring
"@Override
public JavaType[] findTypeParameters(Class<?> expType) {
    JavaType match = findSuperType(expType);
    if (match == null) {
        return NO_TYPES;
    }
    return match.getBindings().typeParameterArray();
}","public void test011() throws Throwable {
    Class<ArrayList> class0 = ArrayList.class;
    TypeFactory typeFactory0 = TypeFactory.instance;
    Class<Proxy.Type> class1 = Proxy.Type.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructCollectionLikeType(class0, class1);
    JavaType[] javaTypeArray0 = collectionLikeType0.findTypeParameters(class0);
    assertEquals(1, javaTypeArray0.length);
}",""
"public int size() {
    return _types.length;
}","public void test022() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    TypeBindings typeBindings1 = (TypeBindings) typeBindings0.readResolve();
    assertEquals(0, typeBindings1.size());
}","/**
 * Returns number of bindings contained
 */"
"@Override
public int hashCode() {
    return _hashCode;
}","public void test033() throws Throwable {
    TypeBindings typeBindings0 = TypeFactory.EMPTY_BINDINGS;
    typeBindings0.hashCode();
}",""
"// safe to pass _types array without copy since it is not exposed via
// any access, nor modified by this class
/*
    /**********************************************************************
    /* Standard methods
    /**********************************************************************
     */
@Override
public String toString() {
    if (_types.length == 0) {
        return ""<>"";
    }
    StringBuilder sb = new StringBuilder();
    sb.append('<');
    for (int i = 0, len = _types.length; i < len; ++i) {
        if (i > 0) {
            sb.append(',');
        }
        //            sb = _types[i].appendBriefDescription(sb);
        String sig = _types[i].getGenericSignature();
        sb.append(sig);
    }
    sb.append('>');
    return sb.toString();
}","public void test044() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ArrayList> class0 = ArrayList.class;
    CollectionType collectionType0 = typeFactory0.constructRawCollectionType(class0);
    JavaType[] javaTypeArray0 = new JavaType[2];
    javaTypeArray0[0] = (JavaType) collectionType0;
    javaTypeArray0[1] = (JavaType) collectionType0;
    Class<Map> class1 = Map.class;
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded(class1, javaTypeArray0);
    String string0 = typeBindings0.toString();
    assertEquals(""<Ljava/util/ArrayList<Ljava/lang/Object;>;,Ljava/util/ArrayList<Ljava/lang/Object;>;>"", string0);
}","/**
 * Factory method that will create an object that can be used as a key for
 * caching purposes by {@link TypeFactory}
 *
 * @since 2.8
 */"
"public boolean isEmpty() {
    return (_types.length == 0);
}","public void test045() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ArrayList> class0 = ArrayList.class;
    CollectionType collectionType0 = typeFactory0.constructRawCollectionType(class0);
    JavaType[] javaTypeArray0 = new JavaType[2];
    javaTypeArray0[0] = (JavaType) collectionType0;
    javaTypeArray0[1] = (JavaType) collectionType0;
    Class<Map> class1 = Map.class;
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded(class1, javaTypeArray0);
    String string0 = typeBindings0.toString();
    assertFalse(typeBindings0.isEmpty());
}",""
"public int size() {
    return _types.length;
}","public void test056() throws Throwable {
    Class<ArrayList> class0 = ArrayList.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
    TypeBindings typeBindings1 = (TypeBindings) typeBindings0.readResolve();
    assertEquals(1, typeBindings1.size());
}","/**
 * Returns number of bindings contained
 */"
"public int size() {
    return _types.length;
}","public void test078() throws Throwable {
    Class<ReferenceType> class0 = ReferenceType.class;
    LinkedList<JavaType> linkedList0 = new LinkedList<JavaType>();
    TypeBindings typeBindings0 = TypeBindings.create((Class<?>) class0, (List<JavaType>) linkedList0);
    assertEquals(0, typeBindings0.size());
}","/**
 * Returns number of bindings contained
 */"
"public boolean isEmpty() {
    return (_types.length == 0);
}","public void test0910() throws Throwable {
    Class<Integer> class0 = Integer.class;
    TypeBindings typeBindings0 = TypeBindings.create(class0, (JavaType[]) null);
    assertTrue(typeBindings0.isEmpty());
}",""
"@Override
public final boolean isInterface() {
    return _class.isInterface();
}","public void test1011() throws Throwable {
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Map> class0 = Map.class;
    MapType mapType0 = typeFactory0.constructRawMapType(class0);
    JavaType javaType0 = mapType0.containedTypeOrUnknown(1);
    assertFalse(javaType0.isInterface());
}",""
"public static TypeBindings create(Class<?> erasedType, JavaType[] types) {
    if (types == null) {
        types = NO_TYPES;
    } else
        switch(types.length) {
            case 1:
                return create(erasedType, types[0]);
            case 2:
                return create(erasedType, types[0], types[1]);
        }
    TypeVariable<?>[] vars = erasedType.getTypeParameters();
    String[] names;
    if (vars == null || vars.length == 0) {
        names = NO_STRINGS;
    } else {
        int len = vars.length;
        names = new String[len];
        for (int i = 0; i < len; ++i) {
            names[i] = vars[i].getName();
        }
    }
    // Check here to give better error message
    if (names.length != types.length) {
        throw new IllegalArgumentException(""Can not create TypeBindings for class "" + erasedType.getName() + "" with "" + types.length + "" type parameter"" + ((types.length == 1) ? """" : ""s"") + "": class expects "" + names.length);
    }
    return new TypeBindings(names, types, null);
}","public void test1112() throws Throwable {
    JavaType[] javaTypeArray0 = new JavaType[2];
    Class<JsonDeserializer> class0 = JsonDeserializer.class;
    // Undeclared exception!
    try {
        TypeBindings.create(class0, javaTypeArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not create TypeBindings for class com.fasterxml.jackson.databind.JsonDeserializer with 2 type parameters: class expects 1
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeBindings"", e);
    }
}",""
"public boolean isEmpty() {
    return (_types.length == 0);
}","public void test1213() throws Throwable {
    Class<Object> class0 = Object.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_COMPARABLE;
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
    assertTrue(typeBindings0.isEmpty());
}",""
"public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType typeArg1) {
    TypeVariable<?>[] vars = erasedType.getTypeParameters();
    int varLen = (vars == null) ? 0 : vars.length;
    if (varLen == 0) {
        return EMPTY;
    }
    if (varLen != 1) {
        throw new IllegalArgumentException(""Can not create TypeBindings for class "" + erasedType.getName() + "" with 1 type parameter: class expects "" + varLen);
    }
    return new TypeBindings(new String[] { vars[0].getName() }, new JavaType[] { typeArg1 }, null);
}","public void test1314() throws Throwable {
    Class<Map> class0 = Map.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;
    // Undeclared exception!
    try {
        TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not create TypeBindings for class java.util.Map with 1 type parameter: class expects 2
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeBindings"", e);
    }
}","/**
 * Alternate factory method that may be called if it is possible that type
 * does or does not require type parameters; this is mostly useful for
 * collection- and map-like types.
 */"
"public boolean isEmpty() {
    return (_types.length == 0);
}","public void test1415() throws Throwable {
    Class<Integer> class0 = Integer.TYPE;
    JavaType[] javaTypeArray0 = new JavaType[1];
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded(class0, javaTypeArray0);
    assertTrue(typeBindings0.isEmpty());
}",""
"public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types) {
    TypeVariable<?>[] vars = erasedType.getTypeParameters();
    if (vars == null || vars.length == 0) {
        return EMPTY;
    }
    if (types == null) {
        types = NO_TYPES;
    }
    int len = vars.length;
    String[] names = new String[len];
    for (int i = 0; i < len; ++i) {
        names[i] = vars[i].getName();
    }
    // Check here to give better error message
    if (names.length != types.length) {
        throw new IllegalArgumentException(""Can not create TypeBindings for class "" + erasedType.getName() + "" with "" + types.length + "" type parameter"" + ((types.length == 1) ? """" : ""s"") + "": class expects "" + names.length);
    }
    return new TypeBindings(names, types, null);
}","public void test1516() throws Throwable {
    Class<ArrayList> class0 = ArrayList.class;
    // Undeclared exception!
    try {
        TypeBindings.createIfNeeded(class0, (JavaType[]) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not create TypeBindings for class java.util.ArrayList with 0 type parameters: class expects 1
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeBindings"", e);
    }
}","/**
 * Alternate factory method that may be called if it is possible that type
 * does or does not require type parameters; this is mostly useful for
 * collection- and map-like types.
 */"
"public static TypeBindings createIfNeeded(Class<?> erasedType, JavaType[] types) {
    TypeVariable<?>[] vars = erasedType.getTypeParameters();
    if (vars == null || vars.length == 0) {
        return EMPTY;
    }
    if (types == null) {
        types = NO_TYPES;
    }
    int len = vars.length;
    String[] names = new String[len];
    for (int i = 0; i < len; ++i) {
        names[i] = vars[i].getName();
    }
    // Check here to give better error message
    if (names.length != types.length) {
        throw new IllegalArgumentException(""Can not create TypeBindings for class "" + erasedType.getName() + "" with "" + types.length + "" type parameter"" + ((types.length == 1) ? """" : ""s"") + "": class expects "" + names.length);
    }
    return new TypeBindings(names, types, null);
}","public void test1617() throws Throwable {
    JavaType[] javaTypeArray0 = new JavaType[1];
    Class<Map> class0 = Map.class;
    // Undeclared exception!
    try {
        TypeBindings.createIfNeeded(class0, javaTypeArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Can not create TypeBindings for class java.util.Map with 1 type parameter: class expects 2
        //
        verifyException(""com.fasterxml.jackson.databind.type.TypeBindings"", e);
    }
}","/**
 * Alternate factory method that may be called if it is possible that type
 * does or does not require type parameters; this is mostly useful for
 * collection- and map-like types.
 */"
"public TypeBindings withUnboundVariable(String name) {
    int len = (_unboundVariables == null) ? 0 : _unboundVariables.length;
    String[] names = (len == 0) ? new String[1] : Arrays.copyOf(_unboundVariables, len + 1);
    names[len] = name;
    return new TypeBindings(_names, _types, names);
}","public void test1718() throws Throwable {
    TypeBindings typeBindings0 = TypeFactory.EMPTY_BINDINGS;
    TypeBindings typeBindings1 = typeBindings0.withUnboundVariable(""_b;Z(\""B,QdH2)E,zds"");
    TypeBindings typeBindings2 = typeBindings1.withUnboundVariable(""_b;Z(\""B,QdH2)E,zds"");
    assertNotSame(typeBindings2, typeBindings0);
}","/**
 * Method for creating an instance that has same bindings as this object,
 * plus an indicator for additional type variable that may be unbound within
 * this context; this is needed to resolve recursive self-references.
 */"
"/*
    /**********************************************************************
    /* Accessors
    /**********************************************************************
     */
/**
 * Find type bound to specified name, if there is one; returns bound type if so, null if not.
 */
public JavaType findBoundType(String name) {
    for (int i = 0, len = _names.length; i < len; ++i) {
        if (name.equals(_names[i])) {
            JavaType t = _types[i];
            if (t instanceof ResolvedRecursiveType) {
                ResolvedRecursiveType rrt = (ResolvedRecursiveType) t;
                JavaType t2 = rrt.getSelfReferencedType();
                if (t2 != null) {
                    t = t2;
                } else {
                    /* 25-Feb-2016, tatu: Looks like a potential problem, but alas
                         *   we have a test where this should NOT fail and things... seem
                         *   to work. So be it.
                         */
                    /*
                        throw new IllegalStateException(String.format
(""Unresolved ResolvedRecursiveType for parameter '%s' (index #%d; erased type %s)"",
name, i, t.getRawClass()));
*/
                }
            }
            return t;
        }
    }
    return null;
}","public void test1819() throws Throwable {
    TypeBindings typeBindings0 = TypeFactory.EMPTY_BINDINGS;
    JavaType javaType0 = typeBindings0.findBoundType(""~&{,22vsQ\""C"");
    assertNull(javaType0);
}",""
"public ObjectReader readerFor(JavaType type) {
    return _newReader(getDeserializationConfig(), type, null, null, _injectableValues);
}","public void test1920() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<JsonDeserializer> class0 = JsonDeserializer.class;
    JavaType javaType0 = TypeBase._bogusSuperClass(class0);
    ObjectReader objectReader0 = objectMapper0.readerFor(javaType0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * read or update instances of specified type
 *
 * @since 2.6
 */"
"public boolean isEmpty() {
    return (_types.length == 0);
}","public void test2021() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    Class<ArrayList> class0 = ArrayList.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    TypeFactory typeFactory0 = TypeFactory.instance;
    typeFactory0.constructCollectionType((Class<? extends Collection>) class0, (JavaType) resolvedRecursiveType0);
    assertTrue(typeBindings0.isEmpty());
}",""
"public boolean isEmpty() {
    return (_types.length == 0);
}","public void test2122() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    Class<ArrayList> class0 = ArrayList.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    Class<TypeBindings> class1 = TypeBindings.class;
    JavaType[] javaTypeArray0 = new JavaType[4];
    javaTypeArray0[0] = (JavaType) resolvedRecursiveType0;
    CollectionType collectionType0 = CollectionType.construct((Class<?>) class1, typeBindings0, (JavaType) resolvedRecursiveType0, javaTypeArray0, javaTypeArray0[0]);
    resolvedRecursiveType0.setReference(collectionType0);
    TypeFactory typeFactory0 = TypeFactory.instance;
    typeFactory0.constructCollectionType((Class<? extends Collection>) class0, (JavaType) resolvedRecursiveType0);
    assertTrue(typeBindings0.isEmpty());
}",""
"public String getBoundName(int index) {
    if (index < 0 || index >= _names.length) {
        return null;
    }
    return _names[index];
}","public void test2223() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    String string0 = typeBindings0.getBoundName((-1440));
    assertNull(string0);
}",""
"public String getBoundName(int index) {
    if (index < 0 || index >= _names.length) {
        return null;
    }
    return _names[index];
}","public void test2324() throws Throwable {
    Class<ArrayList> class0 = ArrayList.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_COMPARABLE;
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
    String string0 = typeBindings0.getBoundName(0);
    assertNotNull(string0);
}",""
"public boolean isEmpty() {
    return (_types.length == 0);
}","public void test2325() throws Throwable {
    Class<ArrayList> class0 = ArrayList.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_COMPARABLE;
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
    String string0 = typeBindings0.getBoundName(0);
    assertFalse(typeBindings0.isEmpty());
}",""
"public String getBoundName(int index) {
    if (index < 0 || index >= _names.length) {
        return null;
    }
    return _names[index];
}","public void test2426() throws Throwable {
    TypeBindings typeBindings0 = TypeFactory.EMPTY_BINDINGS;
    String string0 = typeBindings0.getBoundName(52);
    assertNull(string0);
}",""
"public JavaType getBoundType(int index) {
    if (index < 0 || index >= _types.length) {
        return null;
    }
    return _types[index];
}","public void test2527() throws Throwable {
    TypeBindings typeBindings0 = TypeFactory.EMPTY_BINDINGS;
    JavaType javaType0 = typeBindings0.getBoundType((-2744));
    assertNull(javaType0);
}",""
"public JavaType getBoundType(int index) {
    if (index < 0 || index >= _types.length) {
        return null;
    }
    return _types[index];
}","public void test2628() throws Throwable {
    TypeBindings typeBindings0 = TypeFactory.EMPTY_BINDINGS;
    JavaType javaType0 = typeBindings0.getBoundType(0);
    assertNull(javaType0);
}",""
"public boolean hasUnbound(String name) {
    if (_unboundVariables != null) {
        for (int i = _unboundVariables.length; --i >= 0; ) {
            if (name.equals(_unboundVariables[i])) {
                return true;
            }
        }
    }
    return false;
}","public void test2830() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    boolean boolean0 = typeBindings0.hasUnbound(""E"");
    assertFalse(boolean0);
}","/**
 * @since 2.3
 */"
"public boolean hasUnbound(String name) {
    if (_unboundVariables != null) {
        for (int i = _unboundVariables.length; --i >= 0; ) {
            if (name.equals(_unboundVariables[i])) {
                return true;
            }
        }
    }
    return false;
}","public void test2931() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    TypeBindings typeBindings1 = typeBindings0.withUnboundVariable("" with 1 type parameter: class expects "");
    boolean boolean0 = typeBindings1.hasUnbound("""");
    assertFalse(boolean0);
}","/**
 * @since 2.3
 */"
"public boolean hasUnbound(String name) {
    if (_unboundVariables != null) {
        for (int i = _unboundVariables.length; --i >= 0; ) {
            if (name.equals(_unboundVariables[i])) {
                return true;
            }
        }
    }
    return false;
}","public void test3032() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    TypeBindings typeBindings1 = typeBindings0.withUnboundVariable("""");
    boolean boolean0 = typeBindings1.hasUnbound("""");
    assertTrue(boolean0);
}","/**
 * @since 2.3
 */"
"// safe to pass _types array without copy since it is not exposed via
// any access, nor modified by this class
/*
    /**********************************************************************
    /* Standard methods
    /**********************************************************************
     */
@Override
public String toString() {
    if (_types.length == 0) {
        return ""<>"";
    }
    StringBuilder sb = new StringBuilder();
    sb.append('<');
    for (int i = 0, len = _types.length; i < len; ++i) {
        if (i > 0) {
            sb.append(',');
        }
        //            sb = _types[i].appendBriefDescription(sb);
        String sig = _types[i].getGenericSignature();
        sb.append(sig);
    }
    sb.append('>');
    return sb.toString();
}","public void test3133() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    String string0 = typeBindings0.toString();
    assertEquals(""<>"", string0);
}","/**
 * Factory method that will create an object that can be used as a key for
 * caching purposes by {@link TypeFactory}
 *
 * @since 2.8
 */"
"public int size() {
    return _types.length;
}","public void test3234() throws Throwable {
    Class<ArrayList> class0 = ArrayList.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_COMPARABLE;
    ReferenceType referenceType0 = ReferenceType.upgradeFrom(simpleType0, simpleType0);
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) referenceType0);
    TypeBindings typeBindings1 = TypeBindings.create((Class<?>) class0, (JavaType) simpleType0);
    boolean boolean0 = typeBindings0.equals(typeBindings1);
    assertEquals(1, typeBindings0.size());
}","/**
 * Returns number of bindings contained
 */"
"@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null || o.getClass() != getClass())
        return false;
    TypeBindings other = (TypeBindings) o;
    int len = _types.length;
    if (len != other.size()) {
        return false;
    }
    JavaType[] otherTypes = other._types;
    for (int i = 0; i < len; ++i) {
        if (!otherTypes[i].equals(_types[i])) {
            return false;
        }
    }
    return true;
}","public void test3235() throws Throwable {
    Class<ArrayList> class0 = ArrayList.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_COMPARABLE;
    ReferenceType referenceType0 = ReferenceType.upgradeFrom(simpleType0, simpleType0);
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) referenceType0);
    TypeBindings typeBindings1 = TypeBindings.create((Class<?>) class0, (JavaType) simpleType0);
    boolean boolean0 = typeBindings0.equals(typeBindings1);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null || o.getClass() != getClass())
        return false;
    TypeBindings other = (TypeBindings) o;
    int len = _types.length;
    if (len != other.size()) {
        return false;
    }
    JavaType[] otherTypes = other._types;
    for (int i = 0; i < len; ++i) {
        if (!otherTypes[i].equals(_types[i])) {
            return false;
        }
    }
    return true;
}","public void test3336() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    boolean boolean0 = typeBindings0.equals(typeBindings0);
    assertTrue(boolean0);
}",""
"@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null || o.getClass() != getClass())
        return false;
    TypeBindings other = (TypeBindings) o;
    int len = _types.length;
    if (len != other.size()) {
        return false;
    }
    JavaType[] otherTypes = other._types;
    for (int i = 0; i < len; ++i) {
        if (!otherTypes[i].equals(_types[i])) {
            return false;
        }
    }
    return true;
}","public void test3437() throws Throwable {
    TypeBindings typeBindings0 = TypeFactory.EMPTY_BINDINGS;
    boolean boolean0 = typeBindings0.equals((Object) null);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null || o.getClass() != getClass())
        return false;
    TypeBindings other = (TypeBindings) o;
    int len = _types.length;
    if (len != other.size()) {
        return false;
    }
    JavaType[] otherTypes = other._types;
    for (int i = 0; i < len; ++i) {
        if (!otherTypes[i].equals(_types[i])) {
            return false;
        }
    }
    return true;
}","public void test3538() throws Throwable {
    Stack<JavaType> stack0 = new Stack<JavaType>();
    TypeBindings typeBindings0 = TypeFactory.EMPTY_BINDINGS;
    boolean boolean0 = typeBindings0.equals(stack0);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null || o.getClass() != getClass())
        return false;
    TypeBindings other = (TypeBindings) o;
    int len = _types.length;
    if (len != other.size()) {
        return false;
    }
    JavaType[] otherTypes = other._types;
    for (int i = 0; i < len; ++i) {
        if (!otherTypes[i].equals(_types[i])) {
            return false;
        }
    }
    return true;
}","public void test3639() throws Throwable {
    Class<ArrayList> class0 = ArrayList.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_COMPARABLE;
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
    TypeBindings typeBindings1 = TypeFactory.EMPTY_BINDINGS;
    boolean boolean0 = typeBindings1.equals(typeBindings0);
    assertFalse(boolean0);
}",""
"@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null || o.getClass() != getClass())
        return false;
    TypeBindings other = (TypeBindings) o;
    int len = _types.length;
    if (len != other.size()) {
        return false;
    }
    JavaType[] otherTypes = other._types;
    for (int i = 0; i < len; ++i) {
        if (!otherTypes[i].equals(_types[i])) {
            return false;
        }
    }
    return true;
}","public void test3640() throws Throwable {
    Class<ArrayList> class0 = ArrayList.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_COMPARABLE;
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
    TypeBindings typeBindings1 = TypeFactory.EMPTY_BINDINGS;
    boolean boolean0 = typeBindings1.equals(typeBindings0);
    assertFalse(typeBindings0.equals((Object) typeBindings1));
}",""
"@Override
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (o == null || o.getClass() != getClass())
        return false;
    TypeBindings other = (TypeBindings) o;
    int len = _types.length;
    if (len != other.size()) {
        return false;
    }
    JavaType[] otherTypes = other._types;
    for (int i = 0; i < len; ++i) {
        if (!otherTypes[i].equals(_types[i])) {
            return false;
        }
    }
    return true;
}","public void test3741() throws Throwable {
    Class<ArrayList> class0 = ArrayList.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
    TypeBindings typeBindings1 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
    boolean boolean0 = typeBindings0.equals(typeBindings1);
    assertTrue(boolean0);
}",""
"public boolean isEmpty() {
    return (_types.length == 0);
}","public void test3742() throws Throwable {
    Class<ArrayList> class0 = ArrayList.class;
    SimpleType simpleType0 = TypeFactory.CORE_TYPE_BOOL;
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
    TypeBindings typeBindings1 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
    boolean boolean0 = typeBindings0.equals(typeBindings1);
    assertFalse(typeBindings1.isEmpty());
}",""
