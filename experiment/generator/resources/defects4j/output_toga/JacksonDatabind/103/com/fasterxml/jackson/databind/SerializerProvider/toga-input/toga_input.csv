focal_method,test_prefix,docstring
"@SuppressWarnings(""unchecked"")
public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property) throws JsonMappingException {
    if (valueType == null) {
        reportMappingProblem(""Null passed for `valueType` of `findValueSerializer()`"");
    }
    // (see comments from above method)
    JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);
    if (ser == null) {
        ser = _serializerCache.untypedValueSerializer(valueType);
        if (ser == null) {
            ser = _createAndCacheUntypedSerializer(valueType);
            if (ser == null) {
                ser = getUnknownTypeSerializer(valueType.getRawClass());
                if (CACHE_UNKNOWN_MAPPINGS) {
                    _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);
                }
                return ser;
            }
        }
    }
    return (JsonSerializer<Object>) handleSecondaryContextualization(ser, property);
}","public void test000() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    try {
        serializerProvider0.findValueSerializer((JavaType) null, (BeanProperty) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Null passed for `valueType` of `findValueSerializer()`
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 *  Similar to {@link #findValueSerializer(Class,BeanProperty)}, but takes
 *  full generics-aware type instead of raw class.
 *  This is necessary for accurate handling of external type information,
 *  to handle polymorphic types.
 * <p>
 *  Note: this call will also contextualize serializer before returning it.
 *
 *  @param property When creating secondary serializers, property for which
 *    serializer is needed: annotations of the property (or bean that contains it)
 *    may be checked to create contextual serializers.
 */"
"@Override
public Locale getLocale() {
    return _config.getLocale();
}","public void test011() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    // Undeclared exception!
    try {
        defaultSerializerProvider_Impl0.getLocale();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}","/**
 *  Method for accessing default Locale to use: convenience method for
 * <pre>
 *    getConfig().getLocale();
 * </pre>
 */"
"public TypeSerializer findTypeSerializer(JavaType javaType) throws JsonMappingException {
    return _serializerFactory.createTypeSerializer(_config, javaType);
}","public void test022() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    // Undeclared exception!
    try {
        serializerProvider0.findTypeSerializer((JavaType) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.BasicSerializerFactory"", e);
    }
}","/**
 * Method called to get the {@link TypeSerializer} to use for including Type Id necessary
 * for serializing for the given Java class.
 * Useful for schema generators.
 *
 * @since 2.6
 */"
"@Override
public SerializerProvider setAttribute(Object key, Object value) {
    _attributes = _attributes.withPerCallAttribute(key, value);
    return this;
}","public void test033() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    MockDateFormat mockDateFormat0 = new MockDateFormat();
    // Undeclared exception!
    try {
        defaultSerializerProvider_Impl0.setAttribute(mockDateFormat0, mockDateFormat0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}",""
"// since 2.9
@Deprecated
protected JsonMappingException mappingException(Throwable t, String message, Object... msgArgs) {
    return JsonMappingException.from(getGenerator(), _format(message, msgArgs), t);
}","public void test044() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    SQLTransientException sQLTransientException0 = new SQLTransientException();
    Object[] objectArray0 = new Object[9];
    // Undeclared exception!
    try {
        ((SerializerProvider) defaultSerializerProvider_Impl0).mappingException((Throwable) sQLTransientException0, (String) null, objectArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Factory method for constructing a {@link JsonMappingException};
 * usually only indirectly used by calling
 * {@link #reportMappingProblem(Throwable, String, Object...)}
 *
 * @since 2.8
 *
 * @deprecated Since 2.9
 */"
"public final boolean hasSerializationFeatures(int featureMask) {
    return _config.hasSerializationFeatures(featureMask);
}","public void test066() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    boolean boolean0 = serializerProvider0.hasSerializationFeatures(1968);
    assertFalse(boolean0);
}","/**
 * ""Bulk"" access method for checking that all features specified by
 * mask are enabled.
 *
 * @since 2.3
 */"
"/*
    /**********************************************************
    /* Generic attributes (2.3+)
    /**********************************************************
     */
@Override
public Object getAttribute(Object key) {
    return _attributes.getAttribute(key);
}","public void test077() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    Object object0 = new Object();
    // Undeclared exception!
    try {
        defaultSerializerProvider_Impl0.getAttribute(object0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}",""
"@Override
public final boolean isEnabled(MapperFeature feature) {
    return _config.isEnabled(feature);
}","public void test088() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    MapperFeature mapperFeature0 = MapperFeature.SORT_PROPERTIES_ALPHABETICALLY;
    // Undeclared exception!
    try {
        defaultSerializerProvider_Impl0.isEnabled(mapperFeature0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}",""
"public <T> T reportBadDefinition(Class<?> raw, String msg, Throwable cause) throws JsonMappingException {
    InvalidDefinitionException e = InvalidDefinitionException.from(getGenerator(), msg, constructType(raw));
    e.initCause(cause);
    throw e;
}","public void test099() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    Class<BeanSerializer> class0 = BeanSerializer.class;
    SQLWarning sQLWarning0 = new SQLWarning();
    // Undeclared exception!
    try {
        defaultSerializerProvider_Impl0.reportBadDefinition((Class<?>) class0, ""Null passed for `valueType` of `findValueSerializer()`"", (Throwable) sQLWarning0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}","/**
 * @since 2.9
 */"
"public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {
    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first
    //    check if any generics info is added; and only then ask factory
    //    to do translation when necessary
    if (subClass.indexOf('<') > 0) {
        // note: may want to try combining with specialization (esp for EnumMap)?
        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment
        //    compatibility -- needed later anyway, and not doing so may open
        //    security issues.
        JavaType t = getTypeFactory().constructFromCanonical(subClass);
        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {
            return t;
        }
    } else {
        Class<?> cls;
        try {
            cls = getTypeFactory().findClass(subClass);
        } catch (ClassNotFoundException e) {
            // let caller handle this problem
            return null;
        } catch (Exception e) {
            throw invalidTypeIdException(baseType, subClass, String.format(""problem: (%s) %s"", e.getClass().getName(), e.getMessage()));
        }
        if (baseType.isTypeOrSuperTypeOf(cls)) {
            return getTypeFactory().constructSpecializedType(baseType, cls);
        }
    }
    throw invalidTypeIdException(baseType, subClass, ""Not a subtype"");
}","public void test1010() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    try {
        defaultSerializerProvider_Impl0.resolveSubType((JavaType) null, ""-4"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Could not resolve type id '-4' as a subtype of null: problem: (java.lang.NullPointerException) null
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidTypeIdException"", e);
    }
}","/**
 * Lookup method called when code needs to resolve class name from input;
 * usually simple lookup
 *
 * @since 2.9
 */"
"public <T> T reportBadDefinition(JavaType type, String msg, Throwable cause) throws JsonMappingException {
    InvalidDefinitionException e = InvalidDefinitionException.from(getGenerator(), msg, type);
    e.initCause(cause);
    throw e;
}","public void test1111() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    SQLTransientException sQLTransientException0 = new SQLTransientException("""");
    SQLTransientConnectionException sQLTransientConnectionException0 = new SQLTransientConnectionException(""? w#)8Lk..:qLn@X_#<"", sQLTransientException0);
    try {
        defaultSerializerProvider_Impl0.reportBadDefinition((JavaType) null, ""? w#)8Lk..:qLn@X_#<"", (Throwable) sQLTransientConnectionException0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // ? w#)8Lk..:qLn@X_#<
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}","/**
 * @since 2.9
 */"
"public boolean usesObjectId() {
    return false;
}","public void test1212() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    Class<DateFormat> class0 = DateFormat.class;
    BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
    JsonSerializer<Object> jsonSerializer0 = serializerProvider0.findKeySerializer((Class<?>) class0, (BeanProperty) beanProperty_Bogus0);
    assertFalse(jsonSerializer0.usesObjectId());
}","/**
 * Method that can be called to see whether this serializer instance
 * will use Object Id to handle cyclic references.
 */"
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test1313() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl1 = new DefaultSerializerProvider.Impl(defaultSerializerProvider_Impl0);
    assertEquals(0, defaultSerializerProvider_Impl1.cachedSerializersCount());
}",""
"public boolean isUnwrappingSerializer() {
    return false;
}","public void test1414() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    Class<Object> class0 = Object.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
    JsonSerializer<Object> jsonSerializer0 = serializerProvider0.findNullKeySerializer(simpleType0, beanProperty_Bogus0);
    assertFalse(jsonSerializer0.isUnwrappingSerializer());
}","/**
 * Accessor for checking whether this serializer is an
 * ""unwrapping"" serializer; this is necessary to know since
 * it may also require caller to suppress writing of the
 * leading property name.
 */"
"@Deprecated
public final Class<?> getSerializationView() {
    return _serializationView;
}","public void test1515() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    Class<?> class0 = defaultSerializerProvider_Impl0.getSerializationView();
    assertNull(class0);
}","/**
 * @deprecated Since 2.2, use {@link #getActiveView} instead.
 */"
"@Override
public final Class<?> getActiveView() {
    return _serializationView;
}","public void test1616() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    Class<?> class0 = serializerProvider0.getActiveView();
    assertNull(class0);
}",""
"public boolean usesObjectId() {
    return false;
}","public void test1717() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    JsonSerializer<Object> jsonSerializer0 = defaultSerializerProvider_Impl0.getDefaultNullValueSerializer();
    assertFalse(jsonSerializer0.usesObjectId());
}","/**
 * Method that can be called to see whether this serializer instance
 * will use Object Id to handle cyclic references.
 */"
"@Override
public final boolean canOverrideAccessModifiers() {
    return _config.canOverrideAccessModifiers();
}","public void test1818() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    // Undeclared exception!
    try {
        defaultSerializerProvider_Impl0.canOverrideAccessModifiers();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"public boolean usesObjectId() {
    return false;
}","public void test1919() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    JsonSerializer<Object> jsonSerializer0 = defaultSerializerProvider_Impl0.getDefaultNullKeySerializer();
    assertFalse(jsonSerializer0.usesObjectId());
}","/**
 * Method that can be called to see whether this serializer instance
 * will use Object Id to handle cyclic references.
 */"
"public void reportMappingProblem(Throwable t, String message, Object... msgArgs) throws JsonMappingException {
    message = _format(message, msgArgs);
    throw JsonMappingException.from(getGenerator(), message, t);
}","public void test2020() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    SQLNonTransientConnectionException sQLNonTransientConnectionException0 = new SQLNonTransientConnectionException();
    Object[] objectArray0 = new Object[0];
    try {
        serializerProvider0.reportMappingProblem((Throwable) sQLNonTransientConnectionException0, """", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        //
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}","/**
 * Helper method called to indicate problem; default behavior is to construct and
 * throw a {@link JsonMappingException}, but in future may collect more than one
 * and only throw after certain number, or at the end of serialization.
 *
 * @since 2.8
 */"
"@Override
public TimeZone getTimeZone() {
    return _config.getTimeZone();
}","public void test2121() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    // Undeclared exception!
    try {
        defaultSerializerProvider_Impl0.getTimeZone();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}","/**
 *  Method for accessing default TimeZone to use: convenience method for
 * <pre>
 *    getConfig().getTimeZone();
 * </pre>
 */"
"public final FilterProvider getFilterProvider() {
    return _config.getFilterProvider();
}","public void test2222() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    // Undeclared exception!
    try {
        defaultSerializerProvider_Impl0.getFilterProvider();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}","/**
 *  Convenience method for accessing provider to find serialization filters used,
 *  equivalent to calling:
 * <pre>
 *    getConfig().getFilterProvider();
 * </pre>
 */"
"@Override
public final boolean canOverrideAccessModifiers() {
    return _config.canOverrideAccessModifiers();
}","public void test2323() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    serializerProvider0.setDefaultKeySerializer(serializerProvider0.DEFAULT_NULL_KEY_SERIALIZER);
    assertTrue(serializerProvider0.canOverrideAccessModifiers());
}",""
"/*
    /**********************************************************
    /* Methods for configuring default settings
    /**********************************************************
     */
/**
 * Method that can be used to specify serializer that will be
 * used to write JSON property names matching null keys for Java
 * Maps (which will throw an exception if try write such property
 * name)
 */
public void setDefaultKeySerializer(JsonSerializer<Object> ks) {
    if (ks == null) {
        throw new IllegalArgumentException(""Cannot pass null JsonSerializer"");
    }
    _keySerializer = ks;
}","public void test2424() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    // Undeclared exception!
    try {
        defaultSerializerProvider_Impl0.setDefaultKeySerializer((JsonSerializer<Object>) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot pass null JsonSerializer
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}",""
"@Override
public final boolean canOverrideAccessModifiers() {
    return _config.canOverrideAccessModifiers();
}","public void test2525() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    serializerProvider0.setNullValueSerializer(serializerProvider0.DEFAULT_NULL_KEY_SERIALIZER);
    assertTrue(serializerProvider0.canOverrideAccessModifiers());
}",""
"public void setNullValueSerializer(JsonSerializer<Object> nvs) {
    if (nvs == null) {
        throw new IllegalArgumentException(""Cannot pass null JsonSerializer"");
    }
    _nullValueSerializer = nvs;
}","public void test2626() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    // Undeclared exception!
    try {
        serializerProvider0.setNullValueSerializer((JsonSerializer<Object>) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot pass null JsonSerializer
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}","/**
 *  Method that can be used to specify serializer that will be
 *  used to write JSON values matching Java null values
 *  instead of default one (which simply writes JSON null).
 * <p>
 *  Note that you can get finer control over serializer to use by overriding
 *  {@link #findNullValueSerializer}, which gets called once per each
 *  property.
 */"
"@Override
public final boolean canOverrideAccessModifiers() {
    return _config.canOverrideAccessModifiers();
}","public void test2727() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    serializerProvider0.setNullKeySerializer(serializerProvider0.DEFAULT_NULL_KEY_SERIALIZER);
    assertTrue(serializerProvider0.canOverrideAccessModifiers());
}",""
"public void setNullKeySerializer(JsonSerializer<Object> nks) {
    if (nks == null) {
        throw new IllegalArgumentException(""Cannot pass null JsonSerializer"");
    }
    _nullKeySerializer = nks;
}","public void test2828() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    // Undeclared exception!
    try {
        defaultSerializerProvider_Impl0.setNullKeySerializer((JsonSerializer<Object>) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot pass null JsonSerializer
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}","/**
 *  Method that can be used to specify serializer to use for serializing
 *  all non-null JSON property names, unless more specific key serializer
 *  is found (i.e. if not custom key serializer has been registered for
 *  Java type).
 * <p>
 *  Note that key serializer registration are different from value serializer
 *  registrations.
 */"
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test2929() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    Class<ObjectIdGenerators.UUIDGenerator> class0 = ObjectIdGenerators.UUIDGenerator.class;
    defaultSerializerProvider_Impl0.findValueSerializer(class0);
    defaultSerializerProvider_Impl0.findTypedValueSerializer(class0, false, (BeanProperty) null);
    assertEquals(3, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test3030() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    Class<BeanSerializer> class0 = BeanSerializer.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
    defaultSerializerProvider_Impl0.findPrimaryPropertySerializer((JavaType) simpleType0, (BeanProperty) beanProperty_Bogus0);
    defaultSerializerProvider_Impl0.findValueSerializer((Class<?>) class0, (BeanProperty) beanProperty_Bogus0);
    assertEquals(1, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"@SuppressWarnings(""resource"")
public <T> T updateValue(T valueToUpdate, Object overrides) throws JsonMappingException {
    T result = valueToUpdate;
    if ((valueToUpdate != null) && (overrides != null)) {
        TokenBuffer buf = new TokenBuffer(this, false);
        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
            buf = buf.forceUseOfBigDecimal(true);
        }
        try {
            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);
            _serializerProvider(config).serializeValue(buf, overrides);
            JsonParser p = buf.asParser();
            result = readerForUpdating(valueToUpdate).readValue(p);
            p.close();
        } catch (IOException e) {
            // should not occur, no real i/o...
            if (e instanceof JsonMappingException) {
                throw (JsonMappingException) e;
            }
            // 17-Mar-2017, tatu: Really ought not happen...
            throw JsonMappingException.fromUnexpectedIOE(e);
        }
    }
    return result;
}","public void test3131() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    Class<SettableBeanProperty> class0 = SettableBeanProperty.class;
    serializerProvider0.findValueSerializer(class0);
    try {
        objectMapper0.updateValue((Object) serializerProvider0, (Object) serializerProvider0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No serializer found for class com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: com.fasterxml.jackson.databind.ser.DefaultSerializerProvider$Impl[\""annotationIntrospector\""])
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}","/**
 *  Convenience method similar to {@link #convertValue(Object, JavaType)} but one
 *  in which
 * <p>
 *  Implementation is approximately as follows:
 * <ol>
 *  <li>Serialize `updateWithValue` into {@link TokenBuffer}</li>
 *  <li>Construct {@link ObjectReader} with `valueToUpdate` (using {@link #readerForUpdating(Object)})
 *    </li>
 *  <li>Construct {@link JsonParser} (using {@link TokenBuffer#asParser()})
 *    </li>
 *  <li>Update using {@link ObjectReader#readValue(JsonParser)}.
 *    </li>
 *  <li>Return `valueToUpdate`
 *    </li>
 * </ol>
 * <p>
 *  Note that update is ""shallow"" in that only first level of properties (or, immediate contents
 *  of container to update) are modified, unless properties themselves indicate that
 *  merging should be applied for contents. Such merging can be specified using
 *  annotations (see <code>JsonMerge</code>) as well as using ""config overrides"" (see
 *  {@link #configOverride(Class)} and {@link #setDefaultMergeable(Boolean)}).
 *
 *  @param valueToUpdate Object to update
 *  @param overrides Object to conceptually serialize and merge into value to
 *      update; can be thought of as a provider for overrides to apply.
 *
 *  @return Either the first argument (`valueToUpdate`), if it is mutable; or a result of
 *      creating new instance that is result of ""merging"" values (for example, ""updating"" a
 *      Java array will create a new array)
 *
 *  @throws JsonMappingException if there are structural incompatibilities that prevent update.
 *
 *  @since 2.9
 */"
"/*
    /**********************************************************
    /* Extended Public API, accessors
    /**********************************************************
     */
/**
 *  Method that can be called to check whether mapper thinks
 *  it could serialize an instance of given Class.
 *  Check is done
 *  by checking whether a serializer can be found for the type.
 * <p>
 *  NOTE: since this method does NOT throw exceptions, but internal
 *  processing may, caller usually has little information as to why
 *  serialization would fail. If you want access to internal {@link Exception},
 *  call {@link #canSerialize(Class, AtomicReference)} instead.
 *
 *  @return True if mapper can find a serializer for instances of
 *   given class (potentially serializable), false otherwise (not
 *   serializable)
 */
public boolean canSerialize(Class<?> type) {
    return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);
}","public void test3232() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<PropertyName> class0 = PropertyName.class;
    boolean boolean0 = objectMapper0.canSerialize(class0);
    assertTrue(boolean0);
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test3233() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<PropertyName> class0 = PropertyName.class;
    boolean boolean0 = objectMapper0.canSerialize(class0);
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    defaultSerializerProvider_Impl0.findValueSerializer(class0);
    assertEquals(4, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test3334() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    Class<TypeIdResolver> class0 = TypeIdResolver.class;
    defaultSerializerProvider_Impl0.findValueSerializer(class0);
    defaultSerializerProvider_Impl0.findValueSerializer(class0);
    assertEquals(3, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test3435() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    Class<MockSimpleDateFormat> class0 = MockSimpleDateFormat.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    defaultSerializerProvider_Impl0.findValueSerializer((JavaType) simpleType0);
    defaultSerializerProvider_Impl0.findValueSerializer(class0);
    assertEquals(1, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test3536() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    SimpleType simpleType0 = (SimpleType) TypeFactory.unknownType();
    defaultSerializerProvider_Impl0.findValueSerializer((JavaType) simpleType0);
    defaultSerializerProvider_Impl0.findValueSerializer((JavaType) simpleType0);
    assertEquals(1, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test3637() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    SimpleType simpleType0 = (SimpleType) TypeFactory.unknownType();
    defaultSerializerProvider_Impl0.findPrimaryPropertySerializer((JavaType) simpleType0, (BeanProperty) null);
    defaultSerializerProvider_Impl0.findPrimaryPropertySerializer((JavaType) simpleType0, (BeanProperty) null);
    assertEquals(1, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test3739() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<PropertyName> class0 = PropertyName.class;
    boolean boolean0 = objectMapper0.canSerialize(class0);
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    defaultSerializerProvider_Impl0.findPrimaryPropertySerializer(class0, (BeanProperty) null);
    assertEquals(4, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test3840() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    Class<SettableBeanProperty> class0 = SettableBeanProperty.class;
    ((SerializerProvider) defaultSerializerProvider_Impl0)._findExplicitUntypedSerializer(class0);
    BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
    defaultSerializerProvider_Impl0.findPrimaryPropertySerializer((Class<?>) class0, (BeanProperty) beanProperty_Bogus0);
    assertEquals(5, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test3941() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    Class<Object> class0 = Object.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
    defaultSerializerProvider_Impl0.findValueSerializer((JavaType) simpleType0);
    defaultSerializerProvider_Impl0.findPrimaryPropertySerializer((Class<?>) class0, (BeanProperty) beanProperty_Bogus0);
    assertEquals(1, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test4042() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
    Class<ClientInfoStatus> class0 = ClientInfoStatus.class;
    defaultSerializerProvider_Impl0.findTypedValueSerializer((Class<?>) class0, true, (BeanProperty) beanProperty_Bogus0);
    defaultSerializerProvider_Impl0.findTypedValueSerializer((Class<?>) class0, true, (BeanProperty) beanProperty_Bogus0);
    assertEquals(3, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test4143() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
    SimpleType simpleType0 = (SimpleType) beanProperty_Bogus0.getType();
    defaultSerializerProvider_Impl0.findTypedValueSerializer((JavaType) simpleType0, true, (BeanProperty) beanProperty_Bogus0);
    defaultSerializerProvider_Impl0.findTypedValueSerializer((JavaType) simpleType0, true, (BeanProperty) beanProperty_Bogus0);
    assertEquals(2, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test4244() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    JavaType javaType0 = TypeFactory.unknownType();
    objectMapper0.enableDefaultTyping();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    defaultSerializerProvider_Impl0.findTypedValueSerializer(javaType0, true, (BeanProperty) null);
    assertEquals(2, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test4345() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
    SimpleType simpleType0 = (SimpleType) beanProperty_Bogus0.getType();
    defaultSerializerProvider_Impl0.findTypedValueSerializer((JavaType) simpleType0, false, (BeanProperty) beanProperty_Bogus0);
    assertEquals(1, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test4446() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    Class<Object> class0 = Object.class;
    ((SerializerProvider) defaultSerializerProvider_Impl0)._findExplicitUntypedSerializer(class0);
    assertEquals(2, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"public boolean isUnknownTypeSerializer(JsonSerializer<?> ser) {
    if ((ser == _unknownTypeSerializer) || (ser == null)) {
        return true;
    }
    // 23-Apr-2015, tatu: ""empty"" serializer is trickier; needs to consider
    //    error handling
    if (isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) {
        if (ser.getClass() == UnknownSerializer.class) {
            return true;
        }
    }
    return false;
}","public void test4547() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    boolean boolean0 = defaultSerializerProvider_Impl0.isUnknownTypeSerializer((JsonSerializer<?>) null);
    assertTrue(boolean0);
}","/**
 * Helper method called to see if given serializer is considered to be
 * something returned by {@link #getUnknownTypeSerializer}, that is, something
 * for which no regular serializer was found or constructed.
 *
 * @since 2.5
 */"
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test4648() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    Class<ObjectIdResolver> class0 = ObjectIdResolver.class;
    ((SerializerProvider) defaultSerializerProvider_Impl0)._findExplicitUntypedSerializer(class0);
    assertEquals(2, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"public JsonSerializer<?> handleSecondaryContextualization(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException {
    if (ser != null) {
        if (ser instanceof ContextualSerializer) {
            ser = ((ContextualSerializer) ser).createContextual(this, property);
        }
    }
    return ser;
}","public void test4749() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
    JsonSerializer<?> jsonSerializer0 = serializerProvider0.handleSecondaryContextualization((JsonSerializer<?>) null, beanProperty_Bogus0);
    assertNull(jsonSerializer0);
}","/**
 * Method called for secondary property serializers (ones
 * NOT directly created to serialize values of a POJO property
 * but instead created as a dependant serializer -- such as value serializers
 * for structured types, or serializers for root values)
 * to handle details of resolving
 * {@link ContextualDeserializer} with given property context.
 * Given that these serializers are not directly related to given property
 * (or, in case of root value property, to any property), annotations
 * accessible may or may not be relevant.
 *
 * @param property Property for which serializer is used, if any; null
 *    when deserializing root values
 *
 * @since 2.3
 */"
"/*
    /********************************************************
    /* Convenience methods for serializing using default methods
    /********************************************************
     */
/**
 * Convenience method that will serialize given value (which can be
 * null) using standard serializer locating functionality. It can
 * be called for all values including field and Map values, but usually
 * field values are best handled calling
 * {@link #defaultSerializeField} instead.
 */
public final void defaultSerializeValue(Object value, JsonGenerator gen) throws IOException {
    if (value == null) {
        if (_stdNullValueSerializer) {
            // minor perf optimization
            gen.writeNull();
        } else {
            _nullValueSerializer.serialize(null, gen, this);
        }
    } else {
        Class<?> cls = value.getClass();
        findTypedValueSerializer(cls, true, null).serialize(value, gen, this);
    }
}","public void test4850() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    // Undeclared exception!
    try {
        serializerProvider0.defaultSerializeValue(serializerProvider0, (JsonGenerator) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.BeanSerializer"", e);
    }
}",""
"/*
    /********************************************************
    /* Convenience methods for serializing using default methods
    /********************************************************
     */
/**
 * Convenience method that will serialize given value (which can be
 * null) using standard serializer locating functionality. It can
 * be called for all values including field and Map values, but usually
 * field values are best handled calling
 * {@link #defaultSerializeField} instead.
 */
public final void defaultSerializeValue(Object value, JsonGenerator gen) throws IOException {
    if (value == null) {
        if (_stdNullValueSerializer) {
            // minor perf optimization
            gen.writeNull();
        } else {
            _nullValueSerializer.serialize(null, gen, this);
        }
    } else {
        Class<?> cls = value.getClass();
        findTypedValueSerializer(cls, true, null).serialize(value, gen, this);
    }
}","public void test4951() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    // Undeclared exception!
    try {
        serializerProvider0.defaultSerializeValue((Object) null, (JsonGenerator) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.std.NullSerializer"", e);
    }
}",""
"/*
    /********************************************************
    /* Convenience methods for serializing using default methods
    /********************************************************
     */
/**
 * Convenience method that will serialize given value (which can be
 * null) using standard serializer locating functionality. It can
 * be called for all values including field and Map values, but usually
 * field values are best handled calling
 * {@link #defaultSerializeField} instead.
 */
public final void defaultSerializeValue(Object value, JsonGenerator gen) throws IOException {
    if (value == null) {
        if (_stdNullValueSerializer) {
            // minor perf optimization
            gen.writeNull();
        } else {
            _nullValueSerializer.serialize(null, gen, this);
        }
    } else {
        Class<?> cls = value.getClass();
        findTypedValueSerializer(cls, true, null).serialize(value, gen, this);
    }
}","public void test5052() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    // Undeclared exception!
    try {
        defaultSerializerProvider_Impl0.defaultSerializeValue((Object) null, (JsonGenerator) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}",""
"public final void defaultSerializeDateValue(long timestamp, JsonGenerator gen) throws IOException {
    if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {
        gen.writeNumber(timestamp);
    } else {
        gen.writeString(_dateFormat().format(new Date(timestamp)));
    }
}","public void test5153() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializationFeature serializationFeature0 = SerializationFeature.WRITE_DATES_AS_TIMESTAMPS;
    SerializationFeature[] serializationFeatureArray0 = new SerializationFeature[7];
    serializationFeatureArray0[0] = serializationFeature0;
    serializationFeatureArray0[1] = serializationFeature0;
    serializationFeatureArray0[2] = serializationFeature0;
    serializationFeatureArray0[3] = serializationFeature0;
    serializationFeatureArray0[4] = serializationFeature0;
    serializationFeatureArray0[5] = serializationFeature0;
    serializationFeatureArray0[6] = serializationFeature0;
    objectMapper0.disable(serializationFeature0, serializationFeatureArray0);
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    // Undeclared exception!
    try {
        serializerProvider0.defaultSerializeDateValue((-18L), (JsonGenerator) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}","/**
 * Method that will handle serialization of Date(-like) values, using
 * {@link SerializationConfig} settings to determine expected serialization
 * behavior.
 * Note: date here means ""full"" date, that is, date AND time, as per
 * Java convention (and not date-only values like in SQL)
 */"
"public final void defaultSerializeDateValue(long timestamp, JsonGenerator gen) throws IOException {
    if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {
        gen.writeNumber(timestamp);
    } else {
        gen.writeString(_dateFormat().format(new Date(timestamp)));
    }
}","public void test5254() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    // Undeclared exception!
    try {
        serializerProvider0.defaultSerializeDateValue((-18L), (JsonGenerator) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}","/**
 * Method that will handle serialization of Date(-like) values, using
 * {@link SerializationConfig} settings to determine expected serialization
 * behavior.
 * Note: date here means ""full"" date, that is, date AND time, as per
 * Java convention (and not date-only values like in SQL)
 */"
"public final void defaultSerializeDateValue(Date date, JsonGenerator gen) throws IOException {
    if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {
        gen.writeNumber(date.getTime());
    } else {
        gen.writeString(_dateFormat().format(date));
    }
}","public void test5355() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    MockDate mockDate0 = new MockDate();
    // Undeclared exception!
    try {
        serializerProvider0.defaultSerializeDateValue((Date) mockDate0, (JsonGenerator) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}","/**
 * Method that will handle serialization of Date(-like) values, using
 * {@link SerializationConfig} settings to determine expected serialization
 * behavior.
 * Note: date here means ""full"" date, that is, date AND time, as per
 * Java convention (and not date-only values like in SQL)
 */"
"public void defaultSerializeDateKey(Date date, JsonGenerator gen) throws IOException {
    if (isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {
        gen.writeFieldName(String.valueOf(date.getTime()));
    } else {
        gen.writeFieldName(_dateFormat().format(date));
    }
}","public void test5456() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    MockDate mockDate0 = new MockDate();
    // Undeclared exception!
    try {
        serializerProvider0.defaultSerializeDateKey((Date) mockDate0, (JsonGenerator) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}","/**
 * Method that will handle serialization of Dates used as {@link java.util.Map} keys,
 * based on {@link SerializationFeature#WRITE_DATE_KEYS_AS_TIMESTAMPS}
 * value (and if using textual representation, configured date format)
 */"
"public final void defaultSerializeNull(JsonGenerator gen) throws IOException {
    if (_stdNullValueSerializer) {
        // minor perf optimization
        gen.writeNull();
    } else {
        _nullValueSerializer.serialize(null, gen, this);
    }
}","public void test5557() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    // Undeclared exception!
    try {
        serializerProvider0.defaultSerializeNull((JsonGenerator) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.ser.std.NullSerializer"", e);
    }
}",""
"public final void defaultSerializeNull(JsonGenerator gen) throws IOException {
    if (_stdNullValueSerializer) {
        // minor perf optimization
        gen.writeNull();
    } else {
        _nullValueSerializer.serialize(null, gen, this);
    }
}","public void test5658() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    // Undeclared exception!
    try {
        defaultSerializerProvider_Impl0.defaultSerializeNull((JsonGenerator) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.SerializerProvider"", e);
    }
}",""
"public <T> T reportBadTypeDefinition(BeanDescription bean, String msg, Object... msgArgs) throws JsonMappingException {
    String beanDesc = ""N/A"";
    if (bean != null) {
        beanDesc = ClassUtil.nameOf(bean.getBeanClass());
    }
    msg = String.format(""Invalid type definition for type %s: %s"", beanDesc, _format(msg, msgArgs));
    throw InvalidDefinitionException.from(getGenerator(), msg, bean, null);
}","public void test5759() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    Object[] objectArray0 = new Object[9];
    // Undeclared exception!
    try {
        defaultSerializerProvider_Impl0.reportBadTypeDefinition((BeanDescription) null, ""%Q>/-FWo"", objectArray0);
        fail(""Expecting exception: UnknownFormatConversionException"");
    } catch (UnknownFormatConversionException e) {
        //
        // Conversion = 'Q'
        //
        verifyException(""java.util.Formatter$FormatSpecifier"", e);
    }
}","/**
 * Helper method called to indicate problem in POJO (serialization) definitions or settings
 * regarding specific Java type, unrelated to actual JSON content to map.
 * Default behavior is to construct and throw a {@link JsonMappingException}.
 *
 * @since 2.9
 */"
"public <T> T reportBadTypeDefinition(BeanDescription bean, String msg, Object... msgArgs) throws JsonMappingException {
    String beanDesc = ""N/A"";
    if (bean != null) {
        beanDesc = ClassUtil.nameOf(bean.getBeanClass());
    }
    msg = String.format(""Invalid type definition for type %s: %s"", beanDesc, _format(msg, msgArgs));
    throw InvalidDefinitionException.from(getGenerator(), msg, bean, null);
}","public void test5860() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forSerialization(pOJOPropertiesCollector0);
    Object[] objectArray0 = new Object[2];
    // Undeclared exception!
    try {
        serializerProvider0.reportBadTypeDefinition((BeanDescription) basicBeanDescription0, (String) null, objectArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.BeanDescription"", e);
    }
}","/**
 * Helper method called to indicate problem in POJO (serialization) definitions or settings
 * regarding specific Java type, unrelated to actual JSON content to map.
 * Default behavior is to construct and throw a {@link JsonMappingException}.
 *
 * @since 2.9
 */"
"public <T> T reportBadPropertyDefinition(BeanDescription bean, BeanPropertyDefinition prop, String message, Object... msgArgs) throws JsonMappingException {
    message = _format(message, msgArgs);
    String propName = ""N/A"";
    if (prop != null) {
        propName = _quotedString(prop.getName());
    }
    String beanDesc = ""N/A"";
    if (bean != null) {
        beanDesc = ClassUtil.nameOf(bean.getBeanClass());
    }
    message = String.format(""Invalid definition for property %s (of type %s): %s"", propName, beanDesc, message);
    throw InvalidDefinitionException.from(getGenerator(), message, bean, prop);
}","public void test5961() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    SerializerProvider serializerProvider0 = objectMapper0.getSerializerProviderInstance();
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    Object[] objectArray0 = new Object[0];
    // Undeclared exception!
    try {
        serializerProvider0.reportBadPropertyDefinition((BeanDescription) basicBeanDescription0, (BeanPropertyDefinition) null, """", objectArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.BeanDescription"", e);
    }
}","/**
 * Helper method called to indicate problem in POJO (serialization) definitions or settings
 * regarding specific property (of a type), unrelated to actual JSON content to map.
 * Default behavior is to construct and throw a {@link JsonMappingException}.
 *
 * @since 2.9
 */"
"public <T> T reportBadPropertyDefinition(BeanDescription bean, BeanPropertyDefinition prop, String message, Object... msgArgs) throws JsonMappingException {
    message = _format(message, msgArgs);
    String propName = ""N/A"";
    if (prop != null) {
        propName = _quotedString(prop.getName());
    }
    String beanDesc = ""N/A"";
    if (bean != null) {
        beanDesc = ClassUtil.nameOf(bean.getBeanClass());
    }
    message = String.format(""Invalid definition for property %s (of type %s): %s"", propName, beanDesc, message);
    throw InvalidDefinitionException.from(getGenerator(), message, bean, prop);
}","public void test6062() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    Object[] objectArray0 = new Object[2];
    try {
        defaultSerializerProvider_Impl0.reportBadPropertyDefinition((BeanDescription) null, (BeanPropertyDefinition) null, ""avMKyX^h|i"", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Invalid definition for property N/A (of type N/A): avMKyX^h|i
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}","/**
 * Helper method called to indicate problem in POJO (serialization) definitions or settings
 * regarding specific property (of a type), unrelated to actual JSON content to map.
 * Default behavior is to construct and throw a {@link JsonMappingException}.
 *
 * @since 2.9
 */"
"/*
    /********************************************************
    /* Helper methods
    /********************************************************
     */
protected void _reportIncompatibleRootType(Object value, JavaType rootType) throws IOException {
    // One special case: allow primitive/wrapper type coercion
    if (rootType.isPrimitive()) {
        Class<?> wrapperType = ClassUtil.wrapperType(rootType.getRawClass());
        // If it's just difference between wrapper, primitive, let it slide
        if (wrapperType.isAssignableFrom(value.getClass())) {
            return;
        }
    }
    reportBadDefinition(rootType, String.format(""Incompatible types: declared root type (%s) vs %s"", rootType, ClassUtil.classNameOf(value)));
}","public void test6163() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    Class<BeanPropertyWriter> class0 = BeanPropertyWriter.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    try {
        ((SerializerProvider) defaultSerializerProvider_Impl0)._reportIncompatibleRootType(class0, simpleType0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Incompatible types: declared root type ([simple type, class com.fasterxml.jackson.databind.ser.BeanPropertyWriter]) vs `java.lang.Class`
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test6264() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    Class<MockSimpleDateFormat> class0 = MockSimpleDateFormat.class;
    defaultSerializerProvider_Impl0.findTypedValueSerializer(class0, true, (BeanProperty) null);
    ((SerializerProvider) defaultSerializerProvider_Impl0)._findExplicitUntypedSerializer(class0);
    assertEquals(4, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test6365() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    Class<BeanSerializer> class0 = BeanSerializer.class;
    JsonSerializer<Object> jsonSerializer0 = ((SerializerProvider) defaultSerializerProvider_Impl0)._findExplicitUntypedSerializer(class0);
    ((SerializerProvider) defaultSerializerProvider_Impl0)._handleContextualResolvable(jsonSerializer0, (BeanProperty) null);
    assertEquals(3, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"public boolean isUnwrappingSerializer() {
    return false;
}","public void test6466() throws Throwable {
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = new DefaultSerializerProvider.Impl();
    JsonSerializer<Object> jsonSerializer0 = ((SerializerProvider) defaultSerializerProvider_Impl0)._handleResolvable(defaultSerializerProvider_Impl0.DEFAULT_NULL_KEY_SERIALIZER);
    assertFalse(jsonSerializer0.isUnwrappingSerializer());
}","/**
 * Accessor for checking whether this serializer is an
 * ""unwrapping"" serializer; this is necessary to know since
 * it may also require caller to suppress writing of the
 * leading property name.
 */"
"/*
    /********************************************************
    /* Access to caching details
    /********************************************************
     */
/**
 *  Method that can be used to determine how many serializers this
 *  provider is caching currently
 *  (if it does caching: default implementation does)
 *  Exact count depends on what kind of serializers get cached;
 *  default implementation caches all serializers, including ones that
 *  are eagerly constructed (for optimal access speed)
 * <p>
 *  The main use case for this method is to allow conditional flushing of
 *  serializer cache, if certain number of entries is reached.
 */
public int cachedSerializersCount() {
    return _serializerCache.size();
}","public void test6567() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    JsonSerializer<Object> jsonSerializer0 = defaultSerializerProvider_Impl0.findValueSerializer((JavaType) collectionLikeType0);
    defaultSerializerProvider_Impl0.serializerInstance((Annotated) null, jsonSerializer0);
    assertEquals(2, defaultSerializerProvider_Impl0.cachedSerializersCount());
}",""
"/*
    /**********************************************************
    /* Internal methods
    /**********************************************************
     */
protected final DateFormat _dateFormat() {
    if (_dateFormat != null) {
        return _dateFormat;
    }
    /* At this point, all timezone configuration should have occurred, with respect
         * to default dateformat configuration. But we still better clone
         * an instance as formatters are stateful, not thread-safe.
         */
    DateFormat df = _config.getDateFormat();
    _dateFormat = df = (DateFormat) df.clone();
    // [databind#939]: 26-Sep-2015, tatu: With 2.6, formatter has been (pre)configured
    // with TimeZone, so we should NOT try overriding it unlike with earlier versions
    /*
        TimeZone tz = getTimeZone();
        if (tz != df.getTimeZone()) {
            df.setTimeZone(tz);
        }
        */
    return df;
}","public void test6668() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultSerializerProvider.Impl defaultSerializerProvider_Impl0 = (DefaultSerializerProvider.Impl) objectMapper0.getSerializerProviderInstance();
    StdDateFormat stdDateFormat0 = (StdDateFormat) ((SerializerProvider) defaultSerializerProvider_Impl0)._dateFormat();
    StdDateFormat stdDateFormat1 = (StdDateFormat) ((SerializerProvider) defaultSerializerProvider_Impl0)._dateFormat();
    assertSame(stdDateFormat1, stdDateFormat0);
}",""
