focal_method,test_prefix,docstring
"/*
    /********************************************************
    /* Configuration handling: fluent factories
    /********************************************************
     */
/**
 * Convenience method for creating a new factory instance with additional deserializer
 * provider.
 */
@Override
public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {
    return withConfig(_factoryConfig.withAdditionalDeserializers(additional));
}","public void test000() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    // Undeclared exception!
    try {
        beanDeserializerFactory0.withAdditionalDeserializers((Deserializers) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot pass null Deserializers
        //
        verifyException(""com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig"", e);
    }
}",""
"@Override
public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {
    return withConfig(_factoryConfig.withDeserializerModifier(modifier));
}","public void test011() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    // Undeclared exception!
    try {
        beanDeserializerFactory0.withDeserializerModifier((BeanDeserializerModifier) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot pass null modifier
        //
        verifyException(""com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig"", e);
    }
}","/**
 * Convenience method for creating a new factory instance with additional
 * {@link BeanDeserializerModifier}.
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test022() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    int[] intArray0 = new int[3];
    BatchUpdateException batchUpdateException0 = new BatchUpdateException(intArray0);
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(batchUpdateException0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"// since 2.8
@Deprecated
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException {
    return resolveMemberAndTypeAnnotations(ctxt, member, type);
}","public void test033() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    Class<AsArrayTypeDeserializer> class0 = AsArrayTypeDeserializer.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    MapLikeType mapLikeType0 = MapLikeType.upgradeFrom(simpleType0, simpleType0, simpleType0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.resolveType(defaultDeserializationContext_Impl0, basicBeanDescription0, mapLikeType0, (AnnotatedMember) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}","/**
 * @deprecated since 2.8 call {@link #resolveMemberAndTypeAnnotations} instead.
 */"
"public boolean hasDeserializers() {
    return _additionalDeserializers.length > 0;
}","public void test044() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DeserializerFactoryConfig deserializerFactoryConfig0 = beanDeserializerFactory0.getFactoryConfig();
    assertFalse(deserializerFactoryConfig0.hasDeserializers());
}",""
"@Override
public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {
    return withConfig(_factoryConfig.withValueInstantiators(instantiators));
}","public void test055() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    SimpleValueInstantiators simpleValueInstantiators0 = new SimpleValueInstantiators();
    DeserializerFactory deserializerFactory0 = beanDeserializerFactory0.withValueInstantiators(simpleValueInstantiators0);
    assertNotSame(beanDeserializerFactory0, deserializerFactory0);
}","/**
 * Convenience method for creating a new factory instance with additional
 * {@link ValueInstantiators}.
 */"
"// 01-Dec-2016, tatu: As per [databind#265] we cannot yet support passing
//   of unwrapped values through creator properties, so fail fast
protected void _reportUnwrappedCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedParameter param) throws JsonMappingException {
    ctxt.reportBadDefinition(beanDesc.getType(), String.format(""Cannot define Creator parameter %d as `@JsonUnwrapped`: combination not yet supported"", param.getIndex()));
}","public void test066() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0._reportUnwrappedCreatorProperty(defaultDeserializationContext_Impl0, basicBeanDescription0, (AnnotatedParameter) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"@Override
public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {
    return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional));
}","public void test077() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    StdKeyDeserializers stdKeyDeserializers0 = new StdKeyDeserializers();
    DeserializerFactory deserializerFactory0 = beanDeserializerFactory0.withAdditionalKeyDeserializers(stdKeyDeserializers0);
    assertNotSame(deserializerFactory0, beanDeserializerFactory0);
}","/**
 * Convenience method for creating a new factory instance with additional
 * {@link KeyDeserializers}.
 */"
"@Override
public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {
    return withConfig(_factoryConfig.withAbstractTypeResolver(resolver));
}","public void test088() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    SimpleAbstractTypeResolver simpleAbstractTypeResolver0 = new SimpleAbstractTypeResolver();
    DeserializerFactory deserializerFactory0 = beanDeserializerFactory0.withAbstractTypeResolver(simpleAbstractTypeResolver0);
    assertNotSame(beanDeserializerFactory0, deserializerFactory0);
}","/**
 * Convenience method for creating a new factory instance with additional
 * {@link AbstractTypeResolver}.
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test099() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ConcurrentHashMap<AnnotatedMethod, Boolean> concurrentHashMap0 = new ConcurrentHashMap<AnnotatedMethod, Boolean>();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(concurrentHashMap0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"@Override
public final boolean isFinal() {
    return Modifier.isFinal(_class.getModifiers());
}","public void test1010() throws Throwable {
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    SimpleAbstractTypeResolver simpleAbstractTypeResolver0 = new SimpleAbstractTypeResolver();
    DeserializerFactoryConfig deserializerFactoryConfig1 = deserializerFactoryConfig0.withAbstractTypeResolver(simpleAbstractTypeResolver0);
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig1);
    Class<CollectionType> class0 = CollectionType.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    JavaType javaType0 = beanDeserializerFactory0.mapAbstractType((DeserializationConfig) null, simpleType0);
    assertTrue(javaType0.isFinal());
}",""
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test1111() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    BeanDeserializerBuilder beanDeserializerBuilder0 = new BeanDeserializerBuilder((BeanDescription) null, defaultDeserializationContext_Impl0);
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(beanDeserializerBuilder0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {
    if (instDef == null) {
        return null;
    }
    ValueInstantiator inst;
    if (instDef instanceof ValueInstantiator) {
        return (ValueInstantiator) instDef;
    }
    if (!(instDef instanceof Class)) {
        throw new IllegalStateException(""AnnotationIntrospector returned key deserializer definition of type "" + instDef.getClass().getName() + ""; expected type KeyDeserializer or Class<KeyDeserializer> instead"");
    }
    Class<?> instClass = (Class<?>) instDef;
    if (ClassUtil.isBogusClass(instClass)) {
        return null;
    }
    if (!ValueInstantiator.class.isAssignableFrom(instClass)) {
        throw new IllegalStateException(""AnnotationIntrospector returned Class "" + instClass.getName() + ""; expected Class<ValueInstantiator>"");
    }
    HandlerInstantiator hi = config.getHandlerInstantiator();
    if (hi != null) {
        inst = hi.valueInstantiatorInstance(config, annotated, instClass);
        if (inst != null) {
            return inst;
        }
    }
    return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers());
}","public void test1212() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    TextNode textNode0 = TextNode.valueOf(""java.com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder"");
    // Undeclared exception!
    try {
        beanDeserializerFactory0._valueInstantiatorInstance((DeserializationConfig) null, (Annotated) null, textNode0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // AnnotationIntrospector returned key deserializer definition of type com.fasterxml.jackson.databind.node.TextNode; expected type KeyDeserializer or Class<KeyDeserializer> instead
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException {
    if (instDef == null) {
        return null;
    }
    ValueInstantiator inst;
    if (instDef instanceof ValueInstantiator) {
        return (ValueInstantiator) instDef;
    }
    if (!(instDef instanceof Class)) {
        throw new IllegalStateException(""AnnotationIntrospector returned key deserializer definition of type "" + instDef.getClass().getName() + ""; expected type KeyDeserializer or Class<KeyDeserializer> instead"");
    }
    Class<?> instClass = (Class<?>) instDef;
    if (ClassUtil.isBogusClass(instClass)) {
        return null;
    }
    if (!ValueInstantiator.class.isAssignableFrom(instClass)) {
        throw new IllegalStateException(""AnnotationIntrospector returned Class "" + instClass.getName() + ""; expected Class<ValueInstantiator>"");
    }
    HandlerInstantiator hi = config.getHandlerInstantiator();
    if (hi != null) {
        inst = hi.valueInstantiatorInstance(config, annotated, instClass);
        if (inst != null) {
            return inst;
        }
    }
    return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers());
}","public void test1313() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    ValueInstantiator valueInstantiator0 = beanDeserializerFactory0._valueInstantiatorInstance((DeserializationConfig) null, (Annotated) null, (Object) null);
    assertNull(valueInstantiator0);
}",""
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test1414() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    SQLClientInfoException sQLClientInfoException0 = new SQLClientInfoException();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(sQLClientInfoException0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test1515() throws Throwable {
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE;
    objectMapper0.enableDefaultTypingAsProperty(objectMapper_DefaultTyping0, ""JSON"");
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(typeBindings0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test1616() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TreeSet<SQLTransientException> treeSet0 = new TreeSet<SQLTransientException>();
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(treeSet0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"public ObjectReader readerForUpdating(Object valueToUpdate) {
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public void test1717() throws Throwable {
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectReader objectReader0 = objectMapper0.readerForUpdating(basicBeanDescription0);
    assertNotNull(objectReader0);
}","/**
 * Factory method for constructing {@link ObjectReader} that will
 * update given Object (usually Bean, but can be a Collection or Map
 * as well, but NOT an array) with JSON data. Deserialization occurs
 * normally except that the root-level value in JSON is not used for
 * instantiating a new object; instead give updateable object is used
 * as root.
 * Runtime type of value object is used for locating deserializer,
 * unless overridden by other factory methods of {@link ObjectReader}
 */"
"protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config) {
    Class<?> collectionClass = type.getRawClass();
    collectionClass = _collectionFallbacks.get(collectionClass.getName());
    if (collectionClass == null) {
        return null;
    }
    return (CollectionType) config.constructSpecializedType(type, collectionClass);
}","public void test1818() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<BuilderBasedDeserializer> class0 = BuilderBasedDeserializer.class;
    CollectionLikeType collectionLikeType0 = typeFactory0.constructRawCollectionLikeType(class0);
    CollectionType collectionType0 = beanDeserializerFactory0._mapAbstractCollectionType(collectionLikeType0, (DeserializationConfig) null);
    assertNull(collectionType0);
}",""
"// Copied almost verbatim from ""createCollectionDeserializer"" -- should try to share more code
@Override
public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException {
    JavaType contentType = type.getContentType();
    // Very first thing: is deserializer hard-coded for elements?
    JsonDeserializer<Object> contentDeser = contentType.getValueHandler();
    final DeserializationConfig config = ctxt.getConfig();
    // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:
    TypeDeserializer contentTypeDeser = contentType.getTypeHandler();
    // but if not, may still be possible to find:
    if (contentTypeDeser == null) {
        contentTypeDeser = findTypeDeserializer(config, contentType);
    }
    JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser);
    if (deser != null) {
        // and then new with 2.2: ability to post-process it too (Issue#120)
        if (_factoryConfig.hasDeserializerModifiers()) {
            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser);
            }
        }
    }
    return deser;
}","public void test1919() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ConcurrentHashMap> class0 = ConcurrentHashMap.class;
    Class<List> class1 = List.class;
    CollectionType collectionType0 = typeFactory0.constructCollectionType(class1, class0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.createCollectionLikeDeserializer(defaultDeserializationContext_Impl0, collectionType0, (BeanDescription) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"// Copied almost verbatim from ""createMapDeserializer"" -- should try to share more code
@Override
public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException {
    JavaType keyType = type.getKeyType();
    JavaType contentType = type.getContentType();
    final DeserializationConfig config = ctxt.getConfig();
    // First: is there annotation-specified deserializer for values?
    @SuppressWarnings(""unchecked"")
    JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();
    // Ok: need a key deserializer (null indicates 'default' here)
    KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();
    /* !!! 24-Jan-2012, tatu: NOTE: impls MUST use resolve() to find key deserializer!
        if (keyDes == null) {
            keyDes = p.findKeyDeserializer(config, keyType, property);
        }
        */
    // Then optional type info (1.5); either attached to type, or resolve separately:
    TypeDeserializer contentTypeDeser = contentType.getTypeHandler();
    // but if not, may still be possible to find:
    if (contentTypeDeser == null) {
        contentTypeDeser = findTypeDeserializer(config, contentType);
    }
    JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser);
    if (deser != null) {
        // and then new with 2.2: ability to post-process it too (Issue#120)
        if (_factoryConfig.hasDeserializerModifiers()) {
            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser);
            }
        }
    }
    return deser;
}","public void test2020() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ConcurrentHashMap> class0 = ConcurrentHashMap.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class0, class0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.createMapLikeDeserializer(defaultDeserializationContext_Impl0, mapType0, (BeanDescription) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"@Override
public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt, ReferenceType type, BeanDescription beanDesc) throws JsonMappingException {
    JavaType contentType = type.getContentType();
    // Very first thing: is deserializer hard-coded for elements?
    JsonDeserializer<Object> contentDeser = contentType.getValueHandler();
    final DeserializationConfig config = ctxt.getConfig();
    // Then optional type info: if type has been resolved, we may already know type deserializer:
    TypeDeserializer contentTypeDeser = contentType.getTypeHandler();
    if (contentTypeDeser == null) {
        // or if not, may be able to find:
        contentTypeDeser = findTypeDeserializer(config, contentType);
    }
    JsonDeserializer<?> deser = _findCustomReferenceDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser);
    if (deser == null) {
        // Just one referential type as of JDK 1.7 / Java 7: AtomicReference (Java 8 adds Optional)
        if (type.isTypeOrSubTypeOf(AtomicReference.class)) {
            Class<?> rawType = type.getRawClass();
            ValueInstantiator inst;
            if (rawType == AtomicReference.class) {
                inst = null;
            } else {
                /* 23-Oct-2016, tatu: Note that subtypes are probably not supportable
                     *    without either forcing merging (to avoid having to create instance)
                     *    or something else...
                     */
                inst = findValueInstantiator(ctxt, beanDesc);
            }
            return new AtomicReferenceDeserializer(type, inst, contentTypeDeser, contentDeser);
        }
    }
    if (deser != null) {
        // and then post-process
        if (_factoryConfig.hasDeserializerModifiers()) {
            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                deser = mod.modifyReferenceDeserializer(config, type, beanDesc, deser);
            }
        }
    }
    return deser;
}","public void test2121() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<ConcurrentHashMap> class0 = ConcurrentHashMap.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class0, class0);
    ReferenceType referenceType0 = ReferenceType.upgradeFrom(mapType0, mapType0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.createReferenceDeserializer(defaultDeserializationContext_Impl0, referenceType0, (BeanDescription) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {
    Class<?> rawType = type.getRawClass();
    // Object (""untyped""), String equivalents:
    if (rawType == CLASS_OBJECT) {
        // 11-Feb-2015, tatu: As per [databind#700] need to be careful wrt non-default Map, List.
        DeserializationConfig config = ctxt.getConfig();
        JavaType lt, mt;
        if (_factoryConfig.hasAbstractTypeResolvers()) {
            lt = _findRemappedType(config, List.class);
            mt = _findRemappedType(config, Map.class);
        } else {
            lt = mt = null;
        }
        return new UntypedObjectDeserializer(lt, mt);
    }
    if (rawType == CLASS_STRING || rawType == CLASS_CHAR_SEQUENCE) {
        return StringDeserializer.instance;
    }
    if (rawType == CLASS_ITERABLE) {
        // [databind#199]: Can and should 'upgrade' to a Collection type:
        TypeFactory tf = ctxt.getTypeFactory();
        JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);
        JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];
        CollectionType ct = tf.constructCollectionType(Collection.class, elemType);
        // Should we re-introspect beanDesc? For now let's not...
        return createCollectionDeserializer(ctxt, ct, beanDesc);
    }
    if (rawType == CLASS_MAP_ENTRY) {
        // 28-Apr-2015, tatu: TypeFactory does it all for us already so
        JavaType kt = type.containedTypeOrUnknown(0);
        JavaType vt = type.containedTypeOrUnknown(1);
        TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();
        if (vts == null) {
            vts = findTypeDeserializer(ctxt.getConfig(), vt);
        }
        JsonDeserializer<Object> valueDeser = vt.getValueHandler();
        KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();
        return new MapEntryDeserializer(type, keyDes, valueDeser, vts);
    }
    String clsName = rawType.getName();
    if (rawType.isPrimitive() || clsName.startsWith(""java."")) {
        // Primitives/wrappers, other Numbers:
        JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);
        if (deser == null) {
            deser = DateDeserializers.find(rawType, clsName);
        }
        if (deser != null) {
            return deser;
        }
    }
    // and a few Jackson types as well:
    if (rawType == TokenBuffer.class) {
        return new TokenBufferDeserializer();
    }
    JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);
    if (deser != null) {
        return deser;
    }
    return JdkDeserializers.find(rawType, clsName);
}","public void test2222() throws Throwable {
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    SimpleAbstractTypeResolver simpleAbstractTypeResolver0 = new SimpleAbstractTypeResolver();
    DeserializerFactoryConfig deserializerFactoryConfig1 = deserializerFactoryConfig0.withAbstractTypeResolver(simpleAbstractTypeResolver0);
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig1);
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
    JavaType javaType0 = beanProperty_Bogus0.getType();
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.findDefaultDeserializer(deserializationContext0, javaType0, basicBeanDescription0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}","/**
 * Helper method called to find one of default serializers for ""well-known""
 * platform types: JDK-provided types, and small number of public Jackson
 * API types.
 *
 * @since 2.2
 */"
"protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {
    for (Deserializers d : _factoryConfig.deserializers()) {
        JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer);
        if (deser != null) {
            return deser;
        }
    }
    return null;
}","public void test2323() throws Throwable {
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    Deserializers.Base deserializers_Base0 = new Deserializers.Base();
    DeserializerFactoryConfig deserializerFactoryConfig1 = deserializerFactoryConfig0.withAdditionalDeserializers(deserializers_Base0);
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig1);
    Class<UTF8StreamJsonParser> class0 = UTF8StreamJsonParser.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    JsonDeserializer<?> jsonDeserializer0 = beanDeserializerFactory0.createTreeDeserializer((DeserializationConfig) null, simpleType0, (BeanDescription) null);
    MapLikeType mapLikeType0 = MapLikeType.upgradeFrom(simpleType0, simpleType0, simpleType0);
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(mapLikeType0, typeFactory0);
    AsArrayTypeDeserializer asArrayTypeDeserializer0 = new AsArrayTypeDeserializer(mapLikeType0, classNameIdResolver0, ""@JsonUnwrapped"", false, mapLikeType0);
    JsonDeserializer<?> jsonDeserializer1 = beanDeserializerFactory0._findCustomMapLikeDeserializer(mapLikeType0, (DeserializationConfig) null, (BeanDescription) null, (KeyDeserializer) null, asArrayTypeDeserializer0, jsonDeserializer0);
    assertNull(jsonDeserializer1);
}",""
"protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer) throws JsonMappingException {
    for (Deserializers d : _factoryConfig.deserializers()) {
        JsonDeserializer<?> deser = d.findReferenceDeserializer(type, config, beanDesc, contentTypeDeserializer, contentDeserializer);
        if (deser != null) {
            return deser;
        }
    }
    return null;
}","public void test2424() throws Throwable {
    Class<POJOPropertyBuilder> class0 = POJOPropertyBuilder.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) simpleType0);
    JavaType[] javaTypeArray0 = new JavaType[4];
    javaTypeArray0[0] = (JavaType) simpleType0;
    javaTypeArray0[2] = (JavaType) simpleType0;
    ReferenceType referenceType0 = ReferenceType.construct((Class<?>) class0, typeBindings0, (JavaType) simpleType0, javaTypeArray0, javaTypeArray0[2]);
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(referenceType0, typeFactory0);
    MapLikeType mapLikeType0 = MapLikeType.upgradeFrom(referenceType0, referenceType0, javaTypeArray0[0]);
    ArrayType arrayType0 = ArrayType.construct(javaTypeArray0[0], typeBindings0, (Object) javaTypeArray0[2], (Object) mapLikeType0);
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.WRAPPER_OBJECT;
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(referenceType0, classNameIdResolver0, ""_QJXN?E,w0"", false, arrayType0, jsonTypeInfo_As0);
    JsonDeserializer<?> jsonDeserializer0 = beanDeserializerFactory0._findCustomReferenceDeserializer(referenceType0, (DeserializationConfig) null, (BeanDescription) null, asPropertyTypeDeserializer0, (JsonDeserializer<?>) null);
    assertNull(jsonDeserializer0);
}",""
"/*
    /**********************************************************
    /* DeserializerFactory API implementation
    /**********************************************************
     */
/**
 * Method that {@link DeserializerCache}s call to create a new
 * deserializer for types other than Collections, Maps, arrays and
 * enums.
 */
@Override
public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {
    final DeserializationConfig config = ctxt.getConfig();
    // We may also have custom overrides:
    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);
    if (custom != null) {
        return custom;
    }
    /* One more thing to check: do we have an exception type
         * (Throwable or its sub-classes)? If so, need slightly
         * different handling.
         */
    if (type.isThrowable()) {
        return buildThrowableDeserializer(ctxt, type, beanDesc);
    }
    // Or, for abstract types, may have alternate means for resolution
    // (defaulting, materialization)
    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are
    //    not something we could materialize anything for
    if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {
        // Let's make it possible to materialize abstract types.
        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);
        if (concreteType != null) {
            /* important: introspect actual implementation (abstract class or
                 * interface doesn't have constructors, for one)
                 */
            beanDesc = config.introspect(concreteType);
            return buildBeanDeserializer(ctxt, concreteType, beanDesc);
        }
    }
    // Otherwise, may want to check handlers for standard types, from superclass:
    @SuppressWarnings(""unchecked"")
    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);
    if (deser != null) {
        return deser;
    }
    // Otherwise: could the class be a Bean class? If not, bail out
    if (!isPotentialBeanType(type.getRawClass())) {
        return null;
    }
    // For checks like [databind#1599]
    _validateSubType(ctxt, type, beanDesc);
    // Use generic bean introspection to build deserializer
    return buildBeanDeserializer(ctxt, type, beanDesc);
}","public void test2525() throws Throwable {
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    Deserializers.Base deserializers_Base0 = new Deserializers.Base();
    DeserializerFactoryConfig deserializerFactoryConfig1 = deserializerFactoryConfig0.withAdditionalDeserializers(deserializers_Base0);
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig1);
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.createBeanDeserializer(defaultDeserializationContext_Impl0, (JavaType) null, basicBeanDescription0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BeanDeserializerFactory"", e);
    }
}",""
"protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException {
    for (Deserializers d : _factoryConfig.deserializers()) {
        JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer);
        if (deser != null) {
            return deser;
        }
    }
    return null;
}","public void test2626() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<List> class0 = List.class;
    Class<MapType> class1 = MapType.class;
    CollectionType collectionType0 = typeFactory0.constructCollectionType(class0, class1);
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(collectionType0, typeFactory0);
    JsonTypeInfo.As jsonTypeInfo_As0 = JsonTypeInfo.As.WRAPPER_ARRAY;
    AsPropertyTypeDeserializer asPropertyTypeDeserializer0 = new AsPropertyTypeDeserializer(collectionType0, classNameIdResolver0, ""java.com.fasterxl.jackson.databind.cfg.DeserializerFactoryConfig"", true, collectionType0, jsonTypeInfo_As0);
    JsonDeserializer<?> jsonDeserializer0 = beanDeserializerFactory0._findCustomCollectionLikeDeserializer(collectionType0, (DeserializationConfig) null, (BeanDescription) null, asPropertyTypeDeserializer0, (JsonDeserializer<?>) null);
    assertNull(jsonDeserializer0);
}",""
"protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException {
    for (Deserializers d : _factoryConfig.deserializers()) {
        JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);
        if (deser != null) {
            return deser;
        }
    }
    return null;
}","public void test2727() throws Throwable {
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    Deserializers.Base deserializers_Base0 = new Deserializers.Base();
    DeserializerFactoryConfig deserializerFactoryConfig1 = deserializerFactoryConfig0.withAdditionalDeserializers(deserializers_Base0);
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig1);
    Class<POJOPropertyBuilder> class0 = POJOPropertyBuilder.class;
    JsonDeserializer<?> jsonDeserializer0 = beanDeserializerFactory0._findCustomEnumDeserializer(class0, (DeserializationConfig) null, (BeanDescription) null);
    assertNull(jsonDeserializer0);
}",""
"protected EnumResolver constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMember jsonValueAccessor) {
    if (jsonValueAccessor != null) {
        if (config.canOverrideAccessModifiers()) {
            ClassUtil.checkAndFixAccess(jsonValueAccessor.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
        }
        return EnumResolver.constructUnsafeUsingMethod(enumClass, jsonValueAccessor, config.getAnnotationIntrospector());
    }
    // 14-Mar-2016, tatu: We used to check `DeserializationFeature.READ_ENUMS_USING_TO_STRING`
    //   here, but that won't do: it must be dynamically changeable...
    return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());
}","public void test2828() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    Class<SQLFeatureNotSupportedException> class0 = SQLFeatureNotSupportedException.class;
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    PlaceholderForType placeholderForType0 = new PlaceholderForType(2);
    ReferenceType referenceType0 = ReferenceType.upgradeFrom(placeholderForType0, placeholderForType0);
    TypeBindings typeBindings0 = TypeBindings.createIfNeeded((Class<?>) class0, (JavaType) referenceType0);
    TypeResolutionContext.Basic typeResolutionContext_Basic0 = new TypeResolutionContext.Basic(typeFactory0, typeBindings0);
    VirtualAnnotatedMember virtualAnnotatedMember0 = new VirtualAnnotatedMember(typeResolutionContext_Basic0, class0, ""-#c+Bagd~dxM"", referenceType0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.constructEnumResolver(class0, (DeserializationConfig) null, virtualAnnotatedMember0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"// not used, possibly remove as early as 2.9
@Deprecated
protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) {
    if (enumType == null) {
        return null;
    }
    BeanDescription beanDesc = config.introspect(enumType);
    return beanDesc.findJsonValueMethod();
}","public void test2929() throws Throwable {
    Class<POJOPropertyBuilder> class0 = POJOPropertyBuilder.class;
    SimpleType simpleType0 = SimpleType.constructUnsafe(class0);
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    // Undeclared exception!
    try {
        beanDeserializerFactory0._findJsonValueFor((DeserializationConfig) null, simpleType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}","/**
 * @deprecated since 2.8 call <code>findJsonValueMethod</code> on {@link BeanDescription} instead
 */"
"// not used, possibly remove as early as 2.9
@Deprecated
protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) {
    if (enumType == null) {
        return null;
    }
    BeanDescription beanDesc = config.introspect(enumType);
    return beanDesc.findJsonValueMethod();
}","public void test3030() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    AnnotatedMethod annotatedMethod0 = beanDeserializerFactory0._findJsonValueFor((DeserializationConfig) null, (JavaType) null);
    assertNull(annotatedMethod0);
}","/**
 * @deprecated since 2.8 call <code>findJsonValueMethod</code> on {@link BeanDescription} instead
 */"
