focal_method,test_prefix,docstring
"@Override
public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException {
    // First: need a BeanDescription for builder class
    JavaType builderType = ctxt.constructType(builderClass);
    BeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType);
    return buildBuilderBasedDeserializer(ctxt, valueType, builderDesc);
}","public void test011() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    Class<ResolverStyle> class0 = ResolverStyle.class;
    // Undeclared exception!
    try {
        beanDeserializerFactory0.createBuilderBasedDeserializer(defaultDeserializationContext_Impl0, (JavaType) null, (BeanDescription) null, class0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}",""
"// since 2.9 (rename)
@Deprecated
protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {
    addBackReferenceProperties(ctxt, beanDesc, builder);
}","public void test022() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    BeanDeserializerBuilder beanDeserializerBuilder0 = beanDeserializerFactory0.constructBeanDeserializerBuilder(defaultDeserializationContext_Impl0, (BeanDescription) null);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.addReferenceProperties(defaultDeserializationContext_Impl0, (BeanDescription) null, beanDeserializerBuilder0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BeanDeserializerFactory"", e);
    }
}",""
"@Override
public DeserializerFactory withConfig(DeserializerFactoryConfig config) {
    if (_factoryConfig == config) {
        return this;
    }
    /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;
         *    and we pretty much have to here either choose between losing subtype instance
         *    when registering additional deserializers, or losing deserializers.
         *    Instead, let's actually just throw an error if this method is called when subtype
         *    has not properly overridden this method; this to indicate problem as soon as possible.
         */
    ClassUtil.verifyMustOverride(BeanDeserializerFactory.class, this, ""withConfig"");
    return new BeanDeserializerFactory(config);
}","public void test033() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DeserializerFactory deserializerFactory0 = beanDeserializerFactory0.withConfig((DeserializerFactoryConfig) null);
    assertNotSame(deserializerFactory0, beanDeserializerFactory0);
}","/**
 * Method used by module registration functionality, to construct a new bean
 * deserializer factory
 * with different configuration settings.
 */"
"@Override
public DeserializerFactory withConfig(DeserializerFactoryConfig config) {
    if (_factoryConfig == config) {
        return this;
    }
    /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;
         *    and we pretty much have to here either choose between losing subtype instance
         *    when registering additional deserializers, or losing deserializers.
         *    Instead, let's actually just throw an error if this method is called when subtype
         *    has not properly overridden this method; this to indicate problem as soon as possible.
         */
    ClassUtil.verifyMustOverride(BeanDeserializerFactory.class, this, ""withConfig"");
    return new BeanDeserializerFactory(config);
}","public void test044() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory((DeserializerFactoryConfig) null);
    DeserializerFactory deserializerFactory0 = beanDeserializerFactory0.withConfig((DeserializerFactoryConfig) null);
    assertSame(deserializerFactory0, beanDeserializerFactory0);
}","/**
 * Method used by module registration functionality, to construct a new bean
 * deserializer factory
 * with different configuration settings.
 */"
"/*
    /**********************************************************
    /* DeserializerFactory API implementation
    /**********************************************************
     */
/**
 * Method that {@link DeserializerCache}s call to create a new
 * deserializer for types other than Collections, Maps, arrays and
 * enums.
 */
@Override
public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {
    final DeserializationConfig config = ctxt.getConfig();
    // We may also have custom overrides:
    JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);
    if (custom != null) {
        return custom;
    }
    /* One more thing to check: do we have an exception type
         * (Throwable or its sub-classes)? If so, need slightly
         * different handling.
         */
    if (type.isThrowable()) {
        return buildThrowableDeserializer(ctxt, type, beanDesc);
    }
    // Or, for abstract types, may have alternate means for resolution
    // (defaulting, materialization)
    // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are
    //    not something we could materialize anything for
    if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {
        // Let's make it possible to materialize abstract types.
        JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);
        if (concreteType != null) {
            /* important: introspect actual implementation (abstract class or
                 * interface doesn't have constructors, for one)
                 */
            beanDesc = config.introspect(concreteType);
            return buildBeanDeserializer(ctxt, concreteType, beanDesc);
        }
    }
    // Otherwise, may want to check handlers for standard types, from superclass:
    @SuppressWarnings(""unchecked"")
    JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);
    if (deser != null) {
        return deser;
    }
    // Otherwise: could the class be a Bean class? If not, bail out
    if (!isPotentialBeanType(type.getRawClass())) {
        return null;
    }
    // For checks like [databind#1599]
    _validateSubType(ctxt, type, beanDesc);
    // Use generic bean introspection to build deserializer
    return buildBeanDeserializer(ctxt, type, beanDesc);
}","public void test077() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    Class<Object> class0 = Object.class;
    ResolvedRecursiveType resolvedRecursiveType0 = new ResolvedRecursiveType(class0, typeBindings0);
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerModifier beanDeserializerModifier0 = mock(BeanDeserializerModifier.class, new ViolatedAssumptionAnswer());
    doReturn((JsonDeserializer) null).when(beanDeserializerModifier0).modifyDeserializer(any(com.fasterxml.jackson.databind.DeserializationConfig.class), any(com.fasterxml.jackson.databind.BeanDescription.class), any(com.fasterxml.jackson.databind.JsonDeserializer.class));
    DeserializerFactoryConfig deserializerFactoryConfig1 = deserializerFactoryConfig0.withDeserializerModifier(beanDeserializerModifier0);
    BeanDeserializerFactory beanDeserializerFactory1 = new BeanDeserializerFactory(deserializerFactoryConfig1);
    // Undeclared exception!
    try {
        beanDeserializerFactory1.createBeanDeserializer(defaultDeserializationContext_Impl0, resolvedRecursiveType0, (BeanDescription) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"", e);
    }
}",""
"protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {
    // May have multiple resolvers, call in precedence order until one returns non-null
    for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) {
        JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), beanDesc);
        if (concrete != null) {
            return concrete;
        }
    }
    return null;
}","public void test088() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    SimpleAbstractTypeResolver simpleAbstractTypeResolver0 = new SimpleAbstractTypeResolver();
    DeserializerFactoryConfig deserializerFactoryConfig1 = deserializerFactoryConfig0.withAbstractTypeResolver(simpleAbstractTypeResolver0);
    BeanDeserializerFactory beanDeserializerFactory1 = new BeanDeserializerFactory(deserializerFactoryConfig1);
    JavaType javaType0 = beanDeserializerFactory1.materializeAbstractType(defaultDeserializationContext_Impl0, (JavaType) null, (BeanDescription) null);
    assertNull(javaType0);
}",""
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test1212() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((Map) null).when(pOJOPropertiesCollector0).getInjectables();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    BeanDeserializerBuilder beanDeserializerBuilder0 = new BeanDeserializerBuilder(basicBeanDescription0, defaultDeserializationContext_Impl0);
    beanDeserializerFactory0.addInjectables(defaultDeserializationContext_Impl0, basicBeanDescription0, beanDeserializerBuilder0);
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException {
    Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();
    if (raw != null) {
        for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {
            AnnotatedMember m = entry.getValue();
            builder.addInjectable(PropertyName.construct(m.getName()), m.getType(), beanDesc.getClassAnnotations(), m, entry.getKey());
        }
    }
}","public void test1313() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    LinkedHashMap<Object, AnnotatedMember> linkedHashMap0 = new LinkedHashMap<Object, AnnotatedMember>();
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn(linkedHashMap0).when(pOJOPropertiesCollector0).getInjectables();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forDeserialization(pOJOPropertiesCollector0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    Integer integer0 = new Integer(225);
    linkedHashMap0.put(integer0, (AnnotatedMember) null);
    BeanDeserializerBuilder beanDeserializerBuilder0 = new BeanDeserializerBuilder(basicBeanDescription0, defaultDeserializationContext_Impl0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.addInjectables(defaultDeserializationContext_Impl0, basicBeanDescription0, beanDeserializerBuilder0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BeanDeserializerFactory"", e);
    }
}","/**
 * Method called locate all members used for value injection (if any),
 * constructor {@link com.fasterxml.jackson.databind.deser.impl.ValueInjector} instances, and add them to builder.
 */"
"@SuppressWarnings(""unchecked"")
protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMember mutator) throws JsonMappingException {
    //find the java type based on the annotated setter method or setter field
    BeanProperty prop;
    JavaType keyType;
    JavaType valueType;
    if (mutator instanceof AnnotatedMethod) {
        // we know it's a 2-arg method, second arg is the value
        AnnotatedMethod am = (AnnotatedMethod) mutator;
        keyType = am.getParameterType(0);
        valueType = am.getParameterType(1);
        valueType = resolveMemberAndTypeAnnotations(ctxt, mutator, valueType);
        prop = new BeanProperty.Std(PropertyName.construct(mutator.getName()), valueType, null, mutator, PropertyMetadata.STD_OPTIONAL);
    } else if (mutator instanceof AnnotatedField) {
        AnnotatedField af = (AnnotatedField) mutator;
        // get the type from the content type of the map object
        JavaType mapType = af.getType();
        mapType = resolveMemberAndTypeAnnotations(ctxt, mutator, mapType);
        keyType = mapType.getKeyType();
        valueType = mapType.getContentType();
        prop = new BeanProperty.Std(PropertyName.construct(mutator.getName()), mapType, null, mutator, PropertyMetadata.STD_OPTIONAL);
    } else {
        return ctxt.reportBadDefinition(beanDesc.getType(), String.format(""Unrecognized mutator type for any setter: %s"", mutator.getClass()));
    }
    // First: see if there are explicitly specified
    // and then possible direct deserializer override on accessor
    KeyDeserializer keyDeser = findKeyDeserializerFromAnnotation(ctxt, mutator);
    if (keyDeser == null) {
        keyDeser = keyType.getValueHandler();
    }
    if (keyDeser == null) {
        keyDeser = ctxt.findKeyDeserializer(keyType, prop);
    } else {
        if (keyDeser instanceof ContextualKeyDeserializer) {
            keyDeser = ((ContextualKeyDeserializer) keyDeser).createContextual(ctxt, prop);
        }
    }
    JsonDeserializer<Object> deser = findContentDeserializerFromAnnotation(ctxt, mutator);
    if (deser == null) {
        deser = valueType.getValueHandler();
    }
    if (deser != null) {
        // As per [databind#462] need to ensure we contextualize deserializer before passing it on
        deser = (JsonDeserializer<Object>) ctxt.handlePrimaryContextualization(deser, prop, valueType);
    }
    TypeDeserializer typeDeser = valueType.getTypeHandler();
    return new SettableAnyProperty(prop, mutator, valueType, keyDeser, deser, typeDeser);
}","public void test1414() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    TypeBindings typeBindings0 = TypeBindings.emptyBindings();
    TypeResolutionContext.Basic typeResolutionContext_Basic0 = new TypeResolutionContext.Basic(typeFactory0, typeBindings0);
    AnnotationMap annotationMap0 = new AnnotationMap();
    AnnotatedField annotatedField0 = new AnnotatedField(typeResolutionContext_Basic0, (Field) null, annotationMap0);
    // Undeclared exception!
    try {
        beanDeserializerFactory0.constructAnySetter(defaultDeserializationContext_Impl0, (BeanDescription) null, annotatedField0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.introspect.AnnotatedField"", e);
    }
}","/**
 * Method called to construct fallback {@link SettableAnyProperty}
 * for handling unknown bean properties, given a method that
 * has been designated as such setter.
 *
 * @param mutator Either 2-argument method (setter, with key and value), or Field
 *     that contains Map; either way accessor used for passing ""any values""
 */"
"/*
    /**********************************************************
    /* Helper methods for Bean deserializer, other
    /**********************************************************
     */
/**
 *  Helper method used to skip processing for types that we know
 *  cannot be (i.e. are never consider to be) beans:
 *  things like primitives, Arrays, Enums, and proxy types.
 * <p>
 *  Note that usually we shouldn't really be getting these sort of
 *  types anyway; but better safe than sorry.
 */
protected boolean isPotentialBeanType(Class<?> type) {
    String typeStr = ClassUtil.canBeABeanType(type);
    if (typeStr != null) {
        throw new IllegalArgumentException(""Cannot deserialize Class "" + type.getName() + "" (of type "" + typeStr + "") as a Bean"");
    }
    if (ClassUtil.isProxyType(type)) {
        throw new IllegalArgumentException(""Cannot deserialize Proxy class "" + type.getName() + "" as a Bean"");
    }
    /* also: can't deserialize some local classes: static are ok; in-method not;
         * other non-static inner classes are ok
         */
    typeStr = ClassUtil.isLocalType(type, true);
    if (typeStr != null) {
        throw new IllegalArgumentException(""Cannot deserialize Class "" + type.getName() + "" (of type "" + typeStr + "") as a Bean"");
    }
    return true;
}","public void test1515() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    Class<Boolean> class0 = Boolean.TYPE;
    // Undeclared exception!
    try {
        beanDeserializerFactory0.isPotentialBeanType(class0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Cannot deserialize Class boolean (of type primitive) as a Bean
        //
        verifyException(""com.fasterxml.jackson.databind.deser.BeanDeserializerFactory"", e);
    }
}",""
