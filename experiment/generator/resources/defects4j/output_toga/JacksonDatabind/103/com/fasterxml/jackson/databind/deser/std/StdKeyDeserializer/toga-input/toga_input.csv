focal_method,test_prefix,docstring
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test022() throws Throwable {
    Class<Short> class0 = Short.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    // Undeclared exception!
    try {
        stdKeyDeserializer0.deserializeKey(""324192"", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test033() throws Throwable {
    Class<Long> class0 = Long.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    // Undeclared exception!
    try {
        stdKeyDeserializer0.deserializeKey(""Iy~&Sa_R<P#tT1.Hq"", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test044() throws Throwable {
    Class<Float> class0 = Float.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    // Undeclared exception!
    try {
        stdKeyDeserializer0.deserializeKey(""problem: %s"", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test066() throws Throwable {
    Class<String> class0 = String.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    Object object0 = stdKeyDeserializer0.deserializeKey(""_jmf!un4AHsUq}"", defaultDeserializationContext_Impl0);
    assertEquals(""_jmf!un4AHsUq}"", object0);
}",""
"public static StdKeyDeserializer forType(Class<?> raw) {
    int kind;
    // first common types:
    if (raw == String.class || raw == Object.class || raw == CharSequence.class) {
        return StringKD.forType(raw);
    } else if (raw == UUID.class) {
        kind = TYPE_UUID;
    } else if (raw == Integer.class) {
        kind = TYPE_INT;
    } else if (raw == Long.class) {
        kind = TYPE_LONG;
    } else if (raw == Date.class) {
        kind = TYPE_DATE;
    } else if (raw == Calendar.class) {
        kind = TYPE_CALENDAR;
        // then less common ones...
    } else if (raw == Boolean.class) {
        kind = TYPE_BOOLEAN;
    } else if (raw == Byte.class) {
        kind = TYPE_BYTE;
    } else if (raw == Character.class) {
        kind = TYPE_CHAR;
    } else if (raw == Short.class) {
        kind = TYPE_SHORT;
    } else if (raw == Float.class) {
        kind = TYPE_FLOAT;
    } else if (raw == Double.class) {
        kind = TYPE_DOUBLE;
    } else if (raw == URI.class) {
        kind = TYPE_URI;
    } else if (raw == URL.class) {
        kind = TYPE_URL;
    } else if (raw == Class.class) {
        kind = TYPE_CLASS;
    } else if (raw == Locale.class) {
        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);
        return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);
    } else if (raw == Currency.class) {
        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);
        return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);
    } else if (raw == byte[].class) {
        kind = TYPE_BYTE_ARRAY;
    } else {
        return null;
    }
    return new StdKeyDeserializer(kind, raw);
}","public void test1010() throws Throwable {
    Class<Object> class0 = Object.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    assertEquals(10, StdKeyDeserializer.TYPE_DATE);
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test1212() throws Throwable {
    Class<Integer> class0 = Integer.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    // Undeclared exception!
    try {
        stdKeyDeserializer0.deserializeKey(""pUfTHR]Hc`a4.6{GS"", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"protected Object _parse(String key, DeserializationContext ctxt) throws Exception {
    switch(_kind) {
        case TYPE_BOOLEAN:
            if (""true"".equals(key)) {
                return Boolean.TRUE;
            }
            if (""false"".equals(key)) {
                return Boolean.FALSE;
            }
            return ctxt.handleWeirdKey(_keyClass, key, ""value not 'true' or 'false'"");
        case TYPE_BYTE:
            {
                int value = _parseInt(key);
                // allow range up to 255, inclusive (to support ""unsigned"" byte)
                if (value < Byte.MIN_VALUE || value > 255) {
                    return ctxt.handleWeirdKey(_keyClass, key, ""overflow, value cannot be represented as 8-bit value"");
                }
                return Byte.valueOf((byte) value);
            }
        case TYPE_SHORT:
            {
                int value = _parseInt(key);
                if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {
                    return ctxt.handleWeirdKey(_keyClass, key, ""overflow, value cannot be represented as 16-bit value"");
                    // fall-through and truncate if need be
                }
                return Short.valueOf((short) value);
            }
        case TYPE_CHAR:
            if (key.length() == 1) {
                return Character.valueOf(key.charAt(0));
            }
            return ctxt.handleWeirdKey(_keyClass, key, ""can only convert 1-character Strings"");
        case TYPE_INT:
            return _parseInt(key);
        case TYPE_LONG:
            return _parseLong(key);
        case TYPE_FLOAT:
            // Bounds/range checks would be tricky here, so let's not bother even trying...
            return Float.valueOf((float) _parseDouble(key));
        case TYPE_DOUBLE:
            return _parseDouble(key);
        case TYPE_LOCALE:
            try {
                return _deser._deserialize(key, ctxt);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_CURRENCY:
            try {
                return _deser._deserialize(key, ctxt);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_DATE:
            return ctxt.parseDate(key);
        case TYPE_CALENDAR:
            return ctxt.constructCalendar(ctxt.parseDate(key));
        case TYPE_UUID:
            try {
                return UUID.fromString(key);
            } catch (Exception e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_URI:
            try {
                return URI.create(key);
            } catch (Exception e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_URL:
            try {
                return new URL(key);
            } catch (MalformedURLException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_CLASS:
            try {
                return ctxt.findClass(key);
            } catch (Exception e) {
                return ctxt.handleWeirdKey(_keyClass, key, ""unable to parse key as Class"");
            }
        case TYPE_BYTE_ARRAY:
            try {
                return ctxt.getConfig().getBase64Variant().decode(key);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        default:
            throw new IllegalStateException(""Internal error: unknown key type "" + _keyClass);
    }
}","public void test1313() throws Throwable {
    Class<Date> class0 = Date.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    try {
        stdKeyDeserializer0._parse(""false"", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"protected Object _parse(String key, DeserializationContext ctxt) throws Exception {
    switch(_kind) {
        case TYPE_BOOLEAN:
            if (""true"".equals(key)) {
                return Boolean.TRUE;
            }
            if (""false"".equals(key)) {
                return Boolean.FALSE;
            }
            return ctxt.handleWeirdKey(_keyClass, key, ""value not 'true' or 'false'"");
        case TYPE_BYTE:
            {
                int value = _parseInt(key);
                // allow range up to 255, inclusive (to support ""unsigned"" byte)
                if (value < Byte.MIN_VALUE || value > 255) {
                    return ctxt.handleWeirdKey(_keyClass, key, ""overflow, value cannot be represented as 8-bit value"");
                }
                return Byte.valueOf((byte) value);
            }
        case TYPE_SHORT:
            {
                int value = _parseInt(key);
                if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {
                    return ctxt.handleWeirdKey(_keyClass, key, ""overflow, value cannot be represented as 16-bit value"");
                    // fall-through and truncate if need be
                }
                return Short.valueOf((short) value);
            }
        case TYPE_CHAR:
            if (key.length() == 1) {
                return Character.valueOf(key.charAt(0));
            }
            return ctxt.handleWeirdKey(_keyClass, key, ""can only convert 1-character Strings"");
        case TYPE_INT:
            return _parseInt(key);
        case TYPE_LONG:
            return _parseLong(key);
        case TYPE_FLOAT:
            // Bounds/range checks would be tricky here, so let's not bother even trying...
            return Float.valueOf((float) _parseDouble(key));
        case TYPE_DOUBLE:
            return _parseDouble(key);
        case TYPE_LOCALE:
            try {
                return _deser._deserialize(key, ctxt);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_CURRENCY:
            try {
                return _deser._deserialize(key, ctxt);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_DATE:
            return ctxt.parseDate(key);
        case TYPE_CALENDAR:
            return ctxt.constructCalendar(ctxt.parseDate(key));
        case TYPE_UUID:
            try {
                return UUID.fromString(key);
            } catch (Exception e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_URI:
            try {
                return URI.create(key);
            } catch (Exception e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_URL:
            try {
                return new URL(key);
            } catch (MalformedURLException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_CLASS:
            try {
                return ctxt.findClass(key);
            } catch (Exception e) {
                return ctxt.handleWeirdKey(_keyClass, key, ""unable to parse key as Class"");
            }
        case TYPE_BYTE_ARRAY:
            try {
                return ctxt.getConfig().getBase64Variant().decode(key);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        default:
            throw new IllegalStateException(""Internal error: unknown key type "" + _keyClass);
    }
}","public void test1414() throws Throwable {
    Class<Calendar> class0 = Calendar.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    try {
        stdKeyDeserializer0._parse(""-!TME}_O["", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test1515() throws Throwable {
    Class<Byte> class0 = Byte.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    // Undeclared exception!
    try {
        stdKeyDeserializer0.deserializeKey(""610"", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"public static StdKeyDeserializer forType(Class<?> raw) {
    int kind;
    // first common types:
    if (raw == String.class || raw == Object.class || raw == CharSequence.class) {
        return StringKD.forType(raw);
    } else if (raw == UUID.class) {
        kind = TYPE_UUID;
    } else if (raw == Integer.class) {
        kind = TYPE_INT;
    } else if (raw == Long.class) {
        kind = TYPE_LONG;
    } else if (raw == Date.class) {
        kind = TYPE_DATE;
    } else if (raw == Calendar.class) {
        kind = TYPE_CALENDAR;
        // then less common ones...
    } else if (raw == Boolean.class) {
        kind = TYPE_BOOLEAN;
    } else if (raw == Byte.class) {
        kind = TYPE_BYTE;
    } else if (raw == Character.class) {
        kind = TYPE_CHAR;
    } else if (raw == Short.class) {
        kind = TYPE_SHORT;
    } else if (raw == Float.class) {
        kind = TYPE_FLOAT;
    } else if (raw == Double.class) {
        kind = TYPE_DOUBLE;
    } else if (raw == URI.class) {
        kind = TYPE_URI;
    } else if (raw == URL.class) {
        kind = TYPE_URL;
    } else if (raw == Class.class) {
        kind = TYPE_CLASS;
    } else if (raw == Locale.class) {
        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);
        return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);
    } else if (raw == Currency.class) {
        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);
        return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);
    } else if (raw == byte[].class) {
        kind = TYPE_BYTE_ARRAY;
    } else {
        return null;
    }
    return new StdKeyDeserializer(kind, raw);
}","public void test1616() throws Throwable {
    Class<Character> class0 = Character.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    assertNotNull(stdKeyDeserializer0);
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test1617() throws Throwable {
    Class<Character> class0 = Character.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    Object object0 = stdKeyDeserializer0.deserializeKey(""9"", (DeserializationContext) null);
    assertEquals('9', object0);
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test1719() throws Throwable {
    Class<Double> class0 = Double.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    // Undeclared exception!
    try {
        stdKeyDeserializer0.deserializeKey(""com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer"", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"protected Object _parse(String key, DeserializationContext ctxt) throws Exception {
    switch(_kind) {
        case TYPE_BOOLEAN:
            if (""true"".equals(key)) {
                return Boolean.TRUE;
            }
            if (""false"".equals(key)) {
                return Boolean.FALSE;
            }
            return ctxt.handleWeirdKey(_keyClass, key, ""value not 'true' or 'false'"");
        case TYPE_BYTE:
            {
                int value = _parseInt(key);
                // allow range up to 255, inclusive (to support ""unsigned"" byte)
                if (value < Byte.MIN_VALUE || value > 255) {
                    return ctxt.handleWeirdKey(_keyClass, key, ""overflow, value cannot be represented as 8-bit value"");
                }
                return Byte.valueOf((byte) value);
            }
        case TYPE_SHORT:
            {
                int value = _parseInt(key);
                if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {
                    return ctxt.handleWeirdKey(_keyClass, key, ""overflow, value cannot be represented as 16-bit value"");
                    // fall-through and truncate if need be
                }
                return Short.valueOf((short) value);
            }
        case TYPE_CHAR:
            if (key.length() == 1) {
                return Character.valueOf(key.charAt(0));
            }
            return ctxt.handleWeirdKey(_keyClass, key, ""can only convert 1-character Strings"");
        case TYPE_INT:
            return _parseInt(key);
        case TYPE_LONG:
            return _parseLong(key);
        case TYPE_FLOAT:
            // Bounds/range checks would be tricky here, so let's not bother even trying...
            return Float.valueOf((float) _parseDouble(key));
        case TYPE_DOUBLE:
            return _parseDouble(key);
        case TYPE_LOCALE:
            try {
                return _deser._deserialize(key, ctxt);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_CURRENCY:
            try {
                return _deser._deserialize(key, ctxt);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_DATE:
            return ctxt.parseDate(key);
        case TYPE_CALENDAR:
            return ctxt.constructCalendar(ctxt.parseDate(key));
        case TYPE_UUID:
            try {
                return UUID.fromString(key);
            } catch (Exception e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_URI:
            try {
                return URI.create(key);
            } catch (Exception e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_URL:
            try {
                return new URL(key);
            } catch (MalformedURLException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_CLASS:
            try {
                return ctxt.findClass(key);
            } catch (Exception e) {
                return ctxt.handleWeirdKey(_keyClass, key, ""unable to parse key as Class"");
            }
        case TYPE_BYTE_ARRAY:
            try {
                return ctxt.getConfig().getBase64Variant().decode(key);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        default:
            throw new IllegalStateException(""Internal error: unknown key type "" + _keyClass);
    }
}","public void test1921() throws Throwable {
    Class<URL> class0 = URL.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    try {
        stdKeyDeserializer0._parse("""", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"public static StdKeyDeserializer forType(Class<?> raw) {
    int kind;
    // first common types:
    if (raw == String.class || raw == Object.class || raw == CharSequence.class) {
        return StringKD.forType(raw);
    } else if (raw == UUID.class) {
        kind = TYPE_UUID;
    } else if (raw == Integer.class) {
        kind = TYPE_INT;
    } else if (raw == Long.class) {
        kind = TYPE_LONG;
    } else if (raw == Date.class) {
        kind = TYPE_DATE;
    } else if (raw == Calendar.class) {
        kind = TYPE_CALENDAR;
        // then less common ones...
    } else if (raw == Boolean.class) {
        kind = TYPE_BOOLEAN;
    } else if (raw == Byte.class) {
        kind = TYPE_BYTE;
    } else if (raw == Character.class) {
        kind = TYPE_CHAR;
    } else if (raw == Short.class) {
        kind = TYPE_SHORT;
    } else if (raw == Float.class) {
        kind = TYPE_FLOAT;
    } else if (raw == Double.class) {
        kind = TYPE_DOUBLE;
    } else if (raw == URI.class) {
        kind = TYPE_URI;
    } else if (raw == URL.class) {
        kind = TYPE_URL;
    } else if (raw == Class.class) {
        kind = TYPE_CLASS;
    } else if (raw == Locale.class) {
        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);
        return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);
    } else if (raw == Currency.class) {
        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);
        return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);
    } else if (raw == byte[].class) {
        kind = TYPE_BYTE_ARRAY;
    } else {
        return null;
    }
    return new StdKeyDeserializer(kind, raw);
}","public void test2123() throws Throwable {
    Class<ShortNode> class0 = ShortNode.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    assertNull(stdKeyDeserializer0);
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test2224() throws Throwable {
    Class<Currency> class0 = Currency.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    Object object0 = stdKeyDeserializer0.deserializeKey((String) null, (DeserializationContext) null);
    assertNull(object0);
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test2325() throws Throwable {
    Class<ChronoUnit> class0 = ChronoUnit.class;
    FromStringDeserializer<Locale> fromStringDeserializer0 = (FromStringDeserializer<Locale>) mock(FromStringDeserializer.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(fromStringDeserializer0)._deserialize(anyString(), any(com.fasterxml.jackson.databind.DeserializationContext.class));
    StdKeyDeserializer stdKeyDeserializer0 = new StdKeyDeserializer(16, class0, fromStringDeserializer0);
    // Undeclared exception!
    try {
        stdKeyDeserializer0.deserializeKey(""4"", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test2426() throws Throwable {
    Class<UUID> class0 = UUID.class;
    FromStringDeserializer<ChronoUnit> fromStringDeserializer0 = (FromStringDeserializer<ChronoUnit>) mock(FromStringDeserializer.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(fromStringDeserializer0)._deserialize(anyString(), any(com.fasterxml.jackson.databind.DeserializationContext.class));
    StdKeyDeserializer stdKeyDeserializer0 = new StdKeyDeserializer(16, class0, fromStringDeserializer0);
    // Undeclared exception!
    try {
        stdKeyDeserializer0.deserializeKey(""_jmf!un4AHsUq}"", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test2527() throws Throwable {
    Class<Boolean> class0 = Boolean.class;
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    Object object0 = stdKeyDeserializer0.deserializeKey(""false"", defaultDeserializationContext_Impl0);
    assertEquals(false, object0);
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test2628() throws Throwable {
    Class<CharBuffer> class0 = CharBuffer.class;
    StdKeyDeserializer stdKeyDeserializer0 = new StdKeyDeserializer(15, class0);
    // Undeclared exception!
    try {
        stdKeyDeserializer0.deserializeKey(""overflow, value cannot be represented as 16-bit value"", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test2729() throws Throwable {
    Class<Byte> class0 = Byte.class;
    StdKeyDeserializer stdKeyDeserializer0 = new StdKeyDeserializer(17, class0);
    // Undeclared exception!
    try {
        stdKeyDeserializer0.deserializeKey(""-10"", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"protected Object _parse(String key, DeserializationContext ctxt) throws Exception {
    switch(_kind) {
        case TYPE_BOOLEAN:
            if (""true"".equals(key)) {
                return Boolean.TRUE;
            }
            if (""false"".equals(key)) {
                return Boolean.FALSE;
            }
            return ctxt.handleWeirdKey(_keyClass, key, ""value not 'true' or 'false'"");
        case TYPE_BYTE:
            {
                int value = _parseInt(key);
                // allow range up to 255, inclusive (to support ""unsigned"" byte)
                if (value < Byte.MIN_VALUE || value > 255) {
                    return ctxt.handleWeirdKey(_keyClass, key, ""overflow, value cannot be represented as 8-bit value"");
                }
                return Byte.valueOf((byte) value);
            }
        case TYPE_SHORT:
            {
                int value = _parseInt(key);
                if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {
                    return ctxt.handleWeirdKey(_keyClass, key, ""overflow, value cannot be represented as 16-bit value"");
                    // fall-through and truncate if need be
                }
                return Short.valueOf((short) value);
            }
        case TYPE_CHAR:
            if (key.length() == 1) {
                return Character.valueOf(key.charAt(0));
            }
            return ctxt.handleWeirdKey(_keyClass, key, ""can only convert 1-character Strings"");
        case TYPE_INT:
            return _parseInt(key);
        case TYPE_LONG:
            return _parseLong(key);
        case TYPE_FLOAT:
            // Bounds/range checks would be tricky here, so let's not bother even trying...
            return Float.valueOf((float) _parseDouble(key));
        case TYPE_DOUBLE:
            return _parseDouble(key);
        case TYPE_LOCALE:
            try {
                return _deser._deserialize(key, ctxt);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_CURRENCY:
            try {
                return _deser._deserialize(key, ctxt);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_DATE:
            return ctxt.parseDate(key);
        case TYPE_CALENDAR:
            return ctxt.constructCalendar(ctxt.parseDate(key));
        case TYPE_UUID:
            try {
                return UUID.fromString(key);
            } catch (Exception e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_URI:
            try {
                return URI.create(key);
            } catch (Exception e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_URL:
            try {
                return new URL(key);
            } catch (MalformedURLException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_CLASS:
            try {
                return ctxt.findClass(key);
            } catch (Exception e) {
                return ctxt.handleWeirdKey(_keyClass, key, ""unable to parse key as Class"");
            }
        case TYPE_BYTE_ARRAY:
            try {
                return ctxt.getConfig().getBase64Variant().decode(key);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        default:
            throw new IllegalStateException(""Internal error: unknown key type "" + _keyClass);
    }
}","public void test2830() throws Throwable {
    Class<Locale> class0 = Locale.class;
    StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class0);
    try {
        stdKeyDeserializer_StringKD0._parse(""not a valid representation, problem: (%s) %s"", (DeserializationContext) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Internal error: unknown key type class java.util.Locale
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test2931() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    Class<Boolean> class0 = Boolean.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    Object object0 = stdKeyDeserializer0.deserializeKey(""true"", defaultDeserializationContext_Impl0);
    assertEquals(true, object0);
}",""
"protected Object _parse(String key, DeserializationContext ctxt) throws Exception {
    switch(_kind) {
        case TYPE_BOOLEAN:
            if (""true"".equals(key)) {
                return Boolean.TRUE;
            }
            if (""false"".equals(key)) {
                return Boolean.FALSE;
            }
            return ctxt.handleWeirdKey(_keyClass, key, ""value not 'true' or 'false'"");
        case TYPE_BYTE:
            {
                int value = _parseInt(key);
                // allow range up to 255, inclusive (to support ""unsigned"" byte)
                if (value < Byte.MIN_VALUE || value > 255) {
                    return ctxt.handleWeirdKey(_keyClass, key, ""overflow, value cannot be represented as 8-bit value"");
                }
                return Byte.valueOf((byte) value);
            }
        case TYPE_SHORT:
            {
                int value = _parseInt(key);
                if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {
                    return ctxt.handleWeirdKey(_keyClass, key, ""overflow, value cannot be represented as 16-bit value"");
                    // fall-through and truncate if need be
                }
                return Short.valueOf((short) value);
            }
        case TYPE_CHAR:
            if (key.length() == 1) {
                return Character.valueOf(key.charAt(0));
            }
            return ctxt.handleWeirdKey(_keyClass, key, ""can only convert 1-character Strings"");
        case TYPE_INT:
            return _parseInt(key);
        case TYPE_LONG:
            return _parseLong(key);
        case TYPE_FLOAT:
            // Bounds/range checks would be tricky here, so let's not bother even trying...
            return Float.valueOf((float) _parseDouble(key));
        case TYPE_DOUBLE:
            return _parseDouble(key);
        case TYPE_LOCALE:
            try {
                return _deser._deserialize(key, ctxt);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_CURRENCY:
            try {
                return _deser._deserialize(key, ctxt);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_DATE:
            return ctxt.parseDate(key);
        case TYPE_CALENDAR:
            return ctxt.constructCalendar(ctxt.parseDate(key));
        case TYPE_UUID:
            try {
                return UUID.fromString(key);
            } catch (Exception e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_URI:
            try {
                return URI.create(key);
            } catch (Exception e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_URL:
            try {
                return new URL(key);
            } catch (MalformedURLException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_CLASS:
            try {
                return ctxt.findClass(key);
            } catch (Exception e) {
                return ctxt.handleWeirdKey(_keyClass, key, ""unable to parse key as Class"");
            }
        case TYPE_BYTE_ARRAY:
            try {
                return ctxt.getConfig().getBase64Variant().decode(key);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        default:
            throw new IllegalStateException(""Internal error: unknown key type "" + _keyClass);
    }
}","public void test3032() throws Throwable {
    Class<Boolean> class0 = Boolean.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    try {
        stdKeyDeserializer0._parse(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer$StringKD"", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test3133() throws Throwable {
    Class<Byte> class0 = Byte.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    // Undeclared exception!
    try {
        stdKeyDeserializer0.deserializeKey(""-630"", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test3234() throws Throwable {
    Class<Byte> class0 = Byte.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    Object object0 = stdKeyDeserializer0.deserializeKey(""0"", (DeserializationContext) null);
    assertEquals((byte) 0, object0);
}",""
"@Override
public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {
    if (key == null) {
        // is this even legal call?
        return null;
    }
    try {
        Object result = _parse(key, ctxt);
        if (result != null) {
            return result;
        }
    } catch (Exception re) {
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"", re.getClass().getName(), re.getMessage());
    }
    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
        return null;
    }
    return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
}","public void test3335() throws Throwable {
    Class<Short> class0 = Short.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    Object object0 = stdKeyDeserializer0.deserializeKey(""0"", (DeserializationContext) null);
    assertEquals((short) 0, object0);
}",""
"protected Object _parse(String key, DeserializationContext ctxt) throws Exception {
    switch(_kind) {
        case TYPE_BOOLEAN:
            if (""true"".equals(key)) {
                return Boolean.TRUE;
            }
            if (""false"".equals(key)) {
                return Boolean.FALSE;
            }
            return ctxt.handleWeirdKey(_keyClass, key, ""value not 'true' or 'false'"");
        case TYPE_BYTE:
            {
                int value = _parseInt(key);
                // allow range up to 255, inclusive (to support ""unsigned"" byte)
                if (value < Byte.MIN_VALUE || value > 255) {
                    return ctxt.handleWeirdKey(_keyClass, key, ""overflow, value cannot be represented as 8-bit value"");
                }
                return Byte.valueOf((byte) value);
            }
        case TYPE_SHORT:
            {
                int value = _parseInt(key);
                if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {
                    return ctxt.handleWeirdKey(_keyClass, key, ""overflow, value cannot be represented as 16-bit value"");
                    // fall-through and truncate if need be
                }
                return Short.valueOf((short) value);
            }
        case TYPE_CHAR:
            if (key.length() == 1) {
                return Character.valueOf(key.charAt(0));
            }
            return ctxt.handleWeirdKey(_keyClass, key, ""can only convert 1-character Strings"");
        case TYPE_INT:
            return _parseInt(key);
        case TYPE_LONG:
            return _parseLong(key);
        case TYPE_FLOAT:
            // Bounds/range checks would be tricky here, so let's not bother even trying...
            return Float.valueOf((float) _parseDouble(key));
        case TYPE_DOUBLE:
            return _parseDouble(key);
        case TYPE_LOCALE:
            try {
                return _deser._deserialize(key, ctxt);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_CURRENCY:
            try {
                return _deser._deserialize(key, ctxt);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_DATE:
            return ctxt.parseDate(key);
        case TYPE_CALENDAR:
            return ctxt.constructCalendar(ctxt.parseDate(key));
        case TYPE_UUID:
            try {
                return UUID.fromString(key);
            } catch (Exception e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_URI:
            try {
                return URI.create(key);
            } catch (Exception e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_URL:
            try {
                return new URL(key);
            } catch (MalformedURLException e) {
                return _weirdKey(ctxt, key, e);
            }
        case TYPE_CLASS:
            try {
                return ctxt.findClass(key);
            } catch (Exception e) {
                return ctxt.handleWeirdKey(_keyClass, key, ""unable to parse key as Class"");
            }
        case TYPE_BYTE_ARRAY:
            try {
                return ctxt.getConfig().getBase64Variant().decode(key);
            } catch (IllegalArgumentException e) {
                return _weirdKey(ctxt, key, e);
            }
        default:
            throw new IllegalStateException(""Internal error: unknown key type "" + _keyClass);
    }
}","public void test3436() throws Throwable {
    Class<Character> class0 = Character.class;
    StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class0);
    try {
        stdKeyDeserializer0._parse("""", (DeserializationContext) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"", e);
    }
}",""
