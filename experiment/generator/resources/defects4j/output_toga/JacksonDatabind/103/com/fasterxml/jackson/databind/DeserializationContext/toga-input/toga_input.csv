focal_method,test_prefix,docstring
"/*
    /**********************************************************
    /* Implementation of rest of ObjectCodec methods
    /**********************************************************
     */
@Override
public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {
    try {
        return readValue(treeAsTokens(n), valueType);
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
}","public void test000() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    BooleanNode booleanNode0 = BooleanNode.getTrue();
    Class<ResolvedRecursiveType> class0 = ResolvedRecursiveType.class;
    try {
        objectReader0.treeToValue((TreeNode) booleanNode0, class0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Cannot construct instance of `com.fasterxml.jackson.databind.type.ResolvedRecursiveType` (no Creators, like default construct, exist): no boolean/Boolean-argument constructor/factory method to deserialize from boolean value (true)
        //  at [Source: UNKNOWN; line: -1, column: -1]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}",""
"public Object handleWeirdKey(Class<?> keyClass, String keyValue, String msg, Object... msgArgs) throws IOException {
    // but if not handled, just throw exception
    msg = _format(msg, msgArgs);
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object key = h.value().handleWeirdKey(this, keyClass, keyValue, msg);
        if (key != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if ((key == null) || keyClass.isInstance(key)) {
                return key;
            }
            throw weirdStringException(keyValue, keyClass, String.format(""DeserializationProblemHandler.handleWeirdStringValue() for type %s returned value of type %s"", keyClass, key.getClass()));
        }
        h = h.next();
    }
    throw weirdKeyException(keyClass, keyValue, msg);
}","public void test011() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Object[] objectArray0 = new Object[0];
    Class<DateFormat> class0 = DateFormat.class;
    try {
        defaultDeserializationContext0.handleWeirdKey(class0, ""JSON"", ""JSON"", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Cannot deserialize Map key of type `java.text.DateFormat` from String \""JSON\"": JSON
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidFormatException"", e);
    }
}","/**
 * Method that deserializers should call if they encounter a String value
 * that cannot be converted to expected key of a {@link java.util.Map}
 * valued property.
 * Default implementation will try to call {@link DeserializationProblemHandler#handleWeirdNumberValue}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw {@link InvalidFormatException} with given message.
 *
 * @param keyClass Expected type for key
 * @param keyValue String value from which to deserialize key
 * @param msg Error message template caller wants to use if exception is to be thrown
 * @param msgArgs Optional arguments to use for message, if any
 *
 * @return Key value to use
 *
 * @throws IOException To indicate unrecoverable problem, usually based on <code>msg</code>
 *
 * @since 2.8
 */"
"public Object handleWeirdNumberValue(Class<?> targetClass, Number value, String msg, Object... msgArgs) throws IOException {
    msg = _format(msg, msgArgs);
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object key = h.value().handleWeirdNumberValue(this, targetClass, value, msg);
        if (key != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if (_isCompatible(targetClass, key)) {
                return key;
            }
            throw weirdNumberException(value, targetClass, _format(""DeserializationProblemHandler.handleWeirdNumberValue() for type %s returned value of type %s"", targetClass, key.getClass()));
        }
        h = h.next();
    }
    throw weirdNumberException(value, targetClass, msg);
}","public void test022() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<Integer> class0 = Integer.TYPE;
    BigInteger bigInteger0 = BigInteger.ONE;
    Object[] objectArray0 = new Object[1];
    try {
        defaultDeserializationContext0.handleWeirdNumberValue(class0, bigInteger0, ""JSON"", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Cannot deserialize value of type `int` from number 1: JSON
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidFormatException"", e);
    }
}","/**
 * Method that deserializers should call if they encounter a numeric value
 * that cannot be converted to target property type, in cases where some
 * numeric values could be acceptable (either with different settings,
 * or different numeric value).
 * Default implementation will try to call {@link DeserializationProblemHandler#handleWeirdNumberValue}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw {@link InvalidFormatException} with given message.
 *
 * @param targetClass Type of property into which incoming number should be converted
 * @param value Number value from which to deserialize property value
 * @param msg Error message template caller wants to use if exception is to be thrown
 * @param msgArgs Optional arguments to use for message, if any
 *
 * @return Property value to use
 *
 * @throws IOException To indicate unrecoverable problem, usually based on <code>msg</code>
 *
 * @since 2.8
 */"
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test033() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    defaultDeserializationContext_Impl0.unknownTypeException((JavaType) null, (String) null, (String) null);
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"// For testing only:
public int mixInCount() {
    return _mixIns.localSize();
}","public void test044() throws Throwable {
    JsonFactory jsonFactory0 = new JsonFactory();
    ObjectMapper objectMapper0 = new ObjectMapper(jsonFactory0);
    ObjectMapper objectMapper1 = new ObjectMapper(objectMapper0);
    assertEquals(0, objectMapper1.mixInCount());
}",""
"// since 2.9
@Deprecated
public void reportWrongTokenException(JsonParser p, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException {
    msg = _format(msg, msgArgs);
    throw wrongTokenException(p, expToken, msg);
}","public void test055() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<BuilderBasedDeserializer> class0 = BuilderBasedDeserializer.class;
    ObjectReader objectReader0 = objectMapper0.readerFor(class0);
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    JsonToken jsonToken0 = JsonToken.NOT_AVAILABLE;
    Object[] objectArray0 = new Object[3];
    try {
        defaultDeserializationContext0.reportWrongTokenException(jsonParser0, jsonToken0, ""JSON"", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected token (null), expected NOT_AVAILABLE: JSON
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.MismatchedInputException"", e);
    }
}",""
"public Calendar constructCalendar(Date d) {
    // 08-Jan-2008, tatu: not optimal, but should work for the most part; let's revise as needed.
    Calendar c = Calendar.getInstance(getTimeZone());
    c.setTime(d);
    return c;
}","public void test066() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    MockDate mockDate0 = new MockDate(1L);
    // Undeclared exception!
    try {
        defaultDeserializationContext_Impl0.constructCalendar(mockDate0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}","/**
 * Convenience method for constructing Calendar instance set
 * to specified time, to be modified and used by caller.
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(byte[] src) throws IOException {
    if (_dataFormatReaders != null) {
        return (T) _detectBindAndClose(src, 0, src.length);
    }
    return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));
}","public void test077() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationFeature deserializationFeature0 = DeserializationFeature.FAIL_ON_MISSING_CREATOR_PROPERTIES;
    ObjectReader objectReader0 = objectMapper0.reader(deserializationFeature0);
    byte[] byteArray0 = new byte[0];
    try {
        objectReader0.readValue(byteArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No content to map due to end-of-input
        //  at [Source: (byte[])\""\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.MismatchedInputException"", e);
    }
}","/**
 * Method that binds content read from given byte array,
 * using configuration of this reader.
 * Value return is either newly constructed, or root value that
 * was specified with {@link #withValueToUpdate(Object)}.
 */"
"/*
    /**********************************************************
    /* Access to per-call state, like generic attributes (2.3+)
    /**********************************************************
     */
@Override
public Object getAttribute(Object key) {
    return _attributes.getAttribute(key);
}","public void test088() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    // Undeclared exception!
    try {
        defaultDeserializationContext_Impl0.getAttribute(beanDeserializerFactory0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}",""
"@Override
public final boolean canOverrideAccessModifiers() {
    return _config.canOverrideAccessModifiers();
}","public void test1010() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    // Undeclared exception!
    try {
        deserializationContext0.canOverrideAccessModifiers();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}",""
"public <T> T reportInputMismatch(JsonDeserializer<?> src, String msg, Object... msgArgs) throws JsonMappingException {
    msg = _format(msg, msgArgs);
    throw MismatchedInputException.from(getParser(), src.handledType(), msg);
}","public void test1111() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    Object[] objectArray0 = new Object[3];
    // Undeclared exception!
    try {
        defaultDeserializationContext_Impl0.reportInputMismatch((JsonDeserializer<?>) null, ""g1?Mo7~E'k@B"", objectArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}","/**
 * Helper method used to indicate a problem with input in cases where more
 * specific <code>reportXxx()</code> method was not available.
 *
 * @since 2.9
 */"
"@Override
public Locale getLocale() {
    return _config.getLocale();
}","public void test1212() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    // Undeclared exception!
    try {
        defaultDeserializationContext_Impl0.getLocale();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}","/**
 *  Method for accessing default Locale to use: convenience method for
 * <pre>
 *    getConfig().getLocale();
 * </pre>
 */"
"public void reportWrongTokenException(JavaType targetType, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException {
    msg = _format(msg, msgArgs);
    throw wrongTokenException(getParser(), targetType, expToken, msg);
}","public void test1313() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    JsonToken jsonToken0 = JsonToken.VALUE_NULL;
    Object[] objectArray0 = new Object[0];
    // Undeclared exception!
    try {
        defaultDeserializationContext_Impl0.reportWrongTokenException((JavaType) null, jsonToken0, (String) null, objectArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}","/**
 * Method for deserializers to call
 * when the token encountered was of type different than what <b>should</b>
 * be seen at that position, usually within a sequence of expected tokens.
 * Note that this method will throw a {@link JsonMappingException} and no
 * recovery is attempted (via {@link DeserializationProblemHandler}, as
 * problem is considered to be difficult to recover from, in general.
 *
 * @since 2.9
 */"
"@Deprecated
public JsonMappingException mappingException(String msg, Object... msgArgs) {
    return JsonMappingException.from(getParser(), _format(msg, msgArgs));
}","public void test1414() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    // Undeclared exception!
    try {
        deserializationContext0.mappingException(""Cannot deserialize value of type %s from native value (`JsonToken.VALUE_EMBEDDED_OBJECT`) of type %s: incompatible types"", (Object[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DatabindContext"", e);
    }
}","/**
 * Helper method for constructing generic mapping exception with specified
 * message and current location information
 * Note that application code should almost always call
 * one of <code>handleXxx</code> methods, or {@link #reportMappingException(String, Object...)}
 * instead.
 *
 * @since 2.6
 *
 * @deprecated Since 2.9 use more specific error reporting methods instead
 */"
"public Class<?> findClass(String className) throws ClassNotFoundException {
    // By default, delegate to ClassUtil: can be overridden with custom handling
    return getTypeFactory().findClass(className);
}","public void test1515() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    // Undeclared exception!
    try {
        defaultDeserializationContext_Impl0.findClass(""QUx*JK$yo18q<T4 "");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}","/**
 * Helper method that is to be used when resolving basic class name into
 * Class instance, the reason being that it may be necessary to work around
 * various ClassLoader limitations, as well as to handle primitive type
 * signatures.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Deprecated methods for constructing, throwing non-specific
    /* JsonMappingExceptions: as of 2.9, should use more specific
    /* ones.
    /**********************************************************
     */
/**
 * Fallback method that may be called if no other <code>reportXxx</code>
 * is applicable -- but only in that case.
 *
 * @since 2.8
 *
 * @deprecated Since 2.9: use a more specific method, or {@link #reportBadDefinition(JavaType, String)},
 *    or {@link #reportInputMismatch} instead
 */
// since 2.9
@Deprecated
public void reportMappingException(String msg, Object... msgArgs) throws JsonMappingException {
    throw JsonMappingException.from(getParser(), _format(msg, msgArgs));
}","public void test1616() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    Object[] objectArray0 = new Object[0];
    try {
        defaultDeserializationContext_Impl0.reportMappingException(""}f"", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // }f
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}",""
"/*
    /**********************************************************
    /* Methods for problem reporting, in cases where recovery
    /* is not considered possible: input problem
    /**********************************************************
     */
/**
 * Method for deserializers to call
 * when the token encountered was of type different than what <b>should</b>
 * be seen at that position, usually within a sequence of expected tokens.
 * Note that this method will throw a {@link JsonMappingException} and no
 * recovery is attempted (via {@link DeserializationProblemHandler}, as
 * problem is considered to be difficult to recover from, in general.
 *
 * @since 2.9
 */
public void reportWrongTokenException(JsonDeserializer<?> deser, JsonToken expToken, String msg, Object... msgArgs) throws JsonMappingException {
    msg = _format(msg, msgArgs);
    throw wrongTokenException(getParser(), deser.handledType(), expToken, msg);
}","public void test1717() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    JsonToken jsonToken0 = JsonToken.VALUE_EMBEDDED_OBJECT;
    Object[] objectArray0 = new Object[4];
    // Undeclared exception!
    try {
        defaultDeserializationContext_Impl0.reportWrongTokenException((JsonDeserializer<?>) null, jsonToken0, ""EE@Joj"", objectArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}",""
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test1818() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    defaultDeserializationContext_Impl0.mappingException(""DeserializationProblemHandler.handleWeirdNativeValue() for type %s returned value of type %s"");
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test1919() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    Class<BeanDeserializer> class0 = BeanDeserializer.class;
    deserializationContext0.endOfInputException(class0);
    assertEquals(0, deserializationContext0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"public final Base64Variant getBase64Variant() {
    return _config.getBase64Variant();
}","public void test2121() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    // Undeclared exception!
    try {
        defaultDeserializationContext_Impl0.getBase64Variant();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}","/**
 *  Convenience method for accessing the default Base64 encoding
 *  used for decoding base64 encoded binary content.
 *  Same as calling:
 * <pre>
 *   getConfig().getBase64Variant();
 * </pre>
 */"
"public <T> T reportTrailingTokens(Class<?> targetType, JsonParser p, JsonToken trailingToken) throws JsonMappingException {
    throw MismatchedInputException.from(p, targetType, String.format(""Trailing token (of type %s) found after value (bound as %s): not allowed as per `DeserializationFeature.FAIL_ON_TRAILING_TOKENS`"", trailingToken, ClassUtil.nameOf(targetType)));
}","public void test2323() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    Class<BeanDeserializer> class0 = BeanDeserializer.class;
    JsonToken jsonToken0 = JsonToken.END_ARRAY;
    try {
        defaultDeserializationContext_Impl0.reportTrailingTokens((Class<?>) class0, (JsonParser) null, jsonToken0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Trailing token (of type END_ARRAY) found after value (bound as `com.fasterxml.jackson.databind.deser.BeanDeserializer`): not allowed as per `DeserializationFeature.FAIL_ON_TRAILING_TOKENS`
        //
        verifyException(""com.fasterxml.jackson.databind.exc.MismatchedInputException"", e);
    }
}",""
"public Object handleWeirdStringValue(Class<?> targetClass, String value, String msg, Object... msgArgs) throws IOException {
    // but if not handled, just throw exception
    msg = _format(msg, msgArgs);
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object instance = h.value().handleWeirdStringValue(this, targetClass, value, msg);
        if (instance != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if (_isCompatible(targetClass, instance)) {
                return instance;
            }
            throw weirdStringException(value, targetClass, String.format(""DeserializationProblemHandler.handleWeirdStringValue() for type %s returned value of type %s"", targetClass, instance.getClass()));
        }
        h = h.next();
    }
    throw weirdStringException(value, targetClass, msg);
}","public void test2424() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<PlaceholderForType> class0 = PlaceholderForType.class;
    Object[] objectArray0 = new Object[1];
    try {
        defaultDeserializationContext0.handleWeirdStringValue(class0, ""JSON"", ""JSON"", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Cannot deserialize value of type `com.fasterxml.jackson.databind.type.PlaceholderForType` from String \""JSON\"": JSON
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidFormatException"", e);
    }
}","/**
 * Method that deserializers should call if they encounter a String value
 * that cannot be converted to target property type, in cases where some
 * String values could be acceptable (either with different settings,
 * or different value).
 * Default implementation will try to call {@link DeserializationProblemHandler#handleWeirdStringValue}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw {@link InvalidFormatException} with given message.
 *
 * @param targetClass Type of property into which incoming number should be converted
 * @param value String value from which to deserialize property value
 * @param msg Error message template caller wants to use if exception is to be thrown
 * @param msgArgs Optional arguments to use for message, if any
 *
 * @return Property value to use
 *
 * @throws IOException To indicate unrecoverable problem, usually based on <code>msg</code>
 *
 * @since 2.8
 */"
"public JsonMappingException instantiationException(Class<?> instClass, String msg0) {
    // Most likely problem with Creator definition, right?
    JavaType type = constructType(instClass);
    String msg = String.format(""Cannot construct instance of %s: %s"", ClassUtil.nameOf(instClass), msg0);
    return InvalidDefinitionException.from(_parser, msg, type);
}","public void test2525() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    Class<SimpleObjectIdResolver> class0 = SimpleObjectIdResolver.class;
    // Undeclared exception!
    try {
        deserializationContext0.instantiationException(class0, ""com.fasterxml.jackson.databind.SerializationFeature"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}","/**
 *  Helper method for constructing instantiation exception for specified type,
 *  to indicate that instantiation failed due to missing instantiator
 *  (creator; constructor or factory method).
 * <p>
 *  Note that most of the time this method should NOT be called; instead,
 *  {@link #handleMissingInstantiator} should be called which will call this method
 *  if necessary.
 */"
"public <T> T reportBadPropertyDefinition(BeanDescription bean, BeanPropertyDefinition prop, String msg, Object... msgArgs) throws JsonMappingException {
    msg = _format(msg, msgArgs);
    String propName = ClassUtil.nameOf(prop);
    String beanDesc = ClassUtil.nameOf(bean.getBeanClass());
    msg = String.format(""Invalid definition for property %s (of type %s): %s"", propName, beanDesc, msg);
    throw InvalidDefinitionException.from(_parser, msg, bean, prop);
}","public void test2727() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper((JsonFactory) null);
    Class<Throwable> class0 = Throwable.class;
    ObjectReader objectReader0 = objectMapper0.readerWithView(class0);
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext((JsonParser) null);
    POJOPropertiesCollector pOJOPropertiesCollector0 = mock(POJOPropertiesCollector.class, new ViolatedAssumptionAnswer());
    doReturn((AnnotatedClass) null).when(pOJOPropertiesCollector0).getClassDef();
    doReturn((MapperConfig) null).when(pOJOPropertiesCollector0).getConfig();
    doReturn((ObjectIdInfo) null).when(pOJOPropertiesCollector0).getObjectIdInfo();
    doReturn((JavaType) null).when(pOJOPropertiesCollector0).getType();
    BasicBeanDescription basicBeanDescription0 = BasicBeanDescription.forSerialization(pOJOPropertiesCollector0);
    Object[] objectArray0 = new Object[2];
    // Undeclared exception!
    try {
        defaultDeserializationContext0.reportBadPropertyDefinition((BeanDescription) basicBeanDescription0, (BeanPropertyDefinition) null, ""G/"", objectArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.BeanDescription"", e);
    }
}","/**
 * Helper method called to indicate problem in POJO (serialization) definitions or settings
 * regarding specific property (of a type), unrelated to actual JSON content to map.
 * Default behavior is to construct and throw a {@link JsonMappingException}.
 *
 * @since 2.9
 */"
"public Object handleWeirdNativeValue(JavaType targetType, Object badValue, JsonParser p) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    final Class<?> raw = targetType.getRawClass();
    for (; h != null; h = h.next()) {
        // Can bail out if it's handled
        Object goodValue = h.value().handleWeirdNativeValue(this, targetType, badValue, p);
        if (goodValue != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if ((goodValue == null) || raw.isInstance(goodValue)) {
                return goodValue;
            }
            throw JsonMappingException.from(p, _format(""DeserializationProblemHandler.handleWeirdNativeValue() for type %s returned value of type %s"", targetType, goodValue.getClass()));
        }
    }
    throw weirdNativeValueException(badValue, raw);
}","public void test2828() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<SequenceInputStream> class0 = SequenceInputStream.class;
    JavaType javaType0 = defaultDeserializationContext0.constructType(class0);
    try {
        defaultDeserializationContext0.handleWeirdNativeValue(javaType0, jsonFactory0, jsonParser0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Cannot deserialize value of type `java.io.SequenceInputStream` from native value (`JsonToken.VALUE_EMBEDDED_OBJECT`) of type `com.fasterxml.jackson.core.JsonFactory`: incompatible types
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidFormatException"", e);
    }
}",""
"// since 2.9
@Deprecated
public void reportMissingContent(String msg, Object... msgArgs) throws JsonMappingException {
    throw MismatchedInputException.from(getParser(), (JavaType) null, ""No content to map due to end-of-input"");
}","public void test2929() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    Object[] objectArray0 = new Object[1];
    try {
        defaultDeserializationContext_Impl0.reportMissingContent(""~{~hISY3"", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // No content to map due to end-of-input
        //
        verifyException(""com.fasterxml.jackson.databind.exc.MismatchedInputException"", e);
    }
}","/**
 * @since 2.8
 *
 * @deprecated Since 2.9: not clear this ever occurs
 */"
"public <T> T reportUnresolvedObjectId(ObjectIdReader oidReader, Object bean) throws JsonMappingException {
    String msg = String.format(""No Object Id found for an instance of %s, to assign to property '%s'"", ClassUtil.classNameOf(bean), oidReader.propertyName);
    return reportInputMismatch(oidReader.idProperty, msg);
}","public void test3030() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    // Undeclared exception!
    try {
        deserializationContext0.reportUnresolvedObjectId((ObjectIdReader) null, (Object) objectMapper0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}","/**
 * @since 2.8
 */"
"/*
    /**********************************************************
    /* Methods for problem reporting, in cases where recovery
    /* is not considered possible: POJO definition problems
    /**********************************************************
     */
/**
 * Helper method called to indicate problem in POJO (serialization) definitions or settings
 * regarding specific Java type, unrelated to actual JSON content to map.
 * Default behavior is to construct and throw a {@link JsonMappingException}.
 *
 * @since 2.9
 */
public <T> T reportBadTypeDefinition(BeanDescription bean, String msg, Object... msgArgs) throws JsonMappingException {
    msg = _format(msg, msgArgs);
    String beanDesc = ClassUtil.nameOf(bean.getBeanClass());
    msg = String.format(""Invalid type definition for type %s: %s"", beanDesc, msg);
    throw InvalidDefinitionException.from(_parser, msg, bean, null);
}","public void test3131() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    Object[] objectArray0 = new Object[0];
    // Undeclared exception!
    try {
        defaultDeserializationContext_Impl0.reportBadTypeDefinition((BeanDescription) null, ""em?"", objectArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}",""
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test3232() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    defaultDeserializationContext_Impl0.getActiveView();
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Public API, config setting accessors
    /**********************************************************
     */
/**
 * Method for getting current {@link DeserializerFactory}.
 */
public DeserializerFactory getFactory() {
    return _factory;
}","public void test3434() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    DeserializerFactory deserializerFactory0 = defaultDeserializationContext_Impl0.getFactory();
    assertNotNull(deserializerFactory0);
}",""
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test3435() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    DeserializerFactory deserializerFactory0 = defaultDeserializationContext_Impl0.getFactory();
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test3536() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    DefaultDeserializationContext defaultDeserializationContext0 = defaultDeserializationContext_Impl0.with(beanDeserializerFactory0);
    assertEquals(0, defaultDeserializationContext0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test3637() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    Class<ObjectIdResolver> class0 = ObjectIdResolver.class;
    JsonToken jsonToken0 = JsonToken.START_OBJECT;
    defaultDeserializationContext_Impl0.mappingException(class0, jsonToken0);
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test3738() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    int int0 = deserializationContext0.getDeserializationFeatures();
    assertEquals(0, int0);
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"@Override
public DeserializationContext setAttribute(Object key, Object value) {
    _attributes = _attributes.withPerCallAttribute(key, value);
    return this;
}","public void test3839() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    // Undeclared exception!
    try {
        deserializationContext0.setAttribute(objectMapper0, objectMapper0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}",""
"public final JsonNodeFactory getNodeFactory() {
    return _config.getNodeFactory();
}","public void test3940() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    // Undeclared exception!
    try {
        defaultDeserializationContext_Impl0.getNodeFactory();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.fasterxml.jackson.databind.DeserializationContext"", e);
    }
}","/**
 *  Convenience method, functionally equivalent to:
 * <pre>
 *   getConfig().getNodeFactory();
 *  </pre>
 */"
"public final boolean hasDeserializationFeatures(int featureMask) {
    return (_featureFlags & featureMask) == featureMask;
}","public void test4243() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    boolean boolean0 = defaultDeserializationContext_Impl0.hasDeserializationFeatures((-950));
    assertFalse(boolean0);
}","/**
 * Bulk access method for checking that all features specified by
 * mask are enabled.
 *
 * @since 2.3
 */"
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test4244() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    boolean boolean0 = defaultDeserializationContext_Impl0.hasDeserializationFeatures((-950));
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"public final boolean hasDeserializationFeatures(int featureMask) {
    return (_featureFlags & featureMask) == featureMask;
}","public void test4345() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    boolean boolean0 = deserializationContext0.hasDeserializationFeatures((byte) 0);
    assertTrue(boolean0);
}","/**
 * Bulk access method for checking that all features specified by
 * mask are enabled.
 *
 * @since 2.3
 */"
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test4346() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationContext deserializationContext0 = objectMapper0.getDeserializationContext();
    boolean boolean0 = deserializationContext0.hasDeserializationFeatures((byte) 0);
    assertEquals(0, deserializationContext0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"public final boolean hasSomeOfFeatures(int featureMask) {
    return (_featureFlags & featureMask) != 0;
}","public void test4447() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    boolean boolean0 = defaultDeserializationContext_Impl0.hasSomeOfFeatures((-861));
    assertFalse(boolean0);
}","/**
 * Bulk access method for checking that at least one of features specified by
 * mask is enabled.
 *
 * @since 2.6
 */"
"public final boolean hasSomeOfFeatures(int featureMask) {
    return (_featureFlags & featureMask) != 0;
}","public void test4548() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    Class<BuilderBasedDeserializer> class0 = BuilderBasedDeserializer.class;
    ObjectReader objectReader0 = objectMapper0.readerFor(class0);
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""Cannot construct instance of %s (no Creators, like default construct, exist): %s"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    boolean boolean0 = defaultDeserializationContext0.hasSomeOfFeatures(20);
    assertTrue(boolean0);
}","/**
 * Bulk access method for checking that at least one of features specified by
 * mask is enabled.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Public API, pass-through to DeserializerCache
    /**********************************************************
     */
/**
 * Method for checking whether we could find a deserializer
 * for given type.
 *
 * @param type
 * @since 2.3
 */
public boolean hasValueDeserializerFor(JavaType type, AtomicReference<Throwable> cause) {
    try {
        return _cache.hasValueDeserializerFor(this, _factory, type);
    } catch (JsonMappingException e) {
        if (cause != null) {
            cause.set(e);
        }
    } catch (RuntimeException e) {
        if (cause == null) {
            // earlier behavior
            throw e;
        }
        cause.set(e);
    }
    return false;
}","public void test4649() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    AtomicReference<Throwable> atomicReference0 = new AtomicReference<Throwable>();
    boolean boolean0 = defaultDeserializationContext_Impl0.hasValueDeserializerFor((JavaType) null, atomicReference0);
    assertFalse(boolean0);
}",""
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test4650() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    AtomicReference<Throwable> atomicReference0 = new AtomicReference<Throwable>();
    boolean boolean0 = defaultDeserializationContext_Impl0.hasValueDeserializerFor((JavaType) null, atomicReference0);
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Public API, pass-through to DeserializerCache
    /**********************************************************
     */
/**
 * Method for checking whether we could find a deserializer
 * for given type.
 *
 * @param type
 * @since 2.3
 */
public boolean hasValueDeserializerFor(JavaType type, AtomicReference<Throwable> cause) {
    try {
        return _cache.hasValueDeserializerFor(this, _factory, type);
    } catch (JsonMappingException e) {
        if (cause != null) {
            cause.set(e);
        }
    } catch (RuntimeException e) {
        if (cause == null) {
            // earlier behavior
            throw e;
        }
        cause.set(e);
    }
    return false;
}","public void test4751() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    // Undeclared exception!
    try {
        defaultDeserializationContext_Impl0.hasValueDeserializerFor((JavaType) null, (AtomicReference<Throwable>) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Null JavaType passed
        //
        verifyException(""com.fasterxml.jackson.databind.deser.DeserializerCache"", e);
    }
}",""
"@SuppressWarnings(""unchecked"")
public <T> T readValue(JsonParser p, JavaType type) throws IOException {
    JsonDeserializer<Object> deser = findRootValueDeserializer(type);
    if (deser == null) {
        reportBadDefinition(type, ""Could not find JsonDeserializer for type "" + type);
    }
    return (T) deser.deserialize(p, this);
}","public void test4852() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectMapper.DefaultTyping objectMapper_DefaultTyping0 = ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE;
    objectMapper0.enableDefaultTyping(objectMapper_DefaultTyping0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    PlaceholderForType placeholderForType0 = new PlaceholderForType(633);
    try {
        defaultDeserializationContext0.readValue(jsonParser0, (JavaType) placeholderForType0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unexpected end-of-input when binding data into `java.lang.Object`
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.MismatchedInputException"", e);
    }
}","/**
 * @since 2.4
 */"
"public final KeyDeserializer findKeyDeserializer(JavaType keyType, BeanProperty prop) throws JsonMappingException {
    KeyDeserializer kd = _cache.findKeyDeserializer(this, _factory, keyType);
    // Second: contextualize?
    if (kd instanceof ContextualKeyDeserializer) {
        kd = ((ContextualKeyDeserializer) kd).createContextual(this, prop);
    }
    return kd;
}","public void test4953() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
    JavaType javaType0 = beanProperty_Bogus0.getType();
    KeyDeserializer keyDeserializer0 = defaultDeserializationContext0.findKeyDeserializer(javaType0, beanProperty_Bogus0);
    assertNotNull(keyDeserializer0);
}","/**
 *  Convenience method, functionally same as:
 * <pre>
 *   getDeserializerProvider().findKeyDeserializer(getConfig(), prop.getType(), prop);
 * </pre>
 */"
"public Object handleInstantiationProblem(Class<?> instClass, Object argument, Throwable t) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object instance = h.value().handleInstantiationProblem(this, instClass, argument, t);
        if (instance != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if (_isCompatible(instClass, instance)) {
                return instance;
            }
            reportBadDefinition(constructType(instClass), String.format(""DeserializationProblemHandler.handleInstantiationProblem() for type %s returned value of type %s"", instClass, ClassUtil.classNameOf(instance)));
        }
        h = h.next();
    }
    // 18-May-2016, tatu: Only wrap if not already a valid type to throw
    ClassUtil.throwIfIOE(t);
    throw instantiationException(instClass, t);
}","public void test5054() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    SQLTransientConnectionException sQLTransientConnectionException0 = new SQLTransientConnectionException(""JSON"", ""JSON"");
    try {
        defaultDeserializationContext0.handleInstantiationProblem((Class<?>) null, jsonParser0, sQLTransientConnectionException0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Cannot construct instance of [null], problem: JSON
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}","/**
 * Method that deserializers should call if they fail to instantiate value
 * due to an exception that was thrown by constructor (or other mechanism used
 * to create instances).
 * Default implementation will try to call {@link DeserializationProblemHandler#handleInstantiationProblem}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw exception constructed with {@link #instantiationException}.
 *
 * @param instClass Type that was to be instantiated
 * @param argument (optional) Argument that was passed to constructor or equivalent
 *    instantiator; often a {@link java.lang.String}.
 * @param t Exception that caused failure
 *
 * @return Object that should be constructed, if any; has to be of type <code>instClass</code>
 *
 * @since 2.8
 */"
"/*
    /**********************************************************
    /* Public API, helper object recycling
    /**********************************************************
     */
/**
 * Method that can be used to get access to a reusable ObjectBuffer,
 * useful for efficiently constructing Object arrays and Lists.
 * Note that leased buffers should be returned once deserializer
 * is done, to allow for reuse during same round of deserialization.
 */
public final ObjectBuffer leaseObjectBuffer() {
    ObjectBuffer buf = _objectBuffer;
    if (buf == null) {
        buf = new ObjectBuffer();
    } else {
        _objectBuffer = null;
    }
    return buf;
}","public void test5155() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    ObjectBuffer objectBuffer0 = new ObjectBuffer();
    defaultDeserializationContext_Impl0.returnObjectBuffer(objectBuffer0);
    ObjectBuffer objectBuffer1 = defaultDeserializationContext_Impl0.leaseObjectBuffer();
    assertSame(objectBuffer1, objectBuffer0);
}",""
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test5156() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    ObjectBuffer objectBuffer0 = new ObjectBuffer();
    defaultDeserializationContext_Impl0.returnObjectBuffer(objectBuffer0);
    ObjectBuffer objectBuffer1 = defaultDeserializationContext_Impl0.leaseObjectBuffer();
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Public API, helper object recycling
    /**********************************************************
     */
/**
 * Method that can be used to get access to a reusable ObjectBuffer,
 * useful for efficiently constructing Object arrays and Lists.
 * Note that leased buffers should be returned once deserializer
 * is done, to allow for reuse during same round of deserialization.
 */
public final ObjectBuffer leaseObjectBuffer() {
    ObjectBuffer buf = _objectBuffer;
    if (buf == null) {
        buf = new ObjectBuffer();
    } else {
        _objectBuffer = null;
    }
    return buf;
}","public void test5258() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    ObjectBuffer objectBuffer0 = defaultDeserializationContext_Impl0.leaseObjectBuffer();
    assertNotNull(objectBuffer0);
}",""
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test5259() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    ObjectBuffer objectBuffer0 = defaultDeserializationContext_Impl0.leaseObjectBuffer();
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test5360() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    ObjectBuffer objectBuffer0 = new ObjectBuffer();
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    defaultDeserializationContext_Impl0.returnObjectBuffer(objectBuffer0);
    defaultDeserializationContext_Impl0.returnObjectBuffer(objectBuffer0);
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test5461() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    ObjectBuffer objectBuffer0 = new ObjectBuffer();
    objectBuffer0.resetAndStart();
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    defaultDeserializationContext_Impl0.returnObjectBuffer(objectBuffer0);
    ObjectBuffer objectBuffer1 = new ObjectBuffer();
    defaultDeserializationContext_Impl0.returnObjectBuffer(objectBuffer1);
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"public final ArrayBuilders getArrayBuilders() {
    if (_arrayBuilders == null) {
        _arrayBuilders = new ArrayBuilders();
    }
    return _arrayBuilders;
}","public void test5562() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    defaultDeserializationContext_Impl0.getArrayBuilders();
    ArrayBuilders arrayBuilders0 = defaultDeserializationContext_Impl0.getArrayBuilders();
    assertNotNull(arrayBuilders0);
}","/**
 * Method for accessing object useful for building arrays of
 * primitive types (such as int[]).
 */"
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test5563() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    defaultDeserializationContext_Impl0.getArrayBuilders();
    ArrayBuilders arrayBuilders0 = defaultDeserializationContext_Impl0.getArrayBuilders();
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"/*
    /**********************************************************
    /* Methods for problem handling
    /**********************************************************
     */
/**
 * Method that deserializers should call if they encounter an unrecognized
 * property (and once that is not explicitly designed as ignorable), to
 * inform possibly configured {@link DeserializationProblemHandler}s and
 * let it handle the problem.
 *
 * @return True if there was a configured problem handler that was able to handle the
 *   problem
 */
public boolean handleUnknownProperty(JsonParser p, JsonDeserializer<?> deser, Object instanceOrClass, String propName) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        if (h.value().handleUnknownProperty(this, p, deser, instanceOrClass, propName)) {
            return true;
        }
        h = h.next();
    }
    // Nope, not handled. Potentially that's a problem...
    if (!isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {
        p.skipChildren();
        return true;
    }
    // Do we know properties that are expected instead?
    Collection<Object> propIds = (deser == null) ? null : deser.getKnownPropertyNames();
    throw UnrecognizedPropertyException.from(_parser, instanceOrClass, propName, propIds);
}","public void test5664() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn(false).when(deserializationProblemHandler0).handleUnknownProperty(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(com.fasterxml.jackson.core.JsonParser.class), any(com.fasterxml.jackson.databind.JsonDeserializer.class), any(), anyString());
    ObjectMapper objectMapper1 = objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    JsonDeserializer<DoubleNode> jsonDeserializer0 = (JsonDeserializer<DoubleNode>) mock(JsonDeserializer.class, new ViolatedAssumptionAnswer());
    doReturn((Collection) null).when(jsonDeserializer0).getKnownPropertyNames();
    try {
        defaultDeserializationContext0.handleUnknownProperty(jsonParser0, jsonDeserializer0, objectMapper1, ""JSON"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized field \""JSON\"" (class com.fasterxml.jackson.databind.ObjectMapper), not marked as ignorable
        //  at [Source: (String)\""JSON\""; line: 1, column: 1] (through reference chain: com.fasterxml.jackson.databind.ObjectMapper[\""JSON\""])
        //
        verifyException(""com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException"", e);
    }
}",""
"/*
    /**********************************************************
    /* Methods for problem handling
    /**********************************************************
     */
/**
 * Method that deserializers should call if they encounter an unrecognized
 * property (and once that is not explicitly designed as ignorable), to
 * inform possibly configured {@link DeserializationProblemHandler}s and
 * let it handle the problem.
 *
 * @return True if there was a configured problem handler that was able to handle the
 *   problem
 */
public boolean handleUnknownProperty(JsonParser p, JsonDeserializer<?> deser, Object instanceOrClass, String propName) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        if (h.value().handleUnknownProperty(this, p, deser, instanceOrClass, propName)) {
            return true;
        }
        h = h.next();
    }
    // Nope, not handled. Potentially that's a problem...
    if (!isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {
        p.skipChildren();
        return true;
    }
    // Do we know properties that are expected instead?
    Collection<Object> propIds = (deser == null) ? null : deser.getKnownPropertyNames();
    throw UnrecognizedPropertyException.from(_parser, instanceOrClass, propName, propIds);
}","public void test5765() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn(true).when(deserializationProblemHandler0).handleUnknownProperty(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(com.fasterxml.jackson.core.JsonParser.class), any(com.fasterxml.jackson.databind.JsonDeserializer.class), any(), anyString());
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    JsonDeserializer<ObjectIdResolver> jsonDeserializer0 = (JsonDeserializer<ObjectIdResolver>) mock(JsonDeserializer.class, new ViolatedAssumptionAnswer());
    boolean boolean0 = defaultDeserializationContext0.handleUnknownProperty(jsonParser0, jsonDeserializer0, jsonParser0, ""JSON"");
    assertTrue(boolean0);
}",""
"/*
    /**********************************************************
    /* Methods for problem handling
    /**********************************************************
     */
/**
 * Method that deserializers should call if they encounter an unrecognized
 * property (and once that is not explicitly designed as ignorable), to
 * inform possibly configured {@link DeserializationProblemHandler}s and
 * let it handle the problem.
 *
 * @return True if there was a configured problem handler that was able to handle the
 *   problem
 */
public boolean handleUnknownProperty(JsonParser p, JsonDeserializer<?> deser, Object instanceOrClass, String propName) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        if (h.value().handleUnknownProperty(this, p, deser, instanceOrClass, propName)) {
            return true;
        }
        h = h.next();
    }
    // Nope, not handled. Potentially that's a problem...
    if (!isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {
        p.skipChildren();
        return true;
    }
    // Do we know properties that are expected instead?
    Collection<Object> propIds = (deser == null) ? null : deser.getKnownPropertyNames();
    throw UnrecognizedPropertyException.from(_parser, instanceOrClass, propName, propIds);
}","public void test5866() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    try {
        defaultDeserializationContext0.handleUnknownProperty(jsonParser0, (JsonDeserializer<?>) null, jsonParser0, ""JSON"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized field \""JSON\"" (class com.fasterxml.jackson.core.json.ReaderBasedJsonParser), not marked as ignorable
        //  at [Source: (String)\""JSON\""; line: 1, column: 1] (through reference chain: com.fasterxml.jackson.core.json.ReaderBasedJsonParser[\""JSON\""])
        //
        verifyException(""com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException"", e);
    }
}",""
"public Object handleWeirdKey(Class<?> keyClass, String keyValue, String msg, Object... msgArgs) throws IOException {
    // but if not handled, just throw exception
    msg = _format(msg, msgArgs);
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object key = h.value().handleWeirdKey(this, keyClass, keyValue, msg);
        if (key != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if ((key == null) || keyClass.isInstance(key)) {
                return key;
            }
            throw weirdStringException(keyValue, keyClass, String.format(""DeserializationProblemHandler.handleWeirdStringValue() for type %s returned value of type %s"", keyClass, key.getClass()));
        }
        h = h.next();
    }
    throw weirdKeyException(keyClass, keyValue, msg);
}","public void test5967() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(deserializationProblemHandler0).handleWeirdKey(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(java.lang.Class.class), anyString(), anyString());
    ObjectMapper objectMapper1 = objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<Object> class0 = Object.class;
    Object[] objectArray0 = new Object[0];
    Object object0 = defaultDeserializationContext0.handleWeirdKey(class0, ""JSON"", ""JSON"", objectArray0);
    assertSame(object0, objectMapper1);
}","/**
 * Method that deserializers should call if they encounter a String value
 * that cannot be converted to expected key of a {@link java.util.Map}
 * valued property.
 * Default implementation will try to call {@link DeserializationProblemHandler#handleWeirdNumberValue}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw {@link InvalidFormatException} with given message.
 *
 * @param keyClass Expected type for key
 * @param keyValue String value from which to deserialize key
 * @param msg Error message template caller wants to use if exception is to be thrown
 * @param msgArgs Optional arguments to use for message, if any
 *
 * @return Key value to use
 *
 * @throws IOException To indicate unrecoverable problem, usually based on <code>msg</code>
 *
 * @since 2.8
 */"
"public Object handleWeirdKey(Class<?> keyClass, String keyValue, String msg, Object... msgArgs) throws IOException {
    // but if not handled, just throw exception
    msg = _format(msg, msgArgs);
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object key = h.value().handleWeirdKey(this, keyClass, keyValue, msg);
        if (key != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if ((key == null) || keyClass.isInstance(key)) {
                return key;
            }
            throw weirdStringException(keyValue, keyClass, String.format(""DeserializationProblemHandler.handleWeirdStringValue() for type %s returned value of type %s"", keyClass, key.getClass()));
        }
        h = h.next();
    }
    throw weirdKeyException(keyClass, keyValue, msg);
}","public void test6068() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(deserializationProblemHandler0).handleWeirdKey(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(java.lang.Class.class), anyString(), anyString());
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<Object> class0 = Object.class;
    Object[] objectArray0 = new Object[0];
    Object object0 = defaultDeserializationContext0.handleWeirdKey(class0, """", """", objectArray0);
    assertNull(object0);
}","/**
 * Method that deserializers should call if they encounter a String value
 * that cannot be converted to expected key of a {@link java.util.Map}
 * valued property.
 * Default implementation will try to call {@link DeserializationProblemHandler#handleWeirdNumberValue}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw {@link InvalidFormatException} with given message.
 *
 * @param keyClass Expected type for key
 * @param keyValue String value from which to deserialize key
 * @param msg Error message template caller wants to use if exception is to be thrown
 * @param msgArgs Optional arguments to use for message, if any
 *
 * @return Key value to use
 *
 * @throws IOException To indicate unrecoverable problem, usually based on <code>msg</code>
 *
 * @since 2.8
 */"
"public Object handleWeirdKey(Class<?> keyClass, String keyValue, String msg, Object... msgArgs) throws IOException {
    // but if not handled, just throw exception
    msg = _format(msg, msgArgs);
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object key = h.value().handleWeirdKey(this, keyClass, keyValue, msg);
        if (key != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if ((key == null) || keyClass.isInstance(key)) {
                return key;
            }
            throw weirdStringException(keyValue, keyClass, String.format(""DeserializationProblemHandler.handleWeirdStringValue() for type %s returned value of type %s"", keyClass, key.getClass()));
        }
        h = h.next();
    }
    throw weirdKeyException(keyClass, keyValue, msg);
}","public void test6169() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn(objectMapper0).when(deserializationProblemHandler0).handleWeirdKey(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(java.lang.Class.class), anyString(), anyString());
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Object[] objectArray0 = new Object[0];
    Class<Module> class0 = Module.class;
    try {
        defaultDeserializationContext0.handleWeirdKey(class0, ""JSON"", """", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Cannot deserialize value of type `com.fasterxml.jackson.databind.Module` from String \""JSON\"": DeserializationProblemHandler.handleWeirdStringValue() for type class com.fasterxml.jackson.databind.Module returned value of type class com.fasterxml.jackson.databind.ObjectMapper
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidFormatException"", e);
    }
}","/**
 * Method that deserializers should call if they encounter a String value
 * that cannot be converted to expected key of a {@link java.util.Map}
 * valued property.
 * Default implementation will try to call {@link DeserializationProblemHandler#handleWeirdNumberValue}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw {@link InvalidFormatException} with given message.
 *
 * @param keyClass Expected type for key
 * @param keyValue String value from which to deserialize key
 * @param msg Error message template caller wants to use if exception is to be thrown
 * @param msgArgs Optional arguments to use for message, if any
 *
 * @return Key value to use
 *
 * @throws IOException To indicate unrecoverable problem, usually based on <code>msg</code>
 *
 * @since 2.8
 */"
"public Object handleWeirdStringValue(Class<?> targetClass, String value, String msg, Object... msgArgs) throws IOException {
    // but if not handled, just throw exception
    msg = _format(msg, msgArgs);
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object instance = h.value().handleWeirdStringValue(this, targetClass, value, msg);
        if (instance != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if (_isCompatible(targetClass, instance)) {
                return instance;
            }
            throw weirdStringException(value, targetClass, String.format(""DeserializationProblemHandler.handleWeirdStringValue() for type %s returned value of type %s"", targetClass, instance.getClass()));
        }
        h = h.next();
    }
    throw weirdStringException(value, targetClass, msg);
}","public void test6270() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(deserializationProblemHandler0).handleWeirdStringValue(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(java.lang.Class.class), anyString(), anyString());
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<SimpleType> class0 = SimpleType.class;
    Object[] objectArray0 = new Object[0];
    Object object0 = defaultDeserializationContext0.handleWeirdStringValue(class0, ""JSON"", ""JSON"", objectArray0);
    assertNull(object0);
}","/**
 * Method that deserializers should call if they encounter a String value
 * that cannot be converted to target property type, in cases where some
 * String values could be acceptable (either with different settings,
 * or different value).
 * Default implementation will try to call {@link DeserializationProblemHandler#handleWeirdStringValue}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw {@link InvalidFormatException} with given message.
 *
 * @param targetClass Type of property into which incoming number should be converted
 * @param value String value from which to deserialize property value
 * @param msg Error message template caller wants to use if exception is to be thrown
 * @param msgArgs Optional arguments to use for message, if any
 *
 * @return Property value to use
 *
 * @throws IOException To indicate unrecoverable problem, usually based on <code>msg</code>
 *
 * @since 2.8
 */"
"public Object handleWeirdStringValue(Class<?> targetClass, String value, String msg, Object... msgArgs) throws IOException {
    // but if not handled, just throw exception
    msg = _format(msg, msgArgs);
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object instance = h.value().handleWeirdStringValue(this, targetClass, value, msg);
        if (instance != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if (_isCompatible(targetClass, instance)) {
                return instance;
            }
            throw weirdStringException(value, targetClass, String.format(""DeserializationProblemHandler.handleWeirdStringValue() for type %s returned value of type %s"", targetClass, instance.getClass()));
        }
        h = h.next();
    }
    throw weirdStringException(value, targetClass, msg);
}","public void test6371() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn(objectMapper0).when(deserializationProblemHandler0).handleWeirdStringValue(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(java.lang.Class.class), anyString(), anyString());
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<PlaceholderForType> class0 = PlaceholderForType.class;
    Object[] objectArray0 = new Object[1];
    try {
        defaultDeserializationContext0.handleWeirdStringValue(class0, ""JSON"", ""JSON"", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Cannot deserialize value of type `com.fasterxml.jackson.databind.type.PlaceholderForType` from String \""JSON\"": DeserializationProblemHandler.handleWeirdStringValue() for type class com.fasterxml.jackson.databind.type.PlaceholderForType returned value of type class com.fasterxml.jackson.databind.ObjectMapper
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidFormatException"", e);
    }
}","/**
 * Method that deserializers should call if they encounter a String value
 * that cannot be converted to target property type, in cases where some
 * String values could be acceptable (either with different settings,
 * or different value).
 * Default implementation will try to call {@link DeserializationProblemHandler#handleWeirdStringValue}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw {@link InvalidFormatException} with given message.
 *
 * @param targetClass Type of property into which incoming number should be converted
 * @param value String value from which to deserialize property value
 * @param msg Error message template caller wants to use if exception is to be thrown
 * @param msgArgs Optional arguments to use for message, if any
 *
 * @return Property value to use
 *
 * @throws IOException To indicate unrecoverable problem, usually based on <code>msg</code>
 *
 * @since 2.8
 */"
"public Object handleWeirdNumberValue(Class<?> targetClass, Number value, String msg, Object... msgArgs) throws IOException {
    msg = _format(msg, msgArgs);
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object key = h.value().handleWeirdNumberValue(this, targetClass, value, msg);
        if (key != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if (_isCompatible(targetClass, key)) {
                return key;
            }
            throw weirdNumberException(value, targetClass, _format(""DeserializationProblemHandler.handleWeirdNumberValue() for type %s returned value of type %s"", targetClass, key.getClass()));
        }
        h = h.next();
    }
    throw weirdNumberException(value, targetClass, msg);
}","public void test6472() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(deserializationProblemHandler0).handleWeirdNumberValue(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(java.lang.Class.class), any(java.lang.Number.class), anyString());
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<Locale> class0 = Locale.class;
    BigDecimal bigDecimal0 = BigDecimal.ZERO;
    Object[] objectArray0 = new Object[1];
    Object object0 = defaultDeserializationContext0.handleWeirdNumberValue(class0, bigDecimal0, ""JSON"", objectArray0);
    assertNull(object0);
}","/**
 * Method that deserializers should call if they encounter a numeric value
 * that cannot be converted to target property type, in cases where some
 * numeric values could be acceptable (either with different settings,
 * or different numeric value).
 * Default implementation will try to call {@link DeserializationProblemHandler#handleWeirdNumberValue}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw {@link InvalidFormatException} with given message.
 *
 * @param targetClass Type of property into which incoming number should be converted
 * @param value Number value from which to deserialize property value
 * @param msg Error message template caller wants to use if exception is to be thrown
 * @param msgArgs Optional arguments to use for message, if any
 *
 * @return Property value to use
 *
 * @throws IOException To indicate unrecoverable problem, usually based on <code>msg</code>
 *
 * @since 2.8
 */"
"public Object handleWeirdNumberValue(Class<?> targetClass, Number value, String msg, Object... msgArgs) throws IOException {
    msg = _format(msg, msgArgs);
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object key = h.value().handleWeirdNumberValue(this, targetClass, value, msg);
        if (key != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if (_isCompatible(targetClass, key)) {
                return key;
            }
            throw weirdNumberException(value, targetClass, _format(""DeserializationProblemHandler.handleWeirdNumberValue() for type %s returned value of type %s"", targetClass, key.getClass()));
        }
        h = h.next();
    }
    throw weirdNumberException(value, targetClass, msg);
}","public void test6573() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn(objectMapper0).when(deserializationProblemHandler0).handleWeirdNumberValue(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(java.lang.Class.class), any(java.lang.Number.class), anyString());
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<Integer> class0 = Integer.TYPE;
    BigInteger bigInteger0 = BigInteger.ONE;
    Object[] objectArray0 = new Object[1];
    try {
        defaultDeserializationContext0.handleWeirdNumberValue(class0, bigInteger0, ""JSON"", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Cannot deserialize value of type `int` from number 1: DeserializationProblemHandler.handleWeirdNumberValue() for type int returned value of type class com.fasterxml.jackson.databind.ObjectMapper
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidFormatException"", e);
    }
}","/**
 * Method that deserializers should call if they encounter a numeric value
 * that cannot be converted to target property type, in cases where some
 * numeric values could be acceptable (either with different settings,
 * or different numeric value).
 * Default implementation will try to call {@link DeserializationProblemHandler#handleWeirdNumberValue}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw {@link InvalidFormatException} with given message.
 *
 * @param targetClass Type of property into which incoming number should be converted
 * @param value Number value from which to deserialize property value
 * @param msg Error message template caller wants to use if exception is to be thrown
 * @param msgArgs Optional arguments to use for message, if any
 *
 * @return Property value to use
 *
 * @throws IOException To indicate unrecoverable problem, usually based on <code>msg</code>
 *
 * @since 2.8
 */"
"public Object handleWeirdNativeValue(JavaType targetType, Object badValue, JsonParser p) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    final Class<?> raw = targetType.getRawClass();
    for (; h != null; h = h.next()) {
        // Can bail out if it's handled
        Object goodValue = h.value().handleWeirdNativeValue(this, targetType, badValue, p);
        if (goodValue != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if ((goodValue == null) || raw.isInstance(goodValue)) {
                return goodValue;
            }
            throw JsonMappingException.from(p, _format(""DeserializationProblemHandler.handleWeirdNativeValue() for type %s returned value of type %s"", targetType, goodValue.getClass()));
        }
    }
    throw weirdNativeValueException(badValue, raw);
}","public void test6674() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(deserializationProblemHandler0).handleWeirdNativeValue(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(com.fasterxml.jackson.databind.JavaType.class), any(), any(com.fasterxml.jackson.core.JsonParser.class));
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    PlaceholderForType placeholderForType0 = new PlaceholderForType(633);
    Object object0 = defaultDeserializationContext0.handleWeirdNativeValue(placeholderForType0, objectReader0, jsonParser0);
    assertNull(object0);
}",""
"public Object handleWeirdNativeValue(JavaType targetType, Object badValue, JsonParser p) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    final Class<?> raw = targetType.getRawClass();
    for (; h != null; h = h.next()) {
        // Can bail out if it's handled
        Object goodValue = h.value().handleWeirdNativeValue(this, targetType, badValue, p);
        if (goodValue != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if ((goodValue == null) || raw.isInstance(goodValue)) {
                return goodValue;
            }
            throw JsonMappingException.from(p, _format(""DeserializationProblemHandler.handleWeirdNativeValue() for type %s returned value of type %s"", targetType, goodValue.getClass()));
        }
    }
    throw weirdNativeValueException(badValue, raw);
}","public void test6775() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn(objectMapper0).when(deserializationProblemHandler0).handleWeirdNativeValue(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(com.fasterxml.jackson.databind.JavaType.class), any(), any(com.fasterxml.jackson.core.JsonParser.class));
    ObjectMapper objectMapper1 = objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    PlaceholderForType placeholderForType0 = new PlaceholderForType(633);
    Object object0 = defaultDeserializationContext0.handleWeirdNativeValue(placeholderForType0, objectReader0, jsonParser0);
    assertSame(object0, objectMapper1);
}",""
"public Object handleWeirdNativeValue(JavaType targetType, Object badValue, JsonParser p) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    final Class<?> raw = targetType.getRawClass();
    for (; h != null; h = h.next()) {
        // Can bail out if it's handled
        Object goodValue = h.value().handleWeirdNativeValue(this, targetType, badValue, p);
        if (goodValue != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if ((goodValue == null) || raw.isInstance(goodValue)) {
                return goodValue;
            }
            throw JsonMappingException.from(p, _format(""DeserializationProblemHandler.handleWeirdNativeValue() for type %s returned value of type %s"", targetType, goodValue.getClass()));
        }
    }
    throw weirdNativeValueException(badValue, raw);
}","public void test6876() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn(objectMapper0).when(deserializationProblemHandler0).handleWeirdNativeValue(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(com.fasterxml.jackson.databind.JavaType.class), any(), any(com.fasterxml.jackson.core.JsonParser.class));
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<String> class0 = String.class;
    JavaType javaType0 = defaultDeserializationContext0.constructType(class0);
    PlaceholderForType placeholderForType0 = new PlaceholderForType((-1204));
    try {
        defaultDeserializationContext0.handleWeirdNativeValue(javaType0, placeholderForType0, jsonParser0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // DeserializationProblemHandler.handleWeirdNativeValue() for type [simple type, class java.lang.String] returned value of type class com.fasterxml.jackson.databind.ObjectMapper
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.JsonMappingException"", e);
    }
}",""
"@SuppressWarnings(""resource"")
public Object handleMissingInstantiator(Class<?> instClass, ValueInstantiator valueInst, JsonParser p, String msg, Object... msgArgs) throws IOException {
    if (p == null) {
        p = getParser();
    }
    msg = _format(msg, msgArgs);
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object instance = h.value().handleMissingInstantiator(this, instClass, valueInst, p, msg);
        if (instance != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if (_isCompatible(instClass, instance)) {
                return instance;
            }
            reportBadDefinition(constructType(instClass), String.format(""DeserializationProblemHandler.handleMissingInstantiator() for type %s returned value of type %s"", instClass, ClassUtil.classNameOf(instance)));
        }
        h = h.next();
    }
    // 16-Oct-2016, tatu: This is either a definition problem (if no applicable creator
    //   exists), or input mismatch problem (otherwise) since none of existing creators
    //   match with token.
    if ((valueInst != null) && !valueInst.canInstantiate()) {
        msg = String.format(""Cannot construct instance of %s (no Creators, like default construct, exist): %s"", ClassUtil.nameOf(instClass), msg);
        return reportBadDefinition(constructType(instClass), msg);
    }
    msg = String.format(""Cannot construct instance of %s (although at least one Creator exists): %s"", ClassUtil.nameOf(instClass), msg);
    return reportInputMismatch(instClass, msg);
}","public void test6977() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<ResolvedRecursiveType> class0 = ResolvedRecursiveType.class;
    Object[] objectArray0 = new Object[2];
    try {
        defaultDeserializationContext0.handleMissingInstantiator(class0, (ValueInstantiator) null, jsonParser0, ""JSON"", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Cannot construct instance of `com.fasterxml.jackson.databind.type.ResolvedRecursiveType` (although at least one Creator exists): JSON
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.MismatchedInputException"", e);
    }
}","/**
 * Method that deserializers should call if they fail to instantiate value
 * due to lack of viable instantiator (usually creator, that is, constructor
 * or static factory method). Method should be called at point where value
 * has not been decoded, so that handler has a chance to handle decoding
 * using alternate mechanism, and handle underlying content (possibly by
 * just skipping it) to keep input state valid
 *
 * @param instClass Type that was to be instantiated
 * @param valueInst (optional) Value instantiator to be used, if any; null if type does not
 *    use one for instantiation (custom deserialiers don't; standard POJO deserializer does)
 * @param p Parser that points to the JSON value to decode
 *
 * @return Object that should be constructed, if any; has to be of type <code>instClass</code>
 *
 * @since 2.9 (2.8 had alternate that did not take <code>ValueInstantiator</code>)
 */"
"/*
    /**********************************************************
    /* Implementation of rest of ObjectCodec methods
    /**********************************************************
     */
@Override
public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException {
    try {
        return readValue(treeAsTokens(n), valueType);
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        // should not occur, no real i/o...
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
}","public void test7078() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(deserializationProblemHandler0).handleMissingInstantiator(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(java.lang.Class.class), any(com.fasterxml.jackson.databind.deser.ValueInstantiator.class), any(com.fasterxml.jackson.core.JsonParser.class), anyString());
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    BooleanNode booleanNode0 = BooleanNode.getTrue();
    Class<ResolvedRecursiveType> class0 = ResolvedRecursiveType.class;
    ResolvedRecursiveType resolvedRecursiveType0 = objectReader0.treeToValue((TreeNode) booleanNode0, class0);
    assertNull(resolvedRecursiveType0);
}",""
"@SuppressWarnings(""resource"")
public Object handleMissingInstantiator(Class<?> instClass, ValueInstantiator valueInst, JsonParser p, String msg, Object... msgArgs) throws IOException {
    if (p == null) {
        p = getParser();
    }
    msg = _format(msg, msgArgs);
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object instance = h.value().handleMissingInstantiator(this, instClass, valueInst, p, msg);
        if (instance != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if (_isCompatible(instClass, instance)) {
                return instance;
            }
            reportBadDefinition(constructType(instClass), String.format(""DeserializationProblemHandler.handleMissingInstantiator() for type %s returned value of type %s"", instClass, ClassUtil.classNameOf(instance)));
        }
        h = h.next();
    }
    // 16-Oct-2016, tatu: This is either a definition problem (if no applicable creator
    //   exists), or input mismatch problem (otherwise) since none of existing creators
    //   match with token.
    if ((valueInst != null) && !valueInst.canInstantiate()) {
        msg = String.format(""Cannot construct instance of %s (no Creators, like default construct, exist): %s"", ClassUtil.nameOf(instClass), msg);
        return reportBadDefinition(constructType(instClass), msg);
    }
    msg = String.format(""Cannot construct instance of %s (although at least one Creator exists): %s"", ClassUtil.nameOf(instClass), msg);
    return reportInputMismatch(instClass, msg);
}","public void test7179() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn(objectMapper0).when(deserializationProblemHandler0).handleMissingInstantiator(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(java.lang.Class.class), any(com.fasterxml.jackson.databind.deser.ValueInstantiator.class), any(com.fasterxml.jackson.core.JsonParser.class), anyString());
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<SimpleType> class0 = SimpleType.class;
    ValueInstantiator.Base valueInstantiator_Base0 = new ValueInstantiator.Base(class0);
    Object[] objectArray0 = new Object[1];
    try {
        defaultDeserializationContext0.handleMissingInstantiator(class0, valueInstantiator_Base0, jsonParser0, ""JSON"", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // DeserializationProblemHandler.handleMissingInstantiator() for type class com.fasterxml.jackson.databind.type.SimpleType returned value of type `com.fasterxml.jackson.databind.ObjectMapper`
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}","/**
 * Method that deserializers should call if they fail to instantiate value
 * due to lack of viable instantiator (usually creator, that is, constructor
 * or static factory method). Method should be called at point where value
 * has not been decoded, so that handler has a chance to handle decoding
 * using alternate mechanism, and handle underlying content (possibly by
 * just skipping it) to keep input state valid
 *
 * @param instClass Type that was to be instantiated
 * @param valueInst (optional) Value instantiator to be used, if any; null if type does not
 *    use one for instantiation (custom deserialiers don't; standard POJO deserializer does)
 * @param p Parser that points to the JSON value to decode
 *
 * @return Object that should be constructed, if any; has to be of type <code>instClass</code>
 *
 * @since 2.9 (2.8 had alternate that did not take <code>ValueInstantiator</code>)
 */"
"public Object handleInstantiationProblem(Class<?> instClass, Object argument, Throwable t) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object instance = h.value().handleInstantiationProblem(this, instClass, argument, t);
        if (instance != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if (_isCompatible(instClass, instance)) {
                return instance;
            }
            reportBadDefinition(constructType(instClass), String.format(""DeserializationProblemHandler.handleInstantiationProblem() for type %s returned value of type %s"", instClass, ClassUtil.classNameOf(instance)));
        }
        h = h.next();
    }
    // 18-May-2016, tatu: Only wrap if not already a valid type to throw
    ClassUtil.throwIfIOE(t);
    throw instantiationException(instClass, t);
}","public void test7280() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn(objectMapper0).when(deserializationProblemHandler0).handleInstantiationProblem(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(java.lang.Class.class), any(), any(java.lang.Throwable.class));
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    SQLTransientConnectionException sQLTransientConnectionException0 = new SQLTransientConnectionException(""JSON"");
    Class<String> class0 = String.class;
    try {
        defaultDeserializationContext0.handleInstantiationProblem(class0, objectMapper0, sQLTransientConnectionException0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // DeserializationProblemHandler.handleInstantiationProblem() for type class java.lang.String returned value of type `com.fasterxml.jackson.databind.ObjectMapper`
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}","/**
 * Method that deserializers should call if they fail to instantiate value
 * due to an exception that was thrown by constructor (or other mechanism used
 * to create instances).
 * Default implementation will try to call {@link DeserializationProblemHandler#handleInstantiationProblem}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw exception constructed with {@link #instantiationException}.
 *
 * @param instClass Type that was to be instantiated
 * @param argument (optional) Argument that was passed to constructor or equivalent
 *    instantiator; often a {@link java.lang.String}.
 * @param t Exception that caused failure
 *
 * @return Object that should be constructed, if any; has to be of type <code>instClass</code>
 *
 * @since 2.8
 */"
"public Object handleInstantiationProblem(Class<?> instClass, Object argument, Throwable t) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object instance = h.value().handleInstantiationProblem(this, instClass, argument, t);
        if (instance != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if (_isCompatible(instClass, instance)) {
                return instance;
            }
            reportBadDefinition(constructType(instClass), String.format(""DeserializationProblemHandler.handleInstantiationProblem() for type %s returned value of type %s"", instClass, ClassUtil.classNameOf(instance)));
        }
        h = h.next();
    }
    // 18-May-2016, tatu: Only wrap if not already a valid type to throw
    ClassUtil.throwIfIOE(t);
    throw instantiationException(instClass, t);
}","public void test7381() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(deserializationProblemHandler0).handleInstantiationProblem(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(java.lang.Class.class), any(), any(java.lang.Throwable.class));
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    SQLTransientConnectionException sQLTransientConnectionException0 = new SQLTransientConnectionException(""JSON"");
    Class<String> class0 = String.class;
    Object object0 = defaultDeserializationContext0.handleInstantiationProblem(class0, objectMapper0, sQLTransientConnectionException0);
    assertNull(object0);
}","/**
 * Method that deserializers should call if they fail to instantiate value
 * due to an exception that was thrown by constructor (or other mechanism used
 * to create instances).
 * Default implementation will try to call {@link DeserializationProblemHandler#handleInstantiationProblem}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw exception constructed with {@link #instantiationException}.
 *
 * @param instClass Type that was to be instantiated
 * @param argument (optional) Argument that was passed to constructor or equivalent
 *    instantiator; often a {@link java.lang.String}.
 * @param t Exception that caused failure
 *
 * @return Object that should be constructed, if any; has to be of type <code>instClass</code>
 *
 * @since 2.8
 */"
"@SuppressWarnings(""unchecked"")
public <T> T readValue(JsonParser p, JavaType type) throws IOException {
    JsonDeserializer<Object> deser = findRootValueDeserializer(type);
    if (deser == null) {
        reportBadDefinition(type, ""Could not find JsonDeserializer for type "" + type);
    }
    return (T) deser.deserialize(p, this);
}","public void test7482() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn(objectMapper0).when(deserializationProblemHandler0).handleUnexpectedToken(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(java.lang.Class.class), any(com.fasterxml.jackson.core.JsonToken.class), any(com.fasterxml.jackson.core.JsonParser.class), anyString());
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
    JavaType javaType0 = beanProperty_Bogus0.getType();
    DateFormat dateFormat0 = defaultDeserializationContext0.readValue(jsonParser0, javaType0);
    assertNull(dateFormat0);
}","/**
 * @since 2.4
 */"
"public Object handleUnexpectedToken(Class<?> instClass, JsonToken t, JsonParser p, String msg, Object... msgArgs) throws IOException {
    msg = _format(msg, msgArgs);
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        Object instance = h.value().handleUnexpectedToken(this, instClass, t, p, msg);
        if (instance != DeserializationProblemHandler.NOT_HANDLED) {
            if (_isCompatible(instClass, instance)) {
                return instance;
            }
            reportBadDefinition(constructType(instClass), String.format(""DeserializationProblemHandler.handleUnexpectedToken() for type %s returned value of type %s"", ClassUtil.nameOf(instClass), ClassUtil.classNameOf(instance)));
        }
        h = h.next();
    }
    if (msg == null) {
        if (t == null) {
            msg = String.format(""Unexpected end-of-input when binding data into %s"", ClassUtil.nameOf(instClass));
        } else {
            msg = String.format(""Cannot deserialize instance of %s out of %s token"", ClassUtil.nameOf(instClass), t);
        }
    }
    reportInputMismatch(instClass, msg);
    // never gets here
    return null;
}","public void test7583() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn(objectMapper0).when(deserializationProblemHandler0).handleUnexpectedToken(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(java.lang.Class.class), any(com.fasterxml.jackson.core.JsonToken.class), any(com.fasterxml.jackson.core.JsonParser.class), anyString());
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<InputStream> class0 = InputStream.class;
    JsonToken jsonToken0 = JsonToken.END_OBJECT;
    Object[] objectArray0 = new Object[1];
    try {
        defaultDeserializationContext0.handleUnexpectedToken(class0, jsonToken0, jsonParser0, ""JSON"", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // DeserializationProblemHandler.handleUnexpectedToken() for type `java.io.InputStream` returned value of type `com.fasterxml.jackson.databind.ObjectMapper`
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}","/**
 * Method that deserializers should call if the first token of the value to
 * deserialize is of unexpected type (that is, type of token that deserializer
 * cannot handle). This could occur, for example, if a Number deserializer
 * encounter {@link JsonToken#START_ARRAY} instead of
 * {@link JsonToken#VALUE_NUMBER_INT} or {@link JsonToken#VALUE_NUMBER_FLOAT}.
 *
 * @param instClass Type that was to be instantiated
 * @param t Token encountered that does match expected
 * @param p Parser that points to the JSON value to decode
 *
 * @return Object that should be constructed, if any; has to be of type <code>instClass</code>
 *
 * @since 2.8
 */"
"public Object handleUnexpectedToken(Class<?> instClass, JsonToken t, JsonParser p, String msg, Object... msgArgs) throws IOException {
    msg = _format(msg, msgArgs);
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        Object instance = h.value().handleUnexpectedToken(this, instClass, t, p, msg);
        if (instance != DeserializationProblemHandler.NOT_HANDLED) {
            if (_isCompatible(instClass, instance)) {
                return instance;
            }
            reportBadDefinition(constructType(instClass), String.format(""DeserializationProblemHandler.handleUnexpectedToken() for type %s returned value of type %s"", ClassUtil.nameOf(instClass), ClassUtil.classNameOf(instance)));
        }
        h = h.next();
    }
    if (msg == null) {
        if (t == null) {
            msg = String.format(""Unexpected end-of-input when binding data into %s"", ClassUtil.nameOf(instClass));
        } else {
            msg = String.format(""Cannot deserialize instance of %s out of %s token"", ClassUtil.nameOf(instClass), t);
        }
    }
    reportInputMismatch(instClass, msg);
    // never gets here
    return null;
}","public void test7684() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<Locale.LanguageRange> class0 = Locale.LanguageRange.class;
    JsonToken jsonToken0 = JsonToken.VALUE_TRUE;
    Object[] objectArray0 = new Object[0];
    try {
        defaultDeserializationContext0.handleUnexpectedToken(class0, jsonToken0, jsonParser0, ""com.fasterxml.jackson.core.ObjectCodec"", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // com.fasterxml.jackson.core.ObjectCodec
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.MismatchedInputException"", e);
    }
}","/**
 * Method that deserializers should call if the first token of the value to
 * deserialize is of unexpected type (that is, type of token that deserializer
 * cannot handle). This could occur, for example, if a Number deserializer
 * encounter {@link JsonToken#START_ARRAY} instead of
 * {@link JsonToken#VALUE_NUMBER_INT} or {@link JsonToken#VALUE_NUMBER_FLOAT}.
 *
 * @param instClass Type that was to be instantiated
 * @param t Token encountered that does match expected
 * @param p Parser that points to the JSON value to decode
 *
 * @return Object that should be constructed, if any; has to be of type <code>instClass</code>
 *
 * @since 2.8
 */"
"public JavaType handleUnknownTypeId(JavaType baseType, String id, TypeIdResolver idResolver, String extraDesc) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        JavaType type = h.value().handleUnknownTypeId(this, baseType, id, idResolver, extraDesc);
        if (type != null) {
            if (type.hasRawClass(Void.class)) {
                return null;
            }
            // But ensure there's type compatibility
            if (type.isTypeOrSubTypeOf(baseType.getRawClass())) {
                return type;
            }
            throw invalidTypeIdException(baseType, id, ""problem handler tried to resolve into non-subtype: "" + type);
        }
        h = h.next();
    }
    // 24-May-2016, tatu: Actually we may still not want to fail quite yet
    if (!isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {
        return null;
    }
    throw invalidTypeIdException(baseType, id, extraDesc);
}","public void test7785() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn((JavaType) null).when(deserializationProblemHandler0).handleUnknownTypeId(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(com.fasterxml.jackson.databind.JavaType.class), anyString(), any(com.fasterxml.jackson.databind.jsontype.TypeIdResolver.class), anyString());
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    try {
        defaultDeserializationContext0.handleUnknownTypeId((JavaType) null, ""JSON"", (TypeIdResolver) null, (String) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Could not resolve type id 'JSON' as a subtype of null
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidTypeIdException"", e);
    }
}","/**
 * Method that deserializers should call if they encounter a type id
 * (for polymorphic deserialization) that cannot be resolved to an
 * actual type; usually since there is no mapping defined.
 * Default implementation will try to call {@link DeserializationProblemHandler#handleUnknownTypeId}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw exception constructed with {@link #invalidTypeIdException}.
 *
 * @param baseType Base type from which resolution starts
 * @param id Type id that could not be converted
 * @param extraDesc Additional problem description to add to default exception message,
 *    if resolution fails.
 *
 * @return {@link JavaType} that id resolves to
 *
 * @throws IOException To indicate unrecoverable problem, if resolution cannot
 *    be made to work
 *
 * @since 2.8
 */"
"public JavaType handleMissingTypeId(JavaType baseType, TypeIdResolver idResolver, String extraDesc) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        JavaType type = h.value().handleMissingTypeId(this, baseType, idResolver, extraDesc);
        if (type != null) {
            if (type.hasRawClass(Void.class)) {
                return null;
            }
            // But ensure there's type compatibility
            if (type.isTypeOrSubTypeOf(baseType.getRawClass())) {
                return type;
            }
            throw invalidTypeIdException(baseType, null, ""problem handler tried to resolve into non-subtype: "" + type);
        }
        h = h.next();
    }
    // 09-Mar-2017, tatu: We may want to consider yet another feature at some
    //    point to allow returning `null`... but that seems bit risky for now
    //        if (!isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {
    //            return null;
    //        }
    throw missingTypeIdException(baseType, extraDesc);
}","public void test7886() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    TypeFactory typeFactory0 = TypeFactory.defaultInstance();
    Class<Map> class0 = Map.class;
    Class<TypeNameIdResolver> class1 = TypeNameIdResolver.class;
    Class<String> class2 = String.class;
    MapType mapType0 = typeFactory0.constructMapType(class0, class1, class2);
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn(mapType0).when(deserializationProblemHandler0).handleMissingTypeId(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(com.fasterxml.jackson.databind.JavaType.class), any(com.fasterxml.jackson.databind.jsontype.TypeIdResolver.class), anyString());
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    JavaType javaType0 = TypeFactory.unknownType();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(javaType0, typeFactory0);
    JavaType javaType1 = defaultDeserializationContext0.handleMissingTypeId(javaType0, classNameIdResolver0, ""JSON"");
    assertSame(javaType1, mapType0);
}","/**
 * @since 2.9
 */"
"public JavaType handleMissingTypeId(JavaType baseType, TypeIdResolver idResolver, String extraDesc) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        JavaType type = h.value().handleMissingTypeId(this, baseType, idResolver, extraDesc);
        if (type != null) {
            if (type.hasRawClass(Void.class)) {
                return null;
            }
            // But ensure there's type compatibility
            if (type.isTypeOrSubTypeOf(baseType.getRawClass())) {
                return type;
            }
            throw invalidTypeIdException(baseType, null, ""problem handler tried to resolve into non-subtype: "" + type);
        }
        h = h.next();
    }
    // 09-Mar-2017, tatu: We may want to consider yet another feature at some
    //    point to allow returning `null`... but that seems bit risky for now
    //        if (!isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {
    //            return null;
    //        }
    throw missingTypeIdException(baseType, extraDesc);
}","public void test7987() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DeserializationProblemHandler deserializationProblemHandler0 = mock(DeserializationProblemHandler.class, new ViolatedAssumptionAnswer());
    doReturn((JavaType) null).when(deserializationProblemHandler0).handleMissingTypeId(any(com.fasterxml.jackson.databind.DeserializationContext.class), any(com.fasterxml.jackson.databind.JavaType.class), any(com.fasterxml.jackson.databind.jsontype.TypeIdResolver.class), anyString());
    objectMapper0.addHandler(deserializationProblemHandler0);
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    JavaType javaType0 = TypeFactory.unknownType();
    TypeFactory typeFactory0 = objectReader0.getTypeFactory();
    ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(javaType0, typeFactory0);
    try {
        defaultDeserializationContext0.handleMissingTypeId(javaType0, classNameIdResolver0, ""JSON"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Missing type id when trying to resolve subtype of [simple type, class java.lang.Object]: JSON
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidTypeIdException"", e);
    }
}","/**
 * @since 2.9
 */"
"protected boolean _isCompatible(Class<?> target, Object value) {
    if ((value == null) || target.isInstance(value)) {
        return true;
    }
    // [databind#1767]: Make sure to allow wrappers for primitive fields
    return target.isPrimitive() && ClassUtil.wrapperType(target).isInstance(value);
}","public void test8088() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = (DefaultDeserializationContext.Impl) objectMapper0.getDeserializationContext();
    Class<Object> class0 = Object.class;
    boolean boolean0 = ((DeserializationContext) defaultDeserializationContext_Impl0)._isCompatible(class0, objectMapper0);
    assertTrue(boolean0);
}","/**
 * @since 2.9.2
 */"
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test8089() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = (DefaultDeserializationContext.Impl) objectMapper0.getDeserializationContext();
    Class<Object> class0 = Object.class;
    boolean boolean0 = ((DeserializationContext) defaultDeserializationContext_Impl0)._isCompatible(class0, objectMapper0);
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"public <T> T reportInputMismatch(BeanProperty prop, String msg, Object... msgArgs) throws JsonMappingException {
    msg = _format(msg, msgArgs);
    JavaType type = (prop == null) ? null : prop.getType();
    throw MismatchedInputException.from(getParser(), type, msg);
}","public void test8190() throws Throwable {
    DeserializerFactoryConfig deserializerFactoryConfig0 = new DeserializerFactoryConfig();
    BeanDeserializerFactory beanDeserializerFactory0 = new BeanDeserializerFactory(deserializerFactoryConfig0);
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
    Object[] objectArray0 = new Object[6];
    try {
        defaultDeserializationContext_Impl0.reportInputMismatch((BeanProperty) beanProperty_Bogus0, ""|JZ("", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // |JZ(
        //
        verifyException(""com.fasterxml.jackson.databind.exc.MismatchedInputException"", e);
    }
}","/**
 * Helper method used to indicate a problem with input in cases where more
 * specific <code>reportXxx()</code> method was not available.
 *
 * @since 2.9
 */"
"public <T> T reportInputMismatch(BeanProperty prop, String msg, Object... msgArgs) throws JsonMappingException {
    msg = _format(msg, msgArgs);
    JavaType type = (prop == null) ? null : prop.getType();
    throw MismatchedInputException.from(getParser(), type, msg);
}","public void test8291() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    Object[] objectArray0 = new Object[9];
    try {
        defaultDeserializationContext_Impl0.reportInputMismatch((BeanProperty) null, ""Could not find JsonDeserializer for type %s (via property %s)"", objectArray0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Could not find JsonDeserializer for type null (via property null)
        //
        verifyException(""com.fasterxml.jackson.databind.exc.MismatchedInputException"", e);
    }
}","/**
 * Helper method used to indicate a problem with input in cases where more
 * specific <code>reportXxx()</code> method was not available.
 *
 * @since 2.9
 */"
"public final int getDeserializationFeatures() {
    return _featureFlags;
}","public void test8392() throws Throwable {
    BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
    DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
    defaultDeserializationContext_Impl0.reportUnknownProperty(beanDeserializerFactory0, """", (JsonDeserializer<?>) null);
    assertEquals(0, defaultDeserializationContext_Impl0.getDeserializationFeatures());
}","/**
 * Bulk access method for getting the bit mask of all {@link DeserializationFeature}s
 * that are enabled.
 *
 * @since 2.6
 */"
"@Deprecated
public void reportUnknownProperty(Object instanceOrClass, String fieldName, JsonDeserializer<?> deser) throws JsonMappingException {
    if (isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {
        // Do we know properties that are expected instead?
        Collection<Object> propIds = (deser == null) ? null : deser.getKnownPropertyNames();
        throw UnrecognizedPropertyException.from(_parser, instanceOrClass, fieldName, propIds);
    }
}","public void test8493() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    JsonDeserializer<AbstractDeserializer> jsonDeserializer0 = (JsonDeserializer<AbstractDeserializer>) mock(JsonDeserializer.class, new ViolatedAssumptionAnswer());
    doReturn((Collection) null).when(jsonDeserializer0).getKnownPropertyNames();
    try {
        defaultDeserializationContext0.reportUnknownProperty(jsonFactory0, ""JSON"", jsonDeserializer0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized field \""JSON\"" (class com.fasterxml.jackson.core.JsonFactory), not marked as ignorable
        //  at [Source: (String)\""JSON\""; line: 1, column: 1] (through reference chain: com.fasterxml.jackson.core.JsonFactory[\""JSON\""])
        //
        verifyException(""com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException"", e);
    }
}","/**
 * Helper method for reporting a problem with unhandled unknown property.
 *
 * @param instanceOrClass Either value being populated (if one has been
 *   instantiated), or Class that indicates type that would be (or
 *   have been) instantiated
 * @param deser Deserializer that had the problem, if called by deserializer
 *   (or on behalf of one)
 *
 * @deprecated Since 2.8 call {@link #handleUnknownProperty} instead
 */"
"@Deprecated
public void reportUnknownProperty(Object instanceOrClass, String fieldName, JsonDeserializer<?> deser) throws JsonMappingException {
    if (isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {
        // Do we know properties that are expected instead?
        Collection<Object> propIds = (deser == null) ? null : deser.getKnownPropertyNames();
        throw UnrecognizedPropertyException.from(_parser, instanceOrClass, fieldName, propIds);
    }
}","public void test8594() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    StringReader stringReader0 = new StringReader(""JSON"");
    JsonParser jsonParser0 = jsonFactory0.createParser((Reader) stringReader0);
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    try {
        defaultDeserializationContext0.reportUnknownProperty(jsonFactory0, ""JSON"", (JsonDeserializer<?>) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Unrecognized field \""JSON\"" (class com.fasterxml.jackson.core.JsonFactory), not marked as ignorable
        //  at [Source: (StringReader); line: 1, column: 1] (through reference chain: com.fasterxml.jackson.core.JsonFactory[\""JSON\""])
        //
        verifyException(""com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException"", e);
    }
}","/**
 * Helper method for reporting a problem with unhandled unknown property.
 *
 * @param instanceOrClass Either value being populated (if one has been
 *   instantiated), or Class that indicates type that would be (or
 *   have been) instantiated
 * @param deser Deserializer that had the problem, if called by deserializer
 *   (or on behalf of one)
 *
 * @deprecated Since 2.8 call {@link #handleUnknownProperty} instead
 */"
"public <T> T reportBadMerge(JsonDeserializer<?> deser) throws JsonMappingException {
    if (isEnabled(MapperFeature.IGNORE_MERGE_FOR_UNMERGEABLE)) {
        return null;
    }
    JavaType type = constructType(deser.handledType());
    String msg = String.format(""Invalid configuration: values of type %s cannot be merged"", type);
    throw InvalidDefinitionException.from(getParser(), msg, type);
}","public void test8695() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Object object0 = defaultDeserializationContext0.reportBadMerge((JsonDeserializer<?>) null);
    assertNull(object0);
}","/**
 * Method that deserializer may call if it is called to do an update (""merge"")
 * but deserializer operates on a non-mergeable type. Although this should
 * usually be caught earlier, sometimes it may only be caught during operation
 * and if so this is the method to call.
 * Note that if {@link MapperFeature#IGNORE_MERGE_FOR_UNMERGEABLE} is enabled,
 * this method will simply return null; otherwise {@link InvalidDefinitionException}
 * will be thrown.
 *
 * @since 2.9
 */"
"public Object handleInstantiationProblem(Class<?> instClass, Object argument, Throwable t) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object instance = h.value().handleInstantiationProblem(this, instClass, argument, t);
        if (instance != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if (_isCompatible(instClass, instance)) {
                return instance;
            }
            reportBadDefinition(constructType(instClass), String.format(""DeserializationProblemHandler.handleInstantiationProblem() for type %s returned value of type %s"", instClass, ClassUtil.classNameOf(instance)));
        }
        h = h.next();
    }
    // 18-May-2016, tatu: Only wrap if not already a valid type to throw
    ClassUtil.throwIfIOE(t);
    throw instantiationException(instClass, t);
}","public void test8796() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    Class<Integer> class0 = Integer.TYPE;
    try {
        defaultDeserializationContext0.handleInstantiationProblem(class0, jsonFactory0, (Throwable) null);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Cannot construct instance of `int`, problem: N/A
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}","/**
 * Method that deserializers should call if they fail to instantiate value
 * due to an exception that was thrown by constructor (or other mechanism used
 * to create instances).
 * Default implementation will try to call {@link DeserializationProblemHandler#handleInstantiationProblem}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw exception constructed with {@link #instantiationException}.
 *
 * @param instClass Type that was to be instantiated
 * @param argument (optional) Argument that was passed to constructor or equivalent
 *    instantiator; often a {@link java.lang.String}.
 * @param t Exception that caused failure
 *
 * @return Object that should be constructed, if any; has to be of type <code>instClass</code>
 *
 * @since 2.8
 */"
"public Object handleInstantiationProblem(Class<?> instClass, Object argument, Throwable t) throws IOException {
    LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();
    while (h != null) {
        // Can bail out if it's handled
        Object instance = h.value().handleInstantiationProblem(this, instClass, argument, t);
        if (instance != DeserializationProblemHandler.NOT_HANDLED) {
            // Sanity check for broken handlers, otherwise nasty to debug:
            if (_isCompatible(instClass, instance)) {
                return instance;
            }
            reportBadDefinition(constructType(instClass), String.format(""DeserializationProblemHandler.handleInstantiationProblem() for type %s returned value of type %s"", instClass, ClassUtil.classNameOf(instance)));
        }
        h = h.next();
    }
    // 18-May-2016, tatu: Only wrap if not already a valid type to throw
    ClassUtil.throwIfIOE(t);
    throw instantiationException(instClass, t);
}","public void test8897() throws Throwable {
    ObjectMapper objectMapper0 = new ObjectMapper();
    ObjectReader objectReader0 = objectMapper0.reader();
    JsonFactory jsonFactory0 = new JsonFactory();
    JsonParser jsonParser0 = jsonFactory0.createParser(""JSON"");
    DefaultDeserializationContext defaultDeserializationContext0 = objectReader0.createDeserializationContext(jsonParser0);
    SQLTransientConnectionException sQLTransientConnectionException0 = new SQLTransientConnectionException();
    Class<MockDateFormat> class0 = MockDateFormat.class;
    try {
        defaultDeserializationContext0.handleInstantiationProblem(class0, sQLTransientConnectionException0, sQLTransientConnectionException0);
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Cannot construct instance of `org.evosuite.runtime.mock.java.text.MockDateFormat`, problem: `java.sql.SQLTransientConnectionException`
        //  at [Source: (String)\""JSON\""; line: 1, column: 0]
        //
        verifyException(""com.fasterxml.jackson.databind.exc.InvalidDefinitionException"", e);
    }
}","/**
 * Method that deserializers should call if they fail to instantiate value
 * due to an exception that was thrown by constructor (or other mechanism used
 * to create instances).
 * Default implementation will try to call {@link DeserializationProblemHandler#handleInstantiationProblem}
 * on configured handlers, if any, to allow for recovery; if recovery does not
 * succeed, will throw exception constructed with {@link #instantiationException}.
 *
 * @param instClass Type that was to be instantiated
 * @param argument (optional) Argument that was passed to constructor or equivalent
 *    instantiator; often a {@link java.lang.String}.
 * @param t Exception that caused failure
 *
 * @return Object that should be constructed, if any; has to be of type <code>instClass</code>
 *
 * @since 2.8
 */"
